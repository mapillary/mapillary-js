<!DOCTYPE HTML>
<html>

<head>
    <title>MapillaryJS Map-Marker</title>
    <link rel="icon" href="data:,">
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

    <link rel="stylesheet" href="./dist/mapillary.css" />
    <link href="https://unpkg.com/leaflet@1.0.1/dist/leaflet.css" rel="stylesheet" />

    <script src="https://unpkg.com/leaflet@1.0.1/dist/leaflet.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        #mly {
            position: absolute;
            width: 60%;
            height: 100%;
        }

        #map {
            position: absolute;
            width: 40%;
            height: 100%;
            right: 0;
        }
    </style>
</head>

<body>
    <div id="mly"></div>
    <div id="map"></div>

    <script type="module">
        import {
            MarkerComponent as Marker,
            Viewer,
        } from './dist/mapillary.module.js';

        // Setup map
        const map = L.map('map').setView([56.04351888068181, 12.695600612967427], 18);
        const osmUrl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
        const osmAttrib = 'Map data Â© <a href="https://openstreetmap.org">OpenStreetMap</a> contributors';
        const osm = new L.TileLayer(osmUrl, { maxZoom: 19, attribution: osmAttrib });
        map.addLayer(osm);
        map.keyboard.disable();


        // Setup viewer
        const mly = new Viewer({
            apiClient: 'QjI1NnU0aG5FZFZISE56U3R5aWN4ZzpkYzg0NzE3MDA0YTRhZjlh',
            component: {
                marker: { visibleBBoxSize: 100 },
                mouse: { doubleClickZoom: false },
            },
            container: 'mly',
        });

        mly.moveTo('6Zhtztzt67fWmdd4OYH44w').then(
            () => { /* noop */ },
            (e) => { console.error(e); });


        // Show original lngLat and lngLat (if computed exist it will differ) of current
        // viewer image on map. Show line linking the two points together
        const mapimagePosition = {
            line: L.polyline([[0, 0], [0, 0]], { color: '#0ff', weight: 1 }),
            originalPos: L.circleMarker([0, 0], { radius: 7, color: '#0ff' }),
            pos: L.circleMarker([0, 0], { radius: 7, color: '#00f' }),
        };

        mly.on('image', (event) => {
            const image = event.node;
            const lngLat = [image.lngLat.lat, node.lngLat.lng];
            const originalLngLat = [image.originalLngLat.lat, node.originalLngLat.lng];

            mapimagePosition.line.setLatLngs([originalLngLat, lngLat]);
            mapimagePosition.originalPos.setLatLng(originalLngLat);
            mapimagePosition.pos.setLatLng(lngLat);

            map.setView(lngLat);

            if (!map.hasLayer(mapimagePosition.line)) {
                mapimagePosition.line.addTo(map);
                mapimagePosition.originalPos.addTo(map);
                mapimagePosition.pos.addTo(map);
            }
        });


        // Get marker component
        const markerComponent = mly.getComponent('marker');

        // Show a flat circle marker in the viewer when hovering the map
        let mapHoverViewerMarker;

        const removeMapHoverViewerMarker = () => {
            if (!!mapHoverViewerMarker && markerComponent.has(mapHoverViewerMarker.id)) {
                markerComponent.remove([mapHoverViewerMarker.id]);
                mapHoverViewerMarker = null;
            }
        }

        const onMapMouseEvent = (e) => {
            mapHoverViewerMarker = new Marker.CircleMarker(
                'map-hover-viewer-marker-id',
                { lat: e.latlng.lat, lon: e.latlng.lng },
                { color: '#0f0' });

            markerComponent.add([mapHoverViewerMarker]);
        }

        map.on('mousemove', onMapMouseEvent);
        map.on('mouseover', onMapMouseEvent);
        map.on('mouseout', removeMapHoverViewerMarker);


        // Show a flat circle marker in the viewer and a corresponding map marker when hovering the viewer
        const indicator = {
            id: 'indicator-id',
            mapLine: L.polyline([[0, 0], [0, 0]], { color: '#0f0', weight: 1, id: 'indicator-id-line' }),
            mapMarker: L.circleMarker([0, 0], { radius: 5, color: '#0f0', id: 'indicator-id-circle' }),
            viewerMarker: null,
            state: {
                dragging: false,
                lastPos: null,
                moving: false,
            },
        };

        const addMapIndicator = () => {
            if (!map.hasLayer(indicator.mapLine)) {
                indicator.mapLine.addTo(map);
            }

            if (!map.hasLayer(indicator.mapMarker)) {
                indicator.mapMarker.addTo(map);
            }
        }

        const removeMapIndicator = () => {
            if (map.hasLayer(indicator.mapLine)) {
                map.removeLayer(indicator.mapLine);
            }

            if (map.hasLayer(indicator.mapMarker)) {
                map.removeLayer(indicator.mapMarker);
            }
        }

        const removeViewerIndicator = () => {
            if (!!indicator.viewerMarker && markerComponent.has(indicator.viewerMarker.id)) {
                markerComponent.remove([indicator.viewerMarker.id]);
                indicator.viewerMarker = null;
            }
        }

        const setViewerIndicatorMarker = (lngLat) => {
            const viewerMarker = new Marker.CircleMarker(
                indicator.id,
                lngLat,
                { color: '#0f0' });

            markerComponent.add([viewerMarker]);

            indicator.viewerMarker = viewerMarker;
        }

        const moveIndicatorMarker = (lngLat) => {
            if (indicator.state.dragging) { return; }

            if (lngLat == null) {
                removeMapIndicator();
                removeViewerIndicator();
                return;
            }

            const posLatLng = mapimagePosition.pos.getLatLng();
            const lineString = [
                [posLatLng.lat, posLatLng.lng],
                [lngLat.lat, lngLat.lng],
                [
                    posLatLng.lat + 5 * (lngLat.lat - posLatLng.lat),
                    posLatLng.lng + 5 * (lngLat.lng - posLatLng.lng),
                ],
            ];

            indicator.mapLine.setLatLngs(lineString);
            indicator.mapMarker.setLatLng([lngLat.lat, lngLat.lng]);

            setViewerIndicatorMarker({ lat: lngLat.lat, lng: lngLat.lng });

            addMapIndicator();
        }

        const onViewerMouseEvent = (event) => {
            indicator.state.lastPos = event.pixelPoint;
            moveIndicatorMarker(event.lngLat);
        }

        mly.on('mouseup', onViewerMouseEvent);
        mly.on('mouseover', onViewerMouseEvent);
        mly.on('mousedown', onViewerMouseEvent);

        mly.on('mousemove', (event) => {
            // Store last mouse position for later unprojection
            indicator.state.lastPos = event.pixelPoint;

            if (indicator.state.moving || indicator.state.dragging) { return; }

            moveIndicatorMarker(event.lngLat);
        });


        mly.on('mouseout', () => {
            indicator.state.lastPos = null;
            removeViewerIndicator();
            removeMapIndicator();
        });

        mly.on('movestart', () => { indicator.state.moving = true; });
        mly.on('moveend', () => {
            indicator.state.moving = false;

            if (!indicator.state.lastPos) { return; }

            // Unproject the last position and move indicator marker if lngLat exist
            mly.unproject(indicator.state.lastPos).then(moveIndicatorMarker);
        });

        markerComponent.on('markerdragstart', () => {
            // Remove indicators when dragging marker in the viewer
            indicator.state.dragging = true;
            removeViewerIndicator();
            removeMapIndicator();
        });

        markerComponent.on('markerdragend', () => {
            indicator.state.dragging = false;

            if (!indicator.state.lastPos) { return; }

            // Unproject the last position and move indicator marker if lngLat exist
            mly.unproject(indicator.state.lastPos).then(moveIndicatorMarker);
        });


        // Create markers on click in map or viewer
        let addedMarkerId = 0;
        const mapMarkers = {};

        const addOrReplaceViewerMarker = (id, lngLat) => {
            // Create an interactive marker to be able to drag it in viewer
            // and retrieve it with getMarkerIdAt method
            const marker = new Marker.SimpleMarker(
                id,
                lngLat,
                { ballColor: '#f00', color: '#f00', interactive: true });

            markerComponent.add([marker]);
        }

        const handleMapMarkerDrag = (mapMarker) => {
            // Listen to map events and act to move map and viewer markers accordingly
            mapMarker.on({
                mousedown: (event) => {
                    const onMouseMove = (e) => {
                        // Update both viewer marker and map marker on map marker drag
                        addOrReplaceViewerMarker(mapMarker.options.id, { lat: e.latlng.lat, lon: e.latlng.lng });
                        mapMarker.setLatLng(e.latlng);
                    };

                    const onMouseUp = (e) => {
                        map.off('mousemove', onMouseMove)
                        map.off('mouseup', onMouseUp);
                    }

                    map.on('mousemove', onMouseMove);
                    map.on('mouseup', onMouseUp);
                },
                mouseover: (event) => {
                    // Remove map hover viewer marker when hovering a map marker
                    removeMapHoverViewerMarker();

                    // Disable map dragging to ensure that only map marker is dragged
                    map.dragging.disable();
                    map.off('mousemove', onMapMouseEvent);
                    map.off('click', mapOnClick);
                },
                mouseout: (event) => {
                    map.dragging.enable();
                    map.on('mousemove', onMapMouseEvent);
                    map.on('click', mapOnClick);
                },
            });
        }

        const createMarker = (lngLat) => {
            const id = (addedMarkerId++).toString();

            addOrReplaceViewerMarker(id, lngLat);

            const mapMarker =
                L.circleMarker(
                    [lngLat.lat, lngLat.lng],
                    { radius: 5, color: '#f00', draggable: 'true', id: id })
                    .addTo(map);

            mapMarkers[id] = mapMarker;
            handleMapMarkerDrag(mapMarker);
        }

        mly.on('click', (e) => {
            if (!e.lngLat) { return; }

            markerComponent.getMarkerIdAt(e.pixelPoint).then((markerId) => {
                // Only create a new marker if no interactive markers are hovered
                if (markerId != null) { return; }

                createMarker(e.lngLat);
            });
        });

        const mapOnClick = (e) => {
            if (!e.latlng) { return; }

            createMarker({ lat: e.latlng.lat, lon: e.latlng.lng });
        };

        map.on('click', mapOnClick);


        // Update map marker when lngLat changes for a
        // marker by dragging in the viewer.
        markerComponent.on("markerposition", (e) => {
            const mapMarker = mapMarkers[e.marker.id];
            if (!mapMarker) {
                return;
            }

            mapMarker.setLatLng([e.marker.lngLat.lat, e.marker.lngLat.lng]);
        });
    </script>
</body>

</html>
