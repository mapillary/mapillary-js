exports["Mapillary"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Mapillary.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@mapbox/polylabel/polylabel.js":
/*!*****************************************************!*\
  !*** ./node_modules/@mapbox/polylabel/polylabel.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Queue = __webpack_require__(/*! tinyqueue */ \"./node_modules/tinyqueue/index.js\");\n\nmodule.exports = polylabel;\nmodule.exports.default = polylabel;\n\nfunction polylabel(polygon, precision, debug) {\n    precision = precision || 1.0;\n\n    // find the bounding box of the outer ring\n    var minX, minY, maxX, maxY;\n    for (var i = 0; i < polygon[0].length; i++) {\n        var p = polygon[0][i];\n        if (!i || p[0] < minX) minX = p[0];\n        if (!i || p[1] < minY) minY = p[1];\n        if (!i || p[0] > maxX) maxX = p[0];\n        if (!i || p[1] > maxY) maxY = p[1];\n    }\n\n    var width = maxX - minX;\n    var height = maxY - minY;\n    var cellSize = Math.min(width, height);\n    var h = cellSize / 2;\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    var cellQueue = new Queue(null, compareMax);\n\n    if (cellSize === 0) return [minX, minY];\n\n    // cover polygon with initial cells\n    for (var x = minX; x < maxX; x += cellSize) {\n        for (var y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygon));\n        }\n    }\n\n    // take centroid as the first best guess\n    var bestCell = getCentroidCell(polygon);\n\n    // special case for rectangular polygons\n    var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n    if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n\n    var numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        var cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log('num probes: ' + numProbes);\n        console.log('best distance: ' + bestCell.d);\n    }\n\n    return [bestCell.x, bestCell.y];\n}\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.x = x; // cell center x\n    this.y = y; // cell center y\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(x, y, polygon) {\n    var inside = false;\n    var minDistSq = Infinity;\n\n    for (var k = 0; k < polygon.length; k++) {\n        var ring = polygon[k];\n\n        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            var a = ring[i];\n            var b = ring[j];\n\n            if ((a[1] > y !== b[1] > y) &&\n                (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n        }\n    }\n\n    return (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    var area = 0;\n    var x = 0;\n    var y = 0;\n    var points = polygon[0];\n\n    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        var a = points[i];\n        var b = points[j];\n        var f = a[0] * b[1] - b[0] * a[1];\n        x += (a[0] + b[0]) * f;\n        y += (a[1] + b[1]) * f;\n        area += f * 3;\n    }\n    if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);\n    return new Cell(x / area, y / area, 0, polygon);\n}\n\n// get squared distance from a point to a segment\nfunction getSegDistSq(px, py, a, b) {\n\n    var x = a[0];\n    var y = a[1];\n    var dx = b[0] - x;\n    var dy = b[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = b[0];\n            y = b[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/@mapbox/polylabel/polylabel.js?");

/***/ }),

/***/ "./node_modules/@mapbox/unitbezier/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@mapbox/unitbezier/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n * Copyright (C) 2008 Apple Inc. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Ported from Webkit\n * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h\n */\n\nmodule.exports = UnitBezier;\n\nfunction UnitBezier(p1x, p1y, p2x, p2y) {\n    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).\n    this.cx = 3.0 * p1x;\n    this.bx = 3.0 * (p2x - p1x) - this.cx;\n    this.ax = 1.0 - this.cx - this.bx;\n\n    this.cy = 3.0 * p1y;\n    this.by = 3.0 * (p2y - p1y) - this.cy;\n    this.ay = 1.0 - this.cy - this.by;\n\n    this.p1x = p1x;\n    this.p1y = p2y;\n    this.p2x = p2x;\n    this.p2y = p2y;\n}\n\nUnitBezier.prototype.sampleCurveX = function(t) {\n    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\n};\n\nUnitBezier.prototype.sampleCurveY = function(t) {\n    return ((this.ay * t + this.by) * t + this.cy) * t;\n};\n\nUnitBezier.prototype.sampleCurveDerivativeX = function(t) {\n    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n};\n\nUnitBezier.prototype.solveCurveX = function(x, epsilon) {\n    if (typeof epsilon === 'undefined') epsilon = 1e-6;\n\n    var t0, t1, t2, x2, i;\n\n    // First try a few iterations of Newton's method -- normally very fast.\n    for (t2 = x, i = 0; i < 8; i++) {\n\n        x2 = this.sampleCurveX(t2) - x;\n        if (Math.abs(x2) < epsilon) return t2;\n\n        var d2 = this.sampleCurveDerivativeX(t2);\n        if (Math.abs(d2) < 1e-6) break;\n\n        t2 = t2 - x2 / d2;\n    }\n\n    // Fall back to the bisection method for reliability.\n    t0 = 0.0;\n    t1 = 1.0;\n    t2 = x;\n\n    if (t2 < t0) return t0;\n    if (t2 > t1) return t1;\n\n    while (t0 < t1) {\n\n        x2 = this.sampleCurveX(t2);\n        if (Math.abs(x2 - x) < epsilon) return t2;\n\n        if (x > x2) {\n            t0 = t2;\n        } else {\n            t1 = t2;\n        }\n\n        t2 = (t1 - t0) * 0.5 + t0;\n    }\n\n    // Failure.\n    return t2;\n};\n\nUnitBezier.prototype.solve = function(x, epsilon) {\n    return this.sampleCurveY(this.solveCurveX(x, epsilon));\n};\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/@mapbox/unitbezier/index.js?");

/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertice leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(ear, triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return p;\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m.next;\n\n    while (p !== stop) {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    }\n\n    return m;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&\n           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    if ((equals(p1, q1) && equals(p2, q2)) ||\n        (equals(p1, q2) && equals(p2, q1))) return true;\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&\n           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertice index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertice nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/earcut/src/earcut.js?");

/***/ }),

/***/ "./node_modules/falcor-http-datasource/src/XMLHttpSource.js":
/*!******************************************************************!*\
  !*** ./node_modules/falcor-http-datasource/src/XMLHttpSource.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar request = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './request'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nvar buildQueryObject = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './buildQueryObject'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nvar isArray = Array.isArray;\n\nfunction simpleExtend(obj, obj2) {\n  var prop;\n  for (prop in obj2) {\n    obj[prop] = obj2[prop];\n  }\n  return obj;\n}\n\nfunction XMLHttpSource(jsongUrl, config) {\n  this._jsongUrl = jsongUrl;\n  if (typeof config === 'number') {\n    var newConfig = {\n      timeout: config\n    };\n    config = newConfig;\n  }\n  this._config = simpleExtend({\n    timeout: 15000,\n    headers: {}\n  }, config || {});\n}\n\nXMLHttpSource.prototype = {\n  // because javascript\n  constructor: XMLHttpSource,\n  /**\n   * buildQueryObject helper\n   */\n  buildQueryObject: buildQueryObject,\n\n  /**\n   * @inheritDoc DataSource#get\n   */\n  get: function httpSourceGet(pathSet) {\n    var method = 'GET';\n    var queryObject = this.buildQueryObject(this._jsongUrl, method, {\n      paths: pathSet,\n      method: 'get'\n    });\n    var config = simpleExtend(queryObject, this._config);\n    // pass context for onBeforeRequest callback\n    var context = this;\n    return request(method, config, context);\n  },\n\n  /**\n   * @inheritDoc DataSource#set\n   */\n  set: function httpSourceSet(jsongEnv) {\n    var method = 'POST';\n    var queryObject = this.buildQueryObject(this._jsongUrl, method, {\n      jsonGraph: jsongEnv,\n      method: 'set'\n    });\n    var config = simpleExtend(queryObject, this._config);\n    config.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n    \n    // pass context for onBeforeRequest callback\n    var context = this;\n    return request(method, config, context);\n\n  },\n\n  /**\n   * @inheritDoc DataSource#call\n   */\n  call: function httpSourceCall(callPath, args, pathSuffix, paths) {\n    // arguments defaults\n    args = args || [];\n    pathSuffix = pathSuffix || [];\n    paths = paths || [];\n\n    var method = 'POST';\n    var queryData = [];\n    queryData.push('method=call');\n    queryData.push('callPath=' + encodeURIComponent(JSON.stringify(callPath)));\n    queryData.push('arguments=' + encodeURIComponent(JSON.stringify(args)));\n    queryData.push('pathSuffixes=' + encodeURIComponent(JSON.stringify(pathSuffix)));\n    queryData.push('paths=' + encodeURIComponent(JSON.stringify(paths)));\n\n    var queryObject = this.buildQueryObject(this._jsongUrl, method, queryData.join('&'));\n    var config = simpleExtend(queryObject, this._config);\n    config.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n    \n    // pass context for onBeforeRequest callback\n    var context = this;\n    return request(method, config, context);\n  }\n};\n// ES6 modules\nXMLHttpSource.XMLHttpSource = XMLHttpSource;\nXMLHttpSource['default'] = XMLHttpSource;\n// commonjs\nmodule.exports = XMLHttpSource;\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/falcor-http-datasource/src/XMLHttpSource.js?");

/***/ }),

/***/ "./node_modules/falcor/dist/falcor.browser.min.js":
/*!********************************************************!*\
  !*** ./node_modules/falcor/dist/falcor.browser.min.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var require;var require;!function(t){if(true)module.exports=t();else { var e; }}(function(){var t;return function e(t,n,r){function o(s,u){if(!n[s]){if(!t[s]){var a=\"function\"==typeof require&&require;if(!u&&a)return require(s,!0);if(i)return i(s,!0);var c=new Error(\"Cannot find module '\"+s+\"'\");throw c.code=\"MODULE_NOT_FOUND\",c}var p=n[s]={exports:{}};t[s][0].call(p.exports,function(e){var n=t[s][1][e];return o(n?n:e)},p,p.exports,e,t,n,r)}return n[s].exports}for(var i=\"function\"==typeof require&&require,s=0;s<r.length;s++)o(r[s]);return o}({1:[function(t,e,n){var r=t(32),o=t(130);r.atom=o.atom,r.ref=o.ref,r.error=o.error,r.pathValue=o.pathValue,r.HttpDataSource=t(125),e.exports=r},{125:125,130:130,32:32}],2:[function(t,e,n){function r(t){var e=t||{};this._root=e._root||new o(e),this._path=e.path||e._path||[],this._scheduler=e.scheduler||e._scheduler||new l,this._source=e.source||e._source,this._request=e.request||e._request||new s(this,this._scheduler),this._ID=N++,\"number\"==typeof e.maxSize?this._maxSize=e.maxSize:this._maxSize=e._maxSize||r.prototype._maxSize,\"number\"==typeof e.collectRatio?this._collectRatio=e.collectRatio:this._collectRatio=e._collectRatio||r.prototype._collectRatio,(e.boxed||e.hasOwnProperty(\"_boxed\"))&&(this._boxed=e.boxed||e._boxed),(e.materialized||e.hasOwnProperty(\"_materialized\"))&&(this._materialized=e.materialized||e._materialized),\"boolean\"==typeof e.treatErrorsAsValues?this._treatErrorsAsValues=e.treatErrorsAsValues:e.hasOwnProperty(\"_treatErrorsAsValues\")&&(this._treatErrorsAsValues=e._treatErrorsAsValues),e.cache&&this.setCache(e.cache)}var o=t(4),i=t(3),s=t(55),u=t(64),a=t(65),c=t(61),p=t(63),h=t(73),f=t(75),l=t(74),d=t(81),v=t(84),y=t(49),b=t(134),m=t(88),g=t(100),w=t(96),x=t(102),_=t(98),S=t(99),E=t(77),C=t(76),A=t(130),N=0,k=t(116),O=function(){},P=t(14),j=t(19),D={pathValue:!0,pathSyntax:!0,json:!0,jsonGraph:!0},q=t(72);e.exports=r,r.ref=A.ref,r.atom=A.atom,r.error=A.error,r.pathValue=A.pathValue,r.prototype.constructor=r,r.prototype._materialized=!1,r.prototype._boxed=!1,r.prototype._progressive=!1,r.prototype._treatErrorsAsValues=!1,r.prototype._maxSize=Math.pow(2,53)-1,r.prototype._collectRatio=.75,r.prototype.get=t(71),r.prototype._getWithPaths=t(70),r.prototype.set=function(){var t=k(arguments,D,\"set\");return t!==!0?new u(function(e){e.onError(t)}):this._set.apply(this,arguments)},r.prototype.preload=function(){var t=k(arguments,q,\"preload\");if(t!==!0)return new u(function(e){e.onError(t)});var e=Array.prototype.slice.call(arguments),n=this;return new u(function(t){return n.get.apply(n,e).subscribe(function(){},function(e){t.onError(e)},function(){t.onCompleted()})})},r.prototype._set=function(){var t,e=-1,n=arguments.length,r=arguments[n-1];for(w(r)?n-=1:r=void 0,t=new Array(n);++e<n;)t[e]=arguments[e];return a.create(this,t,r)},r.prototype.call=function(){var t,e=-1,n=arguments.length;for(t=new Array(n);++e<n;){var r=arguments[e];t[e]=r;var o=typeof r;if(e>1&&!Array.isArray(r)||0===e&&!Array.isArray(r)&&\"string\"!==o||1===e&&!Array.isArray(r)&&!x(r))return new u(function(t){t.onError(new Error(\"Invalid argument\"))})}return c.create(this,t)},r.prototype.invalidate=function(){var t,e=-1,n=arguments.length,r=arguments[n-1];for(t=new Array(n);++e<n;)if(t[e]=b.fromPath(arguments[e]),\"object\"!=typeof t[e])throw new Error(\"Invalid argument\");p.create(this,t,r).subscribe(O,function(t){throw t})},r.prototype.deref=t(5),r.prototype.getValue=t(16),r.prototype.setValue=t(79),r.prototype._getValueSync=t(24),r.prototype._setValueSync=t(80),r.prototype._derefSync=t(6),r.prototype.setCache=function(t){var e=this._root.cache;if(t!==e){var n=this._root,r=this._path;this._path=[],this._root.cache={},\"undefined\"!=typeof e&&y(n,n.expired,m(e),0),S(t)?C(this,[t]):_(t)?E(this,[t]):g(t)&&E(this,[{json:t}]),this._path=r}else\"undefined\"==typeof e&&(this._root.cache={});return this},r.prototype.getCache=function(){var t=v(arguments);if(0===t.length)return P(this._root.cache);var e=[{}],n=this._path;return j.getWithPathsAsJSONGraph(this,t,e),this._path=n,e[0].jsonGraph},r.prototype.getVersion=function(t){var e=t&&b.fromPath(t)||[];if(Array.isArray(e)===!1)throw new Error(\"Model#getVersion must be called with an Array path.\");return this._path.length&&(e=this._path.concat(e)),this._getVersion(this,e)},r.prototype._syncCheck=function(t){if(Boolean(this._source)&&this._root.syncRefCount<=0&&this._root.unsafeMode===!1)throw new Error(\"Model#\"+t+\" may only be called within the context of a request selector.\");return!0},r.prototype._clone=function(t){var e=new r(this);for(var n in t){var o=t[n];\"delete\"===o?delete e[n]:e[n]=o}return e.setCache=void 0,e},r.prototype.batch=function(t){var e=t;\"number\"==typeof e?e=new f(Math.round(Math.abs(e))):e&&e.schedule||(e=new h);var n=this._clone();return n._request=new s(n,e),n},r.prototype.unbatch=function(){var t=this._clone();return t._request=new s(t,new l),t},r.prototype.treatErrorsAsValues=function(){return this._clone({_treatErrorsAsValues:!0})},r.prototype.asDataSource=function(){return new i(this)},r.prototype._materialize=function(){return this._clone({_materialized:!0})},r.prototype._dematerialize=function(){return this._clone({_materialized:\"delete\"})},r.prototype.boxValues=function(){return this._clone({_boxed:!0})},r.prototype.unboxValues=function(){return this._clone({_boxed:\"delete\"})},r.prototype.withoutDataSource=function(){return this._clone({_source:\"delete\"})},r.prototype.toJSON=function(){return{$type:\"ref\",value:this._path}},r.prototype.getPath=function(){return d(this._path)},r.prototype._getBoundValue=t(13),r.prototype._getVersion=t(18),r.prototype._getValueSync=t(17),r.prototype._getPathValuesAsPathMap=j.getWithPathsAsPathMap,r.prototype._getPathValuesAsJSONG=j.getWithPathsAsJSONGraph,r.prototype._setPathValuesAsJSON=t(78),r.prototype._setPathValuesAsJSONG=t(78),r.prototype._setPathValuesAsPathMap=t(78),r.prototype._setPathValuesAsValues=t(78),r.prototype._setPathMapsAsJSON=t(77),r.prototype._setPathMapsAsJSONG=t(77),r.prototype._setPathMapsAsPathMap=t(77),r.prototype._setPathMapsAsValues=t(77),r.prototype._setJSONGsAsJSON=t(76),r.prototype._setJSONGsAsJSONG=t(76),r.prototype._setJSONGsAsPathMap=t(76),r.prototype._setJSONGsAsValues=t(76),r.prototype._setCache=t(77),r.prototype._invalidatePathValuesAsJSON=t(48),r.prototype._invalidatePathMapsAsJSON=t(47)},{100:100,102:102,116:116,13:13,130:130,134:134,14:14,16:16,17:17,18:18,19:19,24:24,3:3,4:4,47:47,48:48,49:49,5:5,55:55,6:6,61:61,63:63,64:64,65:65,70:70,71:71,72:72,73:73,74:74,75:75,76:76,77:77,78:78,79:79,80:80,81:81,84:84,88:88,96:96,98:98,99:99}],3:[function(t,e,n){function r(t){this._model=t._materialize().treatErrorsAsValues()}r.prototype.get=function(t){return this._model.get.apply(this._model,t)._toJSONG()},r.prototype.set=function(t){return this._model.set(t)._toJSONG()},r.prototype.call=function(t,e,n,r){var o=[t,e,n].concat(r);return this._model.call.apply(this._model,o)._toJSONG()},e.exports=r},{}],4:[function(t,e,n){function r(t){var e=t||{};this.syncRefCount=0,this.expired=e.expired||[],this.unsafeMode=e.unsafeMode||!1,this.collectionScheduler=e.collectionScheduler||new s,this.cache={},o(e.comparator)&&(this.comparator=e.comparator),o(e.errorSelector)&&(this.errorSelector=e.errorSelector),o(e.onChange)&&(this.onChange=e.onChange)}var o=t(96),i=t(91),s=t(74);r.prototype.errorSelector=function(t,e){return e},r.prototype.comparator=function(t,e){return i(t,\"value\")&&i(e,\"value\")?t.value===e.value&&t.$type===e.$type&&t.$expires===e.$expires:t===e},e.exports=r},{74:74,91:91,96:96}],5:[function(t,e,n){function r(t,e){var n,r=!1;try{++t._root.syncRefCount,n=t._derefSync(e)}catch(i){n=i,r=!0}finally{--t._root.syncRefCount}return r?o.Observable[\"throw\"](n):o.Observable[\"return\"](n)}var o=t(159),i=t(134);e.exports=function(t){for(var e=this,n=-1,s=arguments.length-1,u=new Array(s),a=i.fromPath(t);++n<s;)u[n]=i.fromPath(arguments[n+1]);if(0===s)throw new Error(\"Model#deref requires at least one value path.\");return o.Observable.defer(function(){return r(e,a)}).flatMap(function(t){if(Boolean(t)){if(s>0){var n=o.Observable.of(t);return t.get.apply(t,u)[\"catch\"](o.Observable.empty()).concat(n).last().flatMap(function(){return r(e,a)}).filter(function(t){return t})}return o.Observable[\"return\"](t)}if(s>0){var i=u.map(function(t){return a.concat(t)});return e.get.apply(e,i).concat(o.Observable.defer(function(){return r(e,a)})).last().filter(function(t){return t})}return o.Observable.empty()})}},{134:134,159:159}],6:[function(t,e,n){var r=t(134),o=t(13),i=t(8),s=t(118);e.exports=function(t){var e=r.fromPath(t);if(!Array.isArray(e))throw new Error(\"Model#derefSync must be called with an Array path.\");var n=o(this,this._path.concat(e),!1),u=n.path,a=n.value,c=n.found;if(c&&void 0!==a&&(a.$type!==s||void 0!==a.value)){if(a.$type)throw new i;return this._clone({_path:u})}}},{118:118,13:13,134:134,8:8}],7:[function(t,e,n){function r(){this.message=r.message,this.stack=(new Error).stack}r.prototype=new Error,r.prototype.name=\"BoundJSONGraphModelError\",r.message=\"It is not legal to use the JSON Graph format from a bound Model. JSON Graph format can only be used from a root model.\",e.exports=r},{}],8:[function(t,e,n){function r(t,e){this.message=i,this.stack=(new Error).stack,this.boundPath=t,this.shortedPath=e}var o=\"InvalidModelError\",i=\"The boundPath of the model is not valid since a value or error was found before the path end.\";r.prototype=new Error,r.prototype.name=o,r.message=i,e.exports=r},{}],9:[function(t,e,n){function r(t){this.message=\"An exception was thrown when making a request.\",this.stack=(new Error).stack,this.innerError=t}var o=\"InvalidSourceError\";r.prototype=new Error,r.prototype.name=o,r.is=function(t){return t&&t.name===o},e.exports=r},{}],10:[function(t,e,n){function r(){this.message=\"The allowed number of retries have been exceeded.\",this.stack=(new Error).stack}var o=\"MaxRetryExceededError\";r.prototype=new Error,r.prototype.name=o,r.is=function(t){return t&&t.name===o},e.exports=r},{}],11:[function(t,e,n){function r(t,e,n,r,o,h,f){for(var l,d,v=n,y=o,b=r,m=0;;){if(0===m&&b[c]?(m=y.length,d=b[c]):(l=y[m++],d=v[l]),d){var g=d.$type,w=g&&d.value||d;if(m<y.length){if(g){v=d;break}v=d;continue}if(v=d,g&&u(d))break;if(b[c]||i(b,d),g===a){f?s(t,d,h,null,null,null,y,y.length,f):p(t,d),m=0,y=w,b=d,v=e;continue}break}v=void 0;break}if(m<y.length&&void 0!==v){for(var x=[],_=0;m>_;_++)x[_]=y[_];y=x}return[v,y]}var o=t(26),i=o.create,s=t(22),u=t(27),a=t(120),c=t(33),p=t(29).promote;e.exports=r},{120:120,22:22,26:26,27:27,29:29,33:33}],12:[function(t,e,n){var r=t(15),o=t(8),i=t(7);e.exports=function(t,e){return function(n,s,u){var a,c,p,h=u[0],f={values:u,optimizedPaths:[]},l=n._root.cache,d=n._path,v=l,y=d.length,b=[];if(y){if(e)return{criticalError:new i};if(v=r(n,d),v.$type)return{criticalError:new o(d,d)};for(a=[],c=0;y>c;++c)a[c]=d[c]}else a=[],y=0;for(c=0,p=s.length;p>c;c++)t(n,l,v,s[c],0,h,f,b,a,y,e);return f}}},{15:15,7:7,8:8}],13:[function(t,e,n){var r=t(17),o=t(8);e.exports=function(t,e,n){var i,s,u,a,c,p=e,h=e;for(i=t._boxed,n=t._materialized,s=t._treatErrorsAsValues,t._boxed=!0,t._materialized=void 0===n||n,t._treatErrorsAsValues=!0,u=r(t,p.concat(null),!0),t._boxed=i,t._materialized=n,t._treatErrorsAsValues=s,p=u.optimizedPath,a=u.shorted,c=u.found,u=u.value;p.length&&null===p[p.length-1];)p.pop();if(c&&a)throw new o(h,p);return{path:p,value:u,shorted:a,found:c}}},{17:17,8:8}],14:[function(t,e,n){function r(t){var e,n,r,o={},i=Object.keys(t);for(n=0,r=i.length;r>n;n++)e=i[n],s(e)||(o[e]=t[e]);return o}function o(t,e,n){Object.keys(t).filter(function(e){return!s(e)&&t[e]}).forEach(function(n){var s=t[n],u=e[n];if(u||(u=e[n]={}),s.$type){var a,c=s.value&&\"object\"==typeof s.value,p=!t[i];return a=c||p?r(s):s.value,void(e[n]=a)}o(s,u,n)})}var i=t(37),s=t(97);e.exports=function(t){var e={};return o(t,e),e}},{37:37,97:97}],15:[function(t,e,n){e.exports=function(t,e){for(var n=t._root.cache,r=-1,o=e.length;++r<o&&n&&!n.$type;)n=n[e[r]];return n}},{}],16:[function(t,e,n){var r=t(64),o=t(134);e.exports=function(t){for(var e=o.fromPath(t),n=0,i=e.length;++n<i;)if(\"object\"==typeof e[n])return new r(function(t){t.onError(new Error(\"Paths must be simple paths\"))});var s=this;return new r(function(t){return s.get(e).subscribe(function(n){for(var r=n.json,o=-1,i=e.length;r&&++o<i;)r=r[e[o]];t.onNext(r)},function(e){t.onError(e)},function(){t.onCompleted()})})}},{134:134,64:64}],17:[function(t,e,n){var r=t(11),o=t(25),i=t(27),s=t(29).promote,u=t(120),a=t(118),c=t(119);e.exports=function(t,e,n){for(var p,h,f,l,d,v=t._root.cache,y=e.length,b=[],m=!1,g=!1,w=0,x=v,_=v,S=v,E=!0,C=!1;x&&y>w;){if(p=e[w++],null!==p&&(x=_[p],b[b.length]=p),!x){S=void 0,m=!0,E=!1;break}if(f=x.$type,f===a&&void 0===x.value){S=void 0,E=!1,m=y>w;break}if(y>w){if(f===u){if(i(x)){C=!0,S=void 0,E=!1;break}if(l=r(t,v,v,x,x.value),d=l[0],!d){S=void 0,x=void 0,E=!1;break}f=d.$type,x=d,b=l[1].slice(0)}if(f)break}else S=x;_=x}if(y>w&&!C){for(h=w;y>h;++h)if(null!==e[w]){g=!0;break}for(g?(m=!0,S=void 0):S=x,h=w;y>h;++h)null!==e[h]&&(b[b.length]=e[h])}if(S&&f&&(i(S)?S=void 0:s(t,S)),S&&f===c&&!t._treatErrorsAsValues)throw{path:w===y?e:e.slice(0,w),value:S.value};return S&&t._boxed?S=Boolean(f)&&!n?o(S):S:!S&&t._materialized?S={$type:a}:S&&(S=S.value),{value:S,shorted:m,optimizedPath:b,found:E}}},{11:11,118:118,119:119,120:120,25:25,27:27,29:29}],18:[function(t,e,n){var r=t(46);e.exports=function(t,e){var n=t._getValueSync({_boxed:!0,_root:t._root,_treatErrorsAsValues:t._treatErrorsAsValues},e,!0).value,o=n&&n[r];return null==o?-1:o}},{46:46}],19:[function(t,e,n){var r=t(12),o=t(31),i=r(o,!1),s=r(o,!0);e.exports={getValueSync:t(17),getBoundValue:t(13),getWithPathsAsPathMap:i,getWithPathsAsJSONGraph:s}},{12:12,13:13,17:17,31:31}],20:[function(t,e,n){var r=t(29),o=t(25),i=r.promote;e.exports=function(t,e,n,r,s){var u=e.value;s.errors||(s.errors=[]),t._boxed&&(u=o(e)),s.errors.push({path:r.slice(0,n+1),value:u}),i(t,e)}},{25:25,29:29}],21:[function(t,e,n){function r(t,e,n,r,o,i,s){s.requestedMissingPaths.push(r.slice(0,n).concat(e)),s.optimizedMissingPaths.push(o.slice(0,i).concat(e))}var o=t(30),i=o.fastCopy;e.exports=function(t,e,n,o,s,u,a){var c;o.requestedMissingPaths||(o.requestedMissingPaths=[],o.optimizedMissingPaths=[]),c=n<e.length?i(e,n):[],r(t,c,n,s,u,a,o)}},{30:30}],22:[function(t,e,n){var r=t(29),o=t(25),i=r.promote,s=t(120),u=t(118),a=t(119),c=t(37);e.exports=function(t,e,n,r,p,h,f,l,d,v){if(n){var y,b,m,g,w,x,_,S,E=!1;if(e&&i(t,e),e&&void 0!==e.value||(E=t._materialized),E)S={$type:u};else if(t._boxed)S=o(e);else if(e.$type===s||e.$type===a)S=d?o(e):e.value;else if(d){var C=e.value&&\"object\"==typeof e.value,A=!e[c];S=C||A?o(e):e.value}else S=e.value;if(p&&(p.hasValue=!0),d){for(w=n.jsonGraph,w||(w=n.jsonGraph={},n.paths=[]),y=0,b=l-1;b>y;y++)g=f[y],w[g]||(w[g]={}),w=w[g];g=f[y],w[g]=E?{$type:u}:S,h&&n.paths.push(h.slice(0,r))}else if(0===r)n.json=S;else{for(w=n.json,w||(w=n.json={}),y=0;r-1>y;y++)m=h[y],w[m]||(w[m]={}),x=w,_=m,w=w[m];m=h[y],null!==m?w[m]=S:x[_]=S}}}},{118:118,119:119,120:120,25:25,29:29,37:37}],23:[function(t,e,n){var r=t(27),o=t(26),i=t(29),s=o.remove,u=i.splice,a=t(119),c=t(20),p=t(22),h=t(21),f=t(28),l=t(35);e.exports=function(t,e,n,o,i,d,v,y,b,m,g){var w=e&&e.$type,x=e&&void 0===e.value;return e&&w?void(r(e)?(e[l]||(u(t,e),s(e)),h(t,n,o,d,v,y,b)):w===a?(g&&(v[o]=null),m||t._treatErrorsAsValues?p(t,e,i,o,d,v,y,b,m,g):c(t,e,o,v,d)):(g&&(v[o]=null),(!x||x&&t._materialized)&&p(t,e,i,o,d,v,y,b,m,g))):void(f(t)?p(t,e,i,o,d,v,y,b,m,g):h(t,n,o,d,v,y,b))}},{119:119,20:20,21:21,22:22,26:26,27:27,28:28,29:29,35:35}],24:[function(t,e,n){var r=t(134);e.exports=function(t){var e=r.fromPath(t);if(Array.isArray(e)===!1)throw new Error(\"Model#getValueSync must be called with an Array path.\");return this._path.length&&(e=this._path.concat(e)),this._syncCheck(\"getValueSync\")&&this._getValueSync(this,e).value}},{134:134}],25:[function(t,e,n){var r=t(40);e.exports=function(t){var e,n,o,i=Object.keys(t);for(e={},n=0,o=i.length;o>n;n++){var s=i[n];s[0]!==r&&(e[s]=t[s])}return e}},{40:40}],26:[function(t,e,n){function r(t,e){var n=e[a]||0;e[i+n]=t,e[a]=n+1,t[u]=n,t[s]=e}function o(t){var e=t[s];if(e){for(var n=t[u],r=e[a];r>n;)e[i+n]=e[i+n+1],++n;e[a]=r-1,t[s]=void 0,t[u]=void 0}}var i=t(43),s=t(33),u=t(42),a=t(44);e.exports={create:r,remove:o}},{33:33,42:42,43:43,44:44}],27:[function(t,e,n){var r=t(106);e.exports=function(t){var e=void 0===t.$expires&&-1||t.$expires;return-1!==e&&1!==e&&(0===e||e<r())}},{106:106}],28:[function(t,e,n){e.exports=function(t){return t._materialized&&!t._source}},{}],29:[function(t,e,n){function r(t,e){var n=t._root,r=n[i];if(r!==e){var o=e[a],s=e[u];s&&(s[a]=o),o&&(o[u]=s),e[a]=void 0,n[i]=e,e[u]=r,r[a]=e}}function o(t,e){var n=t._root,r=e[a],o=e[u];o&&(o[a]=r),r&&(r[u]=o),e[a]=void 0,e===n[i]&&(n[i]=void 0),e===n[s]&&(n[s]=void 0),e[c]=!0,n.expired.push(e)}var i=t(34),s=t(45),u=t(38),a=t(41),c=t(35);e.exports={promote:r,splice:o}},{34:34,35:35,38:38,41:41,45:45}],30:[function(t,e,n){function r(t,e){var n,r,o,i=[];for(r=0,o=e||0,n=t.length;n>o;r++,o++)i[r]=t[o];return i}function o(t,e){var n,r,o,i=[];for(n=0,r=t.length;r>n;n++)i[n]=t[n];for(o=0,r=e.length;r>o;o++)null!==e[o]&&(i[n++]=e[o]);return i}function i(t,e){var n,r,o,i=[];for(n=0,r=t.length;r>n;n++)i[n]=t[n];for(o=0,r=e.length;r>o;o++)i[n++]=e[o];return i}e.exports={fastCat:i,fastCatSkipNulls:o,fastCopy:r}},{}],31:[function(t,e,n){var r=t(11),o=t(23),i=t(27),s=t(143).iterateKeySet,u=t(120),a=t(29).promote;e.exports=function c(t,e,n,p,h,f,l,d,v,y,b,m){var g=m,w=v;if(!n||n&&n.$type||h===p.length)return void o(t,n,p,h,f,l,d,w,y,b,g);var x,_;x=p[h];var S=\"object\"==typeof x,E=h+1,C=!1,A=x;if(S&&(C={},A=s(x,C)),void 0!==A||!C.done){var N=y+1;do{g=!1;var k;null===A?k=n:(k=n[A],w[y]=A,d[h]=A);var O=w,P=N;if(k){var j=k.$type,D=j&&k.value||k;if(E<p.length&&j&&j===u&&!i(k)){b&&o(t,k,p,E,f,l,null,w,P,b,g),a(t,k);var q=r(t,e,e,k,D,f,b);g=!0,k=q[0];var R=q[1];for(O=[],P=R.length,_=0;P>_;++_)O[_]=R[_]}}c(t,e,k,p,E,f,l,d,O,P,b,g),C&&!C.done&&(A=s(x,C))}while(C&&!C.done)}}},{11:11,120:120,143:143,23:23,27:27,29:29}],32:[function(t,e,n){\"use strict\";function r(t){return new r.Model(t)}\"function\"==typeof Promise?r.Promise=Promise:r.Promise=t(151),e.exports=r,r.Model=t(2)},{151:151,2:2}],33:[function(t,e,n){e.exports=t(40)+\"context\"},{40:40}],34:[function(t,e,n){e.exports=t(40)+\"head\"},{40:40}],35:[function(t,e,n){e.exports=t(40)+\"invalidated\"},{40:40}],36:[function(t,e,n){e.exports=t(40)+\"key\"},{40:40}],37:[function(t,e,n){e.exports=\"$modelCreated\"},{}],38:[function(t,e,n){e.exports=t(40)+\"next\"},{40:40}],39:[function(t,e,n){e.exports=t(40)+\"parent\"},{40:40}],40:[function(t,e,n){e.exports=String.fromCharCode(30)},{}],41:[function(t,e,n){e.exports=t(40)+\"prev\"},{40:40}],42:[function(t,e,n){e.exports=t(40)+\"ref-index\"},{40:40}],43:[function(t,e,n){e.exports=t(40)+\"ref\"},{40:40}],44:[function(t,e,n){e.exports=t(40)+\"refs-length\"},{40:40}],45:[function(t,e,n){e.exports=t(40)+\"tail\"},{40:40}],46:[function(t,e,n){e.exports=t(40)+\"version\"},{40:40}],47:[function(t,e,n){function r(t,e,n,o,s,u,c,p,h,f){if(!_(t)&&!t.$type)for(var l in t)if(l[0]!==a&&\"$\"!==l[0]&&m(t,l)){var d=t[l],v=g(d)&&!d.$type,y=i(n,o,s,l,d,v,!1,u,c,p,h,f),w=y[0],x=y[1];w&&(v?r(d,e+1,n,x,w,u,c,p,h,f):A(w,x,l,p)&&C(x,b(w),p,u))}}function o(t,e,n,r,o,s,a,h){if(w(n))return S(n,o,s),[void 0,e];y(s,n);var d=n,v=n.value,b=e;if(n=n[p],null!=n)b=n[c]||e;else{var m=0,g=v.length-1;b=n=e;do{var x=v[m],E=g>m,C=i(e,b,n,x,t,E,!0,r,o,s,a,h);if(n=C[0],_(n))return C;b=C[1]}while(m++<g);if(d[p]!==n){var A=n[l]||0;n[l]=A+1,n[u+A]=d,d[p]=n,d[f]=A}}return[n,b]}function i(t,e,n,r,i,u,a,c,p,h,f,l){for(var v=n.$type;v===d;){var y=o(i,t,n,c,p,h,f,l);if(n=y[0],_(n))return y;e=y[1],v=n&&n.$type}if(void 0!==v)return[n,e];if(null==r){if(u)throw new Error(\"`null` is not allowed in branch key positions.\");n&&(r=n[s])}else e=n,n=e[r];return[n,e]}var s=t(36),u=t(43),a=t(40),c=t(39),p=t(33),h=t(46),f=t(42),l=t(44),d=t(120),v=t(13),y=t(50),b=t(88),m=t(91),g=t(100),w=t(95),x=t(96),_=t(102),S=t(86),E=t(92),C=t(115),A=t(109);e.exports=function(t,e){for(var n=t._root,o=n,i=n.expired,s=E(),u=n._comparator,a=n._errorSelector,p=t._path,f=n.cache,l=p.length?v(t,p).value:f,d=l[c]||f,y=f[h],b=-1,m=e.length;++b<m;){var g=e[b];r(g.json,0,f,d,l,s,i,o,u,a)}var w=f[h],_=n.onChange;x(_)&&y!==w&&_()}},{100:100,102:102,109:109,115:115,120:120,13:13,33:33,36:36,39:39,40:40,42:42,43:43,44:44,46:46,50:50,86:86,88:88,91:91,92:92,95:95,96:96}],48:[function(t,e,n){function r(t,e,n,o,s,u,a,c){var p={},h=e<t.length-1,f=t[e],l=x(f,p);do{var d=i(n,o,s,l,h,!1,u,a,c),v=d[0],b=d[1];v&&(h?r(t,e+1,n,b,v,u,a,c):E(v,b,l,c)&&S(b,y(v),c,u)),l=x(f,p)}while(!p.done)}function o(t,e,n,r,o){if(b(e))return w(e,r,o),[void 0,t];v(o,e);var s=e,p=e.value,l=t;if(e=e[c],null!=e)l=e[a]||t;else{var d=0,y=p.length-1;l=e=t;do{var m=p[d],x=y>d,_=i(t,l,e,m,x,!0,n,r,o);if(e=_[0],g(e))return _;l=_[1]}while(d++<y);if(s[c]!==e){var S=e[f]||0;e[f]=S+1,e[u+S]=s,s[c]=e,s[h]=S}}return[e,l]}function i(t,e,n,r,i,u,a,c,p){for(var h=n.$type;h===l;){var f=o(t,n,a,c,p);if(n=f[0],g(n))return f;e=f[1],h=n.$type}if(void 0!==h)return[n,e];if(null==r){if(i)throw new Error(\"`null` is not allowed in branch key positions.\");n&&(r=n[s])}else e=n,n=e[r];return[n,e]}var s=t(36),u=t(43),a=t(39),c=t(33),p=t(46),h=t(42),f=t(44),l=t(120),d=t(13),v=t(50),y=t(88),b=t(95),m=t(96),g=t(102),w=t(86),x=t(143).iterateKeySet,_=t(92),S=t(115),E=t(109);e.exports=function(t,e){for(var n=t._root,o=n,i=n.expired,s=_(),u=t._path,c=n.cache,h=u.length?d(t,u).value:c,f=h[a]||c,l=c[p],v=-1,y=e.length;++v<y;){var b=e[v];r(b,0,c,f,h,s,i,o)}var g=c[p],w=n.onChange;m(w)&&l!==g&&w()}},{102:102,109:109,115:115,120:120,13:13,143:143,33:33,36:36,39:39,42:42,43:43,44:44,46:46,50:50,86:86,88:88,92:92,95:95,96:96}],49:[function(t,e,n){var r=t(36),o=t(39),i=t(34),s=t(45),u=t(38),a=t(41),c=t(108),p=t(115);e.exports=function(t,e,n,h,f,l){var d=n,v=f;\"number\"!=typeof v&&(v=.75);var y,b,m,g=\"number\"==typeof l,w=h*v;for(b=e.pop();b;)m=b.$size||0,d-=m,g===!0?p(b,m,t,l):(y=b[o])&&c(b,y,b[r],t),b=e.pop();if(d>=h){var x=t[s];for(b=x;d>=w&&b;)x=x[a],m=b.$size||0,d-=m,g===!0&&p(b,m,t,l),b=x;t[s]=t[a]=b,null==b?t[i]=t[u]=void 0:b[u]=void 0}}},{108:108,115:115,34:34,36:36,38:38,39:39,41:41,45:45}],50:[function(t,e,n){var r=t(121),o=t(34),i=t(45),s=t(38),u=t(41),a=t(100);e.exports=function(t,e){if(a(e)&&e.$expires!==r){var n=t[o],c=t[i],p=e[s],h=e[u];e!==n&&(null!=p&&\"object\"==typeof p&&(p[u]=h),null!=h&&\"object\"==typeof h&&(h[s]=p),p=n,null!=n&&\"object\"==typeof n&&(n[u]=e),t[o]=t[s]=n=e,n[s]=p,n[u]=void 0),null!=c&&e!==c||(t[i]=t[u]=c=h||e)}return e}},{100:100,121:121,34:34,38:38,41:41,45:45}],51:[function(t,e,n){var r=t(34),o=t(45),i=t(38),s=t(41);e.exports=function(t,e){var n=t[r],u=t[o],a=e[i],c=e[s];null!=a&&\"object\"==typeof a&&(a[s]=c),null!=c&&\"object\"==typeof c&&(c[i]=a),e===n&&(t[r]=t[i]=a),e===u&&(t[o]=t[s]=c),e[i]=e[s]=void 0,n=u=a=c=void 0}},{34:34,38:38,41:41,45:45}],52:[function(t,e,n){function r(t,e){var n=!1;return function(){if(!n&&!t._disposed){n=!0,t._callbacks[e]=null,t._optimizedPaths[e]=[],t._requestedPaths[e]=[];var r=--t._count;0!==r||t.sent||(t._disposable.dispose(),t.requestQueue.removeRequest(t))}}}function o(t){for(var e=[],n=-1,r=0,o=t.length;o>r;++r)for(var i=t[r],s=0,u=i.length;u>s;++s)e[++n]=i[s];return e}var i=t(59),s=t(60),u=0,a=t(57).GetRequest,c=t(76),p=t(78),h=t(119),f=[],l=function(t,e){this.sent=!1,this.scheduled=!1,this.requestQueue=e,this.id=++u,this.type=a,this._scheduler=t,this._pathMap={},this._optimizedPaths=[],this._requestedPaths=[],this._callbacks=[],this._count=0,this._disposable=null,this._collapsed=null,this._disposed=!1};l.prototype={batch:function(t,e,n){var o=this,i=o._optimizedPaths,u=o._requestedPaths,a=o._callbacks,c=i.length;return i[c]=e,u[c]=t,a[c]=n,++o._count,o.scheduled||(o.scheduled=!0,o._disposable=o._scheduler.schedule(function(){s(o,i,function(t,e){if(o.requestQueue.removeRequest(o),o._disposed=!0,o._count){o._merge(u,t,e);for(var n=0,r=a.length;r>n;++n){var i=a[n];i&&i(t,e)}}})})),r(o,c)},add:function(t,e,n){var o,s,u=this,a=i(t,e,u._pathMap);a?(s=a[2],o=a[1]):(s=t,o=e);var c=!1,p=!1;if(o.length<e.length){c=!0;var h=u._callbacks.length;u._callbacks[h]=n,u._requestedPaths[h]=a[0],u._optimizedPaths[h]=[],++u._count,p=r(u,h)}return[c,s,o,p]},_merge:function(t,e,n){var r=this,i=r.requestQueue.model,s=i._root,u=s.errorSelector,a=s.comparator,l=i._path;i._path=f;var d=o(t);if(e){var v=e;v instanceof Error&&(v={message:v.message}),v.$type||(v={$type:h,value:v});var y=d.map(function(t){return{path:t,value:v}});p(i,y,null,u,a)}else c(i,[{paths:d,jsonGraph:n.jsonGraph}],null,u,a);i._path=l}},e.exports=l},{119:119,57:57,59:59,60:60,76:76,78:78}],53:[function(t,e,n){function r(){this.length=0,this.pending=!1,this.pathmaps=[],s.call(this,this._subscribe)}var o=t(159),i=o.Observer,s=o.Observable,u=o.Disposable,a=o.SerialDisposable,c=o.CompositeDisposable,p=t(9),h=t(143),f=h.iterateKeySet;r.create=function(t,e,n){var r=new this;return r.queue=t,r.model=e,r.index=n,r},r.prototype=Object.create(s.prototype),r.prototype.constructor=r,r.prototype.insertPath=function(t,e,n,r,o){var i=r||0,s=o||t.length-1,u=n||this.pathmaps[s+1]||(this.pathmaps[s+1]=Object.create(null));if(void 0===u||null===u)return!1;var a,c,p=t[i],h={};a=f(p,h);do{if(c=u[a],s>i){if(null==c){if(e)return!1;c=u[a]=Object.create(null)}if(this.insertPath(t,e,c,i+1,s)===!1)return!1}else u[a]=(c||0)+1,this.length+=1;h.done||(a=f(p,h))}while(!h.done);return!0},r.prototype.removePath=function(t,e,n,r){var o=n||0,i=r||t.length-1,s=e||this.pathmaps[i+1];if(void 0===s||null===s)return!0;var u,a,c=0,p=t[o],h={};u=f(p,h);do if(a=s[u],void 0!==a&&null!==a){if(i>o){c+=this.removePath(t,a,o+1,i);var l=void 0;for(l in a)break;void 0===l&&delete s[u]}else a=s[u]=(a||1)-1,0===a&&delete s[u],c+=1,this.length-=1;h.done||(u=f(p,h))}while(!h.done);return c},r.prototype.getSourceObserver=function(t){var e=this;return i.create(function(n){n.jsonGraph=n.jsonGraph||n.jsong||n.values||n.value,n.index=e.index,t.onNext(n)},function(e){t.onError(e)},function(){t.onCompleted()})},r.prototype._subscribe=function(t){var e=this,n=this.queue;e.pending=!0;var r=!1,o=new a,i=u.create(function(){r||(r=!0,n&&n._remove(e))}),s=new c(o,i);try{o.setDisposable(this.model._source[this.method](this.getSourceArgs()).subscribe(this.getSourceObserver(t)))}catch(h){throw new p(h)}return s},e.exports=r},{143:143,159:159,9:9}],54:[function(t,e,n){function r(t,e){this.total=0,this.model=t,this.requests=[],this.scheduler=e}var o=t(58),i=t(40),s=t(90),u=t(100),a=t(143);r.prototype.set=function(t){return t.paths=a.collapse(t.paths),o.create(this.model,t)},r.prototype._remove=function(t){var e=this.requests,n=e.indexOf(t);-1!==n&&e.splice(n,1)},r.prototype.distributePaths=function(t,e,n){var r,o,i=this.model,s=-1,u=t.length,a=-1,c=e.length,p=[];t:for(;++s<u;){var h=t[s];for(a=-1;++a<c;)if(o=e[a],o.insertPath(h,o.pending)){p[a]=o;continue t}r||(r=n.create(this,i,this.total++),e[a]=r,p[c++]=r),r.insertPath(h,!1)}var f=[],l=-1;for(a=-1;++a<c;)o=p[a],null!=o&&(f[++l]=o);return f},r.prototype.mergeJSONGraphs=function(t,e){var n=0,r=[],o=[],a=[],c=t.index,p=e.index;t.index=Math.max(c,p),r[-1]=t.jsonGraph||{},o[-1]=e.jsonGraph||{};t:for(;n>-1;){for(var h=r[n-1],f=o[n-1],l=a[n-1]||(a[n-1]=Object.keys(f));l.length>0;){var d=l.pop();if(d[0]!==i)if(h.hasOwnProperty(d)){var v=h[d],y=s(v),b=f[d],m=s(b);if(u(v)&&u(b)&&!y&&!m){r[n]=v,o[n]=b,n+=1;continue t}p>c&&(h[d]=b)}else h[d]=f[d]}n-=1}return t},e.exports=r},{100:100,143:143,40:40,58:58,90:90}],55:[function(t,e,n){function r(t,e){this.model=t,this.scheduler=e,this.requests=this._requests=[]}var o=t(54),i=t(56);r.prototype.get=i.prototype.get,r.prototype.removeRequest=i.prototype.removeRequest,r.prototype.set=o.prototype.set,r.prototype.call=o.prototype.call,e.exports=r},{54:54,56:56}],56:[function(t,e,n){function r(t,e){this.model=t,this.scheduler=e,this.requests=this._requests=[]}var o=t(57),i=t(52);r.prototype={setScheduler:function(t){this.scheduler=t},get:function(t,e,n){function r(){v||(--h,0===h&&n())}var s,u,a,c=this,p=[],h=0,f=c._requests,l=e,d=t,v=!1;for(s=0,u=f.length;u>s;++s)if(a=f[s],a.type===o.GetRequest){if(a.sent){var y=a.add(d,l,r);y[0]&&(d=y[1],l=y[2],p[p.length]=y[3],++h)}else a.batch(d,l,r),l=[],d=[],++h;if(!l.length)break}if(l.length){a=new i(c.scheduler,c),f[f.length]=a,++h;var b=a.batch(d,l,r);p[p.length]=b}return function(){if(!v&&0!==h){v=!0;for(var t=p.length,e=0;t>e;++e)p[e]()}}},removeRequest:function(t){for(var e=this._requests,n=e.length;--n>=0;)if(e[n].id===t.id){e.splice(n,1);break}}},e.exports=r},{52:52,57:57}],57:[function(t,e,n){e.exports={GetRequest:\"GET\"}},{}],58:[function(t,e,n){function r(){s.call(this)}var o=t(159),i=o.Observer,s=t(53),u=t(83),a=t(76),c=t(78),p=new Array(0);r.create=function(t,e){var n=new r;return n.model=t,n.jsonGraphEnvelope=e,n},r.prototype=Object.create(s.prototype),r.prototype.constructor=r,r.prototype.method=\"set\",r.prototype.insertPath=function(){return!1},r.prototype.removePath=function(){return 0},r.prototype.getSourceArgs=function(){return this.jsonGraphEnvelope},r.prototype.getSourceObserver=function(t){var e=this.model,n=e._path,r=this.jsonGraphEnvelope.paths,o=e._root,h=o.errorSelector,f=o.comparator;return s.prototype.getSourceObserver.call(this,i.create(function(o){e._path=p;var i=a(e,[{paths:r,jsonGraph:o.jsonGraph}],null,h,f);o.paths=i[1],e._path=n,t.onNext(o)},function(o){e._path=p,c(e,u(r,function(t){return{path:t,value:o}}),null,h,f),e._path=n,t.onError(o)},function(){t.onCompleted()}))},e.exports=r},{159:159,53:53,76:76,78:78,83:83}],59:[function(t,e,n){var r=t(143).hasIntersection,o=t(84);e.exports=function(t,e,n){for(var i=[],s=[],u=[],a=-1,c=-1,p=!1,h=0,f=e.length;f>h;++h){var l=e[h],d=n[l.length];d&&r(d,l,0)?(!p&&h>0&&(s=o(t,0,h),i=o(e,0,h)),u[++a]=t[h],p=!0):p&&(i[++c]=l,s[c]=t[h])}return p?[u,i,s]:null}},{143:143,84:84}],60:[function(t,e,n){var r=t(143),o=r.toTree,i=r.toPaths;e.exports=function(t,e,n){if(0===t._count)return void t.requestQueue.removeRequest(t);t.sent=!0,t.scheduled=!1;for(var r=t._pathMap,s=Object.keys(e),u=0,a=s.length;a>u;++u)for(var c=e[u],p=0,h=c.length;h>p;++p){var f=c[p],l=f.length;if(r[l]){var d=r[l];d[d.length]=f}else r[l]=[f]}for(var v=Object.keys(r),y=0,b=v.length;b>y;++y){var m=v[y];r[m]=o(r[m])}var g,w=t._collasped=i(r);t.requestQueue.model._source.get(w).subscribe(function(t){g=t},function(t){n(t,g)},function(){n(null,g)})}},{143:143}],61:[function(t,e,n){function r(t){u.call(this,t||i)}function o(t){return s.Observable.defer(function(){return t})}function i(t){function e(t){function e(t,e){if(Boolean(e.invalidated))t.invalidations.push(t.localThisPath.concat(e.path));else{var n=e.path,r=e.value;Boolean(r)&&\"object\"==typeof r&&r.$type===f?t.references.push({path:i(n),value:e.value}):t.values.push({path:i(n),value:e.value})}return t}function n(t){var e=t.values.concat(t.references);return e.length>0?o(g.set.apply(g,e)._toJSONG()).map(function(e){return{results:t,envelope:e}}):u[\"return\"]({results:t,envelope:{jsonGraph:{},paths:[]}})}function r(t){var e,n=t.envelope,r=t.results,c=r.values,p=r.references,h=r.invalidations,f=c.map(a).map(i),l=p.reduce(s,[]),d=b.map(i),v=l.concat(d);return e=v.length>0?o(m.get.apply(m,f.concat(v))._toJSONG()):u[\"return\"](n),e.doAction(function(t){t.invalidated=h})}function s(t,e){var n=e.path;return t.push.apply(t,y.map(function(t){return n.concat(t)})),t}function a(t){return t.path}var c=t&&t.localFn;if(\"function\"==typeof c){var p=t.model,h=p._path,l=c.apply(p,v).reduce(e,{values:[],references:[],invalidations:[],localThisPath:h}).flatMap(n).flatMap(r);return u[\"return\"](l)}return u.empty()}function n(t){function e(t){var e=t.invalidated;return e&&e.length&&m.invalidate.apply(m,e),t}return t&&\"object\"==typeof t?s.Observable.defer(function(){\nvar e;try{e=t.call(x,v,y,b)}catch(n){e=u[\"throw\"](new p(n))}return e}).map(e):u.empty()}function r(t){return o(g.set(t)).reduce(function(t){return t},null).map(function(){return{invalidated:t.invalidated,paths:t.paths.map(function(t){return t.slice(w.length)})}})}function i(t){return _.concat(t)}var c=this.args,l=this.model,d=h.fromPath(c[0]),v=c[1]||[],y=(c[2]||[]).map(h.fromPath),b=(c[3]||[]).map(h.fromPath),m=l._clone({_path:[]}),g=m.withoutDataSource(),w=l._path,x=w.concat(d),_=x.slice(0,-1),S=o(l.withoutDataSource().get(d)).map(function(t){for(var e=t.json,n=-1,r=d.length;e&&++n<r;)e=e[d[n]];var o=m._derefSync(_).boxValues();return{model:o,localFn:e}}).flatMap(e).defaultIfEmpty(n(l._source)).mergeAll().flatMap(r),E=new a;return E.add(S.subscribe(function(e){var n=e.paths,r=e.invalidated,i=l.get.apply(l,n);\"AsJSONG\"===t.outputFormat&&(i=o(i._toJSONG()).doAction(function(t){t.invalidated=r})),E.add(i.subscribe(t))},function(e){t.onError(e)})),E}var s=t(159)&&t(158),u=s.Observable,a=s.CompositeDisposable,c=t(64),p=t(9),h=t(134),f=t(120);r.create=c.create,r.prototype=Object.create(u.prototype),r.prototype.constructor=r,r.prototype.invokeSourceRequest=function(t){return this},r.prototype.ensureCollect=function(t){return this},r.prototype.initialize=function(){return this},e.exports=r},{120:120,134:134,158:158,159:159,64:64,9:9}],62:[function(t,e,n){function r(t){i.call(this,t)}var o=t(159),i=o.Observable,s=t(64),u=t(134),a=t(88),c=t(49),p=t(81),h=t(46),f=Array.isArray,l=t(101),d=t(98),v=t(99);r.create=s.create,r.prototype=Object.create(i.prototype),r.prototype.constructor=r,r.prototype.subscribeCount=0,r.prototype.subscribeLimit=10,r.prototype.initialize=function(){for(var t,e,n=this.model,r=this.outputFormat||\"AsPathMap\",o=this.isProgressive,i=[{}],s=[],a=this.args,c=-1,h=a.length;++c<h;){var y,b=a[c];f(b)||\"string\"==typeof b?(b=u.fromPath(b),y=\"PathValues\"):l(b)?(b.path=u.fromPath(b.path),y=\"PathValues\"):v(b)?y=\"JSONGs\":d(b)&&(y=\"PathMaps\"),e!==y&&(e=y,t={inputType:y,arguments:[]},s.push(t),t.values=i),t.arguments.push(b)}return this.boundPath=p(n._path),this.groups=s,this.outputFormat=r,this.isProgressive=o,this.isCompleted=!1,this.isMaster=null==n._source,this.values=i,this},r.prototype.invokeSourceRequest=function(t){return this},r.prototype.ensureCollect=function(t){var e=this[\"finally\"](function(){var e=t._root,n=e.cache;e.collectionScheduler.schedule(function(){c(e,e.expired,a(n),t._maxSize,t._collectRatio,n[h])})});return new this.constructor(function(t){return e.subscribe(t)})},e.exports=r},{101:101,134:134,159:159,46:46,49:49,64:64,81:81,88:88,98:98,99:99}],63:[function(t,e,n){function r(t){u.call(this,t||o)}function o(t){for(var e=this.model,n=this.method,r=this.groups,o=-1,i=r.length;++o<i;){var u=r[o],a=u.inputType,c=u.arguments;if(c.length>0){var p=\"_\"+n+a+\"AsJSON\",h=e[p];h(e,c)}}return t.onCompleted(),s.empty}var i=t(159),s=i.Disposable,u=t(62);r.create=u.create,r.prototype=Object.create(u.prototype),r.prototype.method=\"invalidate\",r.prototype.constructor=r,e.exports=r},{159:159,62:62}],64:[function(t,e,n){function r(t){this._subscribe=t}function o(t){var e=this.model,n=new this.type;return n.model=e,n.args=this.args,n.outputFormat=t.outputFormat||\"AsPathMap\",n.isProgressive=t.isProgressive||!1,n.subscribeCount=0,n.subscribeLimit=t.retryLimit||10,n.initialize().invokeSourceRequest(e).ensureCollect(e).subscribe(t)}var i=t(32),s=t(159)&&t(158),u=s.Observable,a=t(84),c=t(105),p={outputFormat:{value:\"AsJSONG\"}},h={isProgressive:{value:!0}};r.create=function(t,e){var n=new r(o);return n.args=e,n.type=this,n.model=t,n},r.prototype=Object.create(u.prototype),r.prototype.constructor=r,r.prototype._mixin=function(){var t=this,e=a(arguments);return new t.constructor(function(n){return t.subscribe(e.reduce(function(t,e){return Object.create(t,e)},n))})},r.prototype._toJSONG=function(){return this._mixin(p)},r.prototype.progressively=function(){return this._mixin(h)},r.prototype.subscribe=function(t,e,n){var r=t;r&&\"object\"==typeof r||(r={onNext:t||c,onError:e||c,onCompleted:n||c});var o=this._subscribe(r);switch(typeof o){case\"function\":return{dispose:o};case\"object\":return o||{dispose:c};default:return{dispose:c}}},r.prototype.then=function(t,e){var n=this;return new i.Promise(function(t,e){var r,o=!1;n.toArray().subscribe(function(t){r=t.length<=1?t[0]:t},function(t){o=!0,e(t)},function(){o===!1&&t(r)})}).then(t,e)},e.exports=r},{105:105,158:158,159:159,32:32,84:84}],65:[function(t,e,n){function r(t){l.call(this,t||o)}function o(t){return this.isCompleted?s.call(this,t):i.call(this,t)}function i(t){if(this.subscribeCount++>this.subscribeLimit)return t.onError(\"Loop kill switch thrown.\"),h.empty;for(var e=[],n=[],r=this.model,o=this.isMaster,i=r._root,c=this.outputFormat,p=i.errorSelector,f=this.method,l=this.groups,d=-1,y=l.length;++d<y;){var b=l[d],m=b.inputType,g=b.arguments;if(g.length>0){var w=\"_\"+f+m+c,x=r[w],_=x(r,g,null,p);n.push.apply(n,_[1]),\"PathValues\"===m?e.push.apply(e,g.map(u)):\"JSONGs\"===m?e.push.apply(e,v(g,a)):e.push.apply(e,_[0])}}return this.requestedPaths=e,o?(this.isCompleted=!0,s.call(this,t)):void t.onError({method:f,optimizedPaths:n,invokeSourceRequest:!0})}function s(t){var e=new f(this.model,this.requestedPaths);return\"AsJSONG\"===this.outputFormat&&(e=e._toJSONG()),this.isProgressive&&(e=e.progressively()),e.subscribe(t)}function u(t){return t.path}function a(t){return t.paths}var c=t(159),p=c.Observable,h=c.Disposable,f=t(67),l=t(62),d=t(9),v=t(82),y=new Array(0);r.create=l.create,r.prototype=Object.create(l.prototype),r.prototype.method=\"set\",r.prototype.constructor=r,r.prototype.invokeSourceRequest=function(t){var e=this,n=this[\"catch\"](function(r){var o;if(r&&r.invokeSourceRequest===!0){var i={},s=t._path,u=r.optimizedPaths;t._path=y,t._getPathValuesAsJSONG(t._materialize().withoutDataSource(),u,[i]),t._path=s,o=t._request.set(i)[\"do\"](function(t){e.isCompleted=u.length===t.paths.length},function(){e.isCompleted=!0}).materialize().flatMap(function(t){if(\"C\"===t.kind)return p.empty();if(\"E\"===t.kind){var e=t.exception;if(d.is(e))return p[\"throw\"](t.exception)}return n})}else o=p[\"throw\"](r);return o});return new this.constructor(function(t){return n.subscribe(t)})},e.exports=r},{159:159,62:62,67:67,82:82,9:9}],66:[function(t,e,n){var r=function(t){this.disposed=!1,this.currentDisposable=t};r.prototype={dispose:function(){if(!this.disposed&&this.currentDisposable){this.disposed=!0;var t=this.currentDisposable;t.dispose?t.dispose():t()}}},e.exports=r},{}],67:[function(t,e,n){var r=t(64),o=t(68),i=t(69),s={dispose:function(){}},u=t(159).Observable,a=e.exports=function(t,e,n,r){this.model=t,this.currentRemainingPaths=e,this.isJSONGraph=n||!1,this.isProgressive=r||!1};a.prototype=Object.create(u.prototype),a.prototype.subscribe=r.prototype.subscribe,a.prototype.then=r.prototype.then,a.prototype._toJSONG=function(){return new a(this.model,this.currentRemainingPaths,!0,this.isProgressive)},a.prototype.progressively=function(){return new a(this.model,this.currentRemainingPaths,this.isJSONGraph,!0)},a.prototype._subscribe=function(t){var e=[{}],n=[],r=t.isJSONG=this.isJSONGraph,u=this.isProgressive,a=o(this.model,this.currentRemainingPaths,t,u,r,e,n);return a?i(this,this.model,a,t,e,n,1):s}},{159:159,64:64,68:68,69:69}],68:[function(t,e,n){var r=t(19),o=r.getWithPathsAsJSONGraph,i=r.getWithPathsAsPathMap;e.exports=function(t,e,n,r,s,u,a){var c;if(c=s?o(t,e,u):i(t,e,u),c.criticalError)return n.onError(c.criticalError),null;var p=c.hasValue,h=!c.requestedMissingPaths||!t._source,f=u[0].json||u[0].jsonGraph;if(c.errors)for(var l=c.errors,d=a.length,v=0,y=l.length;y>v;++v,++d)a[d]=l[v];if(p&&r||f&&h)try{++t._root.syncRefCount,n.onNext(u[0])}catch(b){throw b}finally{--t._root.syncRefCount}return h?(a.length?n.onError(a):n.onCompleted(),null):c}},{19:19}],69:[function(t,e,n){var r=t(68),o=t(10),i=t(30).fastCat,s=t(49),u=t(88),a=t(66),c=t(46);e.exports=function p(t,e,n,h,f,l,d){if(10===d)throw new o;var v=e._request,y=n.requestedMissingPaths,b=n.optimizedMissingPaths,m=new a,g=[],w=e._path;if(w.length)for(var x=0,_=y.length;_>x;++x)g[x]=i(w,y[x]);else g=y;var S=v.get(g,b,function(){var n=r(e,y,h,t.isProgressive,t.isJSONGraph,f,l);if(n)m.currentDisposable=p(t,e,n,h,f,l,d+1);else{var o=e._root,i=o.cache,a=i[c];s(o,o.expired,u(i),e._maxSize,e._collectRatio,a)}});return m.currentDisposable=S,m}},{10:10,30:30,46:46,49:49,66:66,68:68,88:88}],70:[function(t,e,n){var r=t(67);e.exports=function(t){return new r(this,t)}},{67:67}],71:[function(t,e,n){var r=t(134),o=t(64),i=t(72),s=t(116),u=t(67);e.exports=function(){var t=s(arguments,i,\"get\");if(t!==!0)return new o(function(e){e.onError(t)});var e=r.fromPathsOrPathValues(arguments);return new u(this,e)}},{116:116,134:134,64:64,67:67,72:72}],72:[function(t,e,n){e.exports={path:!0,pathSyntax:!0}},{}],73:[function(t,e,n){function r(){}var o=t(123),i=t(159),s=i.Disposable;r.prototype.schedule=function(t){return o(t),s.empty},r.prototype.scheduleWithState=function(t,e){var n=this;return o(function(){e(n,t)}),s.empty},e.exports=r},{123:123,159:159}],74:[function(t,e,n){function r(){}var o=t(159),i=o.Disposable;r.prototype.schedule=function(t){return t(),i.empty},r.prototype.scheduleWithState=function(t,e){return e(this,t),i.empty},e.exports=r},{159:159}],75:[function(t,e,n){function r(t){this.delay=t}var o=t(159),i=o.Disposable;r.prototype.schedule=function(t){var e=setTimeout(t,this.delay);return i.create(function(){void 0!==e&&(clearTimeout(e),e=void 0)})},r.prototype.scheduleWithState=function(t,e){var n=this,r=setTimeout(function(){e(n,t)},this.delay);return i.create(function(){void 0!==r&&(clearTimeout(r),r=void 0)})},e.exports=r},{159:159}],76:[function(t,e,n){function r(t,e,n,o,s,u,a,c,p,h,f,d,v,y,b,g,w){for(var x={},_=e<t.length-1,S=t[e],E=m(S,x),C=d.index;;){f.depth=e;var A=i(n,o,s,u,a,c,E,_,!1,f,d,v,y,b,g,w);f[e]=E,f.index=e,d[d.index++]=E;var N=A[0],k=A[1];if(N&&(_?r(t,e+1,n,k,N,u,A[3],A[2],p,h,f,d,v,y,b,g,w):(l(b,N),p.push(f.slice(0,f.index+1)),h.push(d.slice(0,d.index)))),E=m(S,x),x.done)break;d.index=C}}function o(t,e,n,r,o,s,c,f,v,m,g){var w=e.value;if(s.splice(0,s.length),s.push.apply(s,w),d(e))return s.index=w.length,b(e,f,v),[void 0,t,r,n];l(v,e);var x=0,_=e,S=w.length-1,E=e=t,C=r=n;do{var A=w[x],N=S>x,k=i(t,E,e,n,C,r,A,N,!0,o,s,c,f,v,m,g);if(e=k[0],y(e))return s.index=x,k;E=k[1],r=k[2],C=k[3]}while(x++<S);if(s.index=x,_[a]!==e){var O=e[h]||0;e[h]=O+1,e[u+O]=_,_[a]=e,_[p]=O}return[e,E,r,C]}function i(t,e,n,r,i,u,a,c,p,h,l,d,v,b,m,g){for(var x=n.$type;x===f;){var _=o(t,n,r,u,h,l,d,v,b,m,g);if(n=_[0],y(n))return _;e=_[1],u=_[2],i=_[3],x=n.$type}if(void 0!==x)return[n,e,u,i];if(null==a){if(c)throw new Error(\"`null` is not allowed in branch key positions.\");n&&(a=n[s])}else e=n,i=u,n=e[a],u=i&&i[a];return n=w(e,n,u,a,h,l,d,v,b,m,g),[n,e,u,i]}var s=t(36),u=t(43),a=t(33),c=t(46),p=t(42),h=t(44),f=t(120),l=t(50),d=t(94),v=t(96),y=t(102),b=t(86),m=t(143).iterateKeySet,g=t(92),w=t(103);e.exports=function(t,e,n,o,i){for(var s=t._root,u=s,a=s.expired,p=g(),h=s.cache,f=h[c],l=[],d=[],y=[],b=[],m=-1,w=e.length;++m<w;)for(var x=e[m],_=x.paths,S=x.jsonGraph,E=-1,C=_.length;++E<C;){var A=_[E];d.index=0,r(A,0,h,h,h,S,S,S,y,b,l,d,p,a,u,i,o)}var N=h[c],k=s.onChange;return v(k)&&f!==N&&k(),[y,b]}},{102:102,103:103,120:120,143:143,33:33,36:36,42:42,43:43,44:44,46:46,50:50,86:86,92:92,94:94,96:96}],77:[function(t,e,n){function r(t,e,n,o,u,a,c,p,h,f,l,d,v,y){var b=s(t);if(b&&b.length)for(var g=0,x=b.length,_=h.index;;){var S=b[g],E=t[S],C=w(E)&&!E.$type;p.depth=e;var A=i(n,o,u,S,E,C,!1,p,h,f,l,d,v,y);p[e]=S,p.index=e,h[h.index++]=S;var N=A[0],k=A[1];if(N&&(C?r(E,e+1,n,k,N,a,c,p,h,f,l,d,v,y):(m(d,N),a.push(p.slice(0,p.index+1)),c.push(h.slice(0,h.index)))),++g>=x)break;h.index=_}}function o(t,e,n,r,o,s,u,c,f,v){var y=n.value;if(o.splice(0,o.length),o.push.apply(o,y),x(n))return o.index=y.length,E(n,u,c),[void 0,e];m(c,n);var b=n,g=e;if(n=n[h],null!=n)g=n[p]||e,o.index=y.length;else{var w=0,_=y.length-1;g=n=e;do{var C=y[w],A=_>w,N=i(e,g,n,C,t,A,!0,r,o,s,u,c,f,v);if(n=N[0],S(n))return o.index=w,N;g=N[1]}while(w++<_);if(o.index=w,b[h]!==n){var k=n[d]||0;n[d]=k+1,n[a+k]=b,b[h]=n,b[l]=k}}return[n,g]}function i(t,e,n,r,i,s,a,c,p,h,f,l,d,y){for(var b=n.$type;b===v;){var m=o(i,t,n,c,p,h,f,l,d,y);if(n=m[0],S(n))return m;e=m[1],b=n&&n.$type}if(void 0!==b)return[n,e];if(null==r){if(s)throw new Error(\"`null` is not allowed in branch key positions.\");n&&(r=n[u])}else e=n,n=e[r];return n=A(e,n,r,i,s,a,c,p,h,f,l,d,y),[n,e]}function s(t){if(w(t)&&!t.$type){var e=[],n=0;b(t)&&(e[n++]=\"length\");for(var r in t)r[0]!==c&&\"$\"!==r[0]&&g(t,r)&&(e[n++]=r);return e}}var u=t(36),a=t(43),c=t(40),p=t(39),h=t(33),f=t(46),l=t(42),d=t(44),v=t(120),y=t(13),b=Array.isArray,m=t(50),g=t(91),w=t(100),x=t(95),_=t(96),S=t(102),E=t(86),C=t(92),A=t(104);e.exports=function(t,e,n,o,i){for(var s=t._root,u=s,a=s.expired,c=C(),h=t._path,l=s.cache,d=h.length?y(t,h).value:l,v=d[p]||l,b=l[f],m=[],g=[],w=[],x=h.length,S=-1,E=e.length;++S<E;){var A=e[S],N=h.slice(0);N.index=x,r(A.json,0,l,v,d,g,w,m,N,c,a,u,i,o)}var k=l[f],O=s.onChange;return _(O)&&b!==k&&O(),[g,w]}},{100:100,102:102,104:104,120:120,13:13,33:33,36:36,39:39,40:40,42:42,43:43,44:44,46:46,50:50,86:86,91:91,92:92,95:95,96:96}],78:[function(t,e,n){function r(t,e,n,o,s,u,a,c,p,h,f,l,d,y,b){for(var m={},g=n<e.length-1,x=e[n],_=w(x,m),S=h.index;;){p.depth=n;var E=i(o,s,u,_,t,g,!1,p,h,f,l,d,y,b);p[n]=_,p.index=n,h[h.index++]=_;var C=E[0],A=E[1];if(C&&(g?r(t,e,n+1,o,A,C,a,c,p,h,f,l,d,y,b):(v(d,C),a.push(p.slice(0,p.index+1)),c.push(h.slice(0,h.index)))),_=w(x,m),m.done)break;h.index=S}}function o(t,e,n,r,o,s,p,l,d,b){var w=n.value;if(o.splice(0,o.length),o.push.apply(o,w),y(n))return o.index=w.length,g(n,p,l),[void 0,e];v(l,n);var x=n,_=e;if(n=n[c],null!=n)_=n[a]||e,o.index=w.length;else{var S=0,E=w.length-1;_=n=e;do{var C=w[S],A=E>S,N=i(e,_,n,C,t,A,!0,r,o,s,p,l,d,b);if(n=N[0],m(n))return o.index=S,N;_=N[1]}while(S++<E);if(o.index=S,x[c]!==n){var k=n[f]||0;n[f]=k+1,n[u+k]=x,x[c]=n,x[h]=k}}return[n,_]}function i(t,e,n,r,i,u,a,c,p,h,f,d,v,y){for(var b=n.$type;b===l;){var g=o(i,t,n,c,p,h,f,d,v,y);if(n=g[0],m(n))return g;e=g[1],b=n.$type}if(void 0!==b)return[n,e];if(null==r){if(u)throw new Error(\"`null` is not allowed in branch key positions.\");n&&(r=n[s])}else e=n,n=e[r];return n=_(e,n,r,i,u,a,c,p,h,f,d,v,y),[n,e]}var s=t(36),u=t(43),a=t(39),c=t(33),p=t(46),h=t(42),f=t(44),l=t(120),d=t(13),v=t(50),y=t(95),b=t(96),m=t(102),g=t(86),w=t(143).iterateKeySet,x=t(92),_=t(104);e.exports=function(t,e,n,o,i){for(var s=t._root,u=s,c=s.expired,h=x(),f=t._path,l=s.cache,v=f.length?d(t,f).value:l,y=v[a]||l,m=l[p],g=[],w=[],_=[],S=f.length,E=-1,C=e.length;++E<C;){var A=e[E],N=A.path,k=A.value,O=f.slice(0);O.index=S,r(k,N,0,l,y,v,w,_,g,O,h,c,u,i,o)}var P=l[p],j=s.onChange;return b(j)&&m!==P&&j(),[w,_]}},{102:102,104:104,120:120,13:13,143:143,33:33,36:36,39:39,42:42,43:43,44:44,46:46,50:50,86:86,92:92,95:95,96:96}],79:[function(t,e,n){var r=t(130),o=t(64),i=t(101);e.exports=function(t,e){for(var n=i(t)?t:r.pathValue(t,e),s=0,u=n.path,a=u.length;++s<a;)if(\"object\"==typeof u[s])return new o(function(t){t.onError(new Error(\"Paths must be simple paths\"))});var c=this;return new o(function(t){return c._set(n).subscribe(function(e){for(var n=e.json,r=-1,o=u.length;n&&++r<o;)n=n[u[r]];t.onNext(n)},function(e){t.onError(e)},function(){t.onCompleted()})})}},{101:101,130:130,64:64}],80:[function(t,e,n){var r=t(134),o=t(101),i=t(78);e.exports=function(t,e,n,s){var u=r.fromPath(t),a=e,c=n,p=s;if(o(u)?(p=c,c=a,a=u):a={path:u,value:a},o(a)===!1)throw new Error(\"Model#setValueSync must be called with an Array path.\");return\"function\"!=typeof c&&(c=this._root._errorSelector),\"function\"!=typeof p&&(p=this._root._comparator),this._syncCheck(\"setValueSync\")?(i(this,[a]),this._getValueSync(this,a.path).value):void 0}},{101:101,134:134,78:78}],81:[function(t,e,n){e.exports=function(t){if(!t)return t;for(var e=-1,n=t.length,r=[];++e<n;)r[e]=t[e];return r}},{}],82:[function(t,e,n){e.exports=function(t,e){for(var n=-1,r=-1,o=t.length,i=[];++r<o;)for(var s=e(t[r],r,t),u=-1,a=s.length;++u<a;)i[++n]=s[u];return i}},{}],83:[function(t,e,n){e.exports=function(t,e){for(var n=-1,r=t.length,o=new Array(r);++n<r;)o[n]=e(t[n],n,t);return o}},{}],84:[function(t,e,n){e.exports=function(t,e,n){var r=e||0,o=-1,i=t.length-r;0>i&&(i=0),n>0&&i>n&&(i=n);for(var s=new Array(i);++o<i;)s[o]=t[o+r];return s}},{}],85:[function(t,e,n){var r=t(40),o=t(91),i=Array.isArray,s=t(100);e.exports=function(t){var e=t;if(s(e)){e=i(t)?[]:{};var n=t;for(var u in n)u[0]!==r&&o(n,u)&&(e[u]=n[u])}return e}},{100:100,40:40,91:91}],86:[function(t,e,n){var r=t(51),o=t(35);e.exports=function(t,e,n){return t[o]||(t[o]=!0,e.push(t),r(n,t)),t}},{35:35,51:51}],87:[function(t,e,n){var r=t(100);e.exports=function(t){return r(t)&&t.$expires||void 0}},{100:100}],88:[function(t,e,n){var r=t(100);e.exports=function(t){return r(t)&&t.$size||0}},{100:100}],89:[function(t,e,n){var r=t(100);e.exports=function(t){return r(t)&&t.$timestamp||void 0}},{100:100}],90:[function(t,e,n){var r=t(100);e.exports=function(t,e){var n=r(t)&&t.$type||void 0;return e&&n?\"branch\":n}},{100:100}],91:[function(t,e,n){var r=t(100),o=Object.prototype.hasOwnProperty;e.exports=function(t,e){return r(t)&&o.call(t,e)}},{100:100}],92:[function(t,e,n){var r=1;e.exports=function(){return r++}},{}],93:[function(t,e,n){var r=t(36),o=t(39),i=t(46);e.exports=function(t,e,n,s){return t[r]=n,t[o]=e,t[i]=s,e[n]=t,t}},{36:36,39:39,46:46}],94:[function(t,e,n){var r=t(106),o=t(122),i=t(121);e.exports=function(t){var e=t.$expires;return null!=e&&e!==i&&e!==o&&e<r()}},{106:106,121:121,122:122}],95:[function(t,e,n){var r=t(106),o=t(122),i=t(121);e.exports=function(t){var e=t.$expires;return null!=e&&e!==i&&(e===o||e<r())}},{106:106,121:121,122:122}],96:[function(t,e,n){var r=\"function\";e.exports=function(t){return Boolean(t)&&typeof t===r}},{}],97:[function(t,e,n){var r=t(40);e.exports=function(t){return\"$size\"===t||t&&t.charAt(0)===r}},{40:40}],98:[function(t,e,n){var r=t(100);e.exports=function(t){return r(t)&&\"json\"in t}},{100:100}],99:[function(t,e,n){var r=Array.isArray,o=t(100);e.exports=function(t){return o(t)&&r(t.paths)&&(o(t.jsonGraph)||o(t.jsong)||o(t.json)||o(t.values)||o(t.value))}},{100:100}],100:[function(t,e,n){var r=\"object\";e.exports=function(t){return null!==t&&typeof t===r}},{}],101:[function(t,e,n){var r=Array.isArray,o=t(100);e.exports=function(t){return o(t)&&(r(t.path)||\"string\"==typeof t.path)}},{100:100}],102:[function(t,e,n){var r=\"object\";e.exports=function(t){return null==t||typeof t!==r}},{}],103:[function(t,e,n){var r=t(36),o=t(39),i=t(120),s=t(119),u=t(88),a=t(89),c=t(100),p=t(95),h=t(96),f=t(50),l=t(117),d=t(93),v=t(86),y=t(110),b=t(115),m=t(107);e.exports=function(t,e,n,g,w,x,_,S,E,C,A){var N,k,O,P,j,D,q;if(e===n){if(null===n)return e=l(n,void 0,n),t=b(t,-e.$size,E,_),e=d(e,t,g),f(E,e),e;if(void 0===n)return n;if(P=c(e),P&&(k=e.$type,null==k))return null==e[o]&&(e[r]=g,e[o]=t),e}else P=c(e),P&&(k=e.$type);if(k!==i){if(j=c(n),j&&(O=n.$type),P&&!k&&(null==n||j&&!O))return e}else{if(null==n)return p(e)?void v(e,S,E):e;if(j=c(n),j&&(O=n.$type,O===i))if(e===n){if(null!=e[o])return e}else if(D=e.$timestamp,q=n.$timestamp,!p(e)&&!p(n)&&D>q)return}if(k&&j&&!O)return d(y(e,n,t,g,E),t,g);if(O||!j){if(O===s&&h(A)&&(n=A(m(w,g),n)),O&&e===n)null==e[o]&&(e=l(e,k,e.value),t=b(t,-e.$size,E,_),e=d(e,t,g,_));else{var R=!0;!k&&P||(R=a(n)<a(e)==!1,(k||O)&&h(C)&&(R=!C(e,n,x.slice(0,x.index)))),R&&(n=l(n,O,O?n.value:n),N=u(e)-u(n),e=y(e,n,t,g,E),t=b(t,N,E,_),e=d(e,t,g,_))}p(e)?v(e,S,E):f(E,e)}else null==e&&(e=d(n,t,g));return e}},{100:100,107:107,110:110,115:115,117:117,119:119,120:120,36:36,39:39,50:50,86:86,88:88,89:89,93:93,95:95,96:96}],104:[function(t,e,n){var r=t(120),o=t(119),i=t(90),s=t(88),u=t(89),a=t(95),c=t(102),p=t(96),h=t(117),f=t(86),l=t(93),d=t(110),v=t(115),y=t(114),b=t(107);e.exports=function(t,e,n,m,g,w,x,_,S,E,C,A,N){var k=i(e,w);if(g||w)k&&a(e)&&(k=\"expired\",f(e,E,C)),(k&&k!==r||c(e))&&(e=d(e,{},t,n,C),e=l(e,t,n,S),e=y(e,S));else{var O=m,P=i(O),j=u(O)<u(e)==!1;if((k||P)&&p(A)&&(j=!A(e,O,_.slice(0,_.index))),j){P===o&&p(N)&&(O=N(b(x,n),O)),O=h(O,P,P?O.value:O);var D=s(e)-s(O);e=d(e,O,t,n,C),t=v(t,D,C,S),e=l(e,t,n,S)}}return e}},{102:102,107:107,110:110,114:114,115:115,117:117,119:119,120:120,86:86,88:88,89:89,90:90,93:93,95:95,96:96}],105:[function(t,e,n){e.exports=function(){}},{}],106:[function(t,e,n){e.exports=Date.now},{}],107:[function(t,e,n){e.exports=function(t,e){var n=t.slice(0,t.depth);return n[n.length]=e,n}},{}],108:[function(t,e,n){var r=t(120),o=t(39),i=t(51),s=t(100),u=t(112),a=t(113);e.exports=function(t,e,n,c){if(s(t)){var p=t.$type;return Boolean(p)&&(p===r&&a(t),i(c,t)),u(t),e[n]=t[o]=void 0,!0}return!1}},{100:100,112:112,113:113,120:120,39:39,51:51}],109:[function(t,e,n){var r=t(91),o=t(40),i=t(108);e.exports=function s(t,e,n,u){if(i(t,e,n,u)){if(null==t.$type)for(var a in t)a[0]!==o&&\"$\"!==a[0]&&r(t,a)&&s(t[a],t,a,u);return!0}return!1}},{108:108,40:40,91:91}],110:[function(t,e,n){var r=t(100),o=t(111),i=t(109);e.exports=function(t,e,n,s,u){return t===e?t:(r(t)&&(o(t,e),i(t,n,s,u)),n[s]=e,e)}},{100:100,109:109,111:111}],111:[function(t,e,n){var r=t(43),o=t(33),i=t(44);e.exports=function(t,e){for(var n=t[i]||0,s=e[i]||0,u=-1;++u<n;){var a=t[r+u];void 0!==a&&(a[o]=e,e[r+(s+u)]=a,t[r+u]=void 0)}return e[i]=n+s,t[i]=void 0,e}},{33:33,43:43,44:44}],112:[function(t,e,n){var r=t(43),o=t(33),i=t(42),s=t(44);e.exports=function(t){for(var e=-1,n=t[s]||0;++e<n;){var u=t[r+e];null!=u&&(u[o]=u[i]=t[r+e]=void 0)}return t[s]=void 0,t}},{33:33,42:42,43:43,44:44}],113:[function(t,e,n){var r=t(43),o=t(33),i=t(42),s=t(44);e.exports=function(t){var e=t[o];if(e){for(var n=(t[i]||0)-1,u=(e[s]||0)-1;++n<=u;)e[r+n]=e[r+(n+1)];e[s]=u,t[i]=t[o]=e=void 0}return t}},{33:33,42:42,43:43,44:44}],114:[function(t,e,n){var r=t(43),o=t(39),i=t(46),s=t(44);e.exports=function(t,e){var n=[t],u=0;do{var a=n[u--];if(a&&a[i]!==e){a[i]=e,n[u++]=a[o];for(var c=-1,p=a[s]||0;++c<p;)n[u++]=a[r+c]}}while(u>-1);return t}},{39:39,43:43,44:44,46:46}],115:[function(t,e,n){var r=t(36),o=t(46),i=t(39),s=t(108),u=t(114);e.exports=function(t,e,n,a){var c=t;do{var p=c[i],h=c.$size=(c.$size||0)-e;0>=h&&null!=p?s(c,p,c[r],n):c[o]!==a&&u(c,a),c=p}while(c);return t}},{108:108,114:114,36:36,39:39,46:46}],116:[function(t,e,n){var r=Array.isArray,o=t(101),i=t(99),s=t(98),u=t(134);e.exports=function(t,e,n){for(var a=0,c=t.length;c>a;++a){var p=t[a],h=!1;if(r(p)&&e.path?h=!0:\"string\"==typeof p&&e.pathSyntax?h=!0:o(p)&&e.pathValue?(p.path=u.fromPath(p.path),h=!0):i(p)&&e.jsonGraph?h=!0:s(p)&&e.json?h=!0:\"function\"==typeof p&&a+1===c&&e.selector&&(h=!0),!h)return new Error(\"Unrecognized argument \"+typeof p+\" [\"+String(p)+\"] to Model#\"+n)}return!0}},{101:101,134:134,98:98,99:99}],117:[function(t,e,n){var r=t(130),o=r.atom,i=t(106),s=t(122),u=t(37),a=50,c=t(85),p=Array.isArray,h=t(88),f=t(87);e.exports=function(t,e,n){var r=0,l=t,d=e;if(d?(l=c(l),r=h(l),l.$type=d):(l=o(n),d=l.$type,l[u]=!0),null==n)r=a+1;else if(null==r||0>=r)switch(typeof n){case\"object\":r=p(n)?a+n.length:a+1;break;case\"string\":r=a+n.length;break;default:r=a+1}var v=f(l);return\"number\"==typeof v&&s>v&&(l.$expires=i()+-1*v),l.$size=r,l}},{106:106,122:122,130:130,37:37,85:85,87:87,88:88}],118:[function(t,e,n){e.exports=\"atom\"},{}],119:[function(t,e,n){e.exports=\"error\"},{}],120:[function(t,e,n){e.exports=\"ref\"},{}],121:[function(t,e,n){e.exports=1},{}],122:[function(t,e,n){e.exports=0},{}],123:[function(t,e,n){\"use strict\";function r(){if(a.length)throw a.shift()}function o(t){var e;e=u.length?u.pop():new i,e.task=t,s(e)}function i(){this.task=null}var s=t(124),u=[],a=[],c=s.makeRequestCallFromTimer(r);e.exports=o,i.prototype.call=function(){try{this.task.call()}catch(t){o.onerror?o.onerror(t):(a.push(t),c())}finally{this.task=null,u[u.length]=this}}},{124:124}],124:[function(t,e,n){(function(t){\"use strict\";function n(t){u.length||(s(),a=!0),u[u.length]=t}function r(){for(;c<u.length;){var t=c;if(c+=1,u[t].call(),c>p){for(var e=0,n=u.length-c;n>e;e++)u[e]=u[e+c];u.length-=c,c=0}}u.length=0,c=0,a=!1}function o(t){var e=1,n=new h(t),r=document.createTextNode(\"\");return n.observe(r,{characterData:!0}),function(){e=-e,r.data=e}}function i(t){return function(){function e(){clearTimeout(n),clearInterval(r),t()}var n=setTimeout(e,0),r=setInterval(e,50)}}e.exports=n;var s,u=[],a=!1,c=0,p=1024,h=t.MutationObserver||t.WebKitMutationObserver;s=\"function\"==typeof h?o(r):i(r),n.requestFlush=s,n.makeRequestCallFromTimer=i}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],125:[function(t,e,n){\"use strict\";function r(t,e){var n;for(n in e)t[n]=e[n];return t}function o(t,e){if(this._jsongUrl=t,\"number\"==typeof e){var n={timeout:e};e=n}this._config=r({timeout:15e3,headers:{}},e||{})}var i=t(129),s=t(126);Array.isArray;o.prototype={constructor:o,buildQueryObject:s,get:function(t){var e=\"GET\",n=this.buildQueryObject(this._jsongUrl,e,{paths:t,method:\"get\"}),o=r(n,this._config),s=this;return i(e,o,s)},set:function(t){var e=\"POST\",n=this.buildQueryObject(this._jsongUrl,e,{jsonGraph:t,method:\"set\"}),o=r(n,this._config);o.headers[\"Content-Type\"]=\"application/x-www-form-urlencoded\";var s=this;return i(e,o,s)},call:function(t,e,n,o){e=e||[],n=n||[],o=o||[];var s=\"POST\",u=[];u.push(\"method=call\"),u.push(\"callPath=\"+encodeURIComponent(JSON.stringify(t))),u.push(\"arguments=\"+encodeURIComponent(JSON.stringify(e))),u.push(\"pathSuffixes=\"+encodeURIComponent(JSON.stringify(n))),u.push(\"paths=\"+encodeURIComponent(JSON.stringify(o)));var a=this.buildQueryObject(this._jsongUrl,s,u.join(\"&\")),c=r(a,this._config);c.headers[\"Content-Type\"]=\"application/x-www-form-urlencoded\";var p=this;return i(s,c,p)}},o.XMLHttpSource=o,o[\"default\"]=o,e.exports=o},{126:126,129:129}],126:[function(t,e,n){\"use strict\";e.exports=function(t,e,n){var r,o=[],i={url:t},s=-1!==t.indexOf(\"?\"),u=s?\"&\":\"?\";return\"string\"==typeof n?o.push(n):(r=Object.keys(n),r.forEach(function(t){var e=\"object\"==typeof n[t]?JSON.stringify(n[t]):n[t];o.push(t+\"=\"+encodeURIComponent(e))})),\"GET\"===e?i.url+=u+o.join(\"&\"):i.data=o.join(\"&\"),i}},{}],127:[function(t,e,n){(function(t){\"use strict\";e.exports=function(){var e=new t.XMLHttpRequest;if(\"withCredentials\"in e)return e;if(t.XDomainRequest)return new XDomainRequest;throw new Error(\"CORS is not supported by your browser\")}}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],128:[function(t,e,n){(function(t){\"use strict\";e.exports=function(){var e,n,r;if(t.XMLHttpRequest)return new t.XMLHttpRequest;try{for(n=[\"Msxml2.XMLHTTP\",\"Microsoft.XMLHTTP\",\"Msxml2.XMLHTTP.4.0\"],r=0;3>r;r++)try{if(e=n[r],new t.ActiveXObject(e))break}catch(o){}return new t.ActiveXObject(e)}catch(o){throw new Error(\"XMLHttpRequest is not supported by your browser\")}}}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],129:[function(t,e,n){\"use strict\";function r(){}function o(t,e,n){return r.create(function(r){var o,i,h,f,l,d={method:t||\"GET\",crossDomain:!1,async:!0,headers:{},responseType:\"json\"};for(l in e)p.call(e,l)&&(d[l]=e[l]);d.crossDomain||d.headers[\"X-Requested-With\"]||(d.headers[\"X-Requested-With\"]=\"XMLHttpRequest\"),null!=n.onBeforeRequest&&n.onBeforeRequest(d);try{o=d.crossDomain?c():a()}catch(v){r.onError(v)}try{d.user?o.open(d.method,d.url,d.async,d.user,d.password):o.open(d.method,d.url,d.async),o.timeout=d.timeout,o.withCredentials=d.withCredentials!==!1,h=d.headers;for(f in h)p.call(h,f)&&o.setRequestHeader(f,h[f]);if(d.responseType)try{o.responseType=d.responseType}catch(y){if(\"json\"!==d.responseType)throw y}o.onreadystatechange=function(t){4===o.readyState&&(i||(i=!0,s(r,o,t)))},o.ontimeout=function(t){i||(i=!0,u(r,o,\"timeout error\",t))},o.send(d.data)}catch(y){r.onError(y)}return function(){i||4===o.readyState||(i=!0,o.abort())}})}function i(t,e,n){n||(n=new Error(e)),t.onError(n)}function s(t,e,n){var r,o;if(e&&t){o=e.responseType,r=\"response\"in e?e.response:e.responseText;var s=1223===e.status?204:e.status;if(s>=200&&399>=s){try{\"json\"!==o&&(r=JSON.parse(r||\"\")),\"string\"==typeof r&&(r=JSON.parse(r||\"\"))}catch(n){i(t,\"invalid json\",n)}return t.onNext(r),void t.onCompleted()}return 401===s||403===s||407===s?i(t,r):410===s?i(t,r):408===s||504===s?i(t,r):i(t,r||\"Response code \"+s)}}function u(t,e,n,r){i(t,n||e.statusText||\"request error\",r)}var a=t(128),c=t(127),p=Object.prototype.hasOwnProperty,h=function(){};r.create=function(t){var e=new r;return e.subscribe=function(e,n,r){var o,i;return o=\"function\"==typeof e?{onNext:e,onError:n||h,onCompleted:r||h}:e,i=t(o),\"function\"==typeof i?{dispose:i}:i},e},e.exports=o},{127:127,128:128}],130:[function(t,e,n){function r(t,e,n){var r=Object.create(null);if(null!=n){for(var o in n)r[o]=n[o];return r.$type=t,r.value=e,r}return{$type:t,value:e}}var o=t(134);e.exports={ref:function(t,e){return r(\"ref\",o.fromPath(t),e)},atom:function(t,e){return r(\"atom\",t,e)},undefined:function(){return r(\"atom\")},error:function(t,e){return r(\"error\",t,e)},pathValue:function(t,e){return{path:o.fromPath(t),value:e}},pathInvalidation:function(t){return{path:o.fromPath(t),invalidated:!0}}}},{134:134}],131:[function(t,e,n){e.exports={integers:\"integers\",ranges:\"ranges\",keys:\"keys\"}},{}],132:[function(t,e,n){var r={token:\"token\",dotSeparator:\".\",commaSeparator:\",\",openingBracket:\"[\",closingBracket:\"]\",openingBrace:\"{\",closingBrace:\"}\",escape:\"\\\\\",space:\" \",colon:\":\",quote:\"quote\",unknown:\"unknown\"};e.exports=r},{}],133:[function(t,e,n){e.exports={indexer:{nested:\"Indexers cannot be nested.\",needQuotes:\"unquoted indexers must be numeric.\",empty:\"cannot have empty indexers.\",leadingDot:\"Indexers cannot have leading dots.\",leadingComma:\"Indexers cannot have leading comma.\",requiresComma:\"Indexers require commas between indexer args.\",routedTokens:\"Only one token can be used per indexer when specifying routed tokens.\"},range:{precedingNaN:\"ranges must be preceded by numbers.\",suceedingNaN:\"ranges must be suceeded by numbers.\"},routed:{invalid:\"Invalid routed token.  only integers|ranges|keys are supported.\"},quote:{empty:\"cannot have empty quoted keys.\",illegalEscape:\"Invalid escape character.  Only quotes are escapable.\"},unexpectedToken:\"Unexpected token.\",invalidIdentifier:\"Invalid Identifier.\",invalidPath:\"Please provide a valid path.\",throwError:function(t,e,n){if(n)throw t+\" -- \"+e.parseString+\" with next token: \"+n;throw t+\" -- \"+e.parseString}}},{}],134:[function(t,e,n){var r=t(140),o=t(135),i=t(131),s=function(t,e){return o(new r(t,e))};e.exports=s,s.fromPathsOrPathValues=function(t,e){if(!t)return[];for(var n=[],r=0,o=t.length;o>r;r++)\"string\"==typeof t[r]?n[r]=s(t[r],e):\"string\"==typeof t[r].path?n[r]={path:s(t[r].path,e),value:t[r].value}:n[r]=t[r];return n},s.fromPath=function(t,e){return t?\"string\"==typeof t?s(t,e):t:[]},s.RoutedTokens=i},{131:131,135:135,140:140}],135:[function(t,e,n){var r=t(132),o=t(133),i=t(136);e.exports=function(t){for(var e=t.next(),n={},s=[];!e.done;){switch(e.type){case r.token:var u=+e.token[0];isNaN(u)||o.throwError(o.invalidIdentifier,t),s[s.length]=e.token;break;case r.dotSeparator:0===s.length&&o.throwError(o.unexpectedToken,t);break;case r.space:break;case r.openingBracket:i(t,e,n,s);break;default:o.throwError(o.unexpectedToken,t)}e=t.next()}return 0===s.length&&o.throwError(o.invalidPath,t),s}},{132:132,133:133,136:136}],136:[function(t,e,n){var r=t(132),o=t(133),i=o.indexer,s=t(138),u=t(137),a=t(139);e.exports=function(t,e,n,c){var p=t.next(),h=!1,f=1,l=!1;for(n.indexer=[];!p.done;){switch(p.type){case r.token:case r.quote:n.indexer.length===f&&o.throwError(i.requiresComma,t)}switch(p.type){case r.openingBrace:l=!0,a(t,p,n,c);break;case r.token:var d=+p.token;isNaN(d)&&o.throwError(i.needQuotes,t),n.indexer[n.indexer.length]=d;break;case r.dotSeparator:n.indexer.length||o.throwError(i.leadingDot,t),s(t,p,n,c);\nbreak;case r.space:break;case r.closingBracket:h=!0;break;case r.quote:u(t,p,n,c);break;case r.openingBracket:o.throwError(i.nested,t);break;case r.commaSeparator:++f;break;default:o.throwError(o.unexpectedToken,t)}if(h)break;p=t.next()}0===n.indexer.length&&o.throwError(i.empty,t),n.indexer.length>1&&l&&o.throwError(i.routedTokens,t),1===n.indexer.length&&(n.indexer=n.indexer[0]),c[c.length]=n.indexer,n.indexer=void 0}},{132:132,133:133,137:137,138:138,139:139}],137:[function(t,e,n){var r=t(132),o=t(133),i=o.quote;e.exports=function(t,e,n,s){for(var u=t.next(),a=\"\",c=e.token,p=!1,h=!1;!u.done;){switch(u.type){case r.token:case r.space:case r.dotSeparator:case r.commaSeparator:case r.openingBracket:case r.closingBracket:case r.openingBrace:case r.closingBrace:p&&o.throwError(i.illegalEscape,t),a+=u.token;break;case r.quote:p?(a+=u.token,p=!1):u.token!==c?a+=u.token:h=!0;break;case r.escape:p=!0;break;default:o.throwError(o.unexpectedToken,t)}if(h)break;u=t.next()}0===a.length&&o.throwError(i.empty,t),n.indexer[n.indexer.length]=a}},{132:132,133:133}],138:[function(t,e,n){var r=t(140),o=t(132),i=t(133);e.exports=function(t,e,n,s){var u,a=t.peek(),c=1,p=!1,h=!0,f=n.indexer.length-1,l=r.toNumber(n.indexer[f]);for(isNaN(l)&&i.throwError(i.range.precedingNaN,t);!p&&!a.done;){switch(a.type){case o.dotSeparator:3===c&&i.throwError(i.unexpectedToken,t),++c,3===c&&(h=!1);break;case o.token:u=r.toNumber(t.next().token),isNaN(u)&&i.throwError(i.range.suceedingNaN,t),p=!0;break;default:p=!0}if(p)break;t.next(),a=t.peek()}n.indexer[f]={from:l,to:h?u:u-1}}},{132:132,133:133,140:140}],139:[function(t,e,n){var r=t(132),o=t(131),i=t(133),s=i.routed;e.exports=function(t,e,n,u){var a=t.next(),c=!1,p=\"\";switch(a.token){case o.integers:case o.ranges:case o.keys:break;default:i.throwError(s.invalid,t)}var h=t.next();if(h.type===r.colon&&(c=!0,h=t.next(),h.type!==r.token&&i.throwError(s.invalid,t),p=h.token,h=t.next()),h.type===r.closingBrace){var f={type:a.token,named:c,name:p};n.indexer[n.indexer.length]=f}else i.throwError(s.invalid,t)}},{131:131,132:132,133:133}],140:[function(t,e,n){function r(t,e,n){return{token:t,done:n,type:e}}function o(t,e,n){var o,g=!1,w=\"\",x=n?m:b;do{if(o=e+1>=t.length)break;var _=t[e+1];if(void 0===_||-1!==x.indexOf(_)){if(w.length)break;++e;var S;switch(_){case s:S=i.dotSeparator;break;case u:S=i.commaSeparator;break;case a:S=i.openingBracket;break;case c:S=i.closingBracket;break;case p:S=i.openingBrace;break;case h:S=i.closingBrace;break;case y:S=i.space;break;case d:case v:S=i.quote;break;case l:S=i.escape;break;case f:S=i.colon;break;default:S=i.unknown}g=r(_,S,!1);break}w+=_,++e}while(!o);return!g&&w.length&&(g=r(w,i.token,!1)),g||(g={done:!0}),{token:g,idx:e}}var i=t(132),s=\".\",u=\",\",a=\"[\",c=\"]\",p=\"{\",h=\"}\",f=\":\",l=\"\\\\\",d='\"',v=\"'\",y=\" \",b=\"\\\\'\\\"[]., \",m=\"\\\\{}'\\\"[]., :\",g=e.exports=function(t,e){this._string=t,this._idx=-1,this._extended=e,this.parseString=\"\"};g.prototype={next:function(){var t=this._nextToken?this._nextToken:o(this._string,this._idx,this._extended);return this._idx=t.idx,this._nextToken=!1,this.parseString+=t.token.token,t.token},peek:function(){var t=this._nextToken?this._nextToken:o(this._string,this._idx,this._extended);return this._nextToken=t,t.token}},g.toNumber=function(t){return isNaN(+t)?NaN:+t}},{132:132}],141:[function(t,e,n){var r=t(147),o=t(148);e.exports=function(t){var e=t.reduce(function(t,e){var n=e.length;return t[n]||(t[n]=[]),t[n].push(e),t},{});return Object.keys(e).forEach(function(t){e[t]=o(e[t])}),r(e)}},{147:147,148:148}],142:[function(t,e,n){var r=t(144);e.exports=function o(t,e,n){for(var i=t,s=!0;s&&n<e.length;++n){var u=e[n],a=typeof u;if(u&&\"object\"===a){var c={},p=r(u,c),h=n+1;do{var f=i[p];s=void 0!==f,s&&(s=o(f,e,h)),p=r(u,c)}while(s&&!c.done);break}i=i[u],s=void 0!==i}return s}},{144:144}],143:[function(t,e,n){e.exports={iterateKeySet:t(144),toTree:t(148),toTreeWithUnion:t(149),pathsComplementFromTree:t(146),pathsComplementFromLengthTree:t(145),hasIntersection:t(142),toPaths:t(147),collapse:t(141)}},{141:141,142:142,144:144,145:145,146:146,147:147,148:148,149:149}],144:[function(t,e,n){function r(t,e){var n=e.from=t.from||0,r=e.to=t.to||\"number\"==typeof t.length&&e.from+t.length-1||0;e.rangeOffset=e.from,e.loaded=!0,n>r&&(e.empty=!0)}function o(t,e){e.done=!1;var n=e.isObject=!(!t||\"object\"!=typeof t);e.isArray=n&&i(t),e.arrayOffset=0}var i=Array.isArray;e.exports=function(t,e){if(void 0===e.isArray&&o(t,e),e.isArray){var n;do{e.loaded&&e.rangeOffset>e.to&&(++e.arrayOffset,e.loaded=!1);var i=e.arrayOffset,s=t.length;if(i>=s){e.done=!0;break}var u=t[e.arrayOffset],a=typeof u;if(\"object\"===a){if(e.loaded||r(u,e),e.empty)continue;n=e.rangeOffset++}else++e.arrayOffset,n=u}while(void 0===n);return n}return e.isObject?(e.loaded||r(t,e),e.rangeOffset>e.to?void(e.done=!0):e.rangeOffset++):(e.done=!0,t)}},{}],145:[function(t,e,n){var r=t(142);e.exports=function(t,e){for(var n=[],o=-1,i=0,s=t.length;s>i;++i){var u=t[i];r(e[u.length],u,0)||(n[++o]=u)}return n}},{142:142}],146:[function(t,e,n){var r=t(142);e.exports=function(t,e){for(var n=[],o=-1,i=0,s=t.length;s>i;++i)r(e,t[i],0)||(n[++o]=t[i]);return n}},{142:142}],147:[function(t,e,n){function r(t){return null!==t&&typeof t===f}function o(t,e,n){var r,i,s,u,h,f,l,d,v,y,b,m,g,w,x=c(String(e)),_=Object.create(null),S=[],E=-1,C=0,A=[],N=0;if(u=[],h=-1,n-1>e){for(f=a(t,u);++h<f;)r=u[h],i=o(t[r],e+1,n),s=i.code,_[s]?i=_[s]:(S[C++]=s,i=_[s]={keys:[],sets:i.sets}),x=c(x+r+s),p(r)&&i.keys.push(parseInt(r,10))||i.keys.push(r);for(;++E<C;)if(r=S[E],i=_[r],u=i.keys,f=u.length,f>0)for(l=i.sets,d=-1,v=l.length,g=u[0];++d<v;){for(y=l[d],b=-1,m=y.length,w=new Array(m+1),w[0]=f>1&&u||g;++b<m;)w[b+1]=y[b];A[N++]=w}}else for(f=a(t,u),f>1?A[N++]=[u]:A[N++]=u;++h<f;)x=c(x+u[h]);return{code:x,sets:A}}function i(t){for(var e=-1,n=t.length;++e<n;){var r=t[e];h(r)&&(t[e]=s(r))}return t}function s(t){for(var e=-1,n=t.length-1,r=n>0;++e<=n;){var o=t[e];if(!p(o)){r=!1;break}t[e]=parseInt(o,10)}if(r===!0){t.sort(u);var i=t[0],s=t[n];if(n>=s-i)return{from:i,to:s}}return t}function u(t,e){return t-e}function a(t,e,n){var r=0;for(var o in t)e[r++]=o;return r>1&&e.sort(n),r}function c(t){for(var e=5381,n=-1,r=t.length;++n<r;)e=(e<<5)+e+t.charCodeAt(n);return String(e)}function p(t){return!h(t)&&t-parseFloat(t)+1>=0}var h=Array.isArray,f=\"object\";e.exports=function(t){var e,n=[],s=0;for(var u in t)if(p(u)&&r(e=t[u]))for(var a=o(e,0,parseInt(u,10)).sets,c=-1,h=a.length;++c<h;)n[s++]=i(a[c]);return n}},{}],148:[function(t,e,n){function r(t,e,n){var i,s=e[n],u={},a=n+1;i=o(s,u);do{var c=t[i];c||(a===e.length?t[i]=null:c=t[i]={}),a<e.length&&r(c,e,a),u.done||(i=o(s,u))}while(!u.done)}var o=t(144);Array.isArray;e.exports=function(t){return t.reduce(function(t,e){return r(t,e,0),t},{})}},{144:144}],149:[function(t,e,n){},{}],150:[function(t,e,n){function r(){p=!1,u.length?c=u.concat(c):h=-1,c.length&&o()}function o(){if(!p){var t=setTimeout(r);p=!0;for(var e=c.length;e;){for(u=c,c=[];++h<e;)u&&u[h].run();h=-1,e=c.length}u=null,p=!1,clearTimeout(t)}}function i(t,e){this.fun=t,this.array=e}function s(){}var u,a=e.exports={},c=[],p=!1,h=-1;a.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];c.push(new i(t,e)),1!==c.length||p||setTimeout(o,0)},i.prototype.run=function(){this.fun.apply(null,this.array)},a.title=\"browser\",a.browser=!0,a.env={},a.argv=[],a.version=\"\",a.versions={},a.on=s,a.addListener=s,a.once=s,a.off=s,a.removeListener=s,a.removeAllListeners=s,a.emit=s,a.binding=function(t){throw new Error(\"process.binding is not supported\")},a.cwd=function(){return\"/\"},a.chdir=function(t){throw new Error(\"process.chdir is not supported\")},a.umask=function(){return 0}},{}],151:[function(t,e,n){\"use strict\";e.exports=t(156)},{156:156}],152:[function(t,e,n){\"use strict\";function r(){}function o(t){try{return t.then}catch(e){return y=e,b}}function i(t,e){try{return t(e)}catch(n){return y=n,b}}function s(t,e,n){try{t(e,n)}catch(r){return y=r,b}}function u(t){if(\"object\"!=typeof this)throw new TypeError(\"Promises must be constructed via new\");if(\"function\"!=typeof t)throw new TypeError(\"not a function\");this._37=0,this._12=null,this._59=[],t!==r&&d(t,this)}function a(t,e,n){return new t.constructor(function(o,i){var s=new u(r);s.then(o,i),c(t,new l(e,n,s))})}function c(t,e){for(;3===t._37;)t=t._12;return 0===t._37?void t._59.push(e):void v(function(){var n=1===t._37?e.onFulfilled:e.onRejected;if(null===n)return void(1===t._37?p(e.promise,t._12):h(e.promise,t._12));var r=i(n,t._12);r===b?h(e.promise,y):p(e.promise,r)})}function p(t,e){if(e===t)return h(t,new TypeError(\"A promise cannot be resolved with itself.\"));if(e&&(\"object\"==typeof e||\"function\"==typeof e)){var n=o(e);if(n===b)return h(t,y);if(n===t.then&&e instanceof u)return t._37=3,t._12=e,void f(t);if(\"function\"==typeof n)return void d(n.bind(e),t)}t._37=1,t._12=e,f(t)}function h(t,e){t._37=2,t._12=e,f(t)}function f(t){for(var e=0;e<t._59.length;e++)c(t,t._59[e]);t._59=null}function l(t,e,n){this.onFulfilled=\"function\"==typeof t?t:null,this.onRejected=\"function\"==typeof e?e:null,this.promise=n}function d(t,e){var n=!1,r=s(t,function(t){n||(n=!0,p(e,t))},function(t){n||(n=!0,h(e,t))});n||r!==b||(n=!0,h(e,y))}var v=t(124),y=null,b={};e.exports=u,u._99=r,u.prototype.then=function(t,e){if(this.constructor!==u)return a(this,t,e);var n=new u(r);return c(this,new l(t,e,n)),n}},{124:124}],153:[function(t,e,n){\"use strict\";var r=t(152);e.exports=r,r.prototype.done=function(t,e){var n=arguments.length?this.then.apply(this,arguments):this;n.then(null,function(t){setTimeout(function(){throw t},0)})}},{152:152}],154:[function(t,e,n){\"use strict\";function r(t){var e=new o(o._99);return e._37=1,e._12=t,e}var o=t(152);e.exports=o;var i=r(!0),s=r(!1),u=r(null),a=r(void 0),c=r(0),p=r(\"\");o.resolve=function(t){if(t instanceof o)return t;if(null===t)return u;if(void 0===t)return a;if(t===!0)return i;if(t===!1)return s;if(0===t)return c;if(\"\"===t)return p;if(\"object\"==typeof t||\"function\"==typeof t)try{var e=t.then;if(\"function\"==typeof e)return new o(e.bind(t))}catch(n){return new o(function(t,e){e(n)})}return r(t)},o.all=function(t){var e=Array.prototype.slice.call(t);return new o(function(t,n){function r(s,u){if(u&&(\"object\"==typeof u||\"function\"==typeof u)){if(u instanceof o&&u.then===o.prototype.then){for(;3===u._37;)u=u._12;return 1===u._37?r(s,u._12):(2===u._37&&n(u._12),void u.then(function(t){r(s,t)},n))}var a=u.then;if(\"function\"==typeof a){var c=new o(a.bind(u));return void c.then(function(t){r(s,t)},n)}}e[s]=u,0===--i&&t(e)}if(0===e.length)return t([]);for(var i=e.length,s=0;s<e.length;s++)r(s,e[s])})},o.reject=function(t){return new o(function(e,n){n(t)})},o.race=function(t){return new o(function(e,n){t.forEach(function(t){o.resolve(t).then(e,n)})})},o.prototype[\"catch\"]=function(t){return this.then(null,t)}},{152:152}],155:[function(t,e,n){\"use strict\";var r=t(152);e.exports=r,r.prototype[\"finally\"]=function(t){return this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})})}},{152:152}],156:[function(t,e,n){\"use strict\";e.exports=t(152),t(153),t(155),t(154),t(157)},{152:152,153:153,154:154,155:155,157:157}],157:[function(t,e,n){\"use strict\";var r=t(152),o=t(123);e.exports=r,r.denodeify=function(t,e){return e=e||1/0,function(){var n=this,o=Array.prototype.slice.call(arguments,0,e>0?e:0);return new r(function(e,r){o.push(function(t,n){t?r(t):e(n)});var i=t.apply(n,o);!i||\"object\"!=typeof i&&\"function\"!=typeof i||\"function\"!=typeof i.then||e(i)})}},r.nodeify=function(t){return function(){var e=Array.prototype.slice.call(arguments),n=\"function\"==typeof e[e.length-1]?e.pop():null,i=this;try{return t.apply(this,arguments).nodeify(n,i)}catch(s){if(null===n||\"undefined\"==typeof n)return new r(function(t,e){e(s)});o(function(){n.call(i,s)})}}},r.prototype.nodeify=function(t,e){return\"function\"!=typeof t?this:void this.then(function(n){o(function(){t.call(e,null,n)})},function(n){o(function(){t.call(e,n)})})}},{123:123,152:152}],158:[function(e,n,r){(function(o){(function(i){var s={\"boolean\":!1,\"function\":!0,object:!0,number:!1,string:!1,undefined:!1},u=s[typeof window]&&window||this,a=s[typeof r]&&r&&!r.nodeType&&r,c=s[typeof n]&&n&&!n.nodeType&&n,p=(c&&c.exports===a&&a,s[typeof o]&&o);!p||p.global!==p&&p.window!==p||(u=p),\"function\"==typeof t&&t.amd?t([\"rx\"],function(t,e){return i(u,e,t)}):\"object\"==typeof n&&n&&n.exports===a?n.exports=i(u,n.exports,e(159)):u.Rx=i(u,{},u.Rx)}).call(this,function(t,e,n,r){function o(){try{return l.apply(this,arguments)}catch(t){return M.e=t,M}}function i(t){if(!E(t))throw new TypeError(\"fn must be a function\");return l=t,o}function s(t,e,n){return new b(function(r){var o=!1,i=null,s=[];return t.subscribe(function(t){var u,a;try{a=e(t)}catch(c){return void r.onError(c)}if(u=0,o)try{u=n(a,i)}catch(p){return void r.onError(p)}else o=!0,i=a;u>0&&(i=a,s=[]),u>=0&&s.push(t)},function(t){r.onError(t)},function(){r.onNext(s),r.onCompleted()})},t)}function u(t){if(0===t.length)throw new D;return t[0]}function a(t,e,n,r){if(0>e)throw new R;return new b(function(o){var i=e;return t.subscribe(function(t){0===i--&&(o.onNext(t),o.onCompleted())},function(t){o.onError(t)},function(){n?(o.onNext(r),o.onCompleted()):o.onError(new R)})},t)}function c(t,e,n){return new b(function(r){var o=n,i=!1;return t.subscribe(function(t){i?r.onError(new Error(\"Sequence contains more than one element\")):(o=t,i=!0)},function(t){r.onError(t)},function(){i||e?(r.onNext(o),r.onCompleted()):r.onError(new D)})},t)}function p(t,e,n){return new b(function(r){return t.subscribe(function(t){r.onNext(t),r.onCompleted()},function(t){r.onError(t)},function(){e?(r.onNext(n),r.onCompleted()):r.onError(new D)})},t)}function h(t,e,n){return new b(function(r){var o=n,i=!1;return t.subscribe(function(t){o=t,i=!0},function(t){r.onError(t)},function(){i||e?(r.onNext(o),r.onCompleted()):r.onError(new D)})},t)}function f(t,e,n,o){var i=j(e,n,3);return new b(function(e){var n=0;return t.subscribe(function(r){var s;try{s=i(r,n,t)}catch(u){return void e.onError(u)}s?(e.onNext(o?n:r),e.onCompleted()):n++},function(t){e.onError(t)},function(){e.onNext(o?-1:r),e.onCompleted()})},t)}var l,d=n.Observable,v=d.prototype,y=n.CompositeDisposable,b=n.AnonymousObservable,m=n.Disposable.empty,g=(n.internals.isEqual,n.helpers),w=g.not,x=g.defaultComparer,_=g.identity,S=g.defaultSubComparer,E=g.isFunction,C=g.isPromise,A=g.isArrayLike,N=g.isIterable,k=n.internals.inherits,O=d.fromPromise,P=d.from,j=n.internals.bindCallback,D=n.EmptyError,q=n.ObservableBase,R=n.ArgumentOutOfRangeError,M={e:{}};v.aggregate=function(){var t,e,n=!1,r=this;return 2===arguments.length?(n=!0,e=arguments[0],t=arguments[1]):t=arguments[0],new b(function(o){var i,s,u;return r.subscribe(function(r){!u&&(u=!0);try{i?s=t(s,r):(s=n?t(e,r):r,i=!0)}catch(a){return o.onError(a)}},function(t){o.onError(t)},function(){u&&o.onNext(s),!u&&n&&o.onNext(e),!u&&!n&&o.onError(new D),o.onCompleted()})},r)};var T=function(t){function e(e,n,r,o){this.source=e,this.acc=n,this.hasSeed=r,this.seed=o,t.call(this)}function n(t,e){this.o=t,this.acc=e.acc,this.hasSeed=e.hasSeed,this.seed=e.seed,this.hasAccumulation=!1,this.result=null,this.hasValue=!1,this.isStopped=!1}return k(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new n(t,this))},n.prototype.onNext=function(t){this.isStopped||(!this.hasValue&&(this.hasValue=!0),this.hasAccumulation?this.result=i(this.acc)(this.result,t):(this.result=this.hasSeed?i(this.acc)(this.seed,t):t,this.hasAccumulation=!0),this.result===M&&this.o.onError(this.result.e))},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.hasValue&&this.o.onNext(this.result),!this.hasValue&&this.hasSeed&&this.o.onNext(this.seed),!this.hasValue&&!this.hasSeed&&this.o.onError(new D),this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(q);return v.reduce=function(t){var e=!1;if(2===arguments.length){e=!0;var n=arguments[1]}return new T(this,t,e,n)},v.some=function(t,e){var n=this;return t?n.filter(t,e).some():new b(function(t){return n.subscribe(function(){t.onNext(!0),t.onCompleted()},function(e){t.onError(e)},function(){t.onNext(!1),t.onCompleted()})},n)},v.any=function(){return this.some.apply(this,arguments)},v.isEmpty=function(){return this.any().map(w)},v.every=function(t,e){return this.filter(function(e){return!t(e)},e).some().map(w)},v.all=function(){return this.every.apply(this,arguments)},v.includes=function(t,e){function n(t,e){return 0===t&&0===e||t===e||isNaN(t)&&isNaN(e)}var r=this;return new b(function(o){var i=0,s=+e||0;return Math.abs(s)===1/0&&(s=0),0>s?(o.onNext(!1),o.onCompleted(),m):r.subscribe(function(e){i++>=s&&n(e,t)&&(o.onNext(!0),o.onCompleted())},function(t){o.onError(t)},function(){o.onNext(!1),o.onCompleted()})},this)},v.contains=function(t,e){v.includes(t,e)},v.count=function(t,e){return t?this.filter(t,e).count():this.reduce(function(t){return t+1},0)},v.indexOf=function(t,e){var n=this;return new b(function(r){var o=0,i=+e||0;return Math.abs(i)===1/0&&(i=0),0>i?(r.onNext(-1),r.onCompleted(),m):n.subscribe(function(e){o>=i&&e===t&&(r.onNext(o),r.onCompleted()),o++},function(t){r.onError(t)},function(){r.onNext(-1),r.onCompleted()})},n)},v.sum=function(t,e){return t&&E(t)?this.map(t,e).sum():this.reduce(function(t,e){return t+e},0)},v.minBy=function(t,e){return e||(e=S),s(this,t,function(t,n){return-1*e(t,n)})},v.min=function(t){return this.minBy(_,t).map(function(t){return u(t)})},v.maxBy=function(t,e){return e||(e=S),s(this,t,e)},v.max=function(t){return this.maxBy(_,t).map(function(t){return u(t)})},v.average=function(t,e){return t&&E(t)?this.map(t,e).average():this.reduce(function(t,e){return{sum:t.sum+e,count:t.count+1}},{sum:0,count:0}).map(function(t){if(0===t.count)throw new D;return t.sum/t.count})},v.sequenceEqual=function(t,e){var n=this;return e||(e=x),new b(function(r){var o=!1,i=!1,s=[],u=[],a=n.subscribe(function(t){var n,o;if(u.length>0){o=u.shift();try{n=e(o,t)}catch(a){return void r.onError(a)}n||(r.onNext(!1),r.onCompleted())}else i?(r.onNext(!1),r.onCompleted()):s.push(t)},function(t){r.onError(t)},function(){o=!0,0===s.length&&(u.length>0?(r.onNext(!1),r.onCompleted()):i&&(r.onNext(!0),r.onCompleted()))});(A(t)||N(t))&&(t=P(t)),C(t)&&(t=O(t));var c=t.subscribe(function(t){var n;if(s.length>0){var i=s.shift();try{n=e(i,t)}catch(a){return void r.onError(a)}n||(r.onNext(!1),r.onCompleted())}else o?(r.onNext(!1),r.onCompleted()):u.push(t)},function(t){r.onError(t)},function(){i=!0,0===u.length&&(s.length>0?(r.onNext(!1),r.onCompleted()):o&&(r.onNext(!0),r.onCompleted()))});return new y(a,c)},n)},v.elementAt=function(t){return a(this,t,!1)},v.elementAtOrDefault=function(t,e){return a(this,t,!0,e)},v.single=function(t,e){return t&&E(t)?this.where(t,e).single():c(this,!1)},v.singleOrDefault=function(t,e,n){return t&&E(t)?this.filter(t,n).singleOrDefault(null,e):c(this,!0,e)},v.first=function(t,e){return t?this.where(t,e).first():p(this,!1)},v.firstOrDefault=function(t,e,n){return t?this.where(t).firstOrDefault(null,e):p(this,!0,e)},v.last=function(t,e){return t?this.where(t,e).last():h(this,!1)},v.lastOrDefault=function(t,e,n){return t?this.where(t,n).lastOrDefault(null,e):h(this,!0,e)},v.find=function(t,e){return f(this,t,e,!1)},v.findIndex=function(t,e){return f(this,t,e,!0)},v.toSet=function(){if(\"undefined\"==typeof t.Set)throw new TypeError;var e=this;return new b(function(n){var r=new t.Set;return e.subscribe(function(t){r.add(t)},function(t){n.onError(t)},function(){n.onNext(r),n.onCompleted()})},e)},v.toMap=function(e,n){if(\"undefined\"==typeof t.Map)throw new TypeError;var r=this;return new b(function(o){var i=new t.Map;return r.subscribe(function(t){var r;try{r=e(t)}catch(s){return void o.onError(s)}var u=t;if(n)try{u=n(t)}catch(s){return void o.onError(s)}i.set(r,u)},function(t){o.onError(t)},function(){o.onNext(i),o.onCompleted()})},r)},n})}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{159:159}],159:[function(e,n,r){(function(e,o){(function(i){function u(t){for(var e=[],n=0,r=t.length;r>n;n++)e.push(t[n]);return e}function a(t,e){if(ct&&e.stack&&\"object\"==typeof t&&null!==t&&t.stack&&-1===t.stack.indexOf(lt)){for(var n=[],r=e;r;r=r.source)r.stack&&n.unshift(r.stack);n.unshift(t.stack);var o=n.join(\"\\n\"+lt+\"\\n\");t.stack=c(o)}}function c(t){for(var e=t.split(\"\\n\"),n=[],r=0,o=e.length;o>r;r++){var i=e[r];p(i)||h(i)||!i||n.push(i)}return n.join(\"\\n\")}function p(t){var e=l(t);if(!e)return!1;var n=e[0],r=e[1];return n===ht&&r>=ft&&$n>=r}function h(t){return-1!==t.indexOf(\"(module.js:\")||-1!==t.indexOf(\"(node.js:\")}function f(){if(ct)try{throw new Error}catch(t){var e=t.stack.split(\"\\n\"),n=e[0].indexOf(\"@\")>0?e[1]:e[2],r=l(n);if(!r)return;return ht=r[0],r[1]}}function l(t){var e=/at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(t);if(e)return[e[1],Number(e[2])];var n=/at ([^ ]+):(\\d+):(?:\\d+)$/.exec(t);if(n)return[n[1],Number(n[2])];var r=/.*@(.+):(\\d+)$/.exec(t);return r?[r[1],Number(r[2])]:void 0}function d(t){var e=[];if(!Ht(t))return e;Ut.nonEnumArgs&&t.length&&Xt(t)&&(t=Yt.call(t));var n=Ut.enumPrototypes&&\"function\"==typeof t,r=Ut.enumErrorProps&&(t===Jt||t instanceof Error);for(var o in t)n&&\"prototype\"==o||r&&(\"message\"==o||\"name\"==o)||e.push(o);if(Ut.nonEnumShadows&&t!==It){var i=t.constructor,s=-1,u=kt;if(t===(i&&i.prototype))var a=t===Lt?$t:t===Jt?qt:Wt.call(t),c=Ft[a];for(;++s<u;)o=Nt[s],c&&c[o]||!zt.call(t,o)||e.push(o)}return e}function v(t,e,n){for(var r=-1,o=n(t),i=o.length;++r<i;){var s=o[r];if(e(t[s],s,t)===!1)break}return t}function y(t,e){return v(t,e,d)}function b(t){return\"function\"!=typeof t.toString&&\"string\"==typeof(t+\"\")}function m(t,e,n,r){if(t===e)return 0!==t||1/t==1/e;var o=typeof t,i=typeof e;if(t===t&&(null==t||null==e||\"function\"!=o&&\"object\"!=o&&\"function\"!=i&&\"object\"!=i))return!1;var s=Wt.call(t),u=Wt.call(e);if(s==Ot&&(s=Tt),u==Ot&&(u=Tt),s!=u)return!1;switch(s){case jt:case Dt:return+t==+e;case Mt:return t!=+t?e!=+e:0==t?1/t==1/e:t==+e;case Vt:case $t:return t==String(e)}var a=s==Pt;if(!a){if(s!=Tt||!Ut.nodeClass&&(b(t)||b(e)))return!1;var c=!Ut.argsObject&&Xt(t)?Object:t.constructor,p=!Ut.argsObject&&Xt(e)?Object:e.constructor;if(!(c==p||zt.call(t,\"constructor\")&&zt.call(e,\"constructor\")||at(c)&&c instanceof c&&at(p)&&p instanceof p||!(\"constructor\"in t&&\"constructor\"in e)))return!1}n||(n=[]),r||(r=[]);for(var h=n.length;h--;)if(n[h]==t)return r[h]==e;var f=0,l=!0;if(n.push(t),r.push(e),a){if(h=t.length,f=e.length,l=f==h)for(;f--;){var d=e[f];if(!(l=m(t[f],d,n,r)))break}}else y(e,function(e,o,i){return zt.call(i,o)?(f++,l=zt.call(t,o)&&m(t[o],e,n,r)):void 0}),l&&y(t,function(t,e,n){return zt.call(n,e)?l=--f>-1:void 0});return n.pop(),r.pop(),l}function g(t,e){for(var n=new Array(t),r=0;t>r;r++)n[r]=e();return n}function w(){try{return Qt.apply(this,arguments)}catch(t){return ne.e=t,ne}}function x(t){if(!at(t))throw new TypeError(\"fn must be a function\");return Qt=t,w}function _(t){throw t}function S(t,e){this.id=t,this.value=e}function E(t,e){this.scheduler=t,this.disposable=e,this.isDisposed=!1}function C(t,e){e.isDisposed||(e.isDisposed=!0,e.disposable.dispose())}function A(t){this._s=s}function N(t){this._s=s,this._l=s.length,this._i=0}function k(t){this._a=t}function O(t){this._a=t,this._l=q(t),this._i=0}function P(t){return\"number\"==typeof t&&X.isFinite(t)}function j(t){var e,n=t[xt];if(!n&&\"string\"==typeof t)return e=new A(t),e[xt]();if(!n&&t.length!==i)return e=new k(t),e[xt]();if(!n)throw new TypeError(\"Object is not iterable\");return t[xt]()}function D(t){var e=+t;return 0===e?e:isNaN(e)?e:0>e?-1:1}function q(t){var e=+t.length;return isNaN(e)?0:0!==e&&P(e)?(e=D(e)*Math.floor(Math.abs(e)),0>=e?0:e>en?en:e):e}function R(t,e){this.observer=t,this.parent=e}function M(t,e){return me(t)||(t=_e),new rn(e,t)}function T(t,e){this.observer=t,this.parent=e}function V(t,e){this.observer=t,this.parent=e}function $(t,e){return new qn(function(n){var r=new fe,o=new le;return o.setDisposable(r),r.setDisposable(t.subscribe(function(t){n.onNext(t)},function(t){try{var r=e(t)}catch(i){return n.onError(i)}ut(r)&&(r=Xe(r));var s=new fe;o.setDisposable(s),s.setDisposable(r.subscribe(n))},function(t){n.onCompleted(t)})),o},t)}function W(){return!1}function z(t,e){var n=this;return new qn(function(r){var o=0,i=t.length;return n.subscribe(function(n){if(i>o){var s=t[o++],u=x(e)(n,s);if(u===ne)return r.onError(u.e);r.onNext(u)}else r.onCompleted()},function(t){r.onError(t)},function(){r.onCompleted()})},n)}function W(){return!1}function G(){return[]}function W(){return!1}function J(){return[]}function I(t,e){this.observer=t,this.accumulator=e.accumulator,this.hasSeed=e.hasSeed,this.seed=e.seed,this.hasAccumulation=!1,this.accumulation=null,this.hasValue=!1,this.isStopped=!1}function L(t,e,n){var r=At(e,n,3);return t.map(function(e,n){var o=r(e,n,t);return ut(o)&&(o=Xe(o)),(Et(o)||St(o))&&(o=nn(o)),o}).concatAll()}function B(t,e,n){for(var r=0,o=t.length;o>r;r++)if(n(t[r],e))return r;return-1}function F(t){this.comparer=t,this.set=[]}function U(t,e,n){var r=At(e,n,3);return t.map(function(e,n){var o=r(e,n,t);return ut(o)&&(o=Xe(o)),(Et(o)||St(o))&&(o=nn(o)),o}).mergeAll()}var H={\"boolean\":!1,\"function\":!0,object:!0,number:!1,string:!1,undefined:!1},X=H[typeof window]&&window||this,Q=H[typeof r]&&r&&!r.nodeType&&r,K=H[typeof n]&&n&&!n.nodeType&&n,Y=K&&K.exports===Q&&Q,Z=H[typeof o]&&o;!Z||Z.global!==Z&&Z.window!==Z||(X=Z);var tt={internals:{},config:{Promise:X.Promise},helpers:{}},et=tt.helpers.noop=function(){},nt=(tt.helpers.notDefined=function(t){return\"undefined\"==typeof t},tt.helpers.identity=function(t){return t}),rt=(tt.helpers.pluck=function(t){return function(e){return e[t]}},tt.helpers.just=function(t){return function(){return t}},tt.helpers.defaultNow=Date.now),ot=tt.helpers.defaultComparer=function(t,e){return Kt(t,e)},it=tt.helpers.defaultSubComparer=function(t,e){return t>e?1:e>t?-1:0},st=(tt.helpers.defaultKeySerializer=function(t){return t.toString()},tt.helpers.defaultError=function(t){throw t}),ut=tt.helpers.isPromise=function(t){return!!t&&\"function\"!=typeof t.subscribe&&\"function\"==typeof t.then},at=(tt.helpers.asArray=function(){return Array.prototype.slice.call(arguments)},tt.helpers.not=function(t){return!t},tt.helpers.isFunction=function(){var t=function(t){return\"function\"==typeof t||!1};return t(/x/)&&(t=function(t){return\"function\"==typeof t&&\"[object Function]\"==Wt.call(t)}),t}());tt.config.longStackSupport=!1;var ct=!1;try{throw new Error}catch(pt){ct=!!pt.stack}var ht,ft=f(),lt=\"From previous event:\",dt=tt.EmptyError=function(){this.message=\"Sequence contains no elements.\",Error.call(this)};dt.prototype=Error.prototype;var vt=tt.ObjectDisposedError=function(){this.message=\"Object has been disposed\",Error.call(this)};vt.prototype=Error.prototype;var yt=tt.ArgumentOutOfRangeError=function(){this.message=\"Argument out of range\",Error.call(this)};yt.prototype=Error.prototype;var bt=tt.NotSupportedError=function(t){this.message=t||\"This operation is not supported\",Error.call(this)};bt.prototype=Error.prototype;var mt=tt.NotImplementedError=function(t){this.message=t||\"This operation is not implemented\",Error.call(this)};mt.prototype=Error.prototype;var gt=tt.helpers.notImplemented=function(){throw new mt},wt=tt.helpers.notSupported=function(){throw new bt},xt=\"function\"==typeof Symbol&&Symbol.iterator||\"_es6shim_iterator_\";X.Set&&\"function\"==typeof(new X.Set)[\"@@iterator\"]&&(xt=\"@@iterator\");var _t=tt.doneEnumerator={done:!0,value:i},St=tt.helpers.isIterable=function(t){return t[xt]!==i},Et=tt.helpers.isArrayLike=function(t){return t&&t.length!==i};tt.helpers.iterator=xt;var Ct,At=tt.internals.bindCallback=function(t,e,n){if(\"undefined\"==typeof e)return t;switch(n){case 0:return function(){return t.call(e)};case 1:return function(n){return t.call(e,n)};case 2:return function(n,r){return t.call(e,n,r)};case 3:return function(n,r,o){return t.call(e,n,r,o)}}return function(){return t.apply(e,arguments)}},Nt=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],kt=Nt.length,Ot=\"[object Arguments]\",Pt=\"[object Array]\",jt=\"[object Boolean]\",Dt=\"[object Date]\",qt=\"[object Error]\",Rt=\"[object Function]\",Mt=\"[object Number]\",Tt=\"[object Object]\",Vt=\"[object RegExp]\",$t=\"[object String]\",Wt=Object.prototype.toString,zt=Object.prototype.hasOwnProperty,Gt=Wt.call(arguments)==Ot,Jt=Error.prototype,It=Object.prototype,Lt=String.prototype,Bt=It.propertyIsEnumerable;try{Ct=!(Wt.call(document)==Tt&&!({toString:0}+\"\"))}catch(pt){Ct=!0}var Ft={};Ft[Pt]=Ft[Dt]=Ft[Mt]={constructor:!0,toLocaleString:!0,toString:!0,valueOf:!0},Ft[jt]=Ft[$t]={constructor:!0,toString:!0,valueOf:!0},Ft[qt]=Ft[Rt]=Ft[Vt]={constructor:!0,toString:!0},Ft[Tt]={constructor:!0};var Ut={};!function(){var t=function(){this.x=1},e=[];t.prototype={valueOf:1,y:1};for(var n in new t)e.push(n);for(n in arguments);Ut.enumErrorProps=Bt.call(Jt,\"message\")||Bt.call(Jt,\"name\"),Ut.enumPrototypes=Bt.call(t,\"prototype\"),Ut.nonEnumArgs=0!=n,Ut.nonEnumShadows=!/valueOf/.test(e)}(1);var Ht=tt.internals.isObject=function(t){var e=typeof t;return t&&(\"function\"==e||\"object\"==e)||!1},Xt=function(t){return t&&\"object\"==typeof t?Wt.call(t)==Ot:!1};Gt||(Xt=function(t){return t&&\"object\"==typeof t?zt.call(t,\"callee\"):!1});var Qt,Kt=tt.internals.isEqual=function(t,e){return m(t,e,[],[])},Yt=({}.hasOwnProperty,Array.prototype.slice),Zt=this.inherits=tt.internals.inherits=function(t,e){function n(){this.constructor=t}n.prototype=e.prototype,t.prototype=new n},te=tt.internals.addProperties=function(t){for(var e=[],n=1,r=arguments.length;r>n;n++)e.push(arguments[n]);for(var o=0,i=e.length;i>o;o++){var s=e[o];for(var u in s)t[u]=s[u]}},ee=tt.internals.addRef=function(t,e){return new qn(function(n){return new ie(e.getDisposable(),t.subscribe(n))})},ne={e:{}};S.prototype.compareTo=function(t){var e=this.value.compareTo(t.value);return 0===e&&(e=this.id-t.id),e};var re=tt.internals.PriorityQueue=function(t){this.items=new Array(t),this.length=0},oe=re.prototype;oe.isHigherPriority=function(t,e){return this.items[t].compareTo(this.items[e])<0},oe.percolate=function(t){if(!(t>=this.length||0>t)){var e=t-1>>1;if(!(0>e||e===t)&&this.isHigherPriority(t,e)){var n=this.items[t];this.items[t]=this.items[e],this.items[e]=n,this.percolate(e)}}},oe.heapify=function(t){if(+t||(t=0),!(t>=this.length||0>t)){var e=2*t+1,n=2*t+2,r=t;if(e<this.length&&this.isHigherPriority(e,r)&&(r=e),n<this.length&&this.isHigherPriority(n,r)&&(r=n),r!==t){var o=this.items[t];this.items[t]=this.items[r],this.items[r]=o,this.heapify(r)}}},oe.peek=function(){return this.items[0].value},oe.removeAt=function(t){this.items[t]=this.items[--this.length],this.items[this.length]=i,this.heapify()},oe.dequeue=function(){var t=this.peek();return this.removeAt(0),t},oe.enqueue=function(t){var e=this.length++;this.items[e]=new S(re.count++,t),this.percolate(e)},oe.remove=function(t){for(var e=0;e<this.length;e++)if(this.items[e].value===t)return this.removeAt(e),!0;return!1},re.count=0;var ie=tt.CompositeDisposable=function(){var t,e,n=[];if(Array.isArray(arguments[0]))n=arguments[0],e=n.length;else for(e=arguments.length,n=new Array(e),t=0;e>t;t++)n[t]=arguments[t];for(t=0;e>t;t++)if(!pe(n[t]))throw new TypeError(\"Not a disposable\");this.disposables=n,this.isDisposed=!1,this.length=n.length},se=ie.prototype;se.add=function(t){this.isDisposed?t.dispose():(this.disposables.push(t),this.length++)},se.remove=function(t){var e=!1;if(!this.isDisposed){var n=this.disposables.indexOf(t);-1!==n&&(e=!0,this.disposables.splice(n,1),this.length--,t.dispose())}return e},se.dispose=function(){\nif(!this.isDisposed){this.isDisposed=!0;for(var t=this.disposables.length,e=new Array(t),n=0;t>n;n++)e[n]=this.disposables[n];for(this.disposables=[],this.length=0,n=0;t>n;n++)e[n].dispose()}};var ue=tt.Disposable=function(t){this.isDisposed=!1,this.action=t||et};ue.prototype.dispose=function(){this.isDisposed||(this.action(),this.isDisposed=!0)};var ae=ue.create=function(t){return new ue(t)},ce=ue.empty={dispose:et},pe=ue.isDisposable=function(t){return t&&at(t.dispose)},he=ue.checkDisposed=function(t){if(t.isDisposed)throw new vt},fe=tt.SingleAssignmentDisposable=function(){this.isDisposed=!1,this.current=null};fe.prototype.getDisposable=function(){return this.current},fe.prototype.setDisposable=function(t){if(this.current)throw new Error(\"Disposable has already been assigned\");var e=this.isDisposed;!e&&(this.current=t),e&&t&&t.dispose()},fe.prototype.dispose=function(){if(!this.isDisposed){this.isDisposed=!0;var t=this.current;this.current=null}t&&t.dispose()};var le=tt.SerialDisposable=function(){this.isDisposed=!1,this.current=null};le.prototype.getDisposable=function(){return this.current},le.prototype.setDisposable=function(t){var e=this.isDisposed;if(!e){var n=this.current;this.current=t}n&&n.dispose(),e&&t&&t.dispose()},le.prototype.dispose=function(){if(!this.isDisposed){this.isDisposed=!0;var t=this.current;this.current=null}t&&t.dispose()};var de=tt.RefCountDisposable=function(){function t(t){this.disposable=t,this.disposable.count++,this.isInnerDisposed=!1}function e(t){this.underlyingDisposable=t,this.isDisposed=!1,this.isPrimaryDisposed=!1,this.count=0}return t.prototype.dispose=function(){this.disposable.isDisposed||this.isInnerDisposed||(this.isInnerDisposed=!0,this.disposable.count--,0===this.disposable.count&&this.disposable.isPrimaryDisposed&&(this.disposable.isDisposed=!0,this.disposable.underlyingDisposable.dispose()))},e.prototype.dispose=function(){this.isDisposed||this.isPrimaryDisposed||(this.isPrimaryDisposed=!0,0===this.count&&(this.isDisposed=!0,this.underlyingDisposable.dispose()))},e.prototype.getDisposable=function(){return this.isDisposed?ce:new t(this)},e}();E.prototype.dispose=function(){this.scheduler.scheduleWithState(this,C)};var ve=tt.internals.ScheduledItem=function(t,e,n,r,o){this.scheduler=t,this.state=e,this.action=n,this.dueTime=r,this.comparer=o||it,this.disposable=new fe};ve.prototype.invoke=function(){this.disposable.setDisposable(this.invokeCore())},ve.prototype.compareTo=function(t){return this.comparer(this.dueTime,t.dueTime)},ve.prototype.isCancelled=function(){return this.disposable.isDisposed},ve.prototype.invokeCore=function(){return this.action(this.scheduler,this.state)};var ye=tt.Scheduler=function(){function t(t,e,n,r){this.now=t,this._schedule=e,this._scheduleRelative=n,this._scheduleAbsolute=r}function e(t,e){return e(),ce}t.isScheduler=function(e){return e instanceof t};var n=t.prototype;return n.schedule=function(t){return this._schedule(t,e)},n.scheduleWithState=function(t,e){return this._schedule(t,e)},n.scheduleWithRelative=function(t,n){return this._scheduleRelative(n,t,e)},n.scheduleWithRelativeAndState=function(t,e,n){return this._scheduleRelative(t,e,n)},n.scheduleWithAbsolute=function(t,n){return this._scheduleAbsolute(n,t,e)},n.scheduleWithAbsoluteAndState=function(t,e,n){return this._scheduleAbsolute(t,e,n)},t.now=rt,t.normalize=function(t){return 0>t&&(t=0),t},t}(),be=ye.normalize,me=ye.isScheduler;!function(t){function e(t,e){function n(e){o(e,function(e){var r=!1,o=!1,s=t.scheduleWithState(e,function(t,e){return r?i.remove(s):o=!0,n(e),ce});o||(i.add(s),r=!0)})}var r=e[0],o=e[1],i=new ie;return n(r),i}function n(t,e,n){function r(e){i(e,function(e,o){var i=!1,u=!1,a=t[n](e,o,function(t,e){return i?s.remove(a):u=!0,r(e),ce});u||(s.add(a),i=!0)})}var o=e[0],i=e[1],s=new ie;return r(o),s}function r(t,e){t(function(n){e(t,n)})}t.scheduleRecursive=function(t){return this.scheduleRecursiveWithState(t,r)},t.scheduleRecursiveWithState=function(t,n){return this.scheduleWithState([t,n],e)},t.scheduleRecursiveWithRelative=function(t,e){return this.scheduleRecursiveWithRelativeAndState(e,t,r)},t.scheduleRecursiveWithRelativeAndState=function(t,e,r){return this._scheduleRelative([t,r],e,function(t,e){return n(t,e,\"scheduleWithRelativeAndState\")})},t.scheduleRecursiveWithAbsolute=function(t,e){return this.scheduleRecursiveWithAbsoluteAndState(e,t,r)},t.scheduleRecursiveWithAbsoluteAndState=function(t,e,r){return this._scheduleAbsolute([t,r],e,function(t,e){return n(t,e,\"scheduleWithAbsoluteAndState\")})}}(ye.prototype),function(t){ye.prototype.schedulePeriodic=function(t,e){return this.schedulePeriodicWithState(null,t,e)},ye.prototype.schedulePeriodicWithState=function(t,e,n){if(\"undefined\"==typeof X.setInterval)throw new bt;e=be(e);var r=t,o=X.setInterval(function(){r=n(r)},e);return ae(function(){X.clearInterval(o)})}}(ye.prototype),function(t){t.catchError=t[\"catch\"]=function(t){return new Ae(this,t)}}(ye.prototype);var ge,we,xe=(tt.internals.SchedulePeriodicRecursive=function(){function t(t,e){e(0,this._period);try{this._state=this._action(this._state)}catch(n){throw this._cancel.dispose(),n}}function e(t,e,n,r){this._scheduler=t,this._state=e,this._period=n,this._action=r}return e.prototype.start=function(){var e=new fe;return this._cancel=e,e.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0,this._period,t.bind(this))),e},e}(),ye.immediate=function(){function t(t,e){return e(this,t)}return new ye(rt,t,wt,wt)}()),_e=ye.currentThread=function(){function t(){for(;n.length>0;){var t=n.dequeue();!t.isCancelled()&&t.invoke()}}function e(e,r){var o=new ve(this,e,r,this.now());if(n)n.enqueue(o);else{n=new re(4),n.enqueue(o);var i=x(t)();if(n=null,i===ne)return _(i.e)}return o.disposable}var n,r=new ye(rt,e,wt,wt);return r.scheduleRequired=function(){return!n},r}(),Se=function(){var t,e=et;if(X.setTimeout)t=X.setTimeout,e=X.clearTimeout;else{if(!X.WScript)throw new bt;t=function(t,e){X.WScript.Sleep(e),t()}}return{setTimeout:t,clearTimeout:e}}(),Ee=Se.setTimeout,Ce=Se.clearTimeout;!function(){function t(e){if(s)Ee(function(){t(e)},0);else{var n=i[e];if(n){s=!0;var r=x(n)();if(we(e),s=!1,r===ne)return _(r.e)}}}function n(){if(!X.postMessage||X.importScripts)return!1;var t=!1,e=X.onmessage;return X.onmessage=function(){t=!0},X.postMessage(\"\",\"*\"),X.onmessage=e,t}function r(e){\"string\"==typeof e.data&&e.data.substring(0,c.length)===c&&t(e.data.substring(c.length))}var o=1,i={},s=!1;we=function(t){delete i[t]};var u=RegExp(\"^\"+String(Wt).replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\").replace(/toString| for [^\\]]+/g,\".*?\")+\"$\"),a=\"function\"==typeof(a=Z&&Y&&Z.setImmediate)&&!u.test(a)&&a;if(at(a))ge=function(e){var n=o++;return i[n]=e,a(function(){t(n)}),n};else if(\"undefined\"!=typeof e&&\"[object process]\"==={}.toString.call(e))ge=function(n){var r=o++;return i[r]=n,e.nextTick(function(){t(r)}),r};else if(n()){var c=\"ms.rx.schedule\"+Math.random();X.addEventListener?X.addEventListener(\"message\",r,!1):X.attachEvent?X.attachEvent(\"onmessage\",r):X.onmessage=r,ge=function(t){var e=o++;return i[e]=t,X.postMessage(c+currentId,\"*\"),e}}else if(X.MessageChannel){var p=new X.MessageChannel;p.port1.onmessage=function(e){t(e.data)},ge=function(t){var e=o++;return i[e]=t,p.port2.postMessage(e),e}}else ge=\"document\"in X&&\"onreadystatechange\"in X.document.createElement(\"script\")?function(e){var n=X.document.createElement(\"script\"),r=o++;return i[r]=e,n.onreadystatechange=function(){t(r),n.onreadystatechange=null,n.parentNode.removeChild(n),n=null},X.document.documentElement.appendChild(n),r}:function(e){var n=o++;return i[n]=e,Ee(function(){t(n)},0),n}}();var Ae=(ye.timeout=ye[\"default\"]=function(){function t(t,e){var n=this,r=new fe,o=ge(function(){!r.isDisposed&&r.setDisposable(e(n,t))});return new ie(r,ae(function(){we(o)}))}function e(t,e,n){var r=this,o=ye.normalize(e),i=new fe;if(0===o)return r.scheduleWithState(t,n);var s=Ee(function(){!i.isDisposed&&i.setDisposable(n(r,t))},o);return new ie(i,ae(function(){Ce(s)}))}function n(t,e,n){return this.scheduleWithRelativeAndState(t,e-this.now(),n)}return new ye(rt,t,e,n)}(),function(t){function e(t,e){return this._scheduler.scheduleWithState(t,this._wrap(e))}function n(t,e,n){return this._scheduler.scheduleWithRelativeAndState(t,e,this._wrap(n))}function r(t,e,n){return this._scheduler.scheduleWithAbsoluteAndState(t,e,this._wrap(n))}function o(o,i){this._scheduler=o,this._handler=i,this._recursiveOriginal=null,this._recursiveWrapper=null,t.call(this,this._scheduler.now.bind(this._scheduler),e,n,r)}return Zt(o,t),o.prototype._clone=function(t){return new o(t,this._handler)},o.prototype._wrap=function(t){var e=this;return function(n,r){try{return t(e._getRecursiveWrapper(n),r)}catch(o){if(!e._handler(o))throw o;return ce}}},o.prototype._getRecursiveWrapper=function(t){if(this._recursiveOriginal!==t){this._recursiveOriginal=t;var e=this._clone(t);e._recursiveOriginal=t,e._recursiveWrapper=e,this._recursiveWrapper=e}return this._recursiveWrapper},o.prototype.schedulePeriodicWithState=function(t,e,n){var r=this,o=!1,i=new fe;return i.setDisposable(this._scheduler.schedulePeriodicWithState(t,e,function(t){if(o)return null;try{return n(t)}catch(e){if(o=!0,!r._handler(e))throw e;return i.dispose(),null}})),i},o}(ye)),Ne=tt.Notification=function(){function t(t,e,n,r,o,i){this.kind=t,this.value=e,this.exception=n,this._accept=r,this._acceptObservable=o,this.toString=i}return t.prototype.accept=function(t,e,n){return t&&\"object\"==typeof t?this._acceptObservable(t):this._accept(t,e,n)},t.prototype.toObservable=function(t){var e=this;return me(t)||(t=xe),new qn(function(n){return t.scheduleWithState(e,function(t,e){e._acceptObservable(n),\"N\"===e.kind&&n.onCompleted()})})},t}(),ke=Ne.createOnNext=function(){function t(t){return t(this.value)}function e(t){return t.onNext(this.value)}function n(){return\"OnNext(\"+this.value+\")\"}return function(r){return new Ne(\"N\",r,null,t,e,n)}}(),Oe=Ne.createOnError=function(){function t(t,e){return e(this.exception)}function e(t){return t.onError(this.exception)}function n(){return\"OnError(\"+this.exception+\")\"}return function(r){return new Ne(\"E\",null,r,t,e,n)}}(),Pe=Ne.createOnCompleted=function(){function t(t,e,n){return n()}function e(t){return t.onCompleted()}function n(){return\"OnCompleted()\"}return function(){return new Ne(\"C\",null,null,t,e,n)}}(),je=tt.Observer=function(){};je.prototype.toNotifier=function(){var t=this;return function(e){return e.accept(t)}},je.prototype.asObserver=function(){return new Me(this.onNext.bind(this),this.onError.bind(this),this.onCompleted.bind(this))},je.prototype.checked=function(){return new Te(this)};var De=je.create=function(t,e,n){return t||(t=et),e||(e=st),n||(n=et),new Me(t,e,n)};je.fromNotifier=function(t,e){return new Me(function(n){return t.call(e,ke(n))},function(n){return t.call(e,Oe(n))},function(){return t.call(e,Pe())})},je.prototype.notifyOn=function(t){return new $e(t,this)},je.prototype.makeSafe=function(t){return new AnonymousSafeObserver(this._onNext,this._onError,this._onCompleted,t)};var qe,Re=tt.internals.AbstractObserver=function(t){function e(){this.isStopped=!1,t.call(this)}return Zt(e,t),e.prototype.next=gt,e.prototype.error=gt,e.prototype.completed=gt,e.prototype.onNext=function(t){this.isStopped||this.next(t)},e.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.error(t))},e.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.completed())},e.prototype.dispose=function(){this.isStopped=!0},e.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.error(t),!0)},e}(je),Me=tt.AnonymousObserver=function(t){function e(e,n,r){t.call(this),this._onNext=e,this._onError=n,this._onCompleted=r}return Zt(e,t),e.prototype.next=function(t){this._onNext(t)},e.prototype.error=function(t){this._onError(t)},e.prototype.completed=function(){this._onCompleted()},e}(Re),Te=function(t){function e(e){t.call(this),this._observer=e,this._state=0}Zt(e,t);var n=e.prototype;return n.onNext=function(t){this.checkAccess();var e=x(this._observer.onNext).call(this._observer,t);this._state=0,e===ne&&_(e.e)},n.onError=function(t){this.checkAccess();var e=x(this._observer.onError).call(this._observer,t);this._state=2,e===ne&&_(e.e)},n.onCompleted=function(){this.checkAccess();var t=x(this._observer.onCompleted).call(this._observer);this._state=2,t===ne&&_(t.e)},n.checkAccess=function(){if(1===this._state)throw new Error(\"Re-entrancy detected\");if(2===this._state)throw new Error(\"Observer completed\");0===this._state&&(this._state=1)},e}(je),Ve=tt.internals.ScheduledObserver=function(t){function e(e,n){t.call(this),this.scheduler=e,this.observer=n,this.isAcquired=!1,this.hasFaulted=!1,this.queue=[],this.disposable=new le}return Zt(e,t),e.prototype.next=function(t){var e=this;this.queue.push(function(){e.observer.onNext(t)})},e.prototype.error=function(t){var e=this;this.queue.push(function(){e.observer.onError(t)})},e.prototype.completed=function(){var t=this;this.queue.push(function(){t.observer.onCompleted()})},e.prototype.ensureActive=function(){var t=!1,e=this;!this.hasFaulted&&this.queue.length>0&&(t=!this.isAcquired,this.isAcquired=!0),t&&this.disposable.setDisposable(this.scheduler.scheduleRecursive(function(t){var n;if(!(e.queue.length>0))return void(e.isAcquired=!1);n=e.queue.shift();try{n()}catch(r){throw e.queue=[],e.hasFaulted=!0,r}t()}))},e.prototype.dispose=function(){t.prototype.dispose.call(this),this.disposable.dispose()},e}(Re),$e=function(t){function e(e,n,r){t.call(this,e,n),this._cancel=r}return Zt(e,t),e.prototype.next=function(e){t.prototype.next.call(this,e),this.ensureActive()},e.prototype.error=function(e){t.prototype.error.call(this,e),this.ensureActive()},e.prototype.completed=function(){t.prototype.completed.call(this),this.ensureActive()},e.prototype.dispose=function(){t.prototype.dispose.call(this),this._cancel&&this._cancel.dispose(),this._cancel=null},e}(Ve),We=tt.Observable=function(){function t(t){if(tt.config.longStackSupport&&ct){try{throw new Error}catch(e){this.stack=e.stack.substring(e.stack.indexOf(\"\\n\")+1)}var n=this;this._subscribe=function(e){var r=e.onError.bind(e);return e.onError=function(t){a(t,n),r(t)},t.call(n,e)}}else this._subscribe=t}return qe=t.prototype,qe.subscribe=qe.forEach=function(t,e,n){return this._subscribe(\"object\"==typeof t?t:De(t,e,n))},qe.subscribeOnNext=function(t,e){return this._subscribe(De(\"undefined\"!=typeof e?function(n){t.call(e,n)}:t))},qe.subscribeOnError=function(t,e){return this._subscribe(De(null,\"undefined\"!=typeof e?function(n){t.call(e,n)}:t))},qe.subscribeOnCompleted=function(t,e){return this._subscribe(De(null,null,\"undefined\"!=typeof e?function(){t.call(e)}:t))},t}(),ze=tt.ObservableBase=function(t){function e(t){return t&&at(t.dispose)?t:at(t)?ae(t):ce}function n(t,n){var r=n[0],o=n[1],i=x(o.subscribeCore).call(o,r);return i!==ne||r.fail(ne.e)?void r.setDisposable(e(i)):_(ne.e)}function r(t){var e=new Rn(t),r=[e,this];return _e.scheduleRequired()?_e.scheduleWithState(r,n):n(null,r),e}function o(){t.call(this,r)}return Zt(o,t),o.prototype.subscribeCore=gt,o}(We),Ge=tt.internals.Enumerable=function(){},Je=function(t){function e(e){this.sources=e,t.call(this)}function n(t,e,n){this.o=t,this.s=e,this.e=n,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){var e,r=new le,o=xe.scheduleRecursiveWithState(this.sources[xt](),function(o,i){if(!e){var s=x(o.next).call(o);if(s===ne)return t.onError(s.e);if(s.done)return t.onCompleted();var u=s.value;ut(u)&&(u=Xe(u));var a=new fe;r.setDisposable(a),a.setDisposable(u.subscribe(new n(t,i,o)))}});return new ie(r,o,ae(function(){e=!0}))},n.prototype.onNext=function(t){this.isStopped||this.o.onNext(t)},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.s(this.e))},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);Ge.prototype.concat=function(){return new Je(this)};var Ie=function(t){function e(e){this.sources=e,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e,n=this.sources[xt](),r=new le,o=xe.scheduleRecursiveWithState(null,function(o,i){if(!e){var s=x(n.next).call(n);if(s===ne)return t.onError(s.e);if(s.done)return null!==o?t.onError(o):t.onCompleted();var u=s.value;ut(u)&&(u=Xe(u));var a=new fe;r.setDisposable(a),a.setDisposable(u.subscribe(function(e){t.onNext(e)},i,function(){t.onCompleted()}))}});return new ie(r,o,ae(function(){e=!0}))},e}(ze);Ge.prototype.catchError=function(){return new Ie(this)},Ge.prototype.catchErrorWhen=function(t){var e=this;return new qn(function(n){var r,o,i=new Tn,s=new Tn,u=t(i),a=u.subscribe(s),c=e[xt](),p=new le,h=xe.scheduleRecursive(function(t){if(!r){var e=x(c.next).call(c);if(e===ne)return n.onError(e.e);if(e.done)return void(o?n.onError(o):n.onCompleted());var u=e.value;ut(u)&&(u=Xe(u));var a=new fe,h=new fe;p.setDisposable(new ie(h,a)),a.setDisposable(u.subscribe(function(t){n.onNext(t)},function(e){h.setDisposable(s.subscribe(t,function(t){n.onError(t)},function(){n.onCompleted()})),i.onNext(e)},function(){n.onCompleted()}))}});return new ie(a,p,h,ae(function(){r=!0}))})};var Le=function(t){function e(t,e){this.v=t,this.c=null==e?-1:e}function n(t){this.v=t.v,this.l=t.c}return Zt(e,t),e.prototype[xt]=function(){return new n(this)},n.prototype.next=function(){return 0===this.l?_t:(this.l>0&&this.l--,{done:!1,value:this.v})},e}(Ge),Be=Ge.repeat=function(t,e){return new Le(t,e)},Fe=function(t){function e(t,e,n){this.s=t,this.fn=e?At(e,n,3):null}function n(t){this.i=-1,this.s=t.s,this.l=this.s.length,this.fn=t.fn}return Zt(e,t),e.prototype[xt]=function(){return new n(this)},n.prototype.next=function(){return++this.i<this.l?{done:!1,value:this.fn?this.fn(this.s[this.i],this.i,this.s):this.s[this.i]}:_t},e}(Ge),Ue=Ge.of=function(t,e,n){return new Fe(t,e,n)};qe.observeOn=function(t){var e=this;return new qn(function(n){return e.subscribe(new $e(t,n))},e)},qe.subscribeOn=function(t){var e=this;return new qn(function(n){var r=new fe,o=new le;return o.setDisposable(r),r.setDisposable(t.schedule(function(){o.setDisposable(new E(t,e.subscribe(n)))})),o},e)};var He=function(t){function e(e){this.p=e,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.p.then(function(e){t.onNext(e),t.onCompleted()},function(e){t.onError(e)}),ce},e}(ze),Xe=We.fromPromise=function(t){return new He(t)};qe.toPromise=function(t){if(t||(t=tt.config.Promise),!t)throw new bt(\"Promise type not provided nor in Rx.config.Promise\");var e=this;return new t(function(t,n){var r,o=!1;e.subscribe(function(t){r=t,o=!0},n,function(){o&&t(r)})})};var Qe=function(t){function e(e){this.source=e,t.call(this)}function n(t){this.o=t,this.a=[],this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new n(t))},n.prototype.onNext=function(t){this.isStopped||this.a.push(t)},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.o.onNext(this.a),this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe.toArray=function(){return new Qe(this)},We.create=We.createWithDisposable=function(t,e){return new qn(t,e)};var Ke=(We.defer=function(t){return new qn(function(e){var n;try{n=t()}catch(r){return dn(r).subscribe(e)}return ut(n)&&(n=Xe(n)),n.subscribe(e)})},function(t){function e(e){this.scheduler=e,t.call(this)}function n(t,e){this.observer=t,this.parent=e}function r(t,e){e.onCompleted()}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new n(t,this);return e.run()},n.prototype.run=function(){return this.parent.scheduler.scheduleWithState(this.observer,r)},e}(ze)),Ye=We.empty=function(t){return me(t)||(t=xe),new Ke(t)},Ze=function(t){function e(e,n,r){this.iterable=e,this.mapper=n,this.scheduler=r,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new tn(t,this);return e.run()},e}(ze),tn=function(){function t(t,e){this.observer=t,this.parent=e}return t.prototype.run=function(){function t(t,e){try{var i=n.next()}catch(s){return r.onError(s)}if(i.done)return r.onCompleted();var u=i.value;if(o)try{u=o(u,t)}catch(s){return r.onError(s)}r.onNext(u),e(t+1)}var e=Object(this.parent.iterable),n=j(e),r=this.observer,o=this.parent.mapper;return this.parent.scheduler.scheduleRecursiveWithState(0,t)},t}(),en=Math.pow(2,53)-1;A.prototype[xt]=function(){return new N(this._s)},N.prototype[xt]=function(){return this},N.prototype.next=function(){return this._i<this._l?{done:!1,value:this._s.charAt(this._i++)}:_t},k.prototype[xt]=function(){return new O(this._a)},O.prototype[xt]=function(){return this},O.prototype.next=function(){return this._i<this._l?{done:!1,value:this._a[this._i++]}:_t};var nn=We.from=function(t,e,n,r){if(null==t)throw new Error(\"iterable cannot be null.\");if(e&&!at(e))throw new Error(\"mapFn when provided must be a function\");if(e)var o=At(e,n,2);return me(r)||(r=_e),new Ze(t,o,r)},rn=function(t){function e(e,n){this.args=e,this.scheduler=n,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new R(t,this);return e.run()},e}(ze);R.prototype.run=function(){function t(t,o){r>t?(e.onNext(n[t]),o(t+1)):e.onCompleted()}var e=this.observer,n=this.parent.args,r=n.length;return this.parent.scheduler.scheduleRecursiveWithState(0,t)};var on=We.fromArray=function(t,e){return me(e)||(e=_e),new rn(t,e)};We.generate=function(t,e,n,r,o){return me(o)||(o=_e),new qn(function(i){var s=!0;return o.scheduleRecursiveWithState(t,function(t,o){var u,a;try{s?s=!1:t=n(t),u=e(t),u&&(a=r(t))}catch(c){return i.onError(c)}u?(i.onNext(a),o(t)):i.onCompleted()})})};var sn=function(t){function e(){t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){return ce},e}(ze),un=We.never=function(){return new sn};We.of=function(){for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];return new rn(e,_e)},We.ofWithScheduler=function(t){for(var e=arguments.length,n=new Array(e-1),r=1;e>r;r++)n[r-1]=arguments[r];return new rn(n,t)};var an=function(t){function e(e,n){this.obj=e,this.keys=Object.keys(e),this.scheduler=n,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new T(t,this);return e.run()},e}(ze);T.prototype.run=function(){function t(t,i){if(o>t){var s=r[t];e.onNext([s,n[s]]),i(t+1)}else e.onCompleted()}var e=this.observer,n=this.parent.obj,r=this.parent.keys,o=r.length;return this.parent.scheduler.scheduleRecursiveWithState(0,t)},We.pairs=function(t,e){return e||(e=_e),new an(t,e)};var cn=function(t){function e(e,n,r){this.start=e,this.rangeCount=n,this.scheduler=r,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new pn(t,this);return e.run()},e}(ze),pn=function(){function t(t,e){this.observer=t,this.parent=e}return t.prototype.run=function(){function t(t,o){n>t?(r.onNext(e+t),o(t+1)):r.onCompleted()}var e=this.parent.start,n=this.parent.rangeCount,r=this.observer;return this.parent.scheduler.scheduleRecursiveWithState(0,t)},t}();We.range=function(t,e,n){return me(n)||(n=_e),new cn(t,e,n)};var hn=function(t){function e(e,n,r){this.value=e,this.repeatCount=null==n?-1:n,this.scheduler=r,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new V(t,this);return e.run()},e}(ze);V.prototype.run=function(){function t(t,r){return(-1===t||t>0)&&(e.onNext(n),t>0&&t--),0===t?e.onCompleted():void r(t)}var e=this.observer,n=this.parent.value;return this.parent.scheduler.scheduleRecursiveWithState(this.parent.repeatCount,t)},We.repeat=function(t,e,n){return me(n)||(n=_e),new hn(t,e,n)};var fn=function(t){function e(e,n){this.value=e,this.scheduler=n,t.call(this)}function n(t,e){this.observer=t,this.parent=e}function r(t,e){var n=e[0],r=e[1];r.onNext(n),r.onCompleted()}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new n(t,this);return e.run()},n.prototype.run=function(){return this.parent.scheduler.scheduleWithState([this.parent.value,this.observer],r)},e}(ze),ln=(We[\"return\"]=We.just=We.returnValue=function(t,e){return me(e)||(e=xe),new fn(t,e)},function(t){function e(e,n){this.error=e,this.scheduler=n,t.call(this)}function n(t,e){this.o=t,this.p=e}function r(t,e){var n=e[0],r=e[1];r.onError(n)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new n(t,this);return e.run()},n.prototype.run=function(){return this.p.scheduler.scheduleWithState([this.p.error,this.o],r)},e}(ze)),dn=We[\"throw\"]=We.throwError=We.throwException=function(t,e){return me(e)||(e=xe),new ln(t,e)};We.using=function(t,e){return new qn(function(n){var r,o,i=ce;try{r=t(),r&&(i=r),o=e(r)}catch(s){return new ie(dn(s).subscribe(n),i)}return new ie(o.subscribe(n),i)})},qe.amb=function(t){var e=this;return new qn(function(n){function r(){i||(i=s,c.dispose())}function o(){i||(i=u,a.dispose())}var i,s=\"L\",u=\"R\",a=new fe,c=new fe;return ut(t)&&(t=Xe(t)),a.setDisposable(e.subscribe(function(t){r(),i===s&&n.onNext(t)},function(t){r(),i===s&&n.onError(t)},function(){r(),i===s&&n.onCompleted()})),c.setDisposable(t.subscribe(function(t){o(),i===u&&n.onNext(t)},function(t){o(),i===u&&n.onError(t)},function(){o(),i===u&&n.onCompleted()})),new ie(a,c)})},We.amb=function(){function t(t,e){return t.amb(e)}var e=un(),n=[];if(Array.isArray(arguments[0]))n=arguments[0];else for(var r=0,o=arguments.length;o>r;r++)n.push(arguments[r]);for(var r=0,o=n.length;o>r;r++)e=t(e,n[r]);return e},qe[\"catch\"]=qe.catchError=qe.catchException=function(t){return\"function\"==typeof t?$(this,t):vn([this,t])};var vn=We.catchError=We[\"catch\"]=We.catchException=function(){var t=[];if(Array.isArray(arguments[0]))t=arguments[0];else for(var e=0,n=arguments.length;n>e;e++)t.push(arguments[e]);return Ue(t).catchError()};qe.combineLatest=function(){for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];return Array.isArray(e[0])?e[0].unshift(this):e.unshift(this),yn.apply(this,e)};var yn=We.combineLatest=function(){for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];var r=e.pop();return Array.isArray(e[0])&&(e=e[0]),new qn(function(t){function n(e){if(u[e]=!0,a||(a=u.every(nt))){try{var n=r.apply(null,p)}catch(o){return t.onError(o)}t.onNext(n)}else c.filter(function(t,n){return n!==e}).every(nt)&&t.onCompleted()}function o(e){c[e]=!0,c.every(nt)&&t.onCompleted()}for(var i=e.length,s=function(){return!1},u=g(i,s),a=!1,c=g(i,s),p=new Array(i),h=new Array(i),f=0;i>f;f++)!function(r){var i=e[r],s=new fe;ut(i)&&(i=Xe(i)),s.setDisposable(i.subscribe(function(t){p[r]=t,n(r)},function(e){t.onError(e)},function(){o(r)})),h[r]=s}(f);return new ie(h)},this)};qe.concat=function(){for(var t=[],e=0,n=arguments.length;n>e;e++)t.push(arguments[e]);return t.unshift(this),mn.apply(null,t)};var bn=function(t){function e(e){this.sources=e,t.call(this)}function n(t,e){this.sources=t,this.o=e}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new n(this.sources,t);return e.run()},n.prototype.run=function(){var t,e=new le,n=this.sources,r=n.length,o=this.o,i=xe.scheduleRecursiveWithState(0,function(i,s){if(!t){if(i===r)return o.onCompleted();var u=n[i];ut(u)&&(u=Xe(u));var a=new fe;e.setDisposable(a),a.setDisposable(u.subscribe(function(t){o.onNext(t)},function(t){o.onError(t)},function(){s(i+1)}))}});return new ie(e,i,ae(function(){t=!0}))},e}(ze),mn=We.concat=function(){var t;if(Array.isArray(arguments[0]))t=arguments[0];else{t=new Array(arguments.length);for(var e=0,n=arguments.length;n>e;e++)t[e]=arguments[e]}return new bn(t)};qe.concatAll=qe.concatObservable=function(){return this.merge(1)};var gn=function(t){function e(e,n){this.source=e,this.maxConcurrent=n,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new ie;return e.add(this.source.subscribe(new wn(t,this.maxConcurrent,e))),e},e}(ze),wn=function(){function t(t,e,n){this.o=t,this.max=e,this.g=n,this.done=!1,this.q=[],this.activeCount=0,this.isStopped=!1}function e(t,e){this.parent=t,this.sad=e,this.isStopped=!1}return t.prototype.handleSubscribe=function(t){var n=new fe;this.g.add(n),ut(t)&&(t=Xe(t)),n.setDisposable(t.subscribe(new e(this,n)))},t.prototype.onNext=function(t){this.isStopped||(this.activeCount<this.max?(this.activeCount++,this.handleSubscribe(t)):this.q.push(t))},t.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},t.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.done=!0,0===this.activeCount&&this.o.onCompleted())},t.prototype.dispose=function(){this.isStopped=!0},t.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e.prototype.onNext=function(t){this.isStopped||this.parent.o.onNext(t)},e.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.parent.o.onError(t))},e.prototype.onCompleted=function(){if(!this.isStopped){this.isStopped=!0;var t=this.parent;t.g.remove(this.sad),t.q.length>0?t.handleSubscribe(t.q.shift()):(t.activeCount--,t.done&&0===t.activeCount&&t.o.onCompleted())}},e.prototype.dispose=function(){this.isStopped=!0},e.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.parent.o.onError(t),!0)},t}();qe.merge=function(t){return\"number\"!=typeof t?xn(this,t):new gn(this,t)};var xn=We.merge=function(){var t,e,n=[],r=arguments.length;if(arguments[0])if(me(arguments[0]))for(t=arguments[0],e=1;r>e;e++)n.push(arguments[e]);else for(t=xe,e=0;r>e;e++)n.push(arguments[e]);else for(t=xe,e=1;r>e;e++)n.push(arguments[e]);return Array.isArray(n[0])&&(n=n[0]),M(t,n).mergeAll()},_n=tt.CompositeError=function(t){this.name=\"NotImplementedError\",this.innerErrors=t,this.message=\"This contains multiple errors. Check the innerErrors\",Error.call(this)};_n.prototype=Error.prototype,We.mergeDelayError=function(){var t;if(Array.isArray(arguments[0]))t=arguments[0];else{var e=arguments.length;t=new Array(e);for(var n=0;e>n;n++)t[n]=arguments[n]}var r=M(null,t);return new qn(function(t){function e(){0===s.length?t.onCompleted():1===s.length?t.onError(s[0]):t.onError(new _n(s))}var n=new ie,o=new fe,i=!1,s=[];return n.add(o),o.setDisposable(r.subscribe(function(r){var o=new fe;n.add(o),ut(r)&&(r=Xe(r)),o.setDisposable(r.subscribe(function(e){t.onNext(e)},function(t){s.push(t),n.remove(o),i&&1===n.length&&e()},function(){n.remove(o),i&&1===n.length&&e()}))},function(t){s.push(t),i=!0,1===n.length&&e()},function(){i=!0,1===n.length&&e()})),n})};var Sn=function(t){function e(e){this.source=e,t.call(this)}function n(t,e){this.o=t,this.g=e,this.isStopped=!1,this.done=!1}function r(t,e,n){this.parent=t,this.g=e,this.sad=n,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new ie,r=new fe;return e.add(r),r.setDisposable(this.source.subscribe(new n(t,e))),e},n.prototype.onNext=function(t){if(!this.isStopped){var e=new fe;this.g.add(e),ut(t)&&(t=Xe(t)),e.setDisposable(t.subscribe(new r(this,this.g,e)))}},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.done=!0,1===this.g.length&&this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},r.prototype.onNext=function(t){this.isStopped||this.parent.o.onNext(t)},r.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.parent.o.onError(t))},r.prototype.onCompleted=function(){if(!this.isStopped){var t=this.parent;this.isStopped=!0,t.g.remove(this.sad),t.done&&1===t.g.length&&t.o.onCompleted()}},r.prototype.dispose=function(){this.isStopped=!0},r.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.parent.o.onError(t),!0)},e}(ze);qe.mergeAll=qe.mergeObservable=function(){\nreturn new Sn(this)},qe.onErrorResumeNext=function(t){if(!t)throw new Error(\"Second observable is required\");return En([this,t])};var En=We.onErrorResumeNext=function(){var t=[];if(Array.isArray(arguments[0]))t=arguments[0];else for(var e=0,n=arguments.length;n>e;e++)t.push(arguments[e]);return new qn(function(e){var n=0,r=new le,o=xe.scheduleRecursive(function(o){var i,s;n<t.length?(i=t[n++],ut(i)&&(i=Xe(i)),s=new fe,r.setDisposable(s),s.setDisposable(i.subscribe(e.onNext.bind(e),o,o))):e.onCompleted()});return new ie(r,o)})};qe.skipUntil=function(t){var e=this;return new qn(function(n){var r=!1,o=new ie(e.subscribe(function(t){r&&n.onNext(t)},function(t){n.onError(t)},function(){r&&n.onCompleted()}));ut(t)&&(t=Xe(t));var i=new fe;return o.add(i),i.setDisposable(t.subscribe(function(){r=!0,i.dispose()},function(t){n.onError(t)},function(){i.dispose()})),o},e)};var Cn=function(t){function e(e){this.source=e,t.call(this)}function n(t,e){this.o=t,this.inner=e,this.stopped=!1,this.latest=0,this.hasLatest=!1,this.isStopped=!1}function r(t,e){this.parent=t,this.id=e,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){var e=new le,r=this.source.subscribe(new n(t,e));return new ie(r,e)},n.prototype.onNext=function(t){if(!this.isStopped){var e=new fe,n=++this.latest;this.hasLatest=!0,this.inner.setDisposable(e),ut(t)&&(t=Xe(t)),e.setDisposable(t.subscribe(new r(this,n)))}},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.stopped=!0,!this.hasLatest&&this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},r.prototype.onNext=function(t){this.isStopped||this.parent.latest===this.id&&this.parent.o.onNext(t)},r.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.parent.latest===this.id&&this.parent.o.onError(t))},r.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.parent.latest===this.id&&(this.parent.hasLatest=!1,this.parent.isStopped&&this.parent.o.onCompleted()))},r.prototype.dispose=function(){this.isStopped=!0},r.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.parent.o.onError(t),!0)},e}(ze);qe[\"switch\"]=qe.switchLatest=function(){return new Cn(this)};var An=function(t){function e(e,n){this.source=e,this.other=ut(n)?Xe(n):n,t.call(this)}function n(t){this.o=t,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return new ie(this.source.subscribe(t),this.other.subscribe(new n(t)))},n.prototype.onNext=function(t){this.isStopped||this.o.onCompleted()},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){!this.isStopped&&(this.isStopped=!0)},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe.takeUntil=function(t){return new An(this,t)},qe.withLatestFrom=function(){for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];var r=e.pop(),o=this;return Array.isArray(e[0])&&(e=e[0]),new qn(function(t){for(var n=e.length,i=g(n,W),s=!1,u=new Array(n),a=new Array(n+1),c=0;n>c;c++)!function(n){var r=e[n],o=new fe;ut(r)&&(r=Xe(r)),o.setDisposable(r.subscribe(function(t){u[n]=t,i[n]=!0,s=i.every(nt)},function(e){t.onError(e)},et)),a[n]=o}(c);var p=new fe;return p.setDisposable(o.subscribe(function(e){var n=[e].concat(u);if(s){var o=x(r).apply(null,n);return o===ne?t.onError(o.e):void t.onNext(o)}},function(e){t.onError(e)},function(){t.onCompleted()})),a[n]=p,new ie(a)},this)},qe.zip=function(){if(Array.isArray(arguments[0]))return z.apply(this,arguments);for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];var r=this,o=e.pop();return e.unshift(r),new qn(function(t){for(var n=e.length,i=g(n,G),s=g(n,W),u=new Array(n),a=0;n>a;a++)!function(n){var a=e[n],c=new fe;ut(a)&&(a=Xe(a)),c.setDisposable(a.subscribe(function(e){if(i[n].push(e),i.every(function(t){return t.length>0})){var u=i.map(function(t){return t.shift()}),a=x(o).apply(r,u);if(a===ne)return t.onError(a.e);t.onNext(a)}else s.filter(function(t,e){return e!==n}).every(nt)&&t.onCompleted()},function(e){t.onError(e)},function(){s[n]=!0,s.every(nt)&&t.onCompleted()})),u[n]=c}(a);return new ie(u)},r)},We.zip=function(){for(var t=arguments.length,e=new Array(t),n=0;t>n;n++)e[n]=arguments[n];var r=e.shift();return r.zip.apply(r,e)},We.zipArray=function(){var t;if(Array.isArray(arguments[0]))t=arguments[0];else{var e=arguments.length;t=new Array(e);for(var n=0;e>n;n++)t[n]=arguments[n]}return new qn(function(e){for(var n=t.length,r=g(n,J),o=g(n,W),i=new Array(n),s=0;n>s;s++)!function(n){i[n]=new fe,i[n].setDisposable(t[n].subscribe(function(t){if(r[n].push(t),r.every(function(t){return t.length>0})){var i=r.map(function(t){return t.shift()});e.onNext(i)}else if(o.filter(function(t,e){return e!==n}).every(nt))return e.onCompleted()},function(t){e.onError(t)},function(){o[n]=!0,o.every(nt)&&e.onCompleted()}))}(s);return new ie(i)})},qe.asObservable=function(){var t=this;return new qn(function(e){return t.subscribe(e)},t)},qe.bufferWithCount=function(t,e){return\"number\"!=typeof e&&(e=t),this.windowWithCount(t,e).selectMany(function(t){return t.toArray()}).where(function(t){return t.length>0})},qe.dematerialize=function(){var t=this;return new qn(function(e){return t.subscribe(function(t){return t.accept(e)},function(t){e.onError(t)},function(){e.onCompleted()})},this)},qe.distinctUntilChanged=function(t,e){var n=this;return e||(e=ot),new qn(function(r){var o,i=!1;return n.subscribe(function(n){var s=n;if(t&&(s=x(t)(n),s===ne))return r.onError(s.e);if(i){var u=x(e)(o,s);if(u===ne)return r.onError(u.e)}i&&u||(i=!0,o=s,r.onNext(n))},function(t){r.onError(t)},function(){r.onCompleted()})},this)};var Nn=function(t){function e(e,n,r,o){this.source=e,this.t=!n||at(n)?De(n||et,r||et,o||et):n,t.call(this)}function n(t,e){this.o=t,this.t=e,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new n(t,this.t))},n.prototype.onNext=function(t){if(!this.isStopped){var e=x(this.t.onNext).call(this.t,t);e===ne&&this.o.onError(e.e),this.o.onNext(t)}},n.prototype.onError=function(t){if(!this.isStopped){this.isStopped=!0;var e=x(this.t.onError).call(this.t,t);if(e===ne)return this.o.onError(e.e);this.o.onError(t)}},n.prototype.onCompleted=function(){if(!this.isStopped){this.isStopped=!0;var t=x(this.t.onCompleted).call(this.t);if(t===ne)return this.o.onError(t.e);this.o.onCompleted()}},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe[\"do\"]=qe.tap=qe.doAction=function(t,e,n){return new Nn(this,t,e,n)},qe.doOnNext=qe.tapOnNext=function(t,e){return this.tap(\"undefined\"!=typeof e?function(n){t.call(e,n)}:t)},qe.doOnError=qe.tapOnError=function(t,e){return this.tap(et,\"undefined\"!=typeof e?function(n){t.call(e,n)}:t)},qe.doOnCompleted=qe.tapOnCompleted=function(t,e){return this.tap(et,null,\"undefined\"!=typeof e?function(){t.call(e)}:t)},qe[\"finally\"]=qe.ensure=function(t){var e=this;return new qn(function(n){var r;try{r=e.subscribe(n)}catch(o){throw t(),o}return ae(function(){try{r.dispose()}catch(e){throw e}finally{t()}})},this)},qe.finallyAction=function(t){return this.ensure(t)};var kn=function(t){function e(e){this.source=e,t.call(this)}function n(t){this.o=t,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new n(t))},n.prototype.onNext=et,n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.observer.onError(t),!0)},e}(ze);qe.ignoreElements=function(){return new kn(this)},qe.materialize=function(){var t=this;return new qn(function(e){return t.subscribe(function(t){e.onNext(ke(t))},function(t){e.onNext(Oe(t)),e.onCompleted()},function(){e.onNext(Pe()),e.onCompleted()})},t)},qe.repeat=function(t){return Be(this,t).concat()},qe.retry=function(t){return Be(this,t).catchError()},qe.retryWhen=function(t){return Be(this).catchErrorWhen(t)};var On=function(t){function e(e,n,r,o){this.source=e,this.accumulator=n,this.hasSeed=r,this.seed=o,t.call(this)}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new I(t,this))},e}(ze);I.prototype.onNext=function(t){if(!this.isStopped){!this.hasValue&&(this.hasValue=!0);try{this.hasAccumulation?this.accumulation=this.accumulator(this.accumulation,t):(this.accumulation=this.hasSeed?this.accumulator(this.seed,t):t,this.hasAccumulation=!0)}catch(e){return this.observer.onError(e)}this.observer.onNext(this.accumulation)}},I.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.observer.onError(t))},I.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,!this.hasValue&&this.hasSeed&&this.observer.onNext(this.seed),this.observer.onCompleted())},I.prototype.dispose=function(){this.isStopped=!0},I.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.observer.onError(t),!0)},qe.scan=function(){var t,e,n=!1;return 2===arguments.length?(n=!0,t=arguments[0],e=arguments[1]):e=arguments[0],new On(this,e,n,t)},qe.skipLast=function(t){if(0>t)throw new yt;var e=this;return new qn(function(n){var r=[];return e.subscribe(function(e){r.push(e),r.length>t&&n.onNext(r.shift())},function(t){n.onError(t)},function(){n.onCompleted()})},e)},qe.startWith=function(){var t,e=0;arguments.length&&me(arguments[0])?(t=arguments[0],e=1):t=xe;for(var n=[],r=e,o=arguments.length;o>r;r++)n.push(arguments[r]);return Ue([on(n,t),this]).concat()},qe.takeLast=function(t){if(0>t)throw new yt;var e=this;return new qn(function(n){var r=[];return e.subscribe(function(e){r.push(e),r.length>t&&r.shift()},function(t){n.onError(t)},function(){for(;r.length>0;)n.onNext(r.shift());n.onCompleted()})},e)},qe.takeLastBuffer=function(t){var e=this;return new qn(function(n){var r=[];return e.subscribe(function(e){r.push(e),r.length>t&&r.shift()},function(t){n.onError(t)},function(){n.onNext(r),n.onCompleted()})},e)},qe.windowWithCount=function(t,e){var n=this;if(+t||(t=0),Math.abs(t)===1/0&&(t=0),0>=t)throw new yt;if(null==e&&(e=t),+e||(e=0),Math.abs(e)===1/0&&(e=0),0>=e)throw new yt;return new qn(function(r){function o(){var t=new Tn;a.push(t),r.onNext(ee(t,s))}var i=new fe,s=new de(i),u=0,a=[];return o(),i.setDisposable(n.subscribe(function(n){for(var r=0,i=a.length;i>r;r++)a[r].onNext(n);var s=u-t+1;s>=0&&s%e===0&&a.shift().onCompleted(),++u%e===0&&o()},function(t){for(;a.length>0;)a.shift().onError(t);r.onError(t)},function(){for(;a.length>0;)a.shift().onCompleted();r.onCompleted()})),s},n)},qe.selectConcat=qe.concatMap=function(t,e,n){return at(t)&&at(e)?this.concatMap(function(n,r){var o=t(n,r);return ut(o)&&(o=Xe(o)),(Et(o)||St(o))&&(o=nn(o)),o.map(function(t,o){return e(n,t,r,o)})}):at(t)?L(this,t,n):L(this,function(){return t})},qe.concatMapObserver=qe.selectConcatObserver=function(t,e,n,r){var o=this,i=At(t,r,2),s=At(e,r,1),u=At(n,r,0);return new qn(function(t){var e=0;return o.subscribe(function(n){var r;try{r=i(n,e++)}catch(o){return void t.onError(o)}ut(r)&&(r=Xe(r)),t.onNext(r)},function(e){var n;try{n=s(e)}catch(r){return void t.onError(r)}ut(n)&&(n=Xe(n)),t.onNext(n),t.onCompleted()},function(){var e;try{e=u()}catch(n){return void t.onError(n)}ut(e)&&(e=Xe(e)),t.onNext(e),t.onCompleted()})},this).concatAll()},qe.defaultIfEmpty=function(t){var e=this;return t===i&&(t=null),new qn(function(n){var r=!1;return e.subscribe(function(t){r=!0,n.onNext(t)},function(t){n.onError(t)},function(){!r&&n.onNext(t),n.onCompleted()})},e)},F.prototype.push=function(t){var e=-1===B(this.set,t,this.comparer);return e&&this.set.push(t),e},qe.distinct=function(t,e){var n=this;return e||(e=ot),new qn(function(r){var o=new F(e);return n.subscribe(function(e){var n=e;if(t)try{n=t(e)}catch(i){return void r.onError(i)}o.push(n)&&r.onNext(e)},function(t){r.onError(t)},function(){r.onCompleted()})},this)};var Pn=function(t){function e(e,n,r){this.source=e,this.selector=At(n,r,3),t.call(this)}function n(t,e){return function(n,r,o){return t.call(this,e.selector(n,r,o),r,o)}}function r(t,e,n){this.o=t,this.selector=e,this.source=n,this.i=0,this.isStopped=!1}return Zt(e,t),e.prototype.internalMap=function(t,r){return new e(this.source,n(t,this),r)},e.prototype.subscribeCore=function(t){return this.source.subscribe(new r(t,this.selector,this))},r.prototype.onNext=function(t){if(!this.isStopped){var e=x(this.selector)(t,this.i++,this.source);return e===ne?this.o.onError(e.e):void this.o.onNext(e)}},r.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},r.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.o.onCompleted())},r.prototype.dispose=function(){this.isStopped=!0},r.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe.map=qe.select=function(t,e){var n=\"function\"==typeof t?t:function(){return t};return this instanceof Pn?this.internalMap(n,e):new Pn(this,n,e)},qe.pluck=function(){var t=arguments,e=arguments.length;if(0===e)throw new Error(\"List of properties cannot be empty.\");return this.map(function(n){for(var r=n,o=0;e>o;o++){var s=r[t[o]];if(\"undefined\"==typeof s)return i;r=s}return r})},qe.flatMapObserver=qe.selectManyObserver=function(t,e,n,r){var o=this;return new qn(function(i){var s=0;return o.subscribe(function(e){var n;try{n=t.call(r,e,s++)}catch(o){return void i.onError(o)}ut(n)&&(n=Xe(n)),i.onNext(n)},function(t){var n;try{n=e.call(r,t)}catch(o){return void i.onError(o)}ut(n)&&(n=Xe(n)),i.onNext(n),i.onCompleted()},function(){var t;try{t=n.call(r)}catch(e){return void i.onError(e)}ut(t)&&(t=Xe(t)),i.onNext(t),i.onCompleted()})},o).mergeAll()},qe.selectMany=qe.flatMap=function(t,e,n){return at(t)&&at(e)?this.flatMap(function(n,r){var o=t(n,r);return ut(o)&&(o=Xe(o)),(Et(o)||St(o))&&(o=nn(o)),o.map(function(t,o){return e(n,t,r,o)})},n):at(t)?U(this,t,n):U(this,function(){return t})},qe.selectSwitch=qe.flatMapLatest=qe.switchMap=function(t,e){return this.select(t,e).switchLatest()};var jn=function(t){function e(e,n){this.source=e,this.skipCount=n,t.call(this)}function n(t,e){this.c=e,this.r=e,this.o=t,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new n(t,this.skipCount))},n.prototype.onNext=function(t){this.isStopped||(this.r<=0?this.o.onNext(t):this.r--)},n.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},n.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.o.onCompleted())},n.prototype.dispose=function(){this.isStopped=!0},n.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe.skip=function(t){if(0>t)throw new yt;return new jn(this,t)},qe.skipWhile=function(t,e){var n=this,r=At(t,e,3);return new qn(function(t){var e=0,o=!1;return n.subscribe(function(i){if(!o)try{o=!r(i,e++,n)}catch(s){return void t.onError(s)}o&&t.onNext(i)},function(e){t.onError(e)},function(){t.onCompleted()})},n)},qe.take=function(t,e){if(0>t)throw new yt;if(0===t)return Ye(e);var n=this;return new qn(function(e){var r=t;return n.subscribe(function(t){r-- >0&&(e.onNext(t),0>=r&&e.onCompleted())},function(t){e.onError(t)},function(){e.onCompleted()})},n)},qe.takeWhile=function(t,e){var n=this,r=At(t,e,3);return new qn(function(t){var e=0,o=!0;return n.subscribe(function(i){if(o){try{o=r(i,e++,n)}catch(s){return void t.onError(s)}o?t.onNext(i):t.onCompleted()}},function(e){t.onError(e)},function(){t.onCompleted()})},n)};var Dn=function(t){function e(e,n,r){this.source=e,this.predicate=At(n,r,3),t.call(this)}function n(t,e){return function(n,r,o){return e.predicate(n,r,o)&&t.call(this,n,r,o)}}function r(t,e,n){this.o=t,this.predicate=e,this.source=n,this.i=0,this.isStopped=!1}return Zt(e,t),e.prototype.subscribeCore=function(t){return this.source.subscribe(new r(t,this.predicate,this))},e.prototype.internalFilter=function(t,r){return new e(this.source,n(t,this),r)},r.prototype.onNext=function(t){if(!this.isStopped){var e=x(this.predicate)(t,this.i++,this.source);return e===ne?this.o.onError(e.e):void(e&&this.o.onNext(t))}},r.prototype.onError=function(t){this.isStopped||(this.isStopped=!0,this.o.onError(t))},r.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.o.onCompleted())},r.prototype.dispose=function(){this.isStopped=!0},r.prototype.fail=function(t){return this.isStopped?!1:(this.isStopped=!0,this.o.onError(t),!0)},e}(ze);qe.filter=qe.where=function(t,e){return this instanceof Dn?this.internalFilter(t,e):new Dn(this,t,e)},qe.transduce=function(t){function e(t){return{\"@@transducer/init\":function(){return t},\"@@transducer/step\":function(t,e){return t.onNext(e)},\"@@transducer/result\":function(t){return t.onCompleted()}}}var n=this;return new qn(function(r){var o=t(e(r));return n.subscribe(function(t){try{o[\"@@transducer/step\"](r,t)}catch(e){r.onError(e)}},function(t){r.onError(t)},function(){o[\"@@transducer/result\"](r)})},n)};var qn=tt.AnonymousObservable=function(t){function e(t){return t&&at(t.dispose)?t:at(t)?ae(t):ce}function n(t,n){var r=n[0],o=n[1],i=x(o)(r);return i!==ne||r.fail(ne.e)?void r.setDisposable(e(i)):_(ne.e)}function r(e,r){function o(t){var r=new Rn(t),o=[r,e];return _e.scheduleRequired()?_e.scheduleWithState(o,n):n(null,o),r}this.source=r,t.call(this,o)}return Zt(r,t),r}(We),Rn=function(t){function e(e){t.call(this),this.observer=e,this.m=new fe}Zt(e,t);var n=e.prototype;return n.next=function(t){var e=x(this.observer.onNext).call(this.observer,t);e===ne&&(this.dispose(),_(e.e))},n.error=function(t){var e=x(this.observer.onError).call(this.observer,t);this.dispose(),e===ne&&_(e.e)},n.completed=function(){var t=x(this.observer.onCompleted).call(this.observer);this.dispose(),t===ne&&_(t.e)},n.setDisposable=function(t){this.m.setDisposable(t)},n.getDisposable=function(){return this.m.getDisposable()},n.dispose=function(){t.prototype.dispose.call(this),this.m.dispose()},e}(Re),Mn=function(t,e){this.subject=t,this.observer=e};Mn.prototype.dispose=function(){if(!this.subject.isDisposed&&null!==this.observer){var t=this.subject.observers.indexOf(this.observer);this.subject.observers.splice(t,1),this.observer=null}};var Tn=tt.Subject=function(t){function e(t){return he(this),this.isStopped?this.hasError?(t.onError(this.error),ce):(t.onCompleted(),ce):(this.observers.push(t),new Mn(this,t))}function n(){t.call(this,e),this.isDisposed=!1,this.isStopped=!1,this.observers=[],this.hasError=!1}return Zt(n,t),te(n.prototype,je.prototype,{hasObservers:function(){return this.observers.length>0},onCompleted:function(){if(he(this),!this.isStopped){this.isStopped=!0;for(var t=0,e=u(this.observers),n=e.length;n>t;t++)e[t].onCompleted();this.observers.length=0}},onError:function(t){if(he(this),!this.isStopped){this.isStopped=!0,this.error=t,this.hasError=!0;for(var e=0,n=u(this.observers),r=n.length;r>e;e++)n[e].onError(t);this.observers.length=0}},onNext:function(t){if(he(this),!this.isStopped)for(var e=0,n=u(this.observers),r=n.length;r>e;e++)n[e].onNext(t)},dispose:function(){this.isDisposed=!0,this.observers=null}}),n.create=function(t,e){return new Vn(t,e)},n}(We),Vn=(tt.AsyncSubject=function(t){function e(t){return he(this),this.isStopped?(this.hasError?t.onError(this.error):this.hasValue?(t.onNext(this.value),t.onCompleted()):t.onCompleted(),ce):(this.observers.push(t),new Mn(this,t))}function n(){t.call(this,e),this.isDisposed=!1,this.isStopped=!1,this.hasValue=!1,this.observers=[],this.hasError=!1}return Zt(n,t),te(n.prototype,je,{hasObservers:function(){return he(this),this.observers.length>0},onCompleted:function(){var t,e;if(he(this),!this.isStopped){this.isStopped=!0;var n=u(this.observers),e=n.length;if(this.hasValue)for(t=0;e>t;t++){var r=n[t];r.onNext(this.value),r.onCompleted()}else for(t=0;e>t;t++)n[t].onCompleted();this.observers.length=0}},onError:function(t){if(he(this),!this.isStopped){this.isStopped=!0,this.hasError=!0,this.error=t;for(var e=0,n=u(this.observers),r=n.length;r>e;e++)n[e].onError(t);this.observers.length=0}},onNext:function(t){he(this),this.isStopped||(this.value=t,this.hasValue=!0)},dispose:function(){this.isDisposed=!0,this.observers=null,this.exception=null,this.value=null}}),n}(We),tt.AnonymousSubject=function(t){function e(t){return this.observable.subscribe(t)}function n(n,r){this.observer=n,this.observable=r,t.call(this,e)}return Zt(n,t),te(n.prototype,je.prototype,{onCompleted:function(){this.observer.onCompleted()},onError:function(t){this.observer.onError(t)},onNext:function(t){this.observer.onNext(t)}}),n}(We));\"function\"==typeof t&&\"object\"==typeof t.amd&&t.amd?(X.Rx=tt,t(function(){return tt})):Q&&K?Y?(K.exports=tt).Rx=tt:Q.Rx=tt:X.Rx=tt;var $n=f()}).call(this)}).call(this,e(150),\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{150:150}]},{},[1])(1)});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://Mapillary/./node_modules/falcor/dist/falcor.browser.min.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/latlon-geohash/latlon-geohash.js":
/*!*******************************************************!*\
  !*** ./node_modules/latlon-geohash/latlon-geohash.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geohash encoding/decoding and associated functions   (c) Chris Veness 2014-2016 / MIT Licence  */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n\n\n/**\n * Geohash encode, decode, bounds, neighbours.\n *\n * @namespace\n */\nvar Geohash = {};\n\n/* (Geohash-specific) Base32 map */\nGeohash.base32 = '0123456789bcdefghjkmnpqrstuvwxyz';\n\n/**\n * Encodes latitude/longitude to geohash, either to specified precision or to automatically\n * evaluated precision.\n *\n * @param   {number} lat - Latitude in degrees.\n * @param   {number} lon - Longitude in degrees.\n * @param   {number} [precision] - Number of characters in resulting geohash.\n * @returns {string} Geohash of supplied latitude/longitude.\n * @throws  Invalid geohash.\n *\n * @example\n *     var geohash = Geohash.encode(52.205, 0.119, 7); // geohash: 'u120fxw'\n */\nGeohash.encode = function(lat, lon, precision) {\n    // infer precision?\n    if (typeof precision == 'undefined') {\n        // refine geohash until it matches precision of supplied lat/lon\n        for (var p=1; p<=12; p++) {\n            var hash = Geohash.encode(lat, lon, p);\n            var posn = Geohash.decode(hash);\n            if (posn.lat==lat && posn.lon==lon) return hash;\n        }\n        precision = 12; // set to maximum\n    }\n\n    lat = Number(lat);\n    lon = Number(lon);\n    precision = Number(precision);\n\n    if (isNaN(lat) || isNaN(lon) || isNaN(precision)) throw new Error('Invalid geohash');\n\n    var idx = 0; // index into base32 map\n    var bit = 0; // each char holds 5 bits\n    var evenBit = true;\n    var geohash = '';\n\n    var latMin =  -90, latMax =  90;\n    var lonMin = -180, lonMax = 180;\n\n    while (geohash.length < precision) {\n        if (evenBit) {\n            // bisect E-W longitude\n            var lonMid = (lonMin + lonMax) / 2;\n            if (lon >= lonMid) {\n                idx = idx*2 + 1;\n                lonMin = lonMid;\n            } else {\n                idx = idx*2;\n                lonMax = lonMid;\n            }\n        } else {\n            // bisect N-S latitude\n            var latMid = (latMin + latMax) / 2;\n            if (lat >= latMid) {\n                idx = idx*2 + 1;\n                latMin = latMid;\n            } else {\n                idx = idx*2;\n                latMax = latMid;\n            }\n        }\n        evenBit = !evenBit;\n\n        if (++bit == 5) {\n            // 5 bits gives us a character: append it and start over\n            geohash += Geohash.base32.charAt(idx);\n            bit = 0;\n            idx = 0;\n        }\n    }\n\n    return geohash;\n};\n\n\n/**\n * Decode geohash to latitude/longitude (location is approximate centre of geohash cell,\n *     to reasonable precision).\n *\n * @param   {string} geohash - Geohash string to be converted to latitude/longitude.\n * @returns {{lat:number, lon:number}} (Center of) geohashed location.\n * @throws  Invalid geohash.\n *\n * @example\n *     var latlon = Geohash.decode('u120fxw'); // latlon: { lat: 52.205, lon: 0.1188 }\n */\nGeohash.decode = function(geohash) {\n\n    var bounds = Geohash.bounds(geohash); // <-- the hard work\n    // now just determine the centre of the cell...\n\n    var latMin = bounds.sw.lat, lonMin = bounds.sw.lon;\n    var latMax = bounds.ne.lat, lonMax = bounds.ne.lon;\n\n    // cell centre\n    var lat = (latMin + latMax)/2;\n    var lon = (lonMin + lonMax)/2;\n\n    // round to close to centre without excessive precision: ⌊2-log10(Δ°)⌋ decimal places\n    lat = lat.toFixed(Math.floor(2-Math.log(latMax-latMin)/Math.LN10));\n    lon = lon.toFixed(Math.floor(2-Math.log(lonMax-lonMin)/Math.LN10));\n\n    return { lat: Number(lat), lon: Number(lon) };\n};\n\n\n/**\n * Returns SW/NE latitude/longitude bounds of specified geohash.\n *\n * @param   {string} geohash - Cell that bounds are required of.\n * @returns {{sw: {lat: number, lon: number}, ne: {lat: number, lon: number}}}\n * @throws  Invalid geohash.\n */\nGeohash.bounds = function(geohash) {\n    if (geohash.length === 0) throw new Error('Invalid geohash');\n\n    geohash = geohash.toLowerCase();\n\n    var evenBit = true;\n    var latMin =  -90, latMax =  90;\n    var lonMin = -180, lonMax = 180;\n\n    for (var i=0; i<geohash.length; i++) {\n        var chr = geohash.charAt(i);\n        var idx = Geohash.base32.indexOf(chr);\n        if (idx == -1) throw new Error('Invalid geohash');\n\n        for (var n=4; n>=0; n--) {\n            var bitN = idx >> n & 1;\n            if (evenBit) {\n                // longitude\n                var lonMid = (lonMin+lonMax) / 2;\n                if (bitN == 1) {\n                    lonMin = lonMid;\n                } else {\n                    lonMax = lonMid;\n                }\n            } else {\n                // latitude\n                var latMid = (latMin+latMax) / 2;\n                if (bitN == 1) {\n                    latMin = latMid;\n                } else {\n                    latMax = latMid;\n                }\n            }\n            evenBit = !evenBit;\n        }\n    }\n\n    var bounds = {\n        sw: { lat: latMin, lon: lonMin },\n        ne: { lat: latMax, lon: lonMax },\n    };\n\n    return bounds;\n};\n\n\n/**\n * Determines adjacent cell in given direction.\n *\n * @param   geohash - Cell to which adjacent cell is required.\n * @param   direction - Direction from geohash (N/S/E/W).\n * @returns {string} Geocode of adjacent cell.\n * @throws  Invalid geohash.\n */\nGeohash.adjacent = function(geohash, direction) {\n    // based on github.com/davetroy/geohash-js\n\n    geohash = geohash.toLowerCase();\n    direction = direction.toLowerCase();\n\n    if (geohash.length === 0) throw new Error('Invalid geohash');\n    if ('nsew'.indexOf(direction) == -1) throw new Error('Invalid direction');\n\n    var neighbour = {\n        n: [ 'p0r21436x8zb9dcf5h7kjnmqesgutwvy', 'bc01fg45238967deuvhjyznpkmstqrwx' ],\n        s: [ '14365h7k9dcfesgujnmqp0r2twvyx8zb', '238967debc01fg45kmstqrwxuvhjyznp' ],\n        e: [ 'bc01fg45238967deuvhjyznpkmstqrwx', 'p0r21436x8zb9dcf5h7kjnmqesgutwvy' ],\n        w: [ '238967debc01fg45kmstqrwxuvhjyznp', '14365h7k9dcfesgujnmqp0r2twvyx8zb' ],\n    };\n    var border = {\n        n: [ 'prxz',     'bcfguvyz' ],\n        s: [ '028b',     '0145hjnp' ],\n        e: [ 'bcfguvyz', 'prxz'     ],\n        w: [ '0145hjnp', '028b'     ],\n    };\n\n    var lastCh = geohash.slice(-1);    // last character of hash\n    var parent = geohash.slice(0, -1); // hash without last character\n\n    var type = geohash.length % 2;\n\n    // check for edge-cases which don't share common prefix\n    if (border[direction][type].indexOf(lastCh) != -1 && parent !== '') {\n        parent = Geohash.adjacent(parent, direction);\n    }\n\n    // append letter for direction to parent\n    return parent + Geohash.base32.charAt(neighbour[direction][type].indexOf(lastCh));\n};\n\n\n/**\n * Returns all 8 adjacent cells to specified geohash.\n *\n * @param   {string} geohash - Geohash neighbours are required of.\n * @returns {{n,ne,e,se,s,sw,w,nw: string}}\n * @throws  Invalid geohash.\n */\nGeohash.neighbours = function(geohash) {\n    return {\n        'n':  Geohash.adjacent(geohash, 'n'),\n        'ne': Geohash.adjacent(Geohash.adjacent(geohash, 'n'), 'e'),\n        'e':  Geohash.adjacent(geohash, 'e'),\n        'se': Geohash.adjacent(Geohash.adjacent(geohash, 's'), 'e'),\n        's':  Geohash.adjacent(geohash, 's'),\n        'sw': Geohash.adjacent(Geohash.adjacent(geohash, 's'), 'w'),\n        'w':  Geohash.adjacent(geohash, 'w'),\n        'nw': Geohash.adjacent(Geohash.adjacent(geohash, 'n'), 'w'),\n    };\n};\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\nif ( true && module.exports) module.exports = Geohash; // CommonJS, node.js\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/latlon-geohash/latlon-geohash.js?");

/***/ }),

/***/ "./node_modules/martinez-polygon-clipping/dist/martinez.umd.js":
/*!*********************************************************************!*\
  !*** ./node_modules/martinez-polygon-clipping/dist/martinez.umd.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * martinez v0.5.0\n * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor\n *\n * @author Alex Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n  function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n  var SplayTree = function SplayTree(compare, noDuplicates) {\n    if ( compare === void 0 ) compare = DEFAULT_COMPARE;\n    if ( noDuplicates === void 0 ) noDuplicates = false;\n\n    this._compare = compare;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  };\n\n  var prototypeAccessors = { size: { configurable: true } };\n\n\n  SplayTree.prototype.rotateLeft = function rotateLeft (x) {\n    var y = x.right;\n    if (y) {\n      x.right = y.left;\n      if (y.left) { y.left.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)              { this._root = y; }\n    else if (x === x.parent.left) { x.parent.left = y; }\n    else                        { x.parent.right = y; }\n    if (y) { y.left = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype.rotateRight = function rotateRight (x) {\n    var y = x.left;\n    if (y) {\n      x.left = y.right;\n      if (y.right) { y.right.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)             { this._root = y; }\n    else if(x === x.parent.left) { x.parent.left = y; }\n    else                       { x.parent.right = y; }\n    if (y) { y.right = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype._splay = function _splay (x) {\n      var this$1 = this;\n\n    while (x.parent) {\n      var p = x.parent;\n      if (!p.parent) {\n        if (p.left === x) { this$1.rotateRight(p); }\n        else            { this$1.rotateLeft(p); }\n      } else if (p.left === x && p.parent.left === p) {\n        this$1.rotateRight(p.parent);\n        this$1.rotateRight(p);\n      } else if (p.right === x && p.parent.right === p) {\n        this$1.rotateLeft(p.parent);\n        this$1.rotateLeft(p);\n      } else if (p.left === x && p.parent.right === p) {\n        this$1.rotateRight(p);\n        this$1.rotateLeft(p);\n      } else {\n        this$1.rotateLeft(p);\n        this$1.rotateRight(p);\n      }\n    }\n  };\n\n\n  SplayTree.prototype.splay = function splay (x) {\n      var this$1 = this;\n\n    var p, gp, ggp, l, r;\n\n    while (x.parent) {\n      p = x.parent;\n      gp = p.parent;\n\n      if (gp && gp.parent) {\n        ggp = gp.parent;\n        if (ggp.left === gp) { ggp.left= x; }\n        else               { ggp.right = x; }\n        x.parent = ggp;\n      } else {\n        x.parent = null;\n        this$1._root = x;\n      }\n\n      l = x.left; r = x.right;\n\n      if (x === p.left) { // left\n        if (gp) {\n          if (gp.left === p) {\n            /* zig-zig */\n            if (p.right) {\n              gp.left = p.right;\n              gp.left.parent = gp;\n            } else { gp.left = null; }\n\n            p.right = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (l) {\n              gp.right = l;\n              l.parent = gp;\n            } else { gp.right = null; }\n\n            x.left  = gp;\n            gp.parent = x;\n          }\n        }\n        if (r) {\n          p.left = r;\n          r.parent = p;\n        } else { p.left = null; }\n\n        x.right= p;\n        p.parent = x;\n      } else { // right\n        if (gp) {\n          if (gp.right === p) {\n            /* zig-zig */\n            if (p.left) {\n              gp.right = p.left;\n              gp.right.parent = gp;\n            } else { gp.right = null; }\n\n            p.left = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (r) {\n              gp.left = r;\n              r.parent = gp;\n            } else { gp.left = null; }\n\n            x.right = gp;\n            gp.parent = x;\n          }\n        }\n        if (l) {\n          p.right = l;\n          l.parent = p;\n        } else { p.right = null; }\n\n        x.left = p;\n        p.parent = x;\n      }\n    }\n  };\n\n\n  SplayTree.prototype.replace = function replace (u, v) {\n    if (!u.parent) { this._root = v; }\n    else if (u === u.parent.left) { u.parent.left = v; }\n    else { u.parent.right = v; }\n    if (v) { v.parent = u.parent; }\n  };\n\n\n  SplayTree.prototype.minNode = function minNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.left) { u = u.left; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.maxNode = function maxNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.right) { u = u.right; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.insert = function insert (key, data) {\n    var z = this._root;\n    var p = null;\n    var comp = this._compare;\n    var cmp;\n\n    if (this._noDuplicates) {\n      while (z) {\n        p = z;\n        cmp = comp(z.key, key);\n        if (cmp === 0) { return; }\n        else if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    } else {\n      while (z) {\n        p = z;\n        if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    }\n\n    z = { key: key, data: data, left: null, right: null, parent: p };\n\n    if (!p)                        { this._root = z; }\n    else if (comp(p.key, z.key) < 0) { p.right = z; }\n    else                           { p.left= z; }\n\n    this.splay(z);\n    this._size++;\n    return z;\n  };\n\n\n  SplayTree.prototype.find = function find (key) {\n    var z  = this._root;\n    var comp = this._compare;\n    while (z) {\n      var cmp = comp(z.key, key);\n      if    (cmp < 0) { z = z.right; }\n      else if (cmp > 0) { z = z.left; }\n      else            { return z; }\n    }\n    return null;\n  };\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param{Key} key\n   * @return {boolean} true/false\n   */\n  SplayTree.prototype.contains = function contains (key) {\n    var node     = this._root;\n    var comparator = this._compare;\n    while (node){\n      var cmp = comparator(key, node.key);\n      if    (cmp === 0) { return true; }\n      else if (cmp < 0) { node = node.left; }\n      else              { node = node.right; }\n    }\n\n    return false;\n  };\n\n\n  SplayTree.prototype.remove = function remove (key) {\n    var z = this.find(key);\n\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.removeNode = function removeNode (z) {\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.erase = function erase (key) {\n    var z = this.find(key);\n    if (!z) { return; }\n\n    this.splay(z);\n\n    var s = z.left;\n    var t = z.right;\n\n    var sMax = null;\n    if (s) {\n      s.parent = null;\n      sMax = this.maxNode(s);\n      this.splay(sMax);\n      this._root = sMax;\n    }\n    if (t) {\n      if (s) { sMax.right = t; }\n      else { this._root = t; }\n      t.parent = sMax;\n    }\n\n    this._size--;\n  };\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  SplayTree.prototype.pop = function pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) { node = node.left; }\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  };\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.next = function next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor && successor.left) { successor = successor.left; }\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  };\n\n\n  /**\n   * Predecessor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.prev = function prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor && predecessor.right) { predecessor = predecessor.right; }\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  };\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * @param{forEachCallback} callback\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.forEach = function forEach (callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return this;\n  };\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param{Key}    low\n   * @param{Key}    high\n   * @param{Function} fn\n   * @param{*?}     ctx\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.range = function range (low, high, fn, ctx) {\n      var this$1 = this;\n\n    var Q = [];\n    var compare = this._compare;\n    var node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  SplayTree.prototype.keys = function keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  SplayTree.prototype.values = function values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns node at given index\n   * @param{number} index\n   * @return {?Node}\n   */\n  SplayTree.prototype.at = function at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) { return current; }\n          i++;\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param{Array<Key>}  keys\n   * @param{Array<Value>}[values]\n   * @param{Boolean}     [presort=false] Pre-sort keys and values, using\n   *                                       tree's comparator. Sorting is done\n   *                                       in-place\n   * @return {AVLTree}\n   */\n  SplayTree.prototype.load = function load (keys, values, presort) {\n      if ( keys === void 0 ) keys = [];\n      if ( values === void 0 ) values = [];\n      if ( presort === void 0 ) presort = false;\n\n    if (this._size !== 0) { throw new Error('bulk-load: tree is not empty'); }\n    var size = keys.length;\n    if (presort) { sort(keys, values, 0, size - 1, this._compare); }\n    this._root = loadRecursive(null, keys, values, 0, size);\n    this._size = size;\n    return this;\n  };\n\n\n  SplayTree.prototype.min = function min () {\n    var node = this.minNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n\n  SplayTree.prototype.max = function max () {\n    var node = this.maxNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n  SplayTree.prototype.isEmpty = function isEmpty () { return this._root === null; };\n  prototypeAccessors.size.get = function () { return this._size; };\n\n\n  /**\n   * Create a tree and load it with items\n   * @param{Array<Key>}        keys\n   * @param{Array<Value>?}      [values]\n\n   * @param{Function?}          [comparator]\n   * @param{Boolean?}           [presort=false] Pre-sort keys and values, using\n   *                                             tree's comparator. Sorting is done\n   *                                             in-place\n   * @param{Boolean?}           [noDuplicates=false] Allow duplicates\n   * @return {SplayTree}\n   */\n  SplayTree.createTree = function createTree (keys, values, comparator, presort, noDuplicates) {\n    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);\n  };\n\n  Object.defineProperties( SplayTree.prototype, prototypeAccessors );\n\n\n  function loadRecursive (parent, keys, values, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key    = keys[middle];\n      var data   = values[middle];\n      var node   = { key: key, data: data, parent: parent };\n      node.left    = loadRecursive(node, keys, values, start, middle);\n      node.right   = loadRecursive(node, keys, values, middle + 1, end);\n      return node;\n    }\n    return null;\n  }\n\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) { return; }\n\n    var pivot = keys[(left + right) >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do { i++; } while (compare(keys[i], pivot) < 0);\n      do { j--; } while (compare(keys[j], pivot) > 0);\n      if (i >= j) { break; }\n\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values,  left,     j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  var NORMAL               = 0;\n  var NON_CONTRIBUTING     = 1;\n  var SAME_TRANSITION      = 2;\n  var DIFFERENT_TRANSITION = 3;\n\n  var INTERSECTION = 0;\n  var UNION        = 1;\n  var DIFFERENCE   = 2;\n  var XOR          = 3;\n\n  /**\n   * @param  {SweepEvent} event\n   * @param  {SweepEvent} prev\n   * @param  {Operation} operation\n   */\n  function computeFields (event, prev, operation) {\n    // compute inOut and otherInOut fields\n    if (prev === null) {\n      event.inOut      = false;\n      event.otherInOut = true;\n\n    // previous line segment in sweepline belongs to the same polygon\n    } else {\n      if (event.isSubject === prev.isSubject) {\n        event.inOut      = !prev.inOut;\n        event.otherInOut = prev.otherInOut;\n\n      // previous line segment in sweepline belongs to the clipping polygon\n      } else {\n        event.inOut      = !prev.otherInOut;\n        event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n      }\n\n      // compute prevInResult field\n      if (prev) {\n        event.prevInResult = (!inResult(prev, operation) || prev.isVertical())\n          ? prev.prevInResult : prev;\n      }\n    }\n\n    // check if the line segment belongs to the Boolean operation\n    event.inResult = inResult(event, operation);\n  }\n\n\n  /* eslint-disable indent */\n  function inResult(event, operation) {\n    switch (event.type) {\n      case NORMAL:\n        switch (operation) {\n          case INTERSECTION:\n            return !event.otherInOut;\n          case UNION:\n            return event.otherInOut;\n          case DIFFERENCE:\n            // return (event.isSubject && !event.otherInOut) ||\n            //         (!event.isSubject && event.otherInOut);\n            return (event.isSubject && event.otherInOut) ||\n                    (!event.isSubject && !event.otherInOut);\n          case XOR:\n            return true;\n        }\n        break;\n      case SAME_TRANSITION:\n        return operation === INTERSECTION || operation === UNION;\n      case DIFFERENT_TRANSITION:\n        return operation === DIFFERENCE;\n      case NON_CONTRIBUTING:\n        return false;\n    }\n    return false;\n  }\n  /* eslint-enable indent */\n\n  var SweepEvent = function SweepEvent (point, left, otherEvent, isSubject, edgeType) {\n\n    /**\n     * Is left endpoint?\n     * @type {Boolean}\n     */\n    this.left = left;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this.point = point;\n\n    /**\n     * Other edge reference\n     * @type {SweepEvent}\n     */\n    this.otherEvent = otherEvent;\n\n    /**\n     * Belongs to source or clipping polygon\n     * @type {Boolean}\n     */\n    this.isSubject = isSubject;\n\n    /**\n     * Edge contribution type\n     * @type {Number}\n     */\n    this.type = edgeType || NORMAL;\n\n\n    /**\n     * In-out transition for the sweepline crossing polygon\n     * @type {Boolean}\n     */\n    this.inOut = false;\n\n\n    /**\n     * @type {Boolean}\n     */\n    this.otherInOut = false;\n\n    /**\n     * Previous event in result?\n     * @type {SweepEvent}\n     */\n    this.prevInResult = null;\n\n    /**\n     * Does event belong to result?\n     * @type {Boolean}\n     */\n    this.inResult = false;\n\n\n    // connection step\n\n    /**\n     * @type {Boolean}\n     */\n    this.resultInOut = false;\n\n    this.isExteriorRing = true;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isBelow = function isBelow (p) {\n    var p0 = this.point, p1 = this.otherEvent.point;\n    return this.left\n      ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0\n      // signedArea(this.point, this.otherEvent.point, p) > 0 :\n      : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;\n      //signedArea(this.otherEvent.point, this.point, p) > 0;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isAbove = function isAbove (p) {\n    return !this.isBelow(p);\n  };\n\n\n  /**\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isVertical = function isVertical () {\n    return this.point[0] === this.otherEvent.point[0];\n  };\n\n\n  SweepEvent.prototype.clone = function clone () {\n    var copy = new SweepEvent(\n      this.point, this.left, this.otherEvent, this.isSubject, this.type);\n\n    copy.inResult     = this.inResult;\n    copy.prevInResult = this.prevInResult;\n    copy.isExteriorRing = this.isExteriorRing;\n    copy.inOut        = this.inOut;\n    copy.otherInOut   = this.otherInOut;\n\n    return copy;\n  };\n\n  function equals(p1, p2) {\n    if (p1[0] === p2[0]) {\n      if (p1[1] === p2[1]) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  // const EPSILON = 1e-9;\n  // const abs = Math.abs;\n  // TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n  // Precision problem.\n  //\n  // module.exports = function equals(p1, p2) {\n  //   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n  // };\n\n  /**\n   * Signed area of the triangle (p0, p1, p2)\n   * @param  {Array.<Number>} p0\n   * @param  {Array.<Number>} p1\n   * @param  {Array.<Number>} p2\n   * @return {Number}\n   */\n  function signedArea(p0, p1, p2) {\n    return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n  }\n\n  /**\n   * @param  {SweepEvent} e1\n   * @param  {SweepEvent} e2\n   * @return {Number}\n   */\n  function compareEvents(e1, e2) {\n    var p1 = e1.point;\n    var p2 = e2.point;\n\n    // Different x-coordinate\n    if (p1[0] > p2[0]) { return 1; }\n    if (p1[0] < p2[0]) { return -1; }\n\n    // Different points, but same x-coordinate\n    // Event with lower y-coordinate is processed first\n    if (p1[1] !== p2[1]) { return p1[1] > p2[1] ? 1 : -1; }\n\n    return specialCases(e1, e2, p1, p2);\n  }\n\n\n  /* eslint-disable no-unused-vars */\n  function specialCases(e1, e2, p1, p2) {\n    // Same coordinates, but one is a left endpoint and the other is\n    // a right endpoint. The right endpoint is processed first\n    if (e1.left !== e2.left)\n      { return e1.left ? 1 : -1; }\n\n    // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n    // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    // Same coordinates, both events\n    // are left endpoints or right endpoints.\n    // not collinear\n    if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n      // the event associate to the bottom segment is processed first\n      return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n    }\n\n    return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n  }\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * @param  {SweepEvent} se\n   * @param  {Array.<Number>} p\n   * @param  {Queue} queue\n   * @return {Queue}\n   */\n  function divideSegment(se, p, queue)  {\n    var r = new SweepEvent(p, false, se,            se.isSubject);\n    var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n    /* eslint-disable no-console */\n    if (equals(se.point, se.otherEvent.point)) {\n\n      console.warn('what is that, a collapsed segment?', se);\n    }\n    /* eslint-enable no-console */\n\n    r.contourId = l.contourId = se.contourId;\n\n    // avoid a rounding error. The left event would be processed after the right event\n    if (compareEvents(l, se.otherEvent) > 0) {\n      se.otherEvent.left = true;\n      l.left = false;\n    }\n\n    // avoid a rounding error. The left event would be processed after the right event\n    // if (compareEvents(se, r) > 0) {}\n\n    se.otherEvent.otherEvent = l;\n    se.otherEvent = r;\n\n    queue.push(l);\n    queue.push(r);\n\n    return queue;\n  }\n\n  //const EPS = 1e-9;\n\n  /**\n   * Finds the magnitude of the cross product of two vectors (if we pretend\n   * they're in three dimensions)\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The magnitude of the cross product\n   */\n  function crossProduct(a, b) {\n    return (a[0] * b[1]) - (a[1] * b[0]);\n  }\n\n  /**\n   * Finds the dot product of two vectors.\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The dot product\n   */\n  function dotProduct(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]);\n  }\n\n  /**\n   * Finds the intersection (if any) between two line segments a and b, given the\n   * line segments' end points a1, a2 and b1, b2.\n   *\n   * This algorithm is based on Schneider and Eberly.\n   * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n   * Page 244.\n   *\n   * @param {Array.<Number>} a1 point of first line\n   * @param {Array.<Number>} a2 point of first line\n   * @param {Array.<Number>} b1 point of second line\n   * @param {Array.<Number>} b2 point of second line\n   * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n   *                                         (meaning connected segments) as\n   *                                         intersections\n   * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n   * intersection. If they overlap, the two end points of the overlapping segment.\n   * Otherwise, null.\n   */\n  function intersection (a1, a2, b1, b2, noEndpointTouch) {\n    // The algorithm expects our lines in the form P + sd, where P is a point,\n    // s is on the interval [0, 1], and d is a vector.\n    // We are passed two points. P can be the first point of each pair. The\n    // vector, then, could be thought of as the distance (in x and y components)\n    // from the first point to the second point.\n    // So first, let's make our vectors:\n    var va = [a2[0] - a1[0], a2[1] - a1[1]];\n    var vb = [b2[0] - b1[0], b2[1] - b1[1]];\n    // We also define a function to convert back to regular point form:\n\n    /* eslint-disable arrow-body-style */\n\n    function toPoint(p, s, d) {\n      return [\n        p[0] + s * d[0],\n        p[1] + s * d[1]\n      ];\n    }\n\n    /* eslint-enable arrow-body-style */\n\n    // The rest is pretty much a straight port of the algorithm.\n    var e = [b1[0] - a1[0], b1[1] - a1[1]];\n    var kross    = crossProduct(va, vb);\n    var sqrKross = kross * kross;\n    var sqrLenA  = dotProduct(va, va);\n    //const sqrLenB  = dotProduct(vb, vb);\n\n    // Check for line intersection. This works because of the properties of the\n    // cross product -- specifically, two vectors are parallel if and only if the\n    // cross product is the 0 vector. The full calculation involves relative error\n    // to account for possible very small line segments. See Schneider & Eberly\n    // for details.\n    if (sqrKross > 0/* EPS * sqrLenB * sqLenA */) {\n      // If they're not parallel, then (because these are line segments) they\n      // still might not actually intersect. This code checks that the\n      // intersection point of the lines is actually on both line segments.\n      var s = crossProduct(e, vb) / kross;\n      if (s < 0 || s > 1) {\n        // not on line segment a\n        return null;\n      }\n      var t = crossProduct(e, va) / kross;\n      if (t < 0 || t > 1) {\n        // not on line segment b\n        return null;\n      }\n      if (s === 0 || s === 1) {\n        // on an endpoint of line segment a\n        return noEndpointTouch ? null : [toPoint(a1, s, va)];\n      }\n      if (t === 0 || t === 1) {\n        // on an endpoint of line segment b\n        return noEndpointTouch ? null : [toPoint(b1, t, vb)];\n      }\n      return [toPoint(a1, s, va)];\n    }\n\n    // If we've reached this point, then the lines are either parallel or the\n    // same, but the segments could overlap partially or fully, or not at all.\n    // So we need to find the overlap, if any. To do that, we can use e, which is\n    // the (vector) difference between the two initial points. If this is parallel\n    // with the line itself, then the two lines are the same line, and there will\n    // be overlap.\n    //const sqrLenE = dotProduct(e, e);\n    kross = crossProduct(e, va);\n    sqrKross = kross * kross;\n\n    if (sqrKross > 0 /* EPS * sqLenB * sqLenE */) {\n    // Lines are just parallel, not the same. No overlap.\n      return null;\n    }\n\n    var sa = dotProduct(va, e) / sqrLenA;\n    var sb = sa + dotProduct(va, vb) / sqrLenA;\n    var smin = Math.min(sa, sb);\n    var smax = Math.max(sa, sb);\n\n    // this is, essentially, the FindIntersection acting on floats from\n    // Schneider & Eberly, just inlined into this function.\n    if (smin <= 1 && smax >= 0) {\n\n      // overlap on an end point\n      if (smin === 1) {\n        return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n      }\n\n      if (smax === 0) {\n        return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n      }\n\n      if (noEndpointTouch && smin === 0 && smax === 1) { return null; }\n\n      // There's overlap on a segment -- two points of intersection. Return both.\n      return [\n        toPoint(a1, smin > 0 ? smin : 0, va),\n        toPoint(a1, smax < 1 ? smax : 1, va)\n      ];\n    }\n\n    return null;\n  }\n\n  /**\n   * @param  {SweepEvent} se1\n   * @param  {SweepEvent} se2\n   * @param  {Queue}      queue\n   * @return {Number}\n   */\n  function possibleIntersection (se1, se2, queue) {\n    // that disallows self-intersecting polygons,\n    // did cost us half a day, so I'll leave it\n    // out of respect\n    // if (se1.isSubject === se2.isSubject) return;\n    var inter = intersection(\n      se1.point, se1.otherEvent.point,\n      se2.point, se2.otherEvent.point\n    );\n\n    var nintersections = inter ? inter.length : 0;\n    if (nintersections === 0) { return 0; } // no intersection\n\n    // the line segments intersect at an endpoint of both line segments\n    if ((nintersections === 1) &&\n        (equals(se1.point, se2.point) ||\n         equals(se1.otherEvent.point, se2.otherEvent.point))) {\n      return 0;\n    }\n\n    if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n      // if(se1.contourId === se2.contourId){\n      // console.warn('Edges of the same polygon overlap',\n      //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n      // }\n      //throw new Error('Edges of the same polygon overlap');\n      return 0;\n    }\n\n    // The line segments associated to se1 and se2 intersect\n    if (nintersections === 1) {\n\n      // if the intersection point is not an endpoint of se1\n      if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n        divideSegment(se1, inter[0], queue);\n      }\n\n      // if the intersection point is not an endpoint of se2\n      if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n        divideSegment(se2, inter[0], queue);\n      }\n      return 1;\n    }\n\n    // The line segments associated to se1 and se2 overlap\n    var events        = [];\n    var leftCoincide  = false;\n    var rightCoincide = false;\n\n    if (equals(se1.point, se2.point)) {\n      leftCoincide = true; // linked\n    } else if (compareEvents(se1, se2) === 1) {\n      events.push(se2, se1);\n    } else {\n      events.push(se1, se2);\n    }\n\n    if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n      rightCoincide = true;\n    } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n      events.push(se2.otherEvent, se1.otherEvent);\n    } else {\n      events.push(se1.otherEvent, se2.otherEvent);\n    }\n\n    if ((leftCoincide && rightCoincide) || leftCoincide) {\n      // both line segments are equal or share the left endpoint\n      se2.type = NON_CONTRIBUTING;\n      se1.type = (se2.inOut === se1.inOut)\n        ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n      if (leftCoincide && !rightCoincide) {\n        // honestly no idea, but changing events selection from [2, 1]\n        // to [0, 1] fixes the overlapping self-intersecting polygons issue\n        divideSegment(events[1].otherEvent, events[0].point, queue);\n      }\n      return 2;\n    }\n\n    // the line segments share the right endpoint\n    if (rightCoincide) {\n      divideSegment(events[0], events[1].point, queue);\n      return 3;\n    }\n\n    // no line segment includes totally the other one\n    if (events[0] !== events[3].otherEvent) {\n      divideSegment(events[0], events[1].point, queue);\n      divideSegment(events[1], events[2].point, queue);\n      return 3;\n    }\n\n    // one line segment includes the other one\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[3].otherEvent, events[2].point, queue);\n\n    return 3;\n  }\n\n  /**\n   * @param  {SweepEvent} le1\n   * @param  {SweepEvent} le2\n   * @return {Number}\n   */\n  function compareSegments(le1, le2) {\n    if (le1 === le2) { return 0; }\n\n    // Segments are not collinear\n    if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n      signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n      // If they share their left endpoint use the right endpoint to sort\n      if (equals(le1.point, le2.point)) { return le1.isBelow(le2.otherEvent.point) ? -1 : 1; }\n\n      // Different left endpoint: use the left endpoint to sort\n      if (le1.point[0] === le2.point[0]) { return le1.point[1] < le2.point[1] ? -1 : 1; }\n\n      // has the line segment associated to e1 been inserted\n      // into S after the line segment associated to e2 ?\n      if (compareEvents(le1, le2) === 1) { return le2.isAbove(le1.point) ? -1 : 1; }\n\n      // The line segment associated to e2 has been inserted\n      // into S after the line segment associated to e1\n      return le1.isBelow(le2.point) ? -1 : 1;\n    }\n\n    if (le1.isSubject === le2.isSubject) { // same polygon\n      var p1 = le1.point, p2 = le2.point;\n      if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {\n        p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;\n        if (p1[0] === p2[0] && p1[1] === p2[1]) { return 0; }\n        else { return le1.contourId > le2.contourId ? 1 : -1; }\n      }\n    } else { // Segments are collinear, but belong to separate polygons\n      return le1.isSubject ? -1 : 1;\n    }\n\n    return compareEvents(le1, le2) === 1 ? 1 : -1;\n  }\n\n  function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n    var sweepLine = new SplayTree(compareSegments);\n    var sortedEvents = [];\n\n    var rightbound = Math.min(sbbox[2], cbbox[2]);\n\n    var prev, next, begin;\n\n    while (eventQueue.length !== 0) {\n      var event = eventQueue.pop();\n      sortedEvents.push(event);\n\n      // optimization by bboxes for intersection and difference goes here\n      if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n          (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n        break;\n      }\n\n      if (event.left) {\n        next  = prev = sweepLine.insert(event);\n        begin = sweepLine.minNode();\n\n        if (prev !== begin) { prev = sweepLine.prev(prev); }\n        else                { prev = null; }\n\n        next = sweepLine.next(next);\n\n        var prevEvent = prev ? prev.key : null;\n        var prevprevEvent = (void 0);\n        computeFields(event, prevEvent, operation);\n        if (next) {\n          if (possibleIntersection(event, next.key, eventQueue) === 2) {\n            computeFields(event, prevEvent, operation);\n            computeFields(event, next.key, operation);\n          }\n        }\n\n        if (prev) {\n          if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n            var prevprev = prev;\n            if (prevprev !== begin) { prevprev = sweepLine.prev(prevprev); }\n            else                    { prevprev = null; }\n\n            prevprevEvent = prevprev ? prevprev.key : null;\n            computeFields(prevEvent, prevprevEvent, operation);\n            computeFields(event,     prevEvent,     operation);\n          }\n        }\n      } else {\n        event = event.otherEvent;\n        next = prev = sweepLine.find(event);\n\n        if (prev && next) {\n\n          if (prev !== begin) { prev = sweepLine.prev(prev); }\n          else                { prev = null; }\n\n          next = sweepLine.next(next);\n          sweepLine.remove(event);\n\n          if (next && prev) {\n            possibleIntersection(prev.key, next.key, eventQueue);\n          }\n        }\n      }\n    }\n    return sortedEvents;\n  }\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<SweepEvent>}\n   */\n  function orderEvents(sortedEvents) {\n    var event, i, len, tmp;\n    var resultEvents = [];\n    for (i = 0, len = sortedEvents.length; i < len; i++) {\n      event = sortedEvents[i];\n      if ((event.left && event.inResult) ||\n        (!event.left && event.otherEvent.inResult)) {\n        resultEvents.push(event);\n      }\n    }\n    // Due to overlapping edges the resultEvents array can be not wholly sorted\n    var sorted = false;\n    while (!sorted) {\n      sorted = true;\n      for (i = 0, len = resultEvents.length; i < len; i++) {\n        if ((i + 1) < len &&\n          compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n          tmp = resultEvents[i];\n          resultEvents[i] = resultEvents[i + 1];\n          resultEvents[i + 1] = tmp;\n          sorted = false;\n        }\n      }\n    }\n\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      event.pos = i;\n    }\n\n    // imagine, the right event is found in the beginning of the queue,\n    // when his left counterpart is not marked yet\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      if (!event.left) {\n        tmp = event.pos;\n        event.pos = event.otherEvent.pos;\n        event.otherEvent.pos = tmp;\n      }\n    }\n\n    return resultEvents;\n  }\n\n\n  /**\n   * @param  {Number} pos\n   * @param  {Array.<SweepEvent>} resultEvents\n   * @param  {Object>}    processed\n   * @return {Number}\n   */\n  function nextPos(pos, resultEvents, processed, origIndex) {\n    var p, p1;\n    var newPos = pos + 1;\n    var length = resultEvents.length;\n\n    p  = resultEvents[pos].point;\n\n    if (newPos < length)\n      { p1 = resultEvents[newPos].point; }\n\n\n    // while in range and not the current one by value\n    while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n      if (!processed[newPos]) {\n        return newPos;\n      } else   {\n        newPos++;\n      }\n      p1 = resultEvents[newPos].point;\n    }\n\n    newPos = pos - 1;\n\n    while (processed[newPos] && newPos >= origIndex) {\n      newPos--;\n    }\n    return newPos;\n  }\n\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<*>} polygons\n   */\n  function connectEdges(sortedEvents, operation) {\n    var i, len;\n    var resultEvents = orderEvents(sortedEvents);\n\n    // \"false\"-filled array\n    var processed = {};\n    var result = [];\n    var event;\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if (processed[i]) { continue; }\n      var contour = [[]];\n\n      if (!resultEvents[i].isExteriorRing) {\n        if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\n          result.push(contour);\n        } else if (result.length === 0) {\n          result.push([[contour]]);\n        } else {\n          result[result.length - 1].push(contour[0]);\n        }\n      } else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\n        result[result.length - 1].push(contour[0]);\n      } else {\n        result.push(contour);\n      }\n\n      var ringId = result.length - 1;\n      var pos = i;\n\n      var initial = resultEvents[i].point;\n      contour[0].push(initial);\n\n      while (pos >= i) {\n        event = resultEvents[pos];\n        processed[pos] = true;\n\n        if (event.left) {\n          event.resultInOut = false;\n          event.contourId   = ringId;\n        } else {\n          event.otherEvent.resultInOut = true;\n          event.otherEvent.contourId   = ringId;\n        }\n\n        pos = event.pos;\n        processed[pos] = true;\n        contour[0].push(resultEvents[pos].point);\n        pos = nextPos(pos, resultEvents, processed, i);\n      }\n\n      pos = pos === -1 ? i : pos;\n\n      event = resultEvents[pos];\n      processed[pos] = processed[event.pos] = true;\n      event.otherEvent.resultInOut = true;\n      event.otherEvent.contourId   = ringId;\n    }\n\n    // Handle if the result is a polygon (eg not multipoly)\n    // Commented it again, let's see what do we mean by that\n    // if (result.length === 1) result = result[0];\n    return result;\n  }\n\n  var tinyqueue = TinyQueue;\n  var default_1 = TinyQueue;\n\n  function TinyQueue(data, compare) {\n      var this$1 = this;\n\n      if (!(this instanceof TinyQueue)) { return new TinyQueue(data, compare); }\n\n      this.data = data || [];\n      this.length = this.data.length;\n      this.compare = compare || defaultCompare;\n\n      if (this.length > 0) {\n          for (var i = (this.length >> 1) - 1; i >= 0; i--) { this$1._down(i); }\n      }\n  }\n\n  function defaultCompare(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  TinyQueue.prototype = {\n\n      push: function (item) {\n          this.data.push(item);\n          this.length++;\n          this._up(this.length - 1);\n      },\n\n      pop: function () {\n          if (this.length === 0) { return undefined; }\n\n          var top = this.data[0];\n          this.length--;\n\n          if (this.length > 0) {\n              this.data[0] = this.data[this.length];\n              this._down(0);\n          }\n          this.data.pop();\n\n          return top;\n      },\n\n      peek: function () {\n          return this.data[0];\n      },\n\n      _up: function (pos) {\n          var data = this.data;\n          var compare = this.compare;\n          var item = data[pos];\n\n          while (pos > 0) {\n              var parent = (pos - 1) >> 1;\n              var current = data[parent];\n              if (compare(item, current) >= 0) { break; }\n              data[pos] = current;\n              pos = parent;\n          }\n\n          data[pos] = item;\n      },\n\n      _down: function (pos) {\n          var this$1 = this;\n\n          var data = this.data;\n          var compare = this.compare;\n          var halfLength = this.length >> 1;\n          var item = data[pos];\n\n          while (pos < halfLength) {\n              var left = (pos << 1) + 1;\n              var right = left + 1;\n              var best = data[left];\n\n              if (right < this$1.length && compare(data[right], best) < 0) {\n                  left = right;\n                  best = data[right];\n              }\n              if (compare(best, item) >= 0) { break; }\n\n              data[pos] = best;\n              pos = left;\n          }\n\n          data[pos] = item;\n      }\n  };\n  tinyqueue.default = default_1;\n\n  var max = Math.max;\n  var min = Math.min;\n\n  var contourId = 0;\n\n\n  function processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n    var i, len, s1, s2, e1, e2;\n    for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n      s1 = contourOrHole[i];\n      s2 = contourOrHole[i + 1];\n      e1 = new SweepEvent(s1, false, undefined, isSubject);\n      e2 = new SweepEvent(s2, false, e1,        isSubject);\n      e1.otherEvent = e2;\n\n      if (s1[0] === s2[0] && s1[1] === s2[1]) {\n        continue; // skip collapsed edges, or it breaks\n      }\n\n      e1.contourId = e2.contourId = depth;\n      if (!isExteriorRing) {\n        e1.isExteriorRing = false;\n        e2.isExteriorRing = false;\n      }\n      if (compareEvents(e1, e2) > 0) {\n        e2.left = true;\n      } else {\n        e1.left = true;\n      }\n\n      var x = s1[0], y = s1[1];\n      bbox[0] = min(bbox[0], x);\n      bbox[1] = min(bbox[1], y);\n      bbox[2] = max(bbox[2], x);\n      bbox[3] = max(bbox[3], y);\n\n      // Pushing it so the queue is sorted from left to right,\n      // with object on the left having the highest priority.\n      Q.push(e1);\n      Q.push(e2);\n    }\n  }\n\n\n  function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n    var eventQueue = new tinyqueue(null, compareEvents);\n    var polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n    for (i = 0, ii = subject.length; i < ii; i++) {\n      polygonSet = subject[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n      }\n    }\n\n    for (i = 0, ii = clipping.length; i < ii; i++) {\n      polygonSet = clipping[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (operation === DIFFERENCE) { isExteriorRing = false; }\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n      }\n    }\n\n    return eventQueue;\n  }\n\n  var EMPTY = [];\n\n\n  function trivialOperation(subject, clipping, operation) {\n    var result = null;\n    if (subject.length * clipping.length === 0) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = (subject.length === 0) ? clipping : subject;\n      }\n    }\n    return result;\n  }\n\n\n  function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n    var result = null;\n    if (sbbox[0] > cbbox[2] ||\n        cbbox[0] > sbbox[2] ||\n        sbbox[1] > cbbox[3] ||\n        cbbox[1] > sbbox[3]) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = subject.concat(clipping);\n      }\n    }\n    return result;\n  }\n\n\n  function boolean(subject, clipping, operation) {\n    if (typeof subject[0][0][0] === 'number') {\n      subject = [subject];\n    }\n    if (typeof clipping[0][0][0] === 'number') {\n      clipping = [clipping];\n    }\n    var trivial = trivialOperation(subject, clipping, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n    var cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n    //console.time('fill queue');\n    var eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('fill queue');\n\n    trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    //console.time('subdivide edges');\n    var sortedEvents = subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('subdivide edges');\n\n    //console.time('connect vertices');\n    var result = connectEdges(sortedEvents, operation);\n    //console.timeEnd('connect vertices');\n    return result;\n  }\n\n  function union (subject, clipping) {\n    return boolean(subject, clipping, UNION);\n  }\n\n  function diff (subject, clipping) {\n    return boolean(subject, clipping, DIFFERENCE);\n  }\n\n  function xor (subject, clipping){\n    return boolean(subject, clipping, XOR);\n  }\n\n  function intersection$1 (subject, clipping) {\n    return boolean(subject, clipping, INTERSECTION);\n  }\n\n  /**\n   * @enum {Number}\n   */\n  var operations = { UNION: UNION, DIFFERENCE: DIFFERENCE, INTERSECTION: INTERSECTION, XOR: XOR };\n\n  exports.union = union;\n  exports.diff = diff;\n  exports.xor = xor;\n  exports.intersection = intersection$1;\n  exports.operations = operations;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=martinez.umd.js.map\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/martinez-polygon-clipping/dist/martinez.umd.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/path-browserify/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/path-browserify/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Mapillary/./node_modules/node-libs-browser/node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/process/browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/process/browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/node-libs-browser/node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/pbf/index.js":
/*!***********************************!*\
  !*** ./node_modules/pbf/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = Pbf;\n\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\n\nfunction Pbf(buf) {\n    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);\n    this.pos = 0;\n    this.type = 0;\n    this.length = this.buf.length;\n}\n\nPbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nPbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64\nPbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nPbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16),\n    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\nPbf.prototype = {\n\n    destroy: function() {\n        this.buf = null;\n    },\n\n    // === READING =================================================================\n\n    readFields: function(readField, result, end) {\n        end = end || this.length;\n\n        while (this.pos < end) {\n            var val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            this.type = val & 0x7;\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    },\n\n    readMessage: function(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    },\n\n    readFixed32: function() {\n        var val = readUInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    readSFixed32: function() {\n        var val = readInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readSFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readFloat: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 23, 4);\n        this.pos += 4;\n        return val;\n    },\n\n    readDouble: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 52, 8);\n        this.pos += 8;\n        return val;\n    },\n\n    readVarint: function(isSigned) {\n        var buf = this.buf,\n            val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n        b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n        return readVarintRemainder(val, isSigned, this);\n    },\n\n    readVarint64: function() { // for compatibility with v2.0.1\n        return this.readVarint(true);\n    },\n\n    readSVarint: function() {\n        var num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    },\n\n    readBoolean: function() {\n        return Boolean(this.readVarint());\n    },\n\n    readString: function() {\n        var end = this.readVarint() + this.pos,\n            str = readUtf8(this.buf, this.pos, end);\n        this.pos = end;\n        return str;\n    },\n\n    readBytes: function() {\n        var end = this.readVarint() + this.pos,\n            buffer = this.buf.subarray(this.pos, end);\n        this.pos = end;\n        return buffer;\n    },\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    readPackedVarint: function(arr, isSigned) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readVarint(isSigned));\n        return arr;\n    },\n    readPackedSVarint: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    },\n    readPackedBoolean: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    },\n    readPackedFloat: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    },\n    readPackedDouble: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    },\n    readPackedFixed32: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    },\n    readPackedSFixed32: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    },\n    readPackedFixed64: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    },\n    readPackedSFixed64: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    },\n\n    skip: function(val) {\n        var type = val & 0x7;\n        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n        else if (type === Pbf.Fixed32) this.pos += 4;\n        else if (type === Pbf.Fixed64) this.pos += 8;\n        else throw new Error('Unimplemented type: ' + type);\n    },\n\n    // === WRITING =================================================================\n\n    writeTag: function(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    },\n\n    realloc: function(min) {\n        var length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            var buf = new Uint8Array(length);\n            buf.set(this.buf);\n            this.buf = buf;\n            this.length = length;\n        }\n    },\n\n    finish: function() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.subarray(0, this.length);\n    },\n\n    writeFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeSFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeSFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeVarint: function(val) {\n        val = +val || 0;\n\n        if (val > 0xfffffff || val < 0) {\n            writeBigVarint(val, this);\n            return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n    },\n\n    writeSVarint: function(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    },\n\n    writeBoolean: function(val) {\n        this.writeVarint(Boolean(val));\n    },\n\n    writeString: function(str) {\n        str = String(str);\n        this.realloc(str.length * 4);\n\n        this.pos++; // reserve 1 byte for short string length\n\n        var startPos = this.pos;\n        // write the string directly to the buffer and see how much was written\n        this.pos = writeUtf8(this.buf, str, this.pos);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeFloat: function(val) {\n        this.realloc(4);\n        ieee754.write(this.buf, val, this.pos, true, 23, 4);\n        this.pos += 4;\n    },\n\n    writeDouble: function(val) {\n        this.realloc(8);\n        ieee754.write(this.buf, val, this.pos, true, 52, 8);\n        this.pos += 8;\n    },\n\n    writeBytes: function(buffer) {\n        var len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    },\n\n    writeRawMessage: function(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        var startPos = this.pos;\n        fn(obj, this);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeMessage: function(tag, fn, obj) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeRawMessage(fn, obj);\n    },\n\n    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },\n    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },\n    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },\n    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },\n    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },\n    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },\n    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },\n    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },\n    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },\n\n    writeBytesField: function(tag, buffer) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeBytes(buffer);\n    },\n    writeFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFixed32(val);\n    },\n    writeSFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeSFixed32(val);\n    },\n    writeFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeFixed64(val);\n    },\n    writeSFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeSFixed64(val);\n    },\n    writeVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeVarint(val);\n    },\n    writeSVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeSVarint(val);\n    },\n    writeStringField: function(tag, str) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeString(str);\n    },\n    writeFloatField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFloat(val);\n    },\n    writeDoubleField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeDouble(val);\n    },\n    writeBooleanField: function(tag, val) {\n        this.writeVarintField(tag, Boolean(val));\n    }\n};\n\nfunction readVarintRemainder(l, s, p) {\n    var buf = p.buf,\n        h, b;\n\n    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n    throw new Error('Expected varint not more than 10 bytes');\n}\n\nfunction readPackedEnd(pbf) {\n    return pbf.type === Pbf.Bytes ?\n        pbf.readVarint() + pbf.pos : pbf.pos + 1;\n}\n\nfunction toNum(low, high, isSigned) {\n    if (isSigned) {\n        return high * 0x100000000 + (low >>> 0);\n    }\n\n    return ((high >>> 0) * 0x100000000) + (low >>> 0);\n}\n\nfunction writeBigVarint(val, pbf) {\n    var low, high;\n\n    if (val >= 0) {\n        low  = (val % 0x100000000) | 0;\n        high = (val / 0x100000000) | 0;\n    } else {\n        low  = ~(-val % 0x100000000);\n        high = ~(-val / 0x100000000);\n\n        if (low ^ 0xffffffff) {\n            low = (low + 1) | 0;\n        } else {\n            low = 0;\n            high = (high + 1) | 0;\n        }\n    }\n\n    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n        throw new Error('Given varint doesn\\'t fit into 10 bytes');\n    }\n\n    pbf.realloc(10);\n\n    writeBigVarintLow(low, high, pbf);\n    writeBigVarintHigh(high, pbf);\n}\n\nfunction writeBigVarintLow(low, high, pbf) {\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos]   = low & 0x7f;\n}\n\nfunction writeBigVarintHigh(high, pbf) {\n    var lsb = (high & 0x07) << 4;\n\n    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f;\n}\n\nfunction makeRoomForExtraLength(startPos, len, pbf) {\n    var extraLen =\n        len <= 0x3fff ? 1 :\n        len <= 0x1fffff ? 2 :\n        len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));\n\n    // if 1 byte isn't enough for encoding message length, shift the data to the right\n    pbf.realloc(extraLen);\n    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n}\n\nfunction writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\nfunction writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\nfunction writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\nfunction writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\nfunction writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\nfunction writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\nfunction writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\nfunction writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\nfunction writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n\n// Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\nfunction readUInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] * 0x1000000);\n}\n\nfunction writeInt32(buf, val, pos) {\n    buf[pos] = val;\n    buf[pos + 1] = (val >>> 8);\n    buf[pos + 2] = (val >>> 16);\n    buf[pos + 3] = (val >>> 24);\n}\n\nfunction readInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] << 24);\n}\n\nfunction readUtf8(buf, pos, end) {\n    var str = '';\n    var i = pos;\n\n    while (i < end) {\n        var b0 = buf[i];\n        var c = null; // codepoint\n        var bytesPerSequence =\n            b0 > 0xEF ? 4 :\n            b0 > 0xDF ? 3 :\n            b0 > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        var b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xC0) === 0x80) {\n                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                if (c <= 0x7F) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                if (c <= 0xFFFF || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xFFFD;\n            bytesPerSequence = 1;\n\n        } else if (c > 0xFFFF) {\n            c -= 0x10000;\n            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n            c = 0xDC00 | c & 0x3FF;\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\nfunction writeUtf8(buf, str, pos) {\n    for (var i = 0, c, lead; i < str.length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n            if (lead) {\n                if (c < 0xDC00) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                    lead = c;\n                    continue;\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n            } else {\n                if (c > 0xDBFF || (i + 1 === str.length)) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                } else {\n                    lead = c;\n                }\n                continue;\n            }\n        } else if (lead) {\n            buf[pos++] = 0xEF;\n            buf[pos++] = 0xBF;\n            buf[pos++] = 0xBD;\n            lead = null;\n        }\n\n        if (c < 0x80) {\n            buf[pos++] = c;\n        } else {\n            if (c < 0x800) {\n                buf[pos++] = c >> 0x6 | 0xC0;\n            } else {\n                if (c < 0x10000) {\n                    buf[pos++] = c >> 0xC | 0xE0;\n                } else {\n                    buf[pos++] = c >> 0x12 | 0xF0;\n                    buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                }\n                buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n            }\n            buf[pos++] = c & 0x3F | 0x80;\n        }\n    }\n    return pos;\n}\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/pbf/index.js?");

/***/ }),

/***/ "./node_modules/quickselect/quickselect.js":
/*!*************************************************!*\
  !*** ./node_modules/quickselect/quickselect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/quickselect/quickselect.js?");

/***/ }),

/***/ "./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = __webpack_require__(/*! quickselect */ \"./node_modules/quickselect/quickselect.js\");\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/rbush/index.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/index.js":
/*!******************************************!*\
  !*** ./node_modules/rxjs/_esm5/index.js ***!
  \******************************************/
/*! exports provided: Observable, ConnectableObservable, GroupedObservable, observable, Subject, BehaviorSubject, ReplaySubject, AsyncSubject, asapScheduler, asyncScheduler, queueScheduler, animationFrameScheduler, VirtualTimeScheduler, VirtualAction, Scheduler, Subscription, Subscriber, Notification, pipe, noop, identity, isObservable, ArgumentOutOfRangeError, EmptyError, ObjectUnsubscribedError, UnsubscriptionError, TimeoutError, bindCallback, bindNodeCallback, combineLatest, concat, defer, empty, forkJoin, from, fromEvent, fromEventPattern, generate, iif, interval, merge, never, of, onErrorResumeNext, pairs, race, range, throwError, timer, using, zip, EMPTY, NEVER, config */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/Observable'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/Observable'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/ConnectableObservable'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/ConnectableObservable'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/operators/groupBy'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/operators/groupBy'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/symbol/observable'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/symbol/observable'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/Subject'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/Subject'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/BehaviorSubject'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/BehaviorSubject'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/ReplaySubject'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/ReplaySubject'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/AsyncSubject'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/AsyncSubject'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/scheduler/asap'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/scheduler/asap'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/scheduler/async'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/scheduler/async'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/scheduler/queue'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/scheduler/queue'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/scheduler/animationFrame'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/scheduler/animationFrame'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/scheduler/VirtualTimeScheduler'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/scheduler/VirtualTimeScheduler'\");\nthrow new Error(\"Cannot find module './internal/scheduler/VirtualTimeScheduler'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/Scheduler'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/Scheduler'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/Subscription'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/Subscription'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/Subscriber'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/Subscriber'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/Notification'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/Notification'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/util/pipe'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/util/pipe'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/util/noop'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/util/noop'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/util/identity'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/util/identity'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/util/isObservable'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/util/isObservable'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/util/ArgumentOutOfRangeError'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/util/ArgumentOutOfRangeError'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/util/EmptyError'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/util/EmptyError'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/util/ObjectUnsubscribedError'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/util/ObjectUnsubscribedError'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/util/UnsubscriptionError'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/util/UnsubscriptionError'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/util/TimeoutError'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/util/TimeoutError'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/bindCallback'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/bindCallback'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/bindNodeCallback'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/bindNodeCallback'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/combineLatest'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/combineLatest'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/concat'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/concat'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/defer'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/defer'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/empty'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/empty'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/forkJoin'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/forkJoin'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/from'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/from'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/fromEvent'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/fromEvent'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/fromEventPattern'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/fromEventPattern'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/generate'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/generate'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/iif'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/iif'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/interval'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/interval'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/merge'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/merge'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/never'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/never'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/of'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/of'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/onErrorResumeNext'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/onErrorResumeNext'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/pairs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/pairs'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/race'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/race'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/range'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/range'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/throwError'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/throwError'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/timer'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/timer'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/using'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/using'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/observable/zip'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/observable/zip'\");\nthrow new Error(\"Cannot find module './internal/observable/empty'\");\nthrow new Error(\"Cannot find module './internal/observable/never'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './internal/config'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module './internal/config'\");\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/rxjs/_esm5/index.js?");

/***/ }),

/***/ "./node_modules/rxjs/_esm5/operators/index.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/_esm5/operators/index.js ***!
  \****************************************************/
/*! exports provided: audit, auditTime, buffer, bufferCount, bufferTime, bufferToggle, bufferWhen, catchError, combineAll, combineLatest, concat, concatAll, concatMap, concatMapTo, count, debounce, debounceTime, defaultIfEmpty, delay, delayWhen, dematerialize, distinct, distinctUntilChanged, distinctUntilKeyChanged, elementAt, endWith, every, exhaust, exhaustMap, expand, filter, finalize, find, findIndex, first, groupBy, ignoreElements, isEmpty, last, map, mapTo, materialize, max, merge, mergeAll, mergeMap, flatMap, mergeMapTo, mergeScan, min, multicast, observeOn, onErrorResumeNext, pairwise, partition, pluck, publish, publishBehavior, publishLast, publishReplay, race, reduce, repeat, repeatWhen, retry, retryWhen, refCount, sample, sampleTime, scan, sequenceEqual, share, shareReplay, single, skip, skipLast, skipUntil, skipWhile, startWith, subscribeOn, switchAll, switchMap, switchMapTo, take, takeLast, takeUntil, takeWhile, tap, throttle, throttleTime, throwIfEmpty, timeInterval, timeout, timeoutWith, timestamp, toArray, window, windowCount, windowTime, windowToggle, windowWhen, withLatestFrom, zip, zipAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/audit'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/audit'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/auditTime'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/auditTime'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/buffer'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/buffer'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/bufferCount'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/bufferCount'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/bufferTime'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/bufferTime'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/bufferToggle'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/bufferToggle'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/bufferWhen'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/bufferWhen'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/catchError'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/catchError'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/combineAll'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/combineAll'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/combineLatest'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/combineLatest'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/concat'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/concat'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/concatAll'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/concatAll'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/concatMap'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/concatMap'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/concatMapTo'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/concatMapTo'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/count'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/count'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/debounce'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/debounce'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/debounceTime'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/debounceTime'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/defaultIfEmpty'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/defaultIfEmpty'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/delay'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/delay'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/delayWhen'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/delayWhen'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/dematerialize'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/dematerialize'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/distinct'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/distinct'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/distinctUntilChanged'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/distinctUntilChanged'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/distinctUntilKeyChanged'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/distinctUntilKeyChanged'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/elementAt'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/elementAt'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/endWith'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/endWith'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/every'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/every'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/exhaust'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/exhaust'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/exhaustMap'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/exhaustMap'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/expand'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/expand'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/filter'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/filter'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/finalize'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/finalize'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/find'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/find'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/findIndex'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/findIndex'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/first'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/first'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/groupBy'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/groupBy'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/ignoreElements'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/ignoreElements'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/isEmpty'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/isEmpty'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/last'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/last'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/map'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/map'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/mapTo'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/mapTo'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/materialize'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/materialize'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/max'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/max'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/merge'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/merge'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/mergeAll'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/mergeAll'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/mergeMap'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/mergeMap'\");\nthrow new Error(\"Cannot find module '../internal/operators/mergeMap'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/mergeMapTo'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/mergeMapTo'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/mergeScan'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/mergeScan'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/min'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/min'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/multicast'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/multicast'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/observeOn'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/observeOn'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/onErrorResumeNext'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/onErrorResumeNext'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/pairwise'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/pairwise'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/partition'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/partition'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/pluck'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/pluck'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/publish'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/publish'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/publishBehavior'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/publishBehavior'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/publishLast'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/publishLast'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/publishReplay'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/publishReplay'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/race'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/race'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/reduce'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/reduce'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/repeat'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/repeat'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/repeatWhen'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/repeatWhen'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/retry'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/retry'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/retryWhen'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/retryWhen'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/refCount'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/refCount'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/sample'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/sample'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/sampleTime'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/sampleTime'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/scan'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/scan'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/sequenceEqual'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/sequenceEqual'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/share'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/share'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/shareReplay'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/shareReplay'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/single'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/single'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/skip'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/skip'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/skipLast'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/skipLast'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/skipUntil'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/skipUntil'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/skipWhile'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/skipWhile'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/startWith'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/startWith'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/subscribeOn'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/subscribeOn'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/switchAll'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/switchAll'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/switchMap'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/switchMap'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/switchMapTo'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/switchMapTo'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/take'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/take'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/takeLast'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/takeLast'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/takeUntil'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/takeUntil'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/takeWhile'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/takeWhile'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/tap'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/tap'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/throttle'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/throttle'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/throttleTime'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/throttleTime'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/throwIfEmpty'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/throwIfEmpty'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/timeInterval'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/timeInterval'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/timeout'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/timeout'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/timeoutWith'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/timeoutWith'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/timestamp'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/timestamp'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/toArray'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/toArray'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/window'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/window'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/windowCount'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/windowCount'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/windowTime'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/windowTime'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/windowToggle'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/windowToggle'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/windowWhen'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/windowWhen'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/withLatestFrom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/withLatestFrom'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/zip'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/zip'\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../internal/operators/zipAll'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nthrow new Error(\"Cannot find module '../internal/operators/zipAll'\");\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/rxjs/_esm5/operators/index.js?");

/***/ }),

/***/ "./node_modules/three/build/three.min.js":
/*!***********************************************!*\
  !*** ./node_modules/three/build/three.min.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// threejs.org/license\n(function(l,ya){ true?ya(exports):undefined})(this,function(l){function ya(){}function z(a,b){this.x=a||0;this.y=b||0}function I(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];0<arguments.length&&console.error(\"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.\")}function fa(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._w=void 0!==d?d:1}function p(a,\nb,c){this.x=a||0;this.y=b||0;this.z=c||0}function ra(){this.elements=[1,0,0,0,1,0,0,0,1];0<arguments.length&&console.error(\"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.\")}function T(a,b,c,d,e,f,g,h,k,m){Object.defineProperty(this,\"id\",{value:Ef++});this.uuid=H.generateUUID();this.name=\"\";this.image=void 0!==a?a:T.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=void 0!==b?b:T.DEFAULT_MAPPING;this.wrapS=void 0!==c?c:1001;this.wrapT=void 0!==d?d:1001;this.magFilter=void 0!==\ne?e:1006;this.minFilter=void 0!==f?f:1008;this.anisotropy=void 0!==k?k:1;this.format=void 0!==g?g:1023;this.type=void 0!==h?h:1009;this.offset=new z(0,0);this.repeat=new z(1,1);this.center=new z(0,0);this.rotation=0;this.matrixAutoUpdate=!0;this.matrix=new ra;this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this.encoding=void 0!==m?m:3E3;this.version=0;this.onUpdate=null}function V(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1}function fb(a,\nb,c){this.width=a;this.height=b;this.scissor=new V(0,0,a,b);this.scissorTest=!1;this.viewport=new V(0,0,a,b);c=c||{};void 0===c.minFilter&&(c.minFilter=1006);this.texture=new T(void 0,void 0,c.wrapS,c.wrapT,c.magFilter,c.minFilter,c.format,c.type,c.anisotropy,c.encoding);this.texture.generateMipmaps=void 0!==c.generateMipmaps?c.generateMipmaps:!0;this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:!0;this.depthTexture=void 0!==c.depthTexture?\nc.depthTexture:null}function Gb(a,b,c){fb.call(this,a,b,c);this.activeMipMapLevel=this.activeCubeFace=0}function gb(a,b,c,d,e,f,g,h,k,m,q,n){T.call(this,null,f,g,h,k,m,d,e,q,n);this.image={data:a,width:b,height:c};this.magFilter=void 0!==k?k:1003;this.minFilter=void 0!==m?m:1003;this.flipY=this.generateMipmaps=!1;this.unpackAlignment=1}function Sa(a,b){this.min=void 0!==a?a:new p(Infinity,Infinity,Infinity);this.max=void 0!==b?b:new p(-Infinity,-Infinity,-Infinity)}function Da(a,b){this.center=void 0!==\na?a:new p;this.radius=void 0!==b?b:0}function Ma(a,b){this.normal=void 0!==a?a:new p(1,0,0);this.constant=void 0!==b?b:0}function md(a,b,c,d,e,f){this.planes=[void 0!==a?a:new Ma,void 0!==b?b:new Ma,void 0!==c?c:new Ma,void 0!==d?d:new Ma,void 0!==e?e:new Ma,void 0!==f?f:new Ma]}function G(a,b,c){return void 0===b&&void 0===c?this.set(a):this.setRGB(a,b,c)}function Qd(){function a(e,f){!1!==c&&(d(e,f),b.requestAnimationFrame(a))}var b=null,c=!1,d=null;return{start:function(){!0!==c&&null!==d&&(b.requestAnimationFrame(a),\nc=!0)},stop:function(){c=!1},setAnimationLoop:function(a){d=a},setContext:function(a){b=a}}}function Ff(a){function b(b,c){var d=b.array,e=b.dynamic?a.DYNAMIC_DRAW:a.STATIC_DRAW,h=a.createBuffer();a.bindBuffer(c,h);a.bufferData(c,d,e);b.onUploadCallback();c=a.FLOAT;d instanceof Float32Array?c=a.FLOAT:d instanceof Float64Array?console.warn(\"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.\"):d instanceof Uint16Array?c=a.UNSIGNED_SHORT:d instanceof Int16Array?c=a.SHORT:d instanceof\nUint32Array?c=a.UNSIGNED_INT:d instanceof Int32Array?c=a.INT:d instanceof Int8Array?c=a.BYTE:d instanceof Uint8Array&&(c=a.UNSIGNED_BYTE);return{buffer:h,type:c,bytesPerElement:d.BYTES_PER_ELEMENT,version:b.version}}var c=new WeakMap;return{get:function(a){a.isInterleavedBufferAttribute&&(a=a.data);return c.get(a)},remove:function(b){b.isInterleavedBufferAttribute&&(b=b.data);var d=c.get(b);d&&(a.deleteBuffer(d.buffer),c.delete(b))},update:function(d,e){d.isInterleavedBufferAttribute&&(d=d.data);\nvar f=c.get(d);if(void 0===f)c.set(d,b(d,e));else if(f.version<d.version){var g=d,h=g.array,k=g.updateRange;a.bindBuffer(e,f.buffer);!1===g.dynamic?a.bufferData(e,h,a.STATIC_DRAW):-1===k.count?a.bufferSubData(e,0,h):0===k.count?console.error(\"THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.\"):(a.bufferSubData(e,k.offset*h.BYTES_PER_ELEMENT,h.subarray(k.offset,k.offset+k.count)),k.count=\n-1);f.version=d.version}}}}function hb(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._order=d||hb.DefaultOrder}function Rd(){this.mask=1}function D(){Object.defineProperty(this,\"id\",{value:Gf++});this.uuid=H.generateUUID();this.name=\"\";this.type=\"Object3D\";this.parent=null;this.children=[];this.up=D.DefaultUp.clone();var a=new p,b=new hb,c=new fa,d=new p(1,1,1);b.onChange(function(){c.setFromEuler(b,!1)});c.onChange(function(){b.setFromQuaternion(c,void 0,!1)});Object.defineProperties(this,\n{position:{enumerable:!0,value:a},rotation:{enumerable:!0,value:b},quaternion:{enumerable:!0,value:c},scale:{enumerable:!0,value:d},modelViewMatrix:{value:new I},normalMatrix:{value:new ra}});this.matrix=new I;this.matrixWorld=new I;this.matrixAutoUpdate=D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=!1;this.layers=new Rd;this.visible=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=!0;this.renderOrder=0;this.userData={}}function Na(){D.call(this);this.type=\"Camera\";this.matrixWorldInverse=\nnew I;this.projectionMatrix=new I}function Hb(a,b,c,d,e,f){Na.call(this);this.type=\"OrthographicCamera\";this.zoom=1;this.view=null;this.left=a;this.right=b;this.top=c;this.bottom=d;this.near=void 0!==e?e:.1;this.far=void 0!==f?f:2E3;this.updateProjectionMatrix()}function Ta(a,b,c,d,e,f){this.a=a;this.b=b;this.c=c;this.normal=d&&d.isVector3?d:new p;this.vertexNormals=Array.isArray(d)?d:[];this.color=e&&e.isColor?e:new G;this.vertexColors=Array.isArray(e)?e:[];this.materialIndex=void 0!==f?f:0}function R(){Object.defineProperty(this,\n\"id\",{value:Hf+=2});this.uuid=H.generateUUID();this.name=\"\";this.type=\"Geometry\";this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.groupsNeedUpdate=this.lineDistancesNeedUpdate=this.colorsNeedUpdate=this.normalsNeedUpdate=this.uvsNeedUpdate=this.verticesNeedUpdate=this.elementsNeedUpdate=!1}function Q(a,b,c){if(Array.isArray(a))throw new TypeError(\"THREE.BufferAttribute: array should be a Typed Array.\");\nthis.name=\"\";this.array=a;this.itemSize=b;this.count=void 0!==a?a.length/b:0;this.normalized=!0===c;this.dynamic=!1;this.updateRange={offset:0,count:-1};this.version=0}function oc(a,b,c){Q.call(this,new Int8Array(a),b,c)}function pc(a,b,c){Q.call(this,new Uint8Array(a),b,c)}function qc(a,b,c){Q.call(this,new Uint8ClampedArray(a),b,c)}function rc(a,b,c){Q.call(this,new Int16Array(a),b,c)}function ib(a,b,c){Q.call(this,new Uint16Array(a),b,c)}function sc(a,b,c){Q.call(this,new Int32Array(a),b,c)}function jb(a,\nb,c){Q.call(this,new Uint32Array(a),b,c)}function A(a,b,c){Q.call(this,new Float32Array(a),b,c)}function tc(a,b,c){Q.call(this,new Float64Array(a),b,c)}function Ee(){this.vertices=[];this.normals=[];this.colors=[];this.uvs=[];this.uvs2=[];this.groups=[];this.morphTargets={};this.skinWeights=[];this.skinIndices=[];this.boundingSphere=this.boundingBox=null;this.groupsNeedUpdate=this.uvsNeedUpdate=this.colorsNeedUpdate=this.normalsNeedUpdate=this.verticesNeedUpdate=!1}function Fe(a){if(0===a.length)return-Infinity;\nfor(var b=a[0],c=1,d=a.length;c<d;++c)a[c]>b&&(b=a[c]);return b}function C(){Object.defineProperty(this,\"id\",{value:If+=2});this.uuid=H.generateUUID();this.name=\"\";this.type=\"BufferGeometry\";this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingSphere=this.boundingBox=null;this.drawRange={start:0,count:Infinity};this.userData={}}function Ib(a,b,c,d,e,f){R.call(this);this.type=\"BoxGeometry\";this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,\ndepthSegments:f};this.fromBufferGeometry(new kb(a,b,c,d,e,f));this.mergeVertices()}function kb(a,b,c,d,e,f){function g(a,b,c,d,e,f,g,l,N,O,Jf){var r=f/N,v=g/O,P=f/2,y=g/2,w=l/2;g=N+1;var E=O+1,x=f=0,B,z,A=new p;for(z=0;z<E;z++){var D=z*v-y;for(B=0;B<g;B++)A[a]=(B*r-P)*d,A[b]=D*e,A[c]=w,m.push(A.x,A.y,A.z),A[a]=0,A[b]=0,A[c]=0<l?1:-1,q.push(A.x,A.y,A.z),n.push(B/N),n.push(1-z/O),f+=1}for(z=0;z<O;z++)for(B=0;B<N;B++)a=t+B+g*(z+1),b=t+(B+1)+g*(z+1),c=t+(B+1)+g*z,k.push(t+B+g*z,a,c),k.push(a,b,c),x+=\n6;h.addGroup(u,x,Jf);u+=x;t+=f}C.call(this);this.type=\"BoxBufferGeometry\";this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,depthSegments:f};var h=this;a=a||1;b=b||1;c=c||1;d=Math.floor(d)||1;e=Math.floor(e)||1;f=Math.floor(f)||1;var k=[],m=[],q=[],n=[],t=0,u=0;g(\"z\",\"y\",\"x\",-1,-1,c,b,a,f,e,0);g(\"z\",\"y\",\"x\",1,-1,c,b,-a,f,e,1);g(\"x\",\"z\",\"y\",1,1,a,c,b,d,f,2);g(\"x\",\"z\",\"y\",1,-1,a,c,-b,d,f,3);g(\"x\",\"y\",\"z\",1,-1,a,b,c,d,e,4);g(\"x\",\"y\",\"z\",-1,-1,a,b,-c,d,e,5);this.setIndex(k);this.addAttribute(\"position\",\nnew A(m,3));this.addAttribute(\"normal\",new A(q,3));this.addAttribute(\"uv\",new A(n,2))}function uc(a,b,c,d){R.call(this);this.type=\"PlaneGeometry\";this.parameters={width:a,height:b,widthSegments:c,heightSegments:d};this.fromBufferGeometry(new lb(a,b,c,d));this.mergeVertices()}function lb(a,b,c,d){C.call(this);this.type=\"PlaneBufferGeometry\";this.parameters={width:a,height:b,widthSegments:c,heightSegments:d};a=a||1;b=b||1;var e=a/2,f=b/2;c=Math.floor(c)||1;d=Math.floor(d)||1;var g=c+1,h=d+1,k=a/c,m=\nb/d,q=[],n=[],t=[],u=[];for(a=0;a<h;a++){var r=a*m-f;for(b=0;b<g;b++)n.push(b*k-e,-r,0),t.push(0,0,1),u.push(b/c),u.push(1-a/d)}for(a=0;a<d;a++)for(b=0;b<c;b++)e=b+g*(a+1),f=b+1+g*(a+1),h=b+1+g*a,q.push(b+g*a,e,h),q.push(e,f,h);this.setIndex(q);this.addAttribute(\"position\",new A(n,3));this.addAttribute(\"normal\",new A(t,3));this.addAttribute(\"uv\",new A(u,2))}function J(){Object.defineProperty(this,\"id\",{value:Kf++});this.uuid=H.generateUUID();this.name=\"\";this.type=\"Material\";this.lights=this.fog=\n!0;this.blending=1;this.side=0;this.flatShading=!1;this.vertexColors=0;this.opacity=1;this.transparent=!1;this.blendSrc=204;this.blendDst=205;this.blendEquation=100;this.blendEquationAlpha=this.blendDstAlpha=this.blendSrcAlpha=null;this.depthFunc=3;this.depthWrite=this.depthTest=!0;this.clippingPlanes=null;this.clipShadows=this.clipIntersection=!1;this.shadowSide=null;this.colorWrite=!0;this.precision=null;this.polygonOffset=!1;this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.dithering=!1;\nthis.alphaTest=0;this.premultipliedAlpha=!1;this.overdraw=0;this.visible=!0;this.userData={};this.needsUpdate=!0}function da(a){J.call(this);this.type=\"MeshBasicMaterial\";this.color=new G(16777215);this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.envMap=this.alphaMap=this.specularMap=null;this.combine=0;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\"round\";this.lights=\nthis.morphTargets=this.skinning=!1;this.setValues(a)}function ta(a){J.call(this);this.type=\"ShaderMaterial\";this.defines={};this.uniforms={};this.vertexShader=\"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";this.fragmentShader=\"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";this.linewidth=1;this.wireframe=!1;this.wireframeLinewidth=1;this.morphNormals=this.morphTargets=this.skinning=this.clipping=this.lights=this.fog=!1;this.extensions=\n{derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1};this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName=void 0;this.uniformsNeedUpdate=!1;void 0!==a&&(void 0!==a.attributes&&console.error(\"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.\"),this.setValues(a))}function mb(a,b){this.origin=void 0!==a?a:new p;this.direction=void 0!==b?b:new p}function ja(a,b,c){this.a=void 0!==a?a:new p;this.b=void 0!==b?b:new p;this.c=\nvoid 0!==c?c:new p}function la(a,b){D.call(this);this.type=\"Mesh\";this.geometry=void 0!==a?a:new C;this.material=void 0!==b?b:new da({color:16777215*Math.random()});this.drawMode=0;this.updateMorphTargets()}function Lf(a,b,c,d){function e(a,c){b.buffers.color.setClear(a.r,a.g,a.b,c,d)}var f=new G(0),g=0,h,k,m;return{getClearColor:function(){return f},setClearColor:function(a,b){f.set(a);g=void 0!==b?b:1;e(f,g)},getClearAlpha:function(){return g},setClearAlpha:function(a){g=a;e(f,g)},render:function(b,\nd,t,u){d=d.background;null===d?e(f,g):d&&d.isColor&&(e(d,1),u=!0);(a.autoClear||u)&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil);d&&d.isCubeTexture?(void 0===m&&(m=new la(new kb(1,1,1),new ta({uniforms:nb.cube.uniforms,vertexShader:nb.cube.vertexShader,fragmentShader:nb.cube.fragmentShader,side:1,depthTest:!0,depthWrite:!1,fog:!1})),m.geometry.removeAttribute(\"normal\"),m.geometry.removeAttribute(\"uv\"),m.onBeforeRender=function(a,b,c){this.matrixWorld.copyPosition(c.matrixWorld)},\nc.update(m)),m.material.uniforms.tCube.value=d,b.push(m,m.geometry,m.material,0,null)):d&&d.isTexture&&(void 0===h&&(h=new Hb(-1,1,1,-1,0,1),k=new la(new lb(2,2),new da({depthTest:!1,depthWrite:!1,fog:!1})),c.update(k)),k.material.map=d,a.renderBufferDirect(h,null,k.geometry,k.material,k,null))}}}function Mf(a,b,c,d){var e;this.setMode=function(a){e=a};this.render=function(b,d){a.drawArrays(e,b,d);c.update(d,e)};this.renderInstances=function(f,g,h){if(d.isWebGL2)var k=a;else if(k=b.get(\"ANGLE_instanced_arrays\"),\nnull===k){console.error(\"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\");return}k[d.isWebGL2?\"drawArraysInstanced\":\"drawArraysInstancedANGLE\"](e,g,h,f.maxInstancedCount);c.update(h,e,f.maxInstancedCount)}}function Nf(a,b,c){function d(b){if(\"highp\"===b){if(0<a.getShaderPrecisionFormat(a.VERTEX_SHADER,a.HIGH_FLOAT).precision&&0<a.getShaderPrecisionFormat(a.FRAGMENT_SHADER,a.HIGH_FLOAT).precision)return\"highp\";b=\"mediump\"}return\"mediump\"===\nb&&0<a.getShaderPrecisionFormat(a.VERTEX_SHADER,a.MEDIUM_FLOAT).precision&&0<a.getShaderPrecisionFormat(a.FRAGMENT_SHADER,a.MEDIUM_FLOAT).precision?\"mediump\":\"lowp\"}var e,f=\"undefined\"!==typeof WebGL2RenderingContext&&a instanceof WebGL2RenderingContext,g=void 0!==c.precision?c.precision:\"highp\",h=d(g);h!==g&&(console.warn(\"THREE.WebGLRenderer:\",g,\"not supported, using\",h,\"instead.\"),g=h);c=!0===c.logarithmicDepthBuffer;h=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);var k=a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),\nm=a.getParameter(a.MAX_TEXTURE_SIZE),q=a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),n=a.getParameter(a.MAX_VERTEX_ATTRIBS),t=a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),u=a.getParameter(a.MAX_VARYING_VECTORS),r=a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),l=0<k,y=f||!!b.get(\"OES_texture_float\");return{isWebGL2:f,getMaxAnisotropy:function(){if(void 0!==e)return e;var c=b.get(\"EXT_texture_filter_anisotropic\");return e=null!==c?a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0},getMaxPrecision:d,\nprecision:g,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:k,maxTextureSize:m,maxCubemapSize:q,maxAttributes:n,maxVertexUniforms:t,maxVaryings:u,maxFragmentUniforms:r,vertexTextures:l,floatFragmentTextures:y,floatVertexTextures:l&&y}}function Of(){function a(){m.value!==d&&(m.value=d,m.needsUpdate=0<e);c.numPlanes=e;c.numIntersection=0}function b(a,b,d,e){var f=null!==a?a.length:0,g=null;if(0!==f){g=m.value;if(!0!==e||null===g){e=d+4*f;b=b.matrixWorldInverse;k.getNormalMatrix(b);if(null===\ng||g.length<e)g=new Float32Array(e);for(e=0;e!==f;++e,d+=4)h.copy(a[e]).applyMatrix4(b,k),h.normal.toArray(g,d),g[d+3]=h.constant}m.value=g;m.needsUpdate=!0}c.numPlanes=f;return g}var c=this,d=null,e=0,f=!1,g=!1,h=new Ma,k=new ra,m={value:null,needsUpdate:!1};this.uniform=m;this.numIntersection=this.numPlanes=0;this.init=function(a,c,g){var h=0!==a.length||c||0!==e||f;f=c;d=b(a,g,0);e=a.length;return h};this.beginShadows=function(){g=!0;b(null)};this.endShadows=function(){g=!1;a()};this.setState=\nfunction(c,h,k,u,r,l){if(!f||null===c||0===c.length||g&&!k)g?b(null):a();else{k=g?0:e;var n=4*k,q=r.clippingState||null;m.value=q;q=b(c,u,n,l);for(c=0;c!==n;++c)q[c]=d[c];r.clippingState=q;this.numIntersection=h?this.numPlanes:0;this.numPlanes+=k}}}function Pf(a){var b={};return{get:function(c){if(void 0!==b[c])return b[c];switch(c){case \"WEBGL_depth_texture\":var d=a.getExtension(\"WEBGL_depth_texture\")||a.getExtension(\"MOZ_WEBGL_depth_texture\")||a.getExtension(\"WEBKIT_WEBGL_depth_texture\");break;\ncase \"EXT_texture_filter_anisotropic\":d=a.getExtension(\"EXT_texture_filter_anisotropic\")||a.getExtension(\"MOZ_EXT_texture_filter_anisotropic\")||a.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\");break;case \"WEBGL_compressed_texture_s3tc\":d=a.getExtension(\"WEBGL_compressed_texture_s3tc\")||a.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\")||a.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\");break;case \"WEBGL_compressed_texture_pvrtc\":d=a.getExtension(\"WEBGL_compressed_texture_pvrtc\")||a.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\");\nbreak;default:d=a.getExtension(c)}null===d&&console.warn(\"THREE.WebGLRenderer: \"+c+\" extension not supported.\");return b[c]=d}}}function Qf(a,b,c){function d(a){var h=a.target;a=e[h.id];null!==a.index&&b.remove(a.index);for(var g in a.attributes)b.remove(a.attributes[g]);h.removeEventListener(\"dispose\",d);delete e[h.id];if(g=f[a.id])b.remove(g),delete f[a.id];c.memory.geometries--}var e={},f={};return{get:function(a,b){var f=e[b.id];if(f)return f;b.addEventListener(\"dispose\",d);b.isBufferGeometry?\nf=b:b.isGeometry&&(void 0===b._bufferGeometry&&(b._bufferGeometry=(new C).setFromObject(a)),f=b._bufferGeometry);e[b.id]=f;c.memory.geometries++;return f},update:function(c){var d=c.index,e=c.attributes;null!==d&&b.update(d,a.ELEMENT_ARRAY_BUFFER);for(var f in e)b.update(e[f],a.ARRAY_BUFFER);c=c.morphAttributes;for(f in c){d=c[f];e=0;for(var g=d.length;e<g;e++)b.update(d[e],a.ARRAY_BUFFER)}},getWireframeAttribute:function(c){var d=f[c.id];if(d)return d;d=[];var e=c.index,g=c.attributes;if(null!==\ne){e=e.array;g=0;for(var q=e.length;g<q;g+=3){var n=e[g+0],t=e[g+1],u=e[g+2];d.push(n,t,t,u,u,n)}}else for(e=g.position.array,g=0,q=e.length/3-1;g<q;g+=3)n=g+0,t=g+1,u=g+2,d.push(n,t,t,u,u,n);d=new (65535<Fe(d)?jb:ib)(d,1);b.update(d,a.ELEMENT_ARRAY_BUFFER);return f[c.id]=d}}}function Rf(a,b,c,d){var e,f,g;this.setMode=function(a){e=a};this.setIndex=function(a){f=a.type;g=a.bytesPerElement};this.render=function(b,d){a.drawElements(e,d,f,b*g);c.update(d,e)};this.renderInstances=function(h,k,m){if(d.isWebGL2)var q=\na;else if(q=b.get(\"ANGLE_instanced_arrays\"),null===q){console.error(\"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\");return}q[d.isWebGL2?\"drawElementsInstanced\":\"drawElementsInstancedANGLE\"](e,m,f,k*g,h.maxInstancedCount);c.update(m,e,h.maxInstancedCount)}}function Sf(a){var b={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:b,programs:null,autoReset:!0,reset:function(){b.frame++;\nb.calls=0;b.triangles=0;b.points=0;b.lines=0},update:function(c,d,e){e=e||1;b.calls++;switch(d){case a.TRIANGLES:b.triangles+=c/3*e;break;case a.TRIANGLE_STRIP:case a.TRIANGLE_FAN:b.triangles+=e*(c-2);break;case a.LINES:b.lines+=c/2*e;break;case a.LINE_STRIP:b.lines+=e*(c-1);break;case a.LINE_LOOP:b.lines+=e*c;break;case a.POINTS:b.points+=e*c;break;default:console.error(\"THREE.WebGLInfo: Unknown draw mode:\",d)}}}}function Tf(a,b){return Math.abs(b[1])-Math.abs(a[1])}function Uf(a){var b={},c=new Float32Array(8);\nreturn{update:function(d,e,f,g){var h=d.morphTargetInfluences,k=h.length;d=b[e.id];if(void 0===d){d=[];for(var m=0;m<k;m++)d[m]=[m,0];b[e.id]=d}var q=f.morphTargets&&e.morphAttributes.position;f=f.morphNormals&&e.morphAttributes.normal;for(m=0;m<k;m++){var n=d[m];0!==n[1]&&(q&&e.removeAttribute(\"morphTarget\"+m),f&&e.removeAttribute(\"morphNormal\"+m))}for(m=0;m<k;m++)n=d[m],n[0]=m,n[1]=h[m];d.sort(Tf);for(m=0;8>m;m++){if(n=d[m])if(h=n[0],k=n[1]){q&&e.addAttribute(\"morphTarget\"+m,q[h]);f&&e.addAttribute(\"morphNormal\"+\nm,f[h]);c[m]=k;continue}c[m]=0}g.getUniforms().setValue(a,\"morphTargetInfluences\",c)}}}function Vf(a,b){var c={};return{update:function(d){var e=b.render.frame,f=d.geometry,g=a.get(d,f);c[g.id]!==e&&(f.isGeometry&&g.updateFromObject(d),a.update(g),c[g.id]=e);return g},dispose:function(){c={}}}}function Ua(a,b,c,d,e,f,g,h,k,m){a=void 0!==a?a:[];T.call(this,a,void 0!==b?b:301,c,d,e,f,g,h,k,m);this.flipY=!1}function Jb(a,b,c){var d=a[0];if(0>=d||0<d)return a;var e=b*c,f=Ge[e];void 0===f&&(f=new Float32Array(e),\nGe[e]=f);if(0!==b)for(d.toArray(f,0),d=1,e=0;d!==b;++d)e+=c,a[d].toArray(f,e);return f}function ea(a,b){if(a.length!==b.length)return!1;for(var c=0,d=a.length;c<d;c++)if(a[c]!==b[c])return!1;return!0}function qa(a,b){for(var c=0,d=b.length;c<d;c++)a[c]=b[c]}function He(a,b){var c=Ie[b];void 0===c&&(c=new Int32Array(b),Ie[b]=c);for(var d=0;d!==b;++d)c[d]=a.allocTextureUnit();return c}function Wf(a,b){var c=this.cache;c[0]!==b&&(a.uniform1f(this.addr,b),c[0]=b)}function Xf(a,b){var c=this.cache;c[0]!==\nb&&(a.uniform1i(this.addr,b),c[0]=b)}function Yf(a,b){var c=this.cache;if(void 0!==b.x){if(c[0]!==b.x||c[1]!==b.y)a.uniform2f(this.addr,b.x,b.y),c[0]=b.x,c[1]=b.y}else ea(c,b)||(a.uniform2fv(this.addr,b),qa(c,b))}function Zf(a,b){var c=this.cache;if(void 0!==b.x){if(c[0]!==b.x||c[1]!==b.y||c[2]!==b.z)a.uniform3f(this.addr,b.x,b.y,b.z),c[0]=b.x,c[1]=b.y,c[2]=b.z}else if(void 0!==b.r){if(c[0]!==b.r||c[1]!==b.g||c[2]!==b.b)a.uniform3f(this.addr,b.r,b.g,b.b),c[0]=b.r,c[1]=b.g,c[2]=b.b}else ea(c,b)||(a.uniform3fv(this.addr,\nb),qa(c,b))}function $f(a,b){var c=this.cache;if(void 0!==b.x){if(c[0]!==b.x||c[1]!==b.y||c[2]!==b.z||c[3]!==b.w)a.uniform4f(this.addr,b.x,b.y,b.z,b.w),c[0]=b.x,c[1]=b.y,c[2]=b.z,c[3]=b.w}else ea(c,b)||(a.uniform4fv(this.addr,b),qa(c,b))}function ag(a,b){var c=this.cache,d=b.elements;void 0===d?ea(c,b)||(a.uniformMatrix2fv(this.addr,!1,b),qa(c,b)):ea(c,d)||(Je.set(d),a.uniformMatrix2fv(this.addr,!1,Je),qa(c,d))}function bg(a,b){var c=this.cache,d=b.elements;void 0===d?ea(c,b)||(a.uniformMatrix3fv(this.addr,\n!1,b),qa(c,b)):ea(c,d)||(Ke.set(d),a.uniformMatrix3fv(this.addr,!1,Ke),qa(c,d))}function cg(a,b){var c=this.cache,d=b.elements;void 0===d?ea(c,b)||(a.uniformMatrix4fv(this.addr,!1,b),qa(c,b)):ea(c,d)||(Le.set(d),a.uniformMatrix4fv(this.addr,!1,Le),qa(c,d))}function dg(a,b,c){var d=this.cache,e=c.allocTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e);c.setTexture2D(b||Me,e)}function eg(a,b,c){var d=this.cache,e=c.allocTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e);c.setTextureCube(b||\nNe,e)}function Oe(a,b){var c=this.cache;ea(c,b)||(a.uniform2iv(this.addr,b),qa(c,b))}function Pe(a,b){var c=this.cache;ea(c,b)||(a.uniform3iv(this.addr,b),qa(c,b))}function Qe(a,b){var c=this.cache;ea(c,b)||(a.uniform4iv(this.addr,b),qa(c,b))}function fg(a){switch(a){case 5126:return Wf;case 35664:return Yf;case 35665:return Zf;case 35666:return $f;case 35674:return ag;case 35675:return bg;case 35676:return cg;case 35678:case 36198:return dg;case 35680:return eg;case 5124:case 35670:return Xf;case 35667:case 35671:return Oe;\ncase 35668:case 35672:return Pe;case 35669:case 35673:return Qe}}function gg(a,b){var c=this.cache;ea(c,b)||(a.uniform1fv(this.addr,b),qa(c,b))}function hg(a,b){var c=this.cache;ea(c,b)||(a.uniform1iv(this.addr,b),qa(c,b))}function ig(a,b){var c=this.cache;b=Jb(b,this.size,2);ea(c,b)||(a.uniform2fv(this.addr,b),this.updateCache(b))}function jg(a,b){var c=this.cache;b=Jb(b,this.size,3);ea(c,b)||(a.uniform3fv(this.addr,b),this.updateCache(b))}function kg(a,b){var c=this.cache;b=Jb(b,this.size,4);ea(c,\nb)||(a.uniform4fv(this.addr,b),this.updateCache(b))}function lg(a,b){var c=this.cache;b=Jb(b,this.size,4);ea(c,b)||(a.uniformMatrix2fv(this.addr,!1,b),this.updateCache(b))}function mg(a,b){var c=this.cache;b=Jb(b,this.size,9);ea(c,b)||(a.uniformMatrix3fv(this.addr,!1,b),this.updateCache(b))}function ng(a,b){var c=this.cache;b=Jb(b,this.size,16);ea(c,b)||(a.uniformMatrix4fv(this.addr,!1,b),this.updateCache(b))}function og(a,b,c){var d=this.cache,e=b.length,f=He(c,e);!1===ea(d,f)&&(a.uniform1iv(this.addr,\nf),qa(d,f));for(a=0;a!==e;++a)c.setTexture2D(b[a]||Me,f[a])}function pg(a,b,c){var d=this.cache,e=b.length,f=He(c,e);!1===ea(d,f)&&(a.uniform1iv(this.addr,f),qa(d,f));for(a=0;a!==e;++a)c.setTextureCube(b[a]||Ne,f[a])}function qg(a){switch(a){case 5126:return gg;case 35664:return ig;case 35665:return jg;case 35666:return kg;case 35674:return lg;case 35675:return mg;case 35676:return ng;case 35678:return og;case 35680:return pg;case 5124:case 35670:return hg;case 35667:case 35671:return Oe;case 35668:case 35672:return Pe;\ncase 35669:case 35673:return Qe}}function rg(a,b,c){this.id=a;this.addr=c;this.cache=[];this.setValue=fg(b.type)}function Re(a,b,c){this.id=a;this.addr=c;this.cache=[];this.size=b.size;this.setValue=qg(b.type)}function Se(a){this.id=a;this.seq=[];this.map={}}function Za(a,b,c){this.seq=[];this.map={};this.renderer=c;c=a.getProgramParameter(b,a.ACTIVE_UNIFORMS);for(var d=0;d<c;++d){var e=a.getActiveUniform(b,d),f=a.getUniformLocation(b,e.name),g=this,h=e.name,k=h.length;for(Vd.lastIndex=0;;){var m=\nVd.exec(h),q=Vd.lastIndex,n=m[1],t=m[3];\"]\"===m[2]&&(n|=0);if(void 0===t||\"[\"===t&&q+2===k){h=g;e=void 0===t?new rg(n,e,f):new Re(n,e,f);h.seq.push(e);h.map[e.id]=e;break}else t=g.map[n],void 0===t&&(t=new Se(n),n=g,g=t,n.seq.push(g),n.map[g.id]=g),g=t}}}function sg(a){a=a.split(\"\\n\");for(var b=0;b<a.length;b++)a[b]=b+1+\": \"+a[b];return a.join(\"\\n\")}function Te(a,b,c){var d=a.createShader(b);a.shaderSource(d,c);a.compileShader(d);!1===a.getShaderParameter(d,a.COMPILE_STATUS)&&console.error(\"THREE.WebGLShader: Shader couldn't compile.\");\n\"\"!==a.getShaderInfoLog(d)&&console.warn(\"THREE.WebGLShader: gl.getShaderInfoLog()\",b===a.VERTEX_SHADER?\"vertex\":\"fragment\",a.getShaderInfoLog(d),sg(c));return d}function Ue(a){switch(a){case 3E3:return[\"Linear\",\"( value )\"];case 3001:return[\"sRGB\",\"( value )\"];case 3002:return[\"RGBE\",\"( value )\"];case 3004:return[\"RGBM\",\"( value, 7.0 )\"];case 3005:return[\"RGBM\",\"( value, 16.0 )\"];case 3006:return[\"RGBD\",\"( value, 256.0 )\"];case 3007:return[\"Gamma\",\"( value, float( GAMMA_FACTOR ) )\"];default:throw Error(\"unsupported encoding: \"+\na);}}function Wd(a,b){b=Ue(b);return\"vec4 \"+a+\"( vec4 value ) { return \"+b[0]+\"ToLinear\"+b[1]+\"; }\"}function tg(a,b){b=Ue(b);return\"vec4 \"+a+\"( vec4 value ) { return LinearTo\"+b[0]+b[1]+\"; }\"}function ug(a,b){switch(b){case 1:b=\"Linear\";break;case 2:b=\"Reinhard\";break;case 3:b=\"Uncharted2\";break;case 4:b=\"OptimizedCineon\";break;default:throw Error(\"unsupported toneMapping: \"+b);}return\"vec3 \"+a+\"( vec3 color ) { return \"+b+\"ToneMapping( color ); }\"}function vg(a,b,c){a=a||{};return[a.derivatives||\nb.envMapCubeUV||b.bumpMap||b.normalMap&&!b.objectSpaceNormalMap||b.flatShading?\"#extension GL_OES_standard_derivatives : enable\":\"\",(a.fragDepth||b.logarithmicDepthBuffer)&&c.get(\"EXT_frag_depth\")?\"#extension GL_EXT_frag_depth : enable\":\"\",a.drawBuffers&&c.get(\"WEBGL_draw_buffers\")?\"#extension GL_EXT_draw_buffers : require\":\"\",(a.shaderTextureLOD||b.envMap)&&c.get(\"EXT_shader_texture_lod\")?\"#extension GL_EXT_shader_texture_lod : enable\":\"\"].filter(vc).join(\"\\n\")}function wg(a){var b=[],c;for(c in a){var d=\na[c];!1!==d&&b.push(\"#define \"+c+\" \"+d)}return b.join(\"\\n\")}function vc(a){return\"\"!==a}function Ve(a,b){return a.replace(/NUM_DIR_LIGHTS/g,b.numDirLights).replace(/NUM_SPOT_LIGHTS/g,b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,b.numPointLights).replace(/NUM_HEMI_LIGHTS/g,b.numHemiLights)}function We(a,b){return a.replace(/NUM_CLIPPING_PLANES/g,b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,b.numClippingPlanes-b.numClipIntersection)}function Xd(a){return a.replace(/^[ \\t]*#include +<([\\w\\d./]+)>/gm,\nfunction(a,c){a=S[c];if(void 0===a)throw Error(\"Can not resolve #include <\"+c+\">\");return Xd(a)})}function Xe(a){return a.replace(/#pragma unroll_loop[\\s]+?for \\( int i = (\\d+); i < (\\d+); i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g,function(a,c,d,e){a=\"\";for(c=parseInt(c);c<parseInt(d);c++)a+=e.replace(/\\[ i \\]/g,\"[ \"+c+\" ]\");return a})}function xg(a,b,c,d,e,f,g){var h=a.context,k=d.defines,m=e.vertexShader,q=e.fragmentShader,n=\"SHADOWMAP_TYPE_BASIC\";1===f.shadowMapType?n=\"SHADOWMAP_TYPE_PCF\":2===f.shadowMapType&&\n(n=\"SHADOWMAP_TYPE_PCF_SOFT\");var t=\"ENVMAP_TYPE_CUBE\",u=\"ENVMAP_MODE_REFLECTION\",r=\"ENVMAP_BLENDING_MULTIPLY\";if(f.envMap){switch(d.envMap.mapping){case 301:case 302:t=\"ENVMAP_TYPE_CUBE\";break;case 306:case 307:t=\"ENVMAP_TYPE_CUBE_UV\";break;case 303:case 304:t=\"ENVMAP_TYPE_EQUIREC\";break;case 305:t=\"ENVMAP_TYPE_SPHERE\"}switch(d.envMap.mapping){case 302:case 304:u=\"ENVMAP_MODE_REFRACTION\"}switch(d.combine){case 0:r=\"ENVMAP_BLENDING_MULTIPLY\";break;case 1:r=\"ENVMAP_BLENDING_MIX\";break;case 2:r=\"ENVMAP_BLENDING_ADD\"}}var l=\n0<a.gammaFactor?a.gammaFactor:1,y=g.isWebGL2?\"\":vg(d.extensions,f,b),p=wg(k),w=h.createProgram();d.isRawShaderMaterial?(k=[p].filter(vc).join(\"\\n\"),0<k.length&&(k+=\"\\n\"),b=[y,p].filter(vc).join(\"\\n\"),0<b.length&&(b+=\"\\n\")):(k=[\"precision \"+f.precision+\" float;\",\"precision \"+f.precision+\" int;\",\"#define SHADER_NAME \"+e.name,p,f.supportsVertexTextures?\"#define VERTEX_TEXTURES\":\"\",\"#define GAMMA_FACTOR \"+l,\"#define MAX_BONES \"+f.maxBones,f.useFog&&f.fog?\"#define USE_FOG\":\"\",f.useFog&&f.fogExp?\"#define FOG_EXP2\":\n\"\",f.map?\"#define USE_MAP\":\"\",f.envMap?\"#define USE_ENVMAP\":\"\",f.envMap?\"#define \"+u:\"\",f.lightMap?\"#define USE_LIGHTMAP\":\"\",f.aoMap?\"#define USE_AOMAP\":\"\",f.emissiveMap?\"#define USE_EMISSIVEMAP\":\"\",f.bumpMap?\"#define USE_BUMPMAP\":\"\",f.normalMap?\"#define USE_NORMALMAP\":\"\",f.normalMap&&f.objectSpaceNormalMap?\"#define OBJECTSPACE_NORMALMAP\":\"\",f.displacementMap&&f.supportsVertexTextures?\"#define USE_DISPLACEMENTMAP\":\"\",f.specularMap?\"#define USE_SPECULARMAP\":\"\",f.roughnessMap?\"#define USE_ROUGHNESSMAP\":\n\"\",f.metalnessMap?\"#define USE_METALNESSMAP\":\"\",f.alphaMap?\"#define USE_ALPHAMAP\":\"\",f.vertexColors?\"#define USE_COLOR\":\"\",f.flatShading?\"#define FLAT_SHADED\":\"\",f.skinning?\"#define USE_SKINNING\":\"\",f.useVertexTexture?\"#define BONE_TEXTURE\":\"\",f.morphTargets?\"#define USE_MORPHTARGETS\":\"\",f.morphNormals&&!1===f.flatShading?\"#define USE_MORPHNORMALS\":\"\",f.doubleSided?\"#define DOUBLE_SIDED\":\"\",f.flipSided?\"#define FLIP_SIDED\":\"\",f.shadowMapEnabled?\"#define USE_SHADOWMAP\":\"\",f.shadowMapEnabled?\"#define \"+\nn:\"\",f.sizeAttenuation?\"#define USE_SIZEATTENUATION\":\"\",f.logarithmicDepthBuffer?\"#define USE_LOGDEPTHBUF\":\"\",f.logarithmicDepthBuffer&&(g.isWebGL2||b.get(\"EXT_frag_depth\"))?\"#define USE_LOGDEPTHBUF_EXT\":\"\",\"uniform mat4 modelMatrix;\",\"uniform mat4 modelViewMatrix;\",\"uniform mat4 projectionMatrix;\",\"uniform mat4 viewMatrix;\",\"uniform mat3 normalMatrix;\",\"uniform vec3 cameraPosition;\",\"attribute vec3 position;\",\"attribute vec3 normal;\",\"attribute vec2 uv;\",\"#ifdef USE_COLOR\",\"\\tattribute vec3 color;\",\n\"#endif\",\"#ifdef USE_MORPHTARGETS\",\"\\tattribute vec3 morphTarget0;\",\"\\tattribute vec3 morphTarget1;\",\"\\tattribute vec3 morphTarget2;\",\"\\tattribute vec3 morphTarget3;\",\"\\t#ifdef USE_MORPHNORMALS\",\"\\t\\tattribute vec3 morphNormal0;\",\"\\t\\tattribute vec3 morphNormal1;\",\"\\t\\tattribute vec3 morphNormal2;\",\"\\t\\tattribute vec3 morphNormal3;\",\"\\t#else\",\"\\t\\tattribute vec3 morphTarget4;\",\"\\t\\tattribute vec3 morphTarget5;\",\"\\t\\tattribute vec3 morphTarget6;\",\"\\t\\tattribute vec3 morphTarget7;\",\"\\t#endif\",\"#endif\",\n\"#ifdef USE_SKINNING\",\"\\tattribute vec4 skinIndex;\",\"\\tattribute vec4 skinWeight;\",\"#endif\",\"\\n\"].filter(vc).join(\"\\n\"),b=[y,\"precision \"+f.precision+\" float;\",\"precision \"+f.precision+\" int;\",\"#define SHADER_NAME \"+e.name,p,f.alphaTest?\"#define ALPHATEST \"+f.alphaTest+(f.alphaTest%1?\"\":\".0\"):\"\",\"#define GAMMA_FACTOR \"+l,f.useFog&&f.fog?\"#define USE_FOG\":\"\",f.useFog&&f.fogExp?\"#define FOG_EXP2\":\"\",f.map?\"#define USE_MAP\":\"\",f.envMap?\"#define USE_ENVMAP\":\"\",f.envMap?\"#define \"+t:\"\",f.envMap?\"#define \"+\nu:\"\",f.envMap?\"#define \"+r:\"\",f.lightMap?\"#define USE_LIGHTMAP\":\"\",f.aoMap?\"#define USE_AOMAP\":\"\",f.emissiveMap?\"#define USE_EMISSIVEMAP\":\"\",f.bumpMap?\"#define USE_BUMPMAP\":\"\",f.normalMap?\"#define USE_NORMALMAP\":\"\",f.normalMap&&f.objectSpaceNormalMap?\"#define OBJECTSPACE_NORMALMAP\":\"\",f.specularMap?\"#define USE_SPECULARMAP\":\"\",f.roughnessMap?\"#define USE_ROUGHNESSMAP\":\"\",f.metalnessMap?\"#define USE_METALNESSMAP\":\"\",f.alphaMap?\"#define USE_ALPHAMAP\":\"\",f.vertexColors?\"#define USE_COLOR\":\"\",f.gradientMap?\n\"#define USE_GRADIENTMAP\":\"\",f.flatShading?\"#define FLAT_SHADED\":\"\",f.doubleSided?\"#define DOUBLE_SIDED\":\"\",f.flipSided?\"#define FLIP_SIDED\":\"\",f.shadowMapEnabled?\"#define USE_SHADOWMAP\":\"\",f.shadowMapEnabled?\"#define \"+n:\"\",f.premultipliedAlpha?\"#define PREMULTIPLIED_ALPHA\":\"\",f.physicallyCorrectLights?\"#define PHYSICALLY_CORRECT_LIGHTS\":\"\",f.logarithmicDepthBuffer?\"#define USE_LOGDEPTHBUF\":\"\",f.logarithmicDepthBuffer&&(g.isWebGL2||b.get(\"EXT_frag_depth\"))?\"#define USE_LOGDEPTHBUF_EXT\":\"\",f.envMap&&\n(g.isWebGL2||b.get(\"EXT_shader_texture_lod\"))?\"#define TEXTURE_LOD_EXT\":\"\",\"uniform mat4 viewMatrix;\",\"uniform vec3 cameraPosition;\",0!==f.toneMapping?\"#define TONE_MAPPING\":\"\",0!==f.toneMapping?S.tonemapping_pars_fragment:\"\",0!==f.toneMapping?ug(\"toneMapping\",f.toneMapping):\"\",f.dithering?\"#define DITHERING\":\"\",f.outputEncoding||f.mapEncoding||f.envMapEncoding||f.emissiveMapEncoding?S.encodings_pars_fragment:\"\",f.mapEncoding?Wd(\"mapTexelToLinear\",f.mapEncoding):\"\",f.envMapEncoding?Wd(\"envMapTexelToLinear\",\nf.envMapEncoding):\"\",f.emissiveMapEncoding?Wd(\"emissiveMapTexelToLinear\",f.emissiveMapEncoding):\"\",f.outputEncoding?tg(\"linearToOutputTexel\",f.outputEncoding):\"\",f.depthPacking?\"#define DEPTH_PACKING \"+d.depthPacking:\"\",\"\\n\"].filter(vc).join(\"\\n\"));m=Xd(m);m=Ve(m,f);m=We(m,f);q=Xd(q);q=Ve(q,f);q=We(q,f);m=Xe(m);q=Xe(q);g.isWebGL2&&!d.isRawShaderMaterial&&(g=!1,n=/^\\s*#version\\s+300\\s+es\\s*\\n/,d.isShaderMaterial&&null!==m.match(n)&&null!==q.match(n)&&(g=!0,m=m.replace(n,\"\"),q=q.replace(n,\"\")),k=\"#version 300 es\\n\\n#define attribute in\\n#define varying out\\n#define texture2D texture\\n\"+\nk,b=[\"#version 300 es\\n\\n#define varying in\",g?\"\":\"out highp vec4 pc_fragColor;\",g?\"\":\"#define gl_FragColor pc_fragColor\",\"#define gl_FragDepthEXT gl_FragDepth\\n#define texture2D texture\\n#define textureCube texture\\n#define texture2DProj textureProj\\n#define texture2DLodEXT textureLod\\n#define texture2DProjLodEXT textureProjLod\\n#define textureCubeLodEXT textureLod\\n#define texture2DGradEXT textureGrad\\n#define texture2DProjGradEXT textureProjGrad\\n#define textureCubeGradEXT textureGrad\"].join(\"\\n\")+\n\"\\n\"+b);q=b+q;m=Te(h,h.VERTEX_SHADER,k+m);q=Te(h,h.FRAGMENT_SHADER,q);h.attachShader(w,m);h.attachShader(w,q);void 0!==d.index0AttributeName?h.bindAttribLocation(w,0,d.index0AttributeName):!0===f.morphTargets&&h.bindAttribLocation(w,0,\"position\");h.linkProgram(w);f=h.getProgramInfoLog(w).trim();g=h.getShaderInfoLog(m).trim();n=h.getShaderInfoLog(q).trim();u=t=!0;if(!1===h.getProgramParameter(w,h.LINK_STATUS))t=!1,console.error(\"THREE.WebGLProgram: shader error: \",h.getError(),\"gl.VALIDATE_STATUS\",\nh.getProgramParameter(w,h.VALIDATE_STATUS),\"gl.getProgramInfoLog\",f,g,n);else if(\"\"!==f)console.warn(\"THREE.WebGLProgram: gl.getProgramInfoLog()\",f);else if(\"\"===g||\"\"===n)u=!1;u&&(this.diagnostics={runnable:t,material:d,programLog:f,vertexShader:{log:g,prefix:k},fragmentShader:{log:n,prefix:b}});h.deleteShader(m);h.deleteShader(q);var B;this.getUniforms=function(){void 0===B&&(B=new Za(h,w,a));return B};var E;this.getAttributes=function(){if(void 0===E){for(var a={},b=h.getProgramParameter(w,h.ACTIVE_ATTRIBUTES),\nc=0;c<b;c++){var d=h.getActiveAttrib(w,c).name;a[d]=h.getAttribLocation(w,d)}E=a}return E};this.destroy=function(){h.deleteProgram(w);this.program=void 0};Object.defineProperties(this,{uniforms:{get:function(){console.warn(\"THREE.WebGLProgram: .uniforms is now .getUniforms().\");return this.getUniforms()}},attributes:{get:function(){console.warn(\"THREE.WebGLProgram: .attributes is now .getAttributes().\");return this.getAttributes()}}});this.name=e.name;this.id=yg++;this.code=c;this.usedTimes=1;this.program=\nw;this.vertexShader=m;this.fragmentShader=q;return this}function zg(a,b,c){function d(a,b){if(a)a.isTexture?c=a.encoding:a.isWebGLRenderTarget&&(console.warn(\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\"),c=a.texture.encoding);else var c=3E3;3E3===c&&b&&(c=3007);return c}var e=[],f={MeshDepthMaterial:\"depth\",MeshDistanceMaterial:\"distanceRGBA\",MeshNormalMaterial:\"normal\",MeshBasicMaterial:\"basic\",MeshLambertMaterial:\"lambert\",\nMeshPhongMaterial:\"phong\",MeshToonMaterial:\"phong\",MeshStandardMaterial:\"physical\",MeshPhysicalMaterial:\"physical\",LineBasicMaterial:\"basic\",LineDashedMaterial:\"dashed\",PointsMaterial:\"points\",ShadowMaterial:\"shadow\",SpriteMaterial:\"sprite\"},g=\"precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering\".split(\" \");\nthis.getParameters=function(b,e,g,q,n,t,u){var h=f[b.type];if(u.isSkinnedMesh){var k=u.skeleton.bones;if(c.floatVertexTextures)k=1024;else{var m=Math.min(Math.floor((c.maxVertexUniforms-20)/4),k.length);m<k.length?(console.warn(\"THREE.WebGLRenderer: Skeleton has \"+k.length+\" bones. This GPU supports \"+m+\".\"),k=0):k=m}}else k=0;m=c.precision;null!==b.precision&&(m=c.getMaxPrecision(b.precision),m!==b.precision&&console.warn(\"THREE.WebGLProgram.getParameters:\",b.precision,\"not supported, using\",m,\"instead.\"));\nvar l=a.getRenderTarget();return{shaderID:h,precision:m,supportsVertexTextures:c.vertexTextures,outputEncoding:d(l?l.texture:null,a.gammaOutput),map:!!b.map,mapEncoding:d(b.map,a.gammaInput),envMap:!!b.envMap,envMapMode:b.envMap&&b.envMap.mapping,envMapEncoding:d(b.envMap,a.gammaInput),envMapCubeUV:!!b.envMap&&(306===b.envMap.mapping||307===b.envMap.mapping),lightMap:!!b.lightMap,aoMap:!!b.aoMap,emissiveMap:!!b.emissiveMap,emissiveMapEncoding:d(b.emissiveMap,a.gammaInput),bumpMap:!!b.bumpMap,normalMap:!!b.normalMap,\nobjectSpaceNormalMap:1===b.normalMapType,displacementMap:!!b.displacementMap,roughnessMap:!!b.roughnessMap,metalnessMap:!!b.metalnessMap,specularMap:!!b.specularMap,alphaMap:!!b.alphaMap,gradientMap:!!b.gradientMap,combine:b.combine,vertexColors:b.vertexColors,fog:!!q,useFog:b.fog,fogExp:q&&q.isFogExp2,flatShading:b.flatShading,sizeAttenuation:b.sizeAttenuation,logarithmicDepthBuffer:c.logarithmicDepthBuffer,skinning:b.skinning&&0<k,maxBones:k,useVertexTexture:c.floatVertexTextures,morphTargets:b.morphTargets,\nmorphNormals:b.morphNormals,maxMorphTargets:a.maxMorphTargets,maxMorphNormals:a.maxMorphNormals,numDirLights:e.directional.length,numPointLights:e.point.length,numSpotLights:e.spot.length,numRectAreaLights:e.rectArea.length,numHemiLights:e.hemi.length,numClippingPlanes:n,numClipIntersection:t,dithering:b.dithering,shadowMapEnabled:a.shadowMap.enabled&&u.receiveShadow&&0<g.length,shadowMapType:a.shadowMap.type,toneMapping:a.toneMapping,physicallyCorrectLights:a.physicallyCorrectLights,premultipliedAlpha:b.premultipliedAlpha,\nalphaTest:b.alphaTest,doubleSided:2===b.side,flipSided:1===b.side,depthPacking:void 0!==b.depthPacking?b.depthPacking:!1}};this.getProgramCode=function(b,c){var d=[];c.shaderID?d.push(c.shaderID):(d.push(b.fragmentShader),d.push(b.vertexShader));if(void 0!==b.defines)for(var e in b.defines)d.push(e),d.push(b.defines[e]);for(e=0;e<g.length;e++)d.push(c[g[e]]);d.push(b.onBeforeCompile.toString());d.push(a.gammaOutput);return d.join()};this.acquireProgram=function(d,f,g,q){for(var h,k=0,m=e.length;k<\nm;k++){var r=e[k];if(r.code===q){h=r;++h.usedTimes;break}}void 0===h&&(h=new xg(a,b,q,d,f,g,c),e.push(h));return h};this.releaseProgram=function(a){if(0===--a.usedTimes){var b=e.indexOf(a);e[b]=e[e.length-1];e.pop();a.destroy()}};this.programs=e}function Ag(){var a=new WeakMap;return{get:function(b){var c=a.get(b);void 0===c&&(c={},a.set(b,c));return c},remove:function(b){a.delete(b)},update:function(b,c,d){a.get(b)[c]=d},dispose:function(){a=new WeakMap}}}function Bg(a,b){return a.renderOrder!==\nb.renderOrder?a.renderOrder-b.renderOrder:a.program&&b.program&&a.program!==b.program?a.program.id-b.program.id:a.material.id!==b.material.id?a.material.id-b.material.id:a.z!==b.z?a.z-b.z:a.id-b.id}function Cg(a,b){return a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.z!==b.z?b.z-a.z:a.id-b.id}function Dg(){var a=[],b=0,c=[],d=[];return{opaque:c,transparent:d,init:function(){b=0;c.length=0;d.length=0},push:function(e,f,g,h,k){var m=a[b];void 0===m?(m={id:e.id,object:e,geometry:f,material:g,\nprogram:g.program,renderOrder:e.renderOrder,z:h,group:k},a[b]=m):(m.id=e.id,m.object=e,m.geometry=f,m.material=g,m.program=g.program,m.renderOrder=e.renderOrder,m.z=h,m.group=k);(!0===g.transparent?d:c).push(m);b++},sort:function(){1<c.length&&c.sort(Bg);1<d.length&&d.sort(Cg)}}}function Eg(){var a={};return{get:function(b,c){b=b.id+\",\"+c.id;c=a[b];void 0===c&&(c=new Dg,a[b]=c);return c},dispose:function(){a={}}}}function Fg(){var a={};return{get:function(b){if(void 0!==a[b.id])return a[b.id];switch(b.type){case \"DirectionalLight\":var c=\n{direction:new p,color:new G,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new z};break;case \"SpotLight\":c={position:new p,direction:new p,color:new G,distance:0,coneCos:0,penumbraCos:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new z};break;case \"PointLight\":c={position:new p,color:new G,distance:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new z,shadowCameraNear:1,shadowCameraFar:1E3};break;case \"HemisphereLight\":c={direction:new p,skyColor:new G,groundColor:new G};\nbreak;case \"RectAreaLight\":c={color:new G,position:new p,halfWidth:new p,halfHeight:new p}}return a[b.id]=c}}}function Gg(){var a=new Fg,b={id:Hg++,hash:{stateID:-1,directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,shadowsLength:-1},ambient:[0,0,0],directional:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]},c=new p,d=new I,e=new I;return{setup:function(f,\ng,h){var k=0,m=0,q=0,n=0,t=0,u=0,r=0,l=0;h=h.matrixWorldInverse;for(var y=0,p=f.length;y<p;y++){var w=f[y],B=w.color,E=w.intensity,P=w.distance,N=w.shadow&&w.shadow.map?w.shadow.map.texture:null;if(w.isAmbientLight)k+=B.r*E,m+=B.g*E,q+=B.b*E;else if(w.isDirectionalLight){var O=a.get(w);O.color.copy(w.color).multiplyScalar(w.intensity);O.direction.setFromMatrixPosition(w.matrixWorld);c.setFromMatrixPosition(w.target.matrixWorld);O.direction.sub(c);O.direction.transformDirection(h);if(O.shadow=w.castShadow)B=\nw.shadow,O.shadowBias=B.bias,O.shadowRadius=B.radius,O.shadowMapSize=B.mapSize;b.directionalShadowMap[n]=N;b.directionalShadowMatrix[n]=w.shadow.matrix;b.directional[n]=O;n++}else if(w.isSpotLight){O=a.get(w);O.position.setFromMatrixPosition(w.matrixWorld);O.position.applyMatrix4(h);O.color.copy(B).multiplyScalar(E);O.distance=P;O.direction.setFromMatrixPosition(w.matrixWorld);c.setFromMatrixPosition(w.target.matrixWorld);O.direction.sub(c);O.direction.transformDirection(h);O.coneCos=Math.cos(w.angle);\nO.penumbraCos=Math.cos(w.angle*(1-w.penumbra));O.decay=0===w.distance?0:w.decay;if(O.shadow=w.castShadow)B=w.shadow,O.shadowBias=B.bias,O.shadowRadius=B.radius,O.shadowMapSize=B.mapSize;b.spotShadowMap[u]=N;b.spotShadowMatrix[u]=w.shadow.matrix;b.spot[u]=O;u++}else if(w.isRectAreaLight)O=a.get(w),O.color.copy(B).multiplyScalar(E),O.position.setFromMatrixPosition(w.matrixWorld),O.position.applyMatrix4(h),e.identity(),d.copy(w.matrixWorld),d.premultiply(h),e.extractRotation(d),O.halfWidth.set(.5*w.width,\n0,0),O.halfHeight.set(0,.5*w.height,0),O.halfWidth.applyMatrix4(e),O.halfHeight.applyMatrix4(e),b.rectArea[r]=O,r++;else if(w.isPointLight){O=a.get(w);O.position.setFromMatrixPosition(w.matrixWorld);O.position.applyMatrix4(h);O.color.copy(w.color).multiplyScalar(w.intensity);O.distance=w.distance;O.decay=0===w.distance?0:w.decay;if(O.shadow=w.castShadow)B=w.shadow,O.shadowBias=B.bias,O.shadowRadius=B.radius,O.shadowMapSize=B.mapSize,O.shadowCameraNear=B.camera.near,O.shadowCameraFar=B.camera.far;\nb.pointShadowMap[t]=N;b.pointShadowMatrix[t]=w.shadow.matrix;b.point[t]=O;t++}else w.isHemisphereLight&&(O=a.get(w),O.direction.setFromMatrixPosition(w.matrixWorld),O.direction.transformDirection(h),O.direction.normalize(),O.skyColor.copy(w.color).multiplyScalar(E),O.groundColor.copy(w.groundColor).multiplyScalar(E),b.hemi[l]=O,l++)}b.ambient[0]=k;b.ambient[1]=m;b.ambient[2]=q;b.directional.length=n;b.spot.length=u;b.rectArea.length=r;b.point.length=t;b.hemi.length=l;b.hash.stateID=b.id;b.hash.directionalLength=\nn;b.hash.pointLength=t;b.hash.spotLength=u;b.hash.rectAreaLength=r;b.hash.hemiLength=l;b.hash.shadowsLength=g.length},state:b}}function Ye(){var a=new Gg,b=[],c=[];return{init:function(){b.length=0;c.length=0},state:{lightsArray:b,shadowsArray:c,lights:a},setupLights:function(d){a.setup(b,c,d)},pushLight:function(a){b.push(a)},pushShadow:function(a){c.push(a)}}}function Ig(){var a={};return{get:function(b,c){if(void 0===a[b.id]){var d=new Ye;a[b.id]={};a[b.id][c.id]=d}else void 0===a[b.id][c.id]?\n(d=new Ye,a[b.id][c.id]=d):d=a[b.id][c.id];return d},dispose:function(){a={}}}}function $a(a){J.call(this);this.type=\"MeshDepthMaterial\";this.depthPacking=3200;this.morphTargets=this.skinning=!1;this.displacementMap=this.alphaMap=this.map=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=!1;this.wireframeLinewidth=1;this.lights=this.fog=!1;this.setValues(a)}function ab(a){J.call(this);this.type=\"MeshDistanceMaterial\";this.referencePosition=new p;this.nearDistance=1;this.farDistance=\n1E3;this.morphTargets=this.skinning=!1;this.displacementMap=this.alphaMap=this.map=null;this.displacementScale=1;this.displacementBias=0;this.lights=this.fog=!1;this.setValues(a)}function Ze(a,b,c){function d(b,c,d,e,f,g){var h=b.geometry;var k=n;var m=b.customDepthMaterial;d&&(k=t,m=b.customDistanceMaterial);m?k=m:(m=!1,c.morphTargets&&(h&&h.isBufferGeometry?m=h.morphAttributes&&h.morphAttributes.position&&0<h.morphAttributes.position.length:h&&h.isGeometry&&(m=h.morphTargets&&0<h.morphTargets.length)),\nb.isSkinnedMesh&&!1===c.skinning&&console.warn(\"THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:\",b),b=b.isSkinnedMesh&&c.skinning,h=0,m&&(h|=1),b&&(h|=2),k=k[h]);a.localClippingEnabled&&!0===c.clipShadows&&0!==c.clippingPlanes.length&&(h=k.uuid,m=c.uuid,b=u[h],void 0===b&&(b={},u[h]=b),h=b[m],void 0===h&&(h=k.clone(),b[m]=h),k=h);k.visible=c.visible;k.wireframe=c.wireframe;k.side=null!=c.shadowSide?c.shadowSide:r[c.side];k.clipShadows=c.clipShadows;k.clippingPlanes=c.clippingPlanes;\nk.clipIntersection=c.clipIntersection;k.wireframeLinewidth=c.wireframeLinewidth;k.linewidth=c.linewidth;d&&k.isMeshDistanceMaterial&&(k.referencePosition.copy(e),k.nearDistance=f,k.farDistance=g);return k}function e(c,g,h,k){if(!1!==c.visible){if(c.layers.test(g.layers)&&(c.isMesh||c.isLine||c.isPoints)&&c.castShadow&&(!c.frustumCulled||f.intersectsObject(c))){c.modelViewMatrix.multiplyMatrices(h.matrixWorldInverse,c.matrixWorld);var m=b.update(c),n=c.material;if(Array.isArray(n))for(var t=m.groups,\nu=0,r=t.length;u<r;u++){var l=t[u],P=n[l.materialIndex];P&&P.visible&&(P=d(c,P,k,q,h.near,h.far),a.renderBufferDirect(h,null,m,P,c,l))}else n.visible&&(P=d(c,n,k,q,h.near,h.far),a.renderBufferDirect(h,null,m,P,c,null))}c=c.children;m=0;for(n=c.length;m<n;m++)e(c[m],g,h,k)}}var f=new md,g=new I,h=new z,k=new z(c,c),m=new p,q=new p,n=Array(4),t=Array(4),u={},r={0:1,1:0,2:2},l=[new p(1,0,0),new p(-1,0,0),new p(0,0,1),new p(0,0,-1),new p(0,1,0),new p(0,-1,0)],y=[new p(0,1,0),new p(0,1,0),new p(0,1,0),\nnew p(0,1,0),new p(0,0,1),new p(0,0,-1)],x=[new V,new V,new V,new V,new V,new V];for(c=0;4!==c;++c){var w=0!==(c&1),B=0!==(c&2),E=new $a({depthPacking:3201,morphTargets:w,skinning:B});n[c]=E;w=new ab({morphTargets:w,skinning:B});t[c]=w}var P=this;this.enabled=!1;this.autoUpdate=!0;this.needsUpdate=!1;this.type=1;this.render=function(b,c,d){if(!1!==P.enabled&&(!1!==P.autoUpdate||!1!==P.needsUpdate)&&0!==b.length){var n=a.state;n.disable(a.context.BLEND);n.buffers.color.setClear(1,1,1,1);n.buffers.depth.setTest(!0);\nn.setScissorTest(!1);for(var t,u=0,r=b.length;u<r;u++){var v=b[u];t=v.shadow;var p=v&&v.isPointLight;if(void 0===t)console.warn(\"THREE.WebGLShadowMap:\",v,\"has no shadow.\");else{var w=t.camera;h.copy(t.mapSize);h.min(k);if(p){var N=h.x,E=h.y;x[0].set(2*N,E,N,E);x[1].set(0,E,N,E);x[2].set(3*N,E,N,E);x[3].set(N,E,N,E);x[4].set(3*N,0,N,E);x[5].set(N,0,N,E);h.x*=4;h.y*=2}null===t.map&&(t.map=new fb(h.x,h.y,{minFilter:1003,magFilter:1003,format:1023}),t.map.texture.name=v.name+\".shadowMap\",w.updateProjectionMatrix());\nt.isSpotLightShadow&&t.update(v);N=t.map;E=t.matrix;q.setFromMatrixPosition(v.matrixWorld);w.position.copy(q);p?(t=6,E.makeTranslation(-q.x,-q.y,-q.z)):(t=1,m.setFromMatrixPosition(v.target.matrixWorld),w.lookAt(m),w.updateMatrixWorld(),E.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),E.multiply(w.projectionMatrix),E.multiply(w.matrixWorldInverse));a.setRenderTarget(N);a.clear();for(v=0;v<t;v++)p&&(m.copy(w.position),m.add(l[v]),w.up.copy(y[v]),w.lookAt(m),w.updateMatrixWorld(),n.viewport(x[v])),g.multiplyMatrices(w.projectionMatrix,\nw.matrixWorldInverse),f.setFromMatrix(g),e(c,d,w,p)}}P.needsUpdate=!1}}}function Jg(a,b,c,d){function e(b,c,d){var e=new Uint8Array(4),f=a.createTexture();a.bindTexture(b,f);a.texParameteri(b,a.TEXTURE_MIN_FILTER,a.NEAREST);a.texParameteri(b,a.TEXTURE_MAG_FILTER,a.NEAREST);for(b=0;b<d;b++)a.texImage2D(c+b,0,a.RGBA,1,1,0,a.RGBA,a.UNSIGNED_BYTE,e);return f}function f(c,e){x[c]=1;0===w[c]&&(a.enableVertexAttribArray(c),w[c]=1);B[c]!==e&&((d.isWebGL2?a:b.get(\"ANGLE_instanced_arrays\"))[d.isWebGL2?\"vertexAttribDivisor\":\n\"vertexAttribDivisorANGLE\"](c,e),B[c]=e)}function g(b){!0!==E[b]&&(a.enable(b),E[b]=!0)}function h(b){!1!==E[b]&&(a.disable(b),E[b]=!1)}function k(b,d,e,f,k,m,n,q){0!==b?g(a.BLEND):h(a.BLEND);if(5!==b){if(b!==O||q!==C)switch(b){case 2:q?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ONE,a.ONE,a.ONE,a.ONE)):(a.blendEquation(a.FUNC_ADD),a.blendFunc(a.SRC_ALPHA,a.ONE));break;case 3:q?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ZERO,a.ZERO,a.ONE_MINUS_SRC_COLOR,\na.ONE_MINUS_SRC_ALPHA)):(a.blendEquation(a.FUNC_ADD),a.blendFunc(a.ZERO,a.ONE_MINUS_SRC_COLOR));break;case 4:q?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ZERO,a.SRC_COLOR,a.ZERO,a.SRC_ALPHA)):(a.blendEquation(a.FUNC_ADD),a.blendFunc(a.ZERO,a.SRC_COLOR));break;default:q?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ONE,a.ONE_MINUS_SRC_ALPHA,a.ONE,a.ONE_MINUS_SRC_ALPHA)):(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.SRC_ALPHA,\na.ONE_MINUS_SRC_ALPHA,a.ONE,a.ONE_MINUS_SRC_ALPHA))}D=A=Ud=Td=Sd=z=null}else{k=k||d;m=m||e;n=n||f;if(d!==z||k!==Ud)a.blendEquationSeparate(c.convert(d),c.convert(k)),z=d,Ud=k;if(e!==Sd||f!==Td||m!==A||n!==D)a.blendFuncSeparate(c.convert(e),c.convert(f),c.convert(m),c.convert(n)),Sd=e,Td=f,A=m,D=n}O=b;C=q}function m(b){G!==b&&(b?a.frontFace(a.CW):a.frontFace(a.CCW),G=b)}function q(b){0!==b?(g(a.CULL_FACE),b!==K&&(1===b?a.cullFace(a.BACK):2===b?a.cullFace(a.FRONT):a.cullFace(a.FRONT_AND_BACK))):h(a.CULL_FACE);\nK=b}function n(b,c,d){if(b){if(g(a.POLYGON_OFFSET_FILL),R!==c||I!==d)a.polygonOffset(c,d),R=c,I=d}else h(a.POLYGON_OFFSET_FILL)}function t(b){void 0===b&&(b=a.TEXTURE0+J-1);Q!==b&&(a.activeTexture(b),Q=b)}var u=new function(){var b=!1,c=new V,d=null,e=new V(0,0,0,0);return{setMask:function(c){d===c||b||(a.colorMask(c,c,c,c),d=c)},setLocked:function(a){b=a},setClear:function(b,d,f,g,h){!0===h&&(b*=g,d*=g,f*=g);c.set(b,d,f,g);!1===e.equals(c)&&(a.clearColor(b,d,f,g),e.copy(c))},reset:function(){b=!1;\nd=null;e.set(-1,0,0,0)}}},r=new function(){var b=!1,c=null,d=null,e=null;return{setTest:function(b){b?g(a.DEPTH_TEST):h(a.DEPTH_TEST)},setMask:function(d){c===d||b||(a.depthMask(d),c=d)},setFunc:function(b){if(d!==b){if(b)switch(b){case 0:a.depthFunc(a.NEVER);break;case 1:a.depthFunc(a.ALWAYS);break;case 2:a.depthFunc(a.LESS);break;case 3:a.depthFunc(a.LEQUAL);break;case 4:a.depthFunc(a.EQUAL);break;case 5:a.depthFunc(a.GEQUAL);break;case 6:a.depthFunc(a.GREATER);break;case 7:a.depthFunc(a.NOTEQUAL);\nbreak;default:a.depthFunc(a.LEQUAL)}else a.depthFunc(a.LEQUAL);d=b}},setLocked:function(a){b=a},setClear:function(b){e!==b&&(a.clearDepth(b),e=b)},reset:function(){b=!1;e=d=c=null}}},l=new function(){var b=!1,c=null,d=null,e=null,f=null,k=null,m=null,n=null,q=null;return{setTest:function(b){b?g(a.STENCIL_TEST):h(a.STENCIL_TEST)},setMask:function(d){c===d||b||(a.stencilMask(d),c=d)},setFunc:function(b,c,g){if(d!==b||e!==c||f!==g)a.stencilFunc(b,c,g),d=b,e=c,f=g},setOp:function(b,c,d){if(k!==b||m!==\nc||n!==d)a.stencilOp(b,c,d),k=b,m=c,n=d},setLocked:function(a){b=a},setClear:function(b){q!==b&&(a.clearStencil(b),q=b)},reset:function(){b=!1;q=n=m=k=f=e=d=c=null}}},p=a.getParameter(a.MAX_VERTEX_ATTRIBS),x=new Uint8Array(p),w=new Uint8Array(p),B=new Uint8Array(p),E={},P=null,N=null,O=null,z=null,Sd=null,Td=null,Ud=null,A=null,D=null,C=!1,G=null,K=null,L=null,R=null,I=null,J=a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS),H=!1;p=0;p=a.getParameter(a.VERSION);-1!==p.indexOf(\"WebGL\")?(p=parseFloat(/^WebGL ([0-9])/.exec(p)[1]),\nH=1<=p):-1!==p.indexOf(\"OpenGL ES\")&&(p=parseFloat(/^OpenGL ES ([0-9])/.exec(p)[1]),H=2<=p);var Q=null,S={},Y=new V,W=new V,M={};M[a.TEXTURE_2D]=e(a.TEXTURE_2D,a.TEXTURE_2D,1);M[a.TEXTURE_CUBE_MAP]=e(a.TEXTURE_CUBE_MAP,a.TEXTURE_CUBE_MAP_POSITIVE_X,6);u.setClear(0,0,0,1);r.setClear(1);l.setClear(0);g(a.DEPTH_TEST);r.setFunc(3);m(!1);q(1);g(a.CULL_FACE);g(a.BLEND);k(1);return{buffers:{color:u,depth:r,stencil:l},initAttributes:function(){for(var a=0,b=x.length;a<b;a++)x[a]=0},enableAttribute:function(a){f(a,\n0)},enableAttributeAndDivisor:f,disableUnusedAttributes:function(){for(var b=0,c=w.length;b!==c;++b)w[b]!==x[b]&&(a.disableVertexAttribArray(b),w[b]=0)},enable:g,disable:h,getCompressedTextureFormats:function(){if(null===P&&(P=[],b.get(\"WEBGL_compressed_texture_pvrtc\")||b.get(\"WEBGL_compressed_texture_s3tc\")||b.get(\"WEBGL_compressed_texture_etc1\")||b.get(\"WEBGL_compressed_texture_astc\")))for(var c=a.getParameter(a.COMPRESSED_TEXTURE_FORMATS),d=0;d<c.length;d++)P.push(c[d]);return P},useProgram:function(b){return N!==\nb?(a.useProgram(b),N=b,!0):!1},setBlending:k,setMaterial:function(b,c){2===b.side?h(a.CULL_FACE):g(a.CULL_FACE);var d=1===b.side;c&&(d=!d);m(d);1===b.blending&&!1===b.transparent?k(0):k(b.blending,b.blendEquation,b.blendSrc,b.blendDst,b.blendEquationAlpha,b.blendSrcAlpha,b.blendDstAlpha,b.premultipliedAlpha);r.setFunc(b.depthFunc);r.setTest(b.depthTest);r.setMask(b.depthWrite);u.setMask(b.colorWrite);n(b.polygonOffset,b.polygonOffsetFactor,b.polygonOffsetUnits)},setFlipSided:m,setCullFace:q,setLineWidth:function(b){b!==\nL&&(H&&a.lineWidth(b),L=b)},setPolygonOffset:n,setScissorTest:function(b){b?g(a.SCISSOR_TEST):h(a.SCISSOR_TEST)},activeTexture:t,bindTexture:function(b,c){null===Q&&t();var d=S[Q];void 0===d&&(d={type:void 0,texture:void 0},S[Q]=d);if(d.type!==b||d.texture!==c)a.bindTexture(b,c||M[b]),d.type=b,d.texture=c},compressedTexImage2D:function(){try{a.compressedTexImage2D.apply(a,arguments)}catch(U){console.error(\"THREE.WebGLState:\",U)}},texImage2D:function(){try{a.texImage2D.apply(a,arguments)}catch(U){console.error(\"THREE.WebGLState:\",\nU)}},scissor:function(b){!1===Y.equals(b)&&(a.scissor(b.x,b.y,b.z,b.w),Y.copy(b))},viewport:function(b){!1===W.equals(b)&&(a.viewport(b.x,b.y,b.z,b.w),W.copy(b))},reset:function(){for(var b=0;b<w.length;b++)1===w[b]&&(a.disableVertexAttribArray(b),w[b]=0);E={};Q=P=null;S={};K=G=O=N=null;u.reset();r.reset();l.reset()}}}function Kg(a,b,c,d,e,f,g){function h(a,b){if(a.width>b||a.height>b){if(\"data\"in a){console.warn(\"THREE.WebGLRenderer: image in DataTexture is too big (\"+a.width+\"x\"+a.height+\").\");\nreturn}b/=Math.max(a.width,a.height);var c=document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"canvas\");c.width=Math.floor(a.width*b);c.height=Math.floor(a.height*b);c.getContext(\"2d\").drawImage(a,0,0,a.width,a.height,0,0,c.width,c.height);console.warn(\"THREE.WebGLRenderer: image is too big (\"+a.width+\"x\"+a.height+\"). Resized to \"+c.width+\"x\"+c.height);return c}return a}function k(a){return H.isPowerOfTwo(a.width)&&H.isPowerOfTwo(a.height)}function m(a,b){return a.generateMipmaps&&b&&1003!==\na.minFilter&&1006!==a.minFilter}function q(b,c,e,f){a.generateMipmap(b);d.get(c).__maxMipLevel=Math.log(Math.max(e,f))*Math.LOG2E}function n(b,c){if(!e.isWebGL2)return b;if(b===a.RGB){if(c===a.FLOAT)return a.RGB32F;if(c===a.HALF_FLOAT)return a.RGB16F;if(c===a.UNSIGNED_BYTE)return a.RGB8}if(b===a.RGBA){if(c===a.FLOAT)return a.RGBA32F;if(c===a.HALF_FLOAT)return a.RGBA16F;if(c===a.UNSIGNED_BYTE)return a.RGBA8}return b}function t(b){return 1003===b||1004===b||1005===b?a.NEAREST:a.LINEAR}function u(b){b=\nb.target;b.removeEventListener(\"dispose\",u);a:{var c=d.get(b);if(b.image&&c.__image__webglTextureCube)a.deleteTexture(c.__image__webglTextureCube);else{if(void 0===c.__webglInit)break a;a.deleteTexture(c.__webglTexture)}d.remove(b)}b.isVideoTexture&&delete B[b.id];g.memory.textures--}function r(b){b=b.target;b.removeEventListener(\"dispose\",r);var c=d.get(b),e=d.get(b.texture);if(b){void 0!==e.__webglTexture&&a.deleteTexture(e.__webglTexture);b.depthTexture&&b.depthTexture.dispose();if(b.isWebGLRenderTargetCube)for(e=\n0;6>e;e++)a.deleteFramebuffer(c.__webglFramebuffer[e]),c.__webglDepthbuffer&&a.deleteRenderbuffer(c.__webglDepthbuffer[e]);else a.deleteFramebuffer(c.__webglFramebuffer),c.__webglDepthbuffer&&a.deleteRenderbuffer(c.__webglDepthbuffer);d.remove(b.texture);d.remove(b)}g.memory.textures--}function l(b,t){var r=d.get(b);if(b.isVideoTexture){var l=b.id,v=g.render.frame;B[l]!==v&&(B[l]=v,b.update())}if(0<b.version&&r.__version!==b.version)if(l=b.image,void 0===l)console.warn(\"THREE.WebGLRenderer: Texture marked for update but image is undefined\");\nelse if(!1===l.complete)console.warn(\"THREE.WebGLRenderer: Texture marked for update but image is incomplete\");else{void 0===r.__webglInit&&(r.__webglInit=!0,b.addEventListener(\"dispose\",u),r.__webglTexture=a.createTexture(),g.memory.textures++);c.activeTexture(a.TEXTURE0+t);c.bindTexture(a.TEXTURE_2D,r.__webglTexture);a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,b.flipY);a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,b.premultiplyAlpha);a.pixelStorei(a.UNPACK_ALIGNMENT,b.unpackAlignment);t=h(b.image,e.maxTextureSize);\n(e.isWebGL2?0:1001!==b.wrapS||1001!==b.wrapT||1003!==b.minFilter&&1006!==b.minFilter)&&!1===k(t)&&(t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof ImageBitmap)&&(void 0===E&&(E=document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"canvas\")),E.width=H.floorPowerOfTwo(t.width),E.height=H.floorPowerOfTwo(t.height),E.getContext(\"2d\").drawImage(t,0,0,E.width,E.height),console.warn(\"THREE.WebGLRenderer: image is not power of two (\"+t.width+\"x\"+t.height+\"). Resized to \"+E.width+\n\"x\"+E.height),t=E);l=k(t);v=f.convert(b.format);var w=f.convert(b.type),y=n(v,w);p(a.TEXTURE_2D,b,l);var P=b.mipmaps;if(b.isDepthTexture){y=a.DEPTH_COMPONENT;if(1015===b.type){if(!e.isWebGL2)throw Error(\"Float Depth Texture only supported in WebGL2.0\");y=a.DEPTH_COMPONENT32F}else e.isWebGL2&&(y=a.DEPTH_COMPONENT16);1026===b.format&&y===a.DEPTH_COMPONENT&&1012!==b.type&&1014!==b.type&&(console.warn(\"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.\"),b.type=\n1012,w=f.convert(b.type));1027===b.format&&(y=a.DEPTH_STENCIL,1020!==b.type&&(console.warn(\"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.\"),b.type=1020,w=f.convert(b.type)));c.texImage2D(a.TEXTURE_2D,0,y,t.width,t.height,0,v,w,null)}else if(b.isDataTexture)if(0<P.length&&l){for(var N=0,x=P.length;N<x;N++){var z=P[N];c.texImage2D(a.TEXTURE_2D,N,y,z.width,z.height,0,v,w,z.data)}b.generateMipmaps=!1;r.__maxMipLevel=P.length-1}else c.texImage2D(a.TEXTURE_2D,0,y,t.width,\nt.height,0,v,w,t.data),r.__maxMipLevel=0;else if(b.isCompressedTexture){N=0;for(x=P.length;N<x;N++)z=P[N],1023!==b.format&&1022!==b.format?-1<c.getCompressedTextureFormats().indexOf(v)?c.compressedTexImage2D(a.TEXTURE_2D,N,y,z.width,z.height,0,z.data):console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\"):c.texImage2D(a.TEXTURE_2D,N,y,z.width,z.height,0,v,w,z.data);r.__maxMipLevel=P.length-1}else if(0<P.length&&l){N=0;for(x=P.length;N<x;N++)z=\nP[N],c.texImage2D(a.TEXTURE_2D,N,y,v,w,z);b.generateMipmaps=!1;r.__maxMipLevel=P.length-1}else c.texImage2D(a.TEXTURE_2D,0,y,v,w,t),r.__maxMipLevel=0;m(b,l)&&q(a.TEXTURE_2D,b,t.width,t.height);r.__version=b.version;if(b.onUpdate)b.onUpdate(b);return}c.activeTexture(a.TEXTURE0+t);c.bindTexture(a.TEXTURE_2D,r.__webglTexture)}function p(c,g,h){h?(a.texParameteri(c,a.TEXTURE_WRAP_S,f.convert(g.wrapS)),a.texParameteri(c,a.TEXTURE_WRAP_T,f.convert(g.wrapT)),a.texParameteri(c,a.TEXTURE_MAG_FILTER,f.convert(g.magFilter)),\na.texParameteri(c,a.TEXTURE_MIN_FILTER,f.convert(g.minFilter))):(a.texParameteri(c,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(c,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),1001===g.wrapS&&1001===g.wrapT||console.warn(\"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.\"),a.texParameteri(c,a.TEXTURE_MAG_FILTER,t(g.magFilter)),a.texParameteri(c,a.TEXTURE_MIN_FILTER,t(g.minFilter)),1003!==g.minFilter&&1006!==g.minFilter&&console.warn(\"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.\"));\n!(h=b.get(\"EXT_texture_filter_anisotropic\"))||1015===g.type&&null===b.get(\"OES_texture_float_linear\")||1016===g.type&&null===(e.isWebGL2||b.get(\"OES_texture_half_float_linear\"))||!(1<g.anisotropy||d.get(g).__currentAnisotropy)||(a.texParameterf(c,h.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(g.anisotropy,e.getMaxAnisotropy())),d.get(g).__currentAnisotropy=g.anisotropy)}function x(b,e,g,h){var k=f.convert(e.texture.format),m=f.convert(e.texture.type),q=n(k,m);c.texImage2D(h,0,q,e.width,e.height,0,k,m,null);\na.bindFramebuffer(a.FRAMEBUFFER,b);a.framebufferTexture2D(a.FRAMEBUFFER,g,h,d.get(e.texture).__webglTexture,0);a.bindFramebuffer(a.FRAMEBUFFER,null)}function w(b,c){a.bindRenderbuffer(a.RENDERBUFFER,b);c.depthBuffer&&!c.stencilBuffer?(a.renderbufferStorage(a.RENDERBUFFER,a.DEPTH_COMPONENT16,c.width,c.height),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.DEPTH_ATTACHMENT,a.RENDERBUFFER,b)):c.depthBuffer&&c.stencilBuffer?(a.renderbufferStorage(a.RENDERBUFFER,a.DEPTH_STENCIL,c.width,c.height),a.framebufferRenderbuffer(a.FRAMEBUFFER,\na.DEPTH_STENCIL_ATTACHMENT,a.RENDERBUFFER,b)):a.renderbufferStorage(a.RENDERBUFFER,a.RGBA4,c.width,c.height);a.bindRenderbuffer(a.RENDERBUFFER,null)}var B={},E;this.setTexture2D=l;this.setTextureCube=function(b,t){var r=d.get(b);if(6===b.image.length)if(0<b.version&&r.__version!==b.version){r.__image__webglTextureCube||(b.addEventListener(\"dispose\",u),r.__image__webglTextureCube=a.createTexture(),g.memory.textures++);c.activeTexture(a.TEXTURE0+t);c.bindTexture(a.TEXTURE_CUBE_MAP,r.__image__webglTextureCube);\na.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,b.flipY);t=b&&b.isCompressedTexture;for(var l=b.image[0]&&b.image[0].isDataTexture,v=[],w=0;6>w;w++)v[w]=t||l?l?b.image[w].image:b.image[w]:h(b.image[w],e.maxCubemapSize);var y=v[0],E=k(y),P=f.convert(b.format),x=f.convert(b.type),N=n(P,x);p(a.TEXTURE_CUBE_MAP,b,E);for(w=0;6>w;w++)if(t)for(var B,z=v[w].mipmaps,A=0,D=z.length;A<D;A++)B=z[A],1023!==b.format&&1022!==b.format?-1<c.getCompressedTextureFormats().indexOf(P)?c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+\nw,A,N,B.width,B.height,0,B.data):console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\"):c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+w,A,N,B.width,B.height,0,P,x,B.data);else l?c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+w,0,N,v[w].width,v[w].height,0,P,x,v[w].data):c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+w,0,N,P,x,v[w]);r.__maxMipLevel=t?z.length-1:0;m(b,E)&&q(a.TEXTURE_CUBE_MAP,b,y.width,y.height);r.__version=b.version;if(b.onUpdate)b.onUpdate(b)}else c.activeTexture(a.TEXTURE0+\nt),c.bindTexture(a.TEXTURE_CUBE_MAP,r.__image__webglTextureCube)};this.setTextureCubeDynamic=function(b,e){c.activeTexture(a.TEXTURE0+e);c.bindTexture(a.TEXTURE_CUBE_MAP,d.get(b).__webglTexture)};this.setupRenderTarget=function(b){var e=d.get(b),f=d.get(b.texture);b.addEventListener(\"dispose\",r);f.__webglTexture=a.createTexture();g.memory.textures++;var h=!0===b.isWebGLRenderTargetCube,n=k(b);if(h){e.__webglFramebuffer=[];for(var t=0;6>t;t++)e.__webglFramebuffer[t]=a.createFramebuffer()}else e.__webglFramebuffer=\na.createFramebuffer();if(h){c.bindTexture(a.TEXTURE_CUBE_MAP,f.__webglTexture);p(a.TEXTURE_CUBE_MAP,b.texture,n);for(t=0;6>t;t++)x(e.__webglFramebuffer[t],b,a.COLOR_ATTACHMENT0,a.TEXTURE_CUBE_MAP_POSITIVE_X+t);m(b.texture,n)&&q(a.TEXTURE_CUBE_MAP,b.texture,b.width,b.height);c.bindTexture(a.TEXTURE_CUBE_MAP,null)}else c.bindTexture(a.TEXTURE_2D,f.__webglTexture),p(a.TEXTURE_2D,b.texture,n),x(e.__webglFramebuffer,b,a.COLOR_ATTACHMENT0,a.TEXTURE_2D),m(b.texture,n)&&q(a.TEXTURE_2D,b.texture,b.width,b.height),\nc.bindTexture(a.TEXTURE_2D,null);if(b.depthBuffer){e=d.get(b);f=!0===b.isWebGLRenderTargetCube;if(b.depthTexture){if(f)throw Error(\"target.depthTexture not supported in Cube render targets\");if(b&&b.isWebGLRenderTargetCube)throw Error(\"Depth Texture with cube render targets is not supported\");a.bindFramebuffer(a.FRAMEBUFFER,e.__webglFramebuffer);if(!b.depthTexture||!b.depthTexture.isDepthTexture)throw Error(\"renderTarget.depthTexture must be an instance of THREE.DepthTexture\");d.get(b.depthTexture).__webglTexture&&\nb.depthTexture.image.width===b.width&&b.depthTexture.image.height===b.height||(b.depthTexture.image.width=b.width,b.depthTexture.image.height=b.height,b.depthTexture.needsUpdate=!0);l(b.depthTexture,0);e=d.get(b.depthTexture).__webglTexture;if(1026===b.depthTexture.format)a.framebufferTexture2D(a.FRAMEBUFFER,a.DEPTH_ATTACHMENT,a.TEXTURE_2D,e,0);else if(1027===b.depthTexture.format)a.framebufferTexture2D(a.FRAMEBUFFER,a.DEPTH_STENCIL_ATTACHMENT,a.TEXTURE_2D,e,0);else throw Error(\"Unknown depthTexture format\");\n}else if(f)for(e.__webglDepthbuffer=[],f=0;6>f;f++)a.bindFramebuffer(a.FRAMEBUFFER,e.__webglFramebuffer[f]),e.__webglDepthbuffer[f]=a.createRenderbuffer(),w(e.__webglDepthbuffer[f],b);else a.bindFramebuffer(a.FRAMEBUFFER,e.__webglFramebuffer),e.__webglDepthbuffer=a.createRenderbuffer(),w(e.__webglDepthbuffer,b);a.bindFramebuffer(a.FRAMEBUFFER,null)}};this.updateRenderTargetMipmap=function(b){var e=b.texture,f=k(b);if(m(e,f)){f=b.isWebGLRenderTargetCube?a.TEXTURE_CUBE_MAP:a.TEXTURE_2D;var g=d.get(e).__webglTexture;\nc.bindTexture(f,g);q(f,e,b.width,b.height);c.bindTexture(f,null)}}}function $e(a,b,c){return{convert:function(d){if(1E3===d)return a.REPEAT;if(1001===d)return a.CLAMP_TO_EDGE;if(1002===d)return a.MIRRORED_REPEAT;if(1003===d)return a.NEAREST;if(1004===d)return a.NEAREST_MIPMAP_NEAREST;if(1005===d)return a.NEAREST_MIPMAP_LINEAR;if(1006===d)return a.LINEAR;if(1007===d)return a.LINEAR_MIPMAP_NEAREST;if(1008===d)return a.LINEAR_MIPMAP_LINEAR;if(1009===d)return a.UNSIGNED_BYTE;if(1017===d)return a.UNSIGNED_SHORT_4_4_4_4;\nif(1018===d)return a.UNSIGNED_SHORT_5_5_5_1;if(1019===d)return a.UNSIGNED_SHORT_5_6_5;if(1010===d)return a.BYTE;if(1011===d)return a.SHORT;if(1012===d)return a.UNSIGNED_SHORT;if(1013===d)return a.INT;if(1014===d)return a.UNSIGNED_INT;if(1015===d)return a.FLOAT;if(1016===d){if(c.isWebGL2)return a.HALF_FLOAT;var e=b.get(\"OES_texture_half_float\");if(null!==e)return e.HALF_FLOAT_OES}if(1021===d)return a.ALPHA;if(1022===d)return a.RGB;if(1023===d)return a.RGBA;if(1024===d)return a.LUMINANCE;if(1025===\nd)return a.LUMINANCE_ALPHA;if(1026===d)return a.DEPTH_COMPONENT;if(1027===d)return a.DEPTH_STENCIL;if(100===d)return a.FUNC_ADD;if(101===d)return a.FUNC_SUBTRACT;if(102===d)return a.FUNC_REVERSE_SUBTRACT;if(200===d)return a.ZERO;if(201===d)return a.ONE;if(202===d)return a.SRC_COLOR;if(203===d)return a.ONE_MINUS_SRC_COLOR;if(204===d)return a.SRC_ALPHA;if(205===d)return a.ONE_MINUS_SRC_ALPHA;if(206===d)return a.DST_ALPHA;if(207===d)return a.ONE_MINUS_DST_ALPHA;if(208===d)return a.DST_COLOR;if(209===\nd)return a.ONE_MINUS_DST_COLOR;if(210===d)return a.SRC_ALPHA_SATURATE;if(33776===d||33777===d||33778===d||33779===d)if(e=b.get(\"WEBGL_compressed_texture_s3tc\"),null!==e){if(33776===d)return e.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===d)return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===d)return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===d)return e.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===d||35841===d||35842===d||35843===d)if(e=b.get(\"WEBGL_compressed_texture_pvrtc\"),null!==e){if(35840===d)return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\nif(35841===d)return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===d)return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===d)return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===d&&(e=b.get(\"WEBGL_compressed_texture_etc1\"),null!==e))return e.COMPRESSED_RGB_ETC1_WEBGL;if(37808===d||37809===d||37810===d||37811===d||37812===d||37813===d||37814===d||37815===d||37816===d||37817===d||37818===d||37819===d||37820===d||37821===d)if(e=b.get(\"WEBGL_compressed_texture_astc\"),null!==e)return d;if(103===d||104===\nd){if(c.isWebGL2){if(103===d)return a.MIN;if(104===d)return a.MAX}e=b.get(\"EXT_blend_minmax\");if(null!==e){if(103===d)return e.MIN_EXT;if(104===d)return e.MAX_EXT}}if(1020===d){if(c.isWebGL2)return a.UNSIGNED_INT_24_8;e=b.get(\"WEBGL_depth_texture\");if(null!==e)return e.UNSIGNED_INT_24_8_WEBGL}return 0}}}function Kb(){D.call(this);this.type=\"Group\"}function Z(a,b,c,d){Na.call(this);this.type=\"PerspectiveCamera\";this.fov=void 0!==a?a:50;this.zoom=1;this.near=void 0!==c?c:.1;this.far=void 0!==d?d:2E3;\nthis.focus=10;this.aspect=void 0!==b?b:1;this.view=null;this.filmGauge=35;this.filmOffset=0;this.updateProjectionMatrix()}function yc(a){Z.call(this);this.cameras=a||[]}function af(a){function b(){return null!==e&&!0===e.isPresenting}function c(){if(b()){var c=e.getEyeParameters(\"left\"),f=c.renderWidth;c=c.renderHeight;x=a.getPixelRatio();y=a.getSize();a.setDrawingBufferSize(2*f,c,1);B.start()}else d.enabled&&(a.setDrawingBufferSize(y.width,y.height,x),B.stop())}var d=this,e=null,f=null,g=null,h=\n[],k=new I,m=new I;\"undefined\"!==typeof window&&\"VRFrameData\"in window&&(f=new window.VRFrameData,window.addEventListener(\"vrdisplaypresentchange\",c,!1));var q=new I,n=new fa,t=new p,u=new Z;u.bounds=new V(0,0,.5,1);u.layers.enable(1);var r=new Z;r.bounds=new V(.5,0,.5,1);r.layers.enable(2);var l=new yc([u,r]);l.layers.enable(1);l.layers.enable(2);var y,x,w=[];this.enabled=!1;this.userHeight=1.6;this.getController=function(a){var b=h[a];void 0===b&&(b=new Kb,b.matrixAutoUpdate=!1,b.visible=!1,h[a]=\nb);return b};this.getDevice=function(){return e};this.setDevice=function(a){void 0!==a&&(e=a);B.setContext(a)};this.setPoseTarget=function(a){void 0!==a&&(g=a)};this.getCamera=function(a){if(null===e)return a.position.set(0,d.userHeight,0),a;e.depthNear=a.near;e.depthFar=a.far;e.getFrameData(f);var b=e.stageParameters;b?k.fromArray(b.sittingToStandingTransform):k.makeTranslation(0,d.userHeight,0);b=f.pose;var c=null!==g?g:a;c.matrix.copy(k);c.matrix.decompose(c.position,c.quaternion,c.scale);null!==\nb.orientation&&(n.fromArray(b.orientation),c.quaternion.multiply(n));null!==b.position&&(n.setFromRotationMatrix(k),t.fromArray(b.position),t.applyQuaternion(n),c.position.add(t));c.updateMatrixWorld();if(!1===e.isPresenting)return a;u.near=a.near;r.near=a.near;u.far=a.far;r.far=a.far;l.matrixWorld.copy(a.matrixWorld);l.matrixWorldInverse.copy(a.matrixWorldInverse);u.matrixWorldInverse.fromArray(f.leftViewMatrix);r.matrixWorldInverse.fromArray(f.rightViewMatrix);m.getInverse(k);u.matrixWorldInverse.multiply(m);\nr.matrixWorldInverse.multiply(m);a=c.parent;null!==a&&(q.getInverse(a.matrixWorld),u.matrixWorldInverse.multiply(q),r.matrixWorldInverse.multiply(q));u.matrixWorld.getInverse(u.matrixWorldInverse);r.matrixWorld.getInverse(r.matrixWorldInverse);u.projectionMatrix.fromArray(f.leftProjectionMatrix);r.projectionMatrix.fromArray(f.rightProjectionMatrix);l.projectionMatrix.copy(u.projectionMatrix);a=e.getLayers();a.length&&(a=a[0],null!==a.leftBounds&&4===a.leftBounds.length&&u.bounds.fromArray(a.leftBounds),\nnull!==a.rightBounds&&4===a.rightBounds.length&&r.bounds.fromArray(a.rightBounds));a:for(a=0;a<h.length;a++){b=h[a];b:{c=a;for(var v=navigator.getGamepads&&navigator.getGamepads(),p=0,y=0,x=v.length;p<x;p++){var E=v[p];if(E&&(\"Daydream Controller\"===E.id||\"Gear VR Controller\"===E.id||\"Oculus Go Controller\"===E.id||\"OpenVR Gamepad\"===E.id||E.id.startsWith(\"Oculus Touch\")||E.id.startsWith(\"Spatial Controller\"))){if(y===c){c=E;break b}y++}}c=void 0}if(void 0!==c&&void 0!==c.pose){if(null===c.pose)break a;\nv=c.pose;!1===v.hasPosition&&b.position.set(.2,-.6,-.05);null!==v.position&&b.position.fromArray(v.position);null!==v.orientation&&b.quaternion.fromArray(v.orientation);b.matrix.compose(b.position,b.quaternion,b.scale);b.matrix.premultiply(k);b.matrix.decompose(b.position,b.quaternion,b.scale);b.matrixWorldNeedsUpdate=!0;b.visible=!0;v=\"Daydream Controller\"===c.id?0:1;w[a]!==c.buttons[v].pressed&&(w[a]=c.buttons[v].pressed,!0===w[a]?b.dispatchEvent({type:\"selectstart\"}):(b.dispatchEvent({type:\"selectend\"}),\nb.dispatchEvent({type:\"select\"})))}else b.visible=!1}return l};this.getStandingMatrix=function(){return k};this.isPresenting=b;var B=new Qd;this.setAnimationLoop=function(a){B.setAnimationLoop(a)};this.submitFrame=function(){b()&&e.submitFrame()};this.dispose=function(){\"undefined\"!==typeof window&&window.removeEventListener(\"vrdisplaypresentchange\",c)}}function Lg(a){function b(){return null!==h&&null!==k}function c(a){var b=q[n.indexOf(a.inputSource)];b&&b.dispatchEvent({type:a.type})}function d(){a.setFramebuffer(null);\np.stop()}function e(a,b){null===b?a.matrixWorld.copy(a.matrix):a.matrixWorld.multiplyMatrices(b.matrixWorld,a.matrix);a.matrixWorldInverse.getInverse(a.matrixWorld)}var f=a.context,g=null,h=null,k=null,m=null,q=[],n=[],t=new Z;t.layers.enable(1);t.viewport=new V;var u=new Z;u.layers.enable(2);u.viewport=new V;var r=new yc([t,u]);r.layers.enable(1);r.layers.enable(2);this.enabled=!1;this.getController=function(a){var b=q[a];void 0===b&&(b=new Kb,b.matrixAutoUpdate=!1,b.visible=!1,q[a]=b);return b};\nthis.getDevice=function(){return g};this.setDevice=function(a){void 0!==a&&(g=a);a instanceof XRDevice&&f.setCompatibleXRDevice(a)};this.setSession=function(b,e){h=b;null!==h&&(h.addEventListener(\"select\",c),h.addEventListener(\"selectstart\",c),h.addEventListener(\"selectend\",c),h.addEventListener(\"end\",d),h.baseLayer=new XRWebGLLayer(h,f),h.requestFrameOfReference(e.frameOfReferenceType).then(function(b){k=b;a.setFramebuffer(h.baseLayer.framebuffer);p.setContext(h);p.start()}),n=h.getInputSources(),\nh.addEventListener(\"inputsourceschange\",function(){n=h.getInputSources();console.log(n)}))};this.getCamera=function(a){if(b()){var c=a.parent,d=r.cameras;e(r,c);for(var f=0;f<d.length;f++)e(d[f],c);a.matrixWorld.copy(r.matrixWorld);a=a.children;f=0;for(c=a.length;f<c;f++)a[f].updateMatrixWorld(!0);return r}return a};this.isPresenting=b;var l=null,p=new Qd;p.setAnimationLoop(function(a,b){m=b.getDevicePose(k);if(null!==m)for(var c=h.baseLayer,d=b.views,e=0;e<d.length;e++){var f=d[e],g=c.getViewport(f),\nt=m.getViewMatrix(f),u=r.cameras[e];u.matrix.fromArray(t).getInverse(u.matrix);u.projectionMatrix.fromArray(f.projectionMatrix);u.viewport.set(g.x,g.y,g.width,g.height);0===e&&(r.matrix.copy(u.matrix),r.projectionMatrix.copy(u.projectionMatrix))}for(e=0;e<q.length;e++){c=q[e];if(d=n[e])if(d=b.getInputPose(d,k),null!==d){c.matrix.elements=d.pointerMatrix;c.matrix.decompose(c.position,c.rotation,c.scale);c.visible=!0;continue}c.visible=!1}l&&l(a)});this.setAnimationLoop=function(a){l=a};this.dispose=\nfunction(){};this.getStandingMatrix=function(){console.warn(\"THREE.WebXRManager: getStandingMatrix() is no longer needed.\");return new THREE.Matrix4};this.submitFrame=function(){}}function Zd(a){var b;function c(){ha=new Pf(F);ua=new Nf(F,ha,a);ua.isWebGL2||(ha.get(\"WEBGL_depth_texture\"),ha.get(\"OES_texture_float\"),ha.get(\"OES_texture_half_float\"),ha.get(\"OES_texture_half_float_linear\"),ha.get(\"OES_standard_derivatives\"),ha.get(\"OES_element_index_uint\"),ha.get(\"ANGLE_instanced_arrays\"));ha.get(\"OES_texture_float_linear\");\nda=new $e(F,ha,ua);ba=new Jg(F,ha,da,ua);ba.scissor(wc.copy(fa).multiplyScalar(U));ba.viewport(T.copy(od).multiplyScalar(U));ca=new Sf(F);Ba=new Ag;ia=new Kg(F,ha,ba,Ba,ua,da,ca);pa=new Ff(F);ra=new Qf(F,pa,ca);ma=new Vf(ra,ca);va=new Uf(F);la=new zg(C,ha,ua);sa=new Eg;na=new Ig;ka=new Lf(C,ba,ma,N);xa=new Mf(F,ha,ca,ua);ya=new Rf(F,ha,ca,ua);ca.programs=la.programs;C.context=F;C.capabilities=ua;C.extensions=ha;C.properties=Ba;C.renderLists=sa;C.state=ba;C.info=ca}function d(a){a.preventDefault();\nconsole.log(\"THREE.WebGLRenderer: Context Lost.\");G=!0}function e(){console.log(\"THREE.WebGLRenderer: Context Restored.\");G=!1;c()}function f(a){a=a.target;a.removeEventListener(\"dispose\",f);g(a);Ba.remove(a)}function g(a){var b=Ba.get(a).program;a.program=void 0;void 0!==b&&la.releaseProgram(b)}function h(a,b){a.render(function(a){C.renderBufferImmediate(a,b)})}function k(a,b,c){if(!1!==a.visible){if(a.layers.test(b.layers))if(a.isLight)D.pushLight(a),a.castShadow&&D.pushShadow(a);else if(a.isSprite){if(!a.frustumCulled||\noa.intersectsSprite(a)){c&&bb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(xc);var d=ma.update(a),e=a.material;A.push(a,d,e,bb.z,null)}}else if(a.isImmediateRenderObject)c&&bb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(xc),A.push(a,null,a.material,bb.z,null);else if(a.isMesh||a.isLine||a.isPoints)if(a.isSkinnedMesh&&a.skeleton.update(),!a.frustumCulled||oa.intersectsObject(a))if(c&&bb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(xc),d=ma.update(a),e=a.material,Array.isArray(e))for(var f=\nd.groups,g=0,h=f.length;g<h;g++){var m=f[g],n=e[m.materialIndex];n&&n.visible&&A.push(a,d,n,bb.z,m)}else e.visible&&A.push(a,d,e,bb.z,null);a=a.children;g=0;for(h=a.length;g<h;g++)k(a[g],b,c)}}function m(a,b,c,d){for(var e=0,f=a.length;e<f;e++){var g=a[e],h=g.object,k=g.geometry,m=void 0===d?g.material:d;g=g.group;if(c.isArrayCamera){W=c;for(var n=c.cameras,t=0,u=n.length;t<u;t++){var l=n[t];if(h.layers.test(l.layers)){if(\"viewport\"in l)ba.viewport(T.copy(l.viewport));else{var r=l.bounds;ba.viewport(T.set(r.x*\nZ,r.y*M,r.z*Z,r.w*M).multiplyScalar(U))}q(h,b,l,k,m,g)}}}else W=null,q(h,b,c,k,m,g)}}function q(a,c,d,e,f,g){a.onBeforeRender(C,c,d,e,f,g);D=na.get(c,W||d);a.modelViewMatrix.multiplyMatrices(d.matrixWorldInverse,a.matrixWorld);a.normalMatrix.getNormalMatrix(a.modelViewMatrix);if(a.isImmediateRenderObject){ba.setMaterial(f);var k=t(d,c.fog,f,a);S=b=null;nd=!1;h(a,k)}else C.renderBufferDirect(d,c.fog,e,f,a,g);a.onAfterRender(C,c,d,e,f,g);D=na.get(c,W||d)}function n(a,b,c){var d=Ba.get(a),e=D.state.lights,\nh=d.lightsHash,k=e.state.hash;c=la.getParameters(a,e.state,D.state.shadowsArray,b,aa.numPlanes,aa.numIntersection,c);var m=la.getProgramCode(a,c),n=d.program,q=!0;if(void 0===n)a.addEventListener(\"dispose\",f);else if(n.code!==m)g(a);else{if(h.stateID!==k.stateID||h.directionalLength!==k.directionalLength||h.pointLength!==k.pointLength||h.spotLength!==k.spotLength||h.rectAreaLength!==k.rectAreaLength||h.hemiLength!==k.hemiLength||h.shadowsLength!==k.shadowsLength)h.stateID=k.stateID,h.directionalLength=\nk.directionalLength,h.pointLength=k.pointLength,h.spotLength=k.spotLength,h.rectAreaLength=k.rectAreaLength,h.hemiLength=k.hemiLength,h.shadowsLength=k.shadowsLength;else if(void 0!==c.shaderID)return;q=!1}q&&(c.shaderID?(m=nb[c.shaderID],d.shader={name:a.type,uniforms:Aa.clone(m.uniforms),vertexShader:m.vertexShader,fragmentShader:m.fragmentShader}):d.shader={name:a.type,uniforms:a.uniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader},a.onBeforeCompile(d.shader,C),m=la.getProgramCode(a,\nc),n=la.acquireProgram(a,d.shader,c,m),d.program=n,a.program=n);c=n.getAttributes();if(a.morphTargets)for(m=a.numSupportedMorphTargets=0;m<C.maxMorphTargets;m++)0<=c[\"morphTarget\"+m]&&a.numSupportedMorphTargets++;if(a.morphNormals)for(m=a.numSupportedMorphNormals=0;m<C.maxMorphNormals;m++)0<=c[\"morphNormal\"+m]&&a.numSupportedMorphNormals++;c=d.shader.uniforms;if(!a.isShaderMaterial&&!a.isRawShaderMaterial||!0===a.clipping)d.numClippingPlanes=aa.numPlanes,d.numIntersection=aa.numIntersection,c.clippingPlanes=\naa.uniform;d.fog=b;void 0===h&&(d.lightsHash=h={});h.stateID=k.stateID;h.directionalLength=k.directionalLength;h.pointLength=k.pointLength;h.spotLength=k.spotLength;h.rectAreaLength=k.rectAreaLength;h.hemiLength=k.hemiLength;h.shadowsLength=k.shadowsLength;a.lights&&(c.ambientLightColor.value=e.state.ambient,c.directionalLights.value=e.state.directional,c.spotLights.value=e.state.spot,c.rectAreaLights.value=e.state.rectArea,c.pointLights.value=e.state.point,c.hemisphereLights.value=e.state.hemi,c.directionalShadowMap.value=\ne.state.directionalShadowMap,c.directionalShadowMatrix.value=e.state.directionalShadowMatrix,c.spotShadowMap.value=e.state.spotShadowMap,c.spotShadowMatrix.value=e.state.spotShadowMatrix,c.pointShadowMap.value=e.state.pointShadowMap,c.pointShadowMatrix.value=e.state.pointShadowMatrix);a=d.program.getUniforms();a=Za.seqWithValue(a.seq,c);d.uniformsList=a}function t(a,b,c,d){X=0;var e=Ba.get(c),f=e.lightsHash,g=D.state.lights.state.hash;pd&&(Yd||a!==Y)&&aa.setState(c.clippingPlanes,c.clipIntersection,\nc.clipShadows,a,e,a===Y&&c.id===J);!1===c.needsUpdate&&(void 0===e.program?c.needsUpdate=!0:c.fog&&e.fog!==b?c.needsUpdate=!0:!c.lights||f.stateID===g.stateID&&f.directionalLength===g.directionalLength&&f.pointLength===g.pointLength&&f.spotLength===g.spotLength&&f.rectAreaLength===g.rectAreaLength&&f.hemiLength===g.hemiLength&&f.shadowsLength===g.shadowsLength?void 0===e.numClippingPlanes||e.numClippingPlanes===aa.numPlanes&&e.numIntersection===aa.numIntersection||(c.needsUpdate=!0):c.needsUpdate=\n!0);c.needsUpdate&&(n(c,b,d),c.needsUpdate=!1);var h=!1,k=!1,m=!1;f=e.program;g=f.getUniforms();var q=e.shader.uniforms;ba.useProgram(f.program)&&(m=k=h=!0);c.id!==J&&(J=c.id,k=!0);if(h||a!==Y){g.setValue(F,\"projectionMatrix\",a.projectionMatrix);ua.logarithmicDepthBuffer&&g.setValue(F,\"logDepthBufFC\",2/(Math.log(a.far+1)/Math.LN2));Y!==(W||a)&&(Y=W||a,m=k=!0);if(c.isShaderMaterial||c.isMeshPhongMaterial||c.isMeshStandardMaterial||c.envMap)h=g.map.cameraPosition,void 0!==h&&h.setValue(F,bb.setFromMatrixPosition(a.matrixWorld));\n(c.isMeshPhongMaterial||c.isMeshLambertMaterial||c.isMeshBasicMaterial||c.isMeshStandardMaterial||c.isShaderMaterial||c.skinning)&&g.setValue(F,\"viewMatrix\",a.matrixWorldInverse)}if(c.skinning&&(g.setOptional(F,d,\"bindMatrix\"),g.setOptional(F,d,\"bindMatrixInverse\"),a=d.skeleton))if(h=a.bones,ua.floatVertexTextures){if(void 0===a.boneTexture){h=Math.sqrt(4*h.length);h=H.ceilPowerOfTwo(h);h=Math.max(h,4);var t=new Float32Array(h*h*4);t.set(a.boneMatrices);var v=new gb(t,h,h,1023,1015);v.needsUpdate=\n!0;a.boneMatrices=t;a.boneTexture=v;a.boneTextureSize=h}g.setValue(F,\"boneTexture\",a.boneTexture);g.setValue(F,\"boneTextureSize\",a.boneTextureSize)}else g.setOptional(F,a,\"boneMatrices\");k&&(g.setValue(F,\"toneMappingExposure\",C.toneMappingExposure),g.setValue(F,\"toneMappingWhitePoint\",C.toneMappingWhitePoint),c.lights&&(k=m,q.ambientLightColor.needsUpdate=k,q.directionalLights.needsUpdate=k,q.pointLights.needsUpdate=k,q.spotLights.needsUpdate=k,q.rectAreaLights.needsUpdate=k,q.hemisphereLights.needsUpdate=\nk),b&&c.fog&&(q.fogColor.value=b.color,b.isFog?(q.fogNear.value=b.near,q.fogFar.value=b.far):b.isFogExp2&&(q.fogDensity.value=b.density)),c.isMeshBasicMaterial?u(q,c):c.isMeshLambertMaterial?(u(q,c),c.emissiveMap&&(q.emissiveMap.value=c.emissiveMap)):c.isMeshPhongMaterial?(u(q,c),c.isMeshToonMaterial?(r(q,c),c.gradientMap&&(q.gradientMap.value=c.gradientMap)):r(q,c)):c.isMeshStandardMaterial?(u(q,c),c.isMeshPhysicalMaterial?(l(q,c),q.reflectivity.value=c.reflectivity,q.clearCoat.value=c.clearCoat,\nq.clearCoatRoughness.value=c.clearCoatRoughness):l(q,c)):c.isMeshDepthMaterial?(u(q,c),c.displacementMap&&(q.displacementMap.value=c.displacementMap,q.displacementScale.value=c.displacementScale,q.displacementBias.value=c.displacementBias)):c.isMeshDistanceMaterial?(u(q,c),c.displacementMap&&(q.displacementMap.value=c.displacementMap,q.displacementScale.value=c.displacementScale,q.displacementBias.value=c.displacementBias),q.referencePosition.value.copy(c.referencePosition),q.nearDistance.value=c.nearDistance,\nq.farDistance.value=c.farDistance):c.isMeshNormalMaterial?(u(q,c),c.bumpMap&&(q.bumpMap.value=c.bumpMap,q.bumpScale.value=c.bumpScale,1===c.side&&(q.bumpScale.value*=-1)),c.normalMap&&(q.normalMap.value=c.normalMap,q.normalScale.value.copy(c.normalScale),1===c.side&&q.normalScale.value.negate()),c.displacementMap&&(q.displacementMap.value=c.displacementMap,q.displacementScale.value=c.displacementScale,q.displacementBias.value=c.displacementBias)):c.isLineBasicMaterial?(q.diffuse.value=c.color,q.opacity.value=\nc.opacity,c.isLineDashedMaterial&&(q.dashSize.value=c.dashSize,q.totalSize.value=c.dashSize+c.gapSize,q.scale.value=c.scale)):c.isPointsMaterial?(q.diffuse.value=c.color,q.opacity.value=c.opacity,q.size.value=c.size*U,q.scale.value=.5*M,q.map.value=c.map,null!==c.map&&(!0===c.map.matrixAutoUpdate&&c.map.updateMatrix(),q.uvTransform.value.copy(c.map.matrix))):c.isSpriteMaterial?(q.diffuse.value=c.color,q.opacity.value=c.opacity,q.rotation.value=c.rotation,q.map.value=c.map,null!==c.map&&(!0===c.map.matrixAutoUpdate&&\nc.map.updateMatrix(),q.uvTransform.value.copy(c.map.matrix))):c.isShadowMaterial&&(q.color.value=c.color,q.opacity.value=c.opacity),void 0!==q.ltc_1&&(q.ltc_1.value=K.LTC_1),void 0!==q.ltc_2&&(q.ltc_2.value=K.LTC_2),Za.upload(F,e.uniformsList,q,C));c.isShaderMaterial&&!0===c.uniformsNeedUpdate&&(Za.upload(F,e.uniformsList,q,C),c.uniformsNeedUpdate=!1);c.isSpriteMaterial&&g.setValue(F,\"center\",d.center);g.setValue(F,\"modelViewMatrix\",d.modelViewMatrix);g.setValue(F,\"normalMatrix\",d.normalMatrix);g.setValue(F,\n\"modelMatrix\",d.matrixWorld);return f}function u(a,b){a.opacity.value=b.opacity;b.color&&(a.diffuse.value=b.color);b.emissive&&a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity);b.map&&(a.map.value=b.map);b.alphaMap&&(a.alphaMap.value=b.alphaMap);b.specularMap&&(a.specularMap.value=b.specularMap);b.envMap&&(a.envMap.value=b.envMap,a.flipEnvMap.value=b.envMap&&b.envMap.isCubeTexture?-1:1,a.reflectivity.value=b.reflectivity,a.refractionRatio.value=b.refractionRatio,a.maxMipLevel.value=\nBa.get(b.envMap).__maxMipLevel);b.lightMap&&(a.lightMap.value=b.lightMap,a.lightMapIntensity.value=b.lightMapIntensity);b.aoMap&&(a.aoMap.value=b.aoMap,a.aoMapIntensity.value=b.aoMapIntensity);if(b.map)var c=b.map;else b.specularMap?c=b.specularMap:b.displacementMap?c=b.displacementMap:b.normalMap?c=b.normalMap:b.bumpMap?c=b.bumpMap:b.roughnessMap?c=b.roughnessMap:b.metalnessMap?c=b.metalnessMap:b.alphaMap?c=b.alphaMap:b.emissiveMap&&(c=b.emissiveMap);void 0!==c&&(c.isWebGLRenderTarget&&(c=c.texture),\n!0===c.matrixAutoUpdate&&c.updateMatrix(),a.uvTransform.value.copy(c.matrix))}function r(a,b){a.specular.value=b.specular;a.shininess.value=Math.max(b.shininess,1E-4);b.emissiveMap&&(a.emissiveMap.value=b.emissiveMap);b.bumpMap&&(a.bumpMap.value=b.bumpMap,a.bumpScale.value=b.bumpScale,1===b.side&&(a.bumpScale.value*=-1));b.normalMap&&(a.normalMap.value=b.normalMap,a.normalScale.value.copy(b.normalScale),1===b.side&&a.normalScale.value.negate());b.displacementMap&&(a.displacementMap.value=b.displacementMap,\na.displacementScale.value=b.displacementScale,a.displacementBias.value=b.displacementBias)}function l(a,b){a.roughness.value=b.roughness;a.metalness.value=b.metalness;b.roughnessMap&&(a.roughnessMap.value=b.roughnessMap);b.metalnessMap&&(a.metalnessMap.value=b.metalnessMap);b.emissiveMap&&(a.emissiveMap.value=b.emissiveMap);b.bumpMap&&(a.bumpMap.value=b.bumpMap,a.bumpScale.value=b.bumpScale,1===b.side&&(a.bumpScale.value*=-1));b.normalMap&&(a.normalMap.value=b.normalMap,a.normalScale.value.copy(b.normalScale),\n1===b.side&&a.normalScale.value.negate());b.displacementMap&&(a.displacementMap.value=b.displacementMap,a.displacementScale.value=b.displacementScale,a.displacementBias.value=b.displacementBias);b.envMap&&(a.envMapIntensity.value=b.envMapIntensity)}console.log(\"THREE.WebGLRenderer\",\"95\");a=a||{};var y=void 0!==a.canvas?a.canvas:document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"canvas\"),x=void 0!==a.context?a.context:null,w=void 0!==a.alpha?a.alpha:!1,B=void 0!==a.depth?a.depth:!0,E=void 0!==\na.stencil?a.stencil:!0,P=void 0!==a.antialias?a.antialias:!1,N=void 0!==a.premultipliedAlpha?a.premultipliedAlpha:!0,O=void 0!==a.preserveDrawingBuffer?a.preserveDrawingBuffer:!1,z=void 0!==a.powerPreference?a.powerPreference:\"default\",A=null,D=null;this.domElement=y;this.context=null;this.sortObjects=this.autoClearStencil=this.autoClearDepth=this.autoClearColor=this.autoClear=!0;this.clippingPlanes=[];this.localClippingEnabled=!1;this.gammaFactor=2;this.physicallyCorrectLights=this.gammaOutput=this.gammaInput=\n!1;this.toneMappingWhitePoint=this.toneMappingExposure=this.toneMapping=1;this.maxMorphTargets=8;this.maxMorphNormals=4;var C=this,G=!1,L=null,R=null,Q=null,J=-1;var S=b=null;var nd=!1;var Y=null,W=null,T=new V,wc=new V,ea=null,X=0,Z=y.width,M=y.height,U=1,od=new V(0,0,Z,M),fa=new V(0,0,Z,M),qa=!1,oa=new md,aa=new Of,pd=!1,Yd=!1,xc=new I,bb=new p;try{w={alpha:w,depth:B,stencil:E,antialias:P,premultipliedAlpha:N,preserveDrawingBuffer:O,powerPreference:z};y.addEventListener(\"webglcontextlost\",d,!1);\ny.addEventListener(\"webglcontextrestored\",e,!1);var F=x||y.getContext(\"webgl\",w)||y.getContext(\"experimental-webgl\",w);if(null===F){if(null!==y.getContext(\"webgl\"))throw Error(\"Error creating WebGL context with your selected attributes.\");throw Error(\"Error creating WebGL context.\");}void 0===F.getShaderPrecisionFormat&&(F.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Mg){console.error(\"THREE.WebGLRenderer: \"+Mg.message)}var ha,ua,ba,ca,Ba,ia,pa,ra,ma,la,sa,\nna,ka,va,xa,ya,da;c();var ja=\"xr\"in navigator?new Lg(C):new af(C);this.vr=ja;var za=new Ze(C,ma,ua.maxTextureSize);this.shadowMap=za;this.getContext=function(){return F};this.getContextAttributes=function(){return F.getContextAttributes()};this.forceContextLoss=function(){var a=ha.get(\"WEBGL_lose_context\");a&&a.loseContext()};this.forceContextRestore=function(){var a=ha.get(\"WEBGL_lose_context\");a&&a.restoreContext()};this.getPixelRatio=function(){return U};this.setPixelRatio=function(a){void 0!==\na&&(U=a,this.setSize(Z,M,!1))};this.getSize=function(){return{width:Z,height:M}};this.setSize=function(a,b,c){ja.isPresenting()?console.warn(\"THREE.WebGLRenderer: Can't change size while VR device is presenting.\"):(Z=a,M=b,y.width=a*U,y.height=b*U,!1!==c&&(y.style.width=a+\"px\",y.style.height=b+\"px\"),this.setViewport(0,0,a,b))};this.getDrawingBufferSize=function(){return{width:Z*U,height:M*U}};this.setDrawingBufferSize=function(a,b,c){Z=a;M=b;U=c;y.width=a*c;y.height=b*c;this.setViewport(0,0,a,b)};\nthis.getCurrentViewport=function(){return T};this.setViewport=function(a,b,c,d){od.set(a,M-b-d,c,d);ba.viewport(T.copy(od).multiplyScalar(U))};this.setScissor=function(a,b,c,d){fa.set(a,M-b-d,c,d);ba.scissor(wc.copy(fa).multiplyScalar(U))};this.setScissorTest=function(a){ba.setScissorTest(qa=a)};this.getClearColor=function(){return ka.getClearColor()};this.setClearColor=function(){ka.setClearColor.apply(ka,arguments)};this.getClearAlpha=function(){return ka.getClearAlpha()};this.setClearAlpha=function(){ka.setClearAlpha.apply(ka,\narguments)};this.clear=function(a,b,c){var d=0;if(void 0===a||a)d|=F.COLOR_BUFFER_BIT;if(void 0===b||b)d|=F.DEPTH_BUFFER_BIT;if(void 0===c||c)d|=F.STENCIL_BUFFER_BIT;F.clear(d)};this.clearColor=function(){this.clear(!0,!1,!1)};this.clearDepth=function(){this.clear(!1,!0,!1)};this.clearStencil=function(){this.clear(!1,!1,!0)};this.clearTarget=function(a,b,c,d){this.setRenderTarget(a);this.clear(b,c,d)};this.dispose=function(){y.removeEventListener(\"webglcontextlost\",d,!1);y.removeEventListener(\"webglcontextrestored\",\ne,!1);sa.dispose();na.dispose();Ba.dispose();ma.dispose();ja.dispose();ta.stop()};this.renderBufferImmediate=function(a,b){ba.initAttributes();var c=Ba.get(a);a.hasPositions&&!c.position&&(c.position=F.createBuffer());a.hasNormals&&!c.normal&&(c.normal=F.createBuffer());a.hasUvs&&!c.uv&&(c.uv=F.createBuffer());a.hasColors&&!c.color&&(c.color=F.createBuffer());b=b.getAttributes();a.hasPositions&&(F.bindBuffer(F.ARRAY_BUFFER,c.position),F.bufferData(F.ARRAY_BUFFER,a.positionArray,F.DYNAMIC_DRAW),ba.enableAttribute(b.position),\nF.vertexAttribPointer(b.position,3,F.FLOAT,!1,0,0));a.hasNormals&&(F.bindBuffer(F.ARRAY_BUFFER,c.normal),F.bufferData(F.ARRAY_BUFFER,a.normalArray,F.DYNAMIC_DRAW),ba.enableAttribute(b.normal),F.vertexAttribPointer(b.normal,3,F.FLOAT,!1,0,0));a.hasUvs&&(F.bindBuffer(F.ARRAY_BUFFER,c.uv),F.bufferData(F.ARRAY_BUFFER,a.uvArray,F.DYNAMIC_DRAW),ba.enableAttribute(b.uv),F.vertexAttribPointer(b.uv,2,F.FLOAT,!1,0,0));a.hasColors&&(F.bindBuffer(F.ARRAY_BUFFER,c.color),F.bufferData(F.ARRAY_BUFFER,a.colorArray,\nF.DYNAMIC_DRAW),ba.enableAttribute(b.color),F.vertexAttribPointer(b.color,3,F.FLOAT,!1,0,0));ba.disableUnusedAttributes();F.drawArrays(F.TRIANGLES,0,a.count);a.count=0};this.renderBufferDirect=function(a,c,d,e,f,g){var h=f.isMesh&&0>f.normalMatrix.determinant();ba.setMaterial(e,h);var k=t(a,c,e,f),m=!1;if(b!==d.id||S!==k.id||nd!==(!0===e.wireframe))b=d.id,S=k.id,nd=!0===e.wireframe,m=!0;f.morphTargetInfluences&&(va.update(f,d,e,k),m=!0);h=d.index;var q=d.attributes.position;c=1;!0===e.wireframe&&\n(h=ra.getWireframeAttribute(d),c=2);a=xa;if(null!==h){var n=pa.get(h);a=ya;a.setIndex(n)}if(m){if(d&&d.isInstancedBufferGeometry&!ua.isWebGL2&&null===ha.get(\"ANGLE_instanced_arrays\"))console.error(\"THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\");else{ba.initAttributes();m=d.attributes;k=k.getAttributes();var u=e.defaultAttributeValues;for(N in k){var l=k[N];if(0<=l){var r=m[N];if(void 0!==r){var v=r.normalized,\np=r.itemSize,w=pa.get(r);if(void 0!==w){var y=w.buffer,E=w.type;w=w.bytesPerElement;if(r.isInterleavedBufferAttribute){var x=r.data,B=x.stride;r=r.offset;x&&x.isInstancedInterleavedBuffer?(ba.enableAttributeAndDivisor(l,x.meshPerAttribute),void 0===d.maxInstancedCount&&(d.maxInstancedCount=x.meshPerAttribute*x.count)):ba.enableAttribute(l);F.bindBuffer(F.ARRAY_BUFFER,y);F.vertexAttribPointer(l,p,E,v,B*w,r*w)}else r.isInstancedBufferAttribute?(ba.enableAttributeAndDivisor(l,r.meshPerAttribute),void 0===\nd.maxInstancedCount&&(d.maxInstancedCount=r.meshPerAttribute*r.count)):ba.enableAttribute(l),F.bindBuffer(F.ARRAY_BUFFER,y),F.vertexAttribPointer(l,p,E,v,0,0)}}else if(void 0!==u&&(v=u[N],void 0!==v))switch(v.length){case 2:F.vertexAttrib2fv(l,v);break;case 3:F.vertexAttrib3fv(l,v);break;case 4:F.vertexAttrib4fv(l,v);break;default:F.vertexAttrib1fv(l,v)}}}ba.disableUnusedAttributes()}null!==h&&F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,n.buffer)}n=Infinity;null!==h?n=h.count:void 0!==q&&(n=q.count);h=d.drawRange.start*\nc;q=null!==g?g.start*c:0;var N=Math.max(h,q);g=Math.max(0,Math.min(n,h+d.drawRange.count*c,q+(null!==g?g.count*c:Infinity))-1-N+1);if(0!==g){if(f.isMesh)if(!0===e.wireframe)ba.setLineWidth(e.wireframeLinewidth*(null===R?U:1)),a.setMode(F.LINES);else switch(f.drawMode){case 0:a.setMode(F.TRIANGLES);break;case 1:a.setMode(F.TRIANGLE_STRIP);break;case 2:a.setMode(F.TRIANGLE_FAN)}else f.isLine?(e=e.linewidth,void 0===e&&(e=1),ba.setLineWidth(e*(null===R?U:1)),f.isLineSegments?a.setMode(F.LINES):f.isLineLoop?\na.setMode(F.LINE_LOOP):a.setMode(F.LINE_STRIP)):f.isPoints?a.setMode(F.POINTS):f.isSprite&&a.setMode(F.TRIANGLES);d&&d.isInstancedBufferGeometry?0<d.maxInstancedCount&&a.renderInstances(d,N,g):a.render(N,g)}};this.compile=function(a,b){D=na.get(a,b);D.init();a.traverse(function(a){a.isLight&&(D.pushLight(a),a.castShadow&&D.pushShadow(a))});D.setupLights(b);a.traverse(function(b){if(b.material)if(Array.isArray(b.material))for(var c=0;c<b.material.length;c++)n(b.material[c],a.fog,b);else n(b.material,\na.fog,b)})};var wa=null,ta=new Qd;ta.setAnimationLoop(function(a){ja.isPresenting()||wa&&wa(a)});\"undefined\"!==typeof window&&ta.setContext(window);this.setAnimationLoop=function(a){wa=a;ja.setAnimationLoop(a);ta.start()};this.render=function(a,c,d,e){if(!c||!c.isCamera)console.error(\"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\");else if(!G){S=b=null;nd=!1;J=-1;Y=null;!0===a.autoUpdate&&a.updateMatrixWorld();null===c.parent&&c.updateMatrixWorld();ja.enabled&&(c=ja.getCamera(c));\nD=na.get(a,c);D.init();a.onBeforeRender(C,a,c,d);xc.multiplyMatrices(c.projectionMatrix,c.matrixWorldInverse);oa.setFromMatrix(xc);Yd=this.localClippingEnabled;pd=aa.init(this.clippingPlanes,Yd,c);A=sa.get(a,c);A.init();k(a,c,C.sortObjects);!0===C.sortObjects&&A.sort();pd&&aa.beginShadows();za.render(D.state.shadowsArray,a,c);D.setupLights(c);pd&&aa.endShadows();this.info.autoReset&&this.info.reset();void 0===d&&(d=null);this.setRenderTarget(d);ka.render(A,a,c,e);e=A.opaque;var f=A.transparent;if(a.overrideMaterial){var g=\na.overrideMaterial;e.length&&m(e,a,c,g);f.length&&m(f,a,c,g)}else e.length&&m(e,a,c),f.length&&m(f,a,c);d&&ia.updateRenderTargetMipmap(d);ba.buffers.depth.setTest(!0);ba.buffers.depth.setMask(!0);ba.buffers.color.setMask(!0);ba.setPolygonOffset(!1);a.onAfterRender(C,a,c);ja.enabled&&ja.submitFrame();D=A=null}};this.allocTextureUnit=function(){var a=X;a>=ua.maxTextures&&console.warn(\"THREE.WebGLRenderer: Trying to use \"+a+\" texture units while this GPU supports only \"+ua.maxTextures);X+=1;return a};\nthis.setTexture2D=function(){var a=!1;return function(b,c){b&&b.isWebGLRenderTarget&&(a||(console.warn(\"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\"),a=!0),b=b.texture);ia.setTexture2D(b,c)}}();this.setTexture=function(){var a=!1;return function(b,c){a||(console.warn(\"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\"),a=!0);ia.setTexture2D(b,c)}}();this.setTextureCube=function(){var a=!1;return function(b,c){b&&\nb.isWebGLRenderTargetCube&&(a||(console.warn(\"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\"),a=!0),b=b.texture);b&&b.isCubeTexture||Array.isArray(b.image)&&6===b.image.length?ia.setTextureCube(b,c):ia.setTextureCubeDynamic(b,c)}}();this.setFramebuffer=function(a){L=a};this.getRenderTarget=function(){return R};this.setRenderTarget=function(a){(R=a)&&void 0===Ba.get(a).__webglFramebuffer&&ia.setupRenderTarget(a);var b=L,c=!1;a?(b=\nBa.get(a).__webglFramebuffer,a.isWebGLRenderTargetCube&&(b=b[a.activeCubeFace],c=!0),T.copy(a.viewport),wc.copy(a.scissor),ea=a.scissorTest):(T.copy(od).multiplyScalar(U),wc.copy(fa).multiplyScalar(U),ea=qa);Q!==b&&(F.bindFramebuffer(F.FRAMEBUFFER,b),Q=b);ba.viewport(T);ba.scissor(wc);ba.setScissorTest(ea);c&&(c=Ba.get(a.texture),F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_CUBE_MAP_POSITIVE_X+a.activeCubeFace,c.__webglTexture,a.activeMipMapLevel))};this.readRenderTargetPixels=\nfunction(a,b,c,d,e,f){if(a&&a.isWebGLRenderTarget){var g=Ba.get(a).__webglFramebuffer;if(g){var h=!1;g!==Q&&(F.bindFramebuffer(F.FRAMEBUFFER,g),h=!0);try{var k=a.texture,m=k.format,q=k.type;1023!==m&&da.convert(m)!==F.getParameter(F.IMPLEMENTATION_COLOR_READ_FORMAT)?console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.\"):1009===q||da.convert(q)===F.getParameter(F.IMPLEMENTATION_COLOR_READ_TYPE)||1015===q&&(ua.isWebGL2||ha.get(\"OES_texture_float\")||\nha.get(\"WEBGL_color_buffer_float\"))||1016===q&&(ua.isWebGL2?ha.get(\"EXT_color_buffer_float\"):ha.get(\"EXT_color_buffer_half_float\"))?F.checkFramebufferStatus(F.FRAMEBUFFER)===F.FRAMEBUFFER_COMPLETE?0<=b&&b<=a.width-d&&0<=c&&c<=a.height-e&&F.readPixels(b,c,d,e,da.convert(m),da.convert(q),f):console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.\"):console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.\")}finally{h&&\nF.bindFramebuffer(F.FRAMEBUFFER,Q)}}}else console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.\")};this.copyFramebufferToTexture=function(a,b,c){var d=b.image.width,e=b.image.height,f=da.convert(b.format);this.setTexture2D(b,0);F.copyTexImage2D(F.TEXTURE_2D,c||0,f,a.x,a.y,d,e,0)};this.copyTextureToTexture=function(a,b,c,d){var e=b.image.width,f=b.image.height,g=da.convert(c.format),h=da.convert(c.type);this.setTexture2D(c,0);b.isDataTexture?F.texSubImage2D(F.TEXTURE_2D,\nd||0,a.x,a.y,e,f,g,h,b.image.data):F.texSubImage2D(F.TEXTURE_2D,d||0,a.x,a.y,g,h,b.image)}}function Lb(a,b){this.name=\"\";this.color=new G(a);this.density=void 0!==b?b:2.5E-4}function Mb(a,b,c){this.name=\"\";this.color=new G(a);this.near=void 0!==b?b:1;this.far=void 0!==c?c:1E3}function qd(){D.call(this);this.type=\"Scene\";this.overrideMaterial=this.fog=this.background=null;this.autoUpdate=!0}function ob(a,b){this.array=a;this.stride=b;this.count=void 0!==a?a.length/b:0;this.dynamic=!1;this.updateRange=\n{offset:0,count:-1};this.version=0}function zc(a,b,c,d){this.data=a;this.itemSize=b;this.offset=c;this.normalized=!0===d}function cb(a){J.call(this);this.type=\"SpriteMaterial\";this.color=new G(16777215);this.map=null;this.rotation=0;this.lights=!1;this.transparent=!0;this.setValues(a)}function Ac(a){D.call(this);this.type=\"Sprite\";if(void 0===Nb){Nb=new C;var b=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]);b=new ob(b,5);Nb.setIndex([0,1,2,0,2,3]);Nb.addAttribute(\"position\",\nnew zc(b,3,0,!1));Nb.addAttribute(\"uv\",new zc(b,2,3,!1))}this.geometry=Nb;this.material=void 0!==a?a:new cb;this.center=new z(.5,.5)}function Bc(){D.call(this);this.type=\"LOD\";Object.defineProperties(this,{levels:{enumerable:!0,value:[]}})}function Cc(a,b){a=a||[];this.bones=a.slice(0);this.boneMatrices=new Float32Array(16*this.bones.length);if(void 0===b)this.calculateInverses();else if(this.bones.length===b.length)this.boneInverses=b.slice(0);else for(console.warn(\"THREE.Skeleton boneInverses is the wrong length.\"),\nthis.boneInverses=[],a=0,b=this.bones.length;a<b;a++)this.boneInverses.push(new I)}function rd(){D.call(this);this.type=\"Bone\"}function sd(a,b){la.call(this,a,b);this.type=\"SkinnedMesh\";this.bindMode=\"attached\";this.bindMatrix=new I;this.bindMatrixInverse=new I;a=this.initBones();a=new Cc(a);this.bind(a,this.matrixWorld);this.normalizeSkinWeights()}function Y(a){J.call(this);this.type=\"LineBasicMaterial\";this.color=new G(16777215);this.linewidth=1;this.linejoin=this.linecap=\"round\";this.lights=!1;\nthis.setValues(a)}function sa(a,b,c){1===c&&console.error(\"THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.\");D.call(this);this.type=\"Line\";this.geometry=void 0!==a?a:new C;this.material=void 0!==b?b:new Y({color:16777215*Math.random()})}function W(a,b){sa.call(this,a,b);this.type=\"LineSegments\"}function td(a,b){sa.call(this,a,b);this.type=\"LineLoop\"}function Ea(a){J.call(this);this.type=\"PointsMaterial\";this.color=new G(16777215);this.map=null;this.size=\n1;this.sizeAttenuation=!0;this.lights=this.morphTargets=!1;this.setValues(a)}function Ob(a,b){D.call(this);this.type=\"Points\";this.geometry=void 0!==a?a:new C;this.material=void 0!==b?b:new Ea({color:16777215*Math.random()})}function $d(a,b,c,d,e,f,g,h,k){T.call(this,a,b,c,d,e,f,g,h,k);this.generateMipmaps=!1}function Pb(a,b,c,d,e,f,g,h,k,m,q,n){T.call(this,null,f,g,h,k,m,d,e,q,n);this.image={width:b,height:c};this.mipmaps=a;this.generateMipmaps=this.flipY=!1}function Dc(a,b,c,d,e,f,g,h,k){T.call(this,\na,b,c,d,e,f,g,h,k);this.needsUpdate=!0}function Ec(a,b,c,d,e,f,g,h,k,m){m=void 0!==m?m:1026;if(1026!==m&&1027!==m)throw Error(\"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat\");void 0===c&&1026===m&&(c=1012);void 0===c&&1027===m&&(c=1020);T.call(this,null,d,e,f,g,h,m,c,k);this.image={width:a,height:b};this.magFilter=void 0!==g?g:1003;this.minFilter=void 0!==h?h:1003;this.generateMipmaps=this.flipY=!1}function Qb(a){C.call(this);this.type=\"WireframeGeometry\";var b=\n[],c,d,e,f=[0,0],g={},h=[\"a\",\"b\",\"c\"];if(a&&a.isGeometry){var k=a.faces;var m=0;for(d=k.length;m<d;m++){var q=k[m];for(c=0;3>c;c++){var n=q[h[c]];var t=q[h[(c+1)%3]];f[0]=Math.min(n,t);f[1]=Math.max(n,t);n=f[0]+\",\"+f[1];void 0===g[n]&&(g[n]={index1:f[0],index2:f[1]})}}for(n in g)m=g[n],h=a.vertices[m.index1],b.push(h.x,h.y,h.z),h=a.vertices[m.index2],b.push(h.x,h.y,h.z)}else if(a&&a.isBufferGeometry)if(h=new p,null!==a.index){k=a.attributes.position;q=a.index;var u=a.groups;0===u.length&&(u=[{start:0,\ncount:q.count,materialIndex:0}]);a=0;for(e=u.length;a<e;++a)for(m=u[a],c=m.start,d=m.count,m=c,d=c+d;m<d;m+=3)for(c=0;3>c;c++)n=q.getX(m+c),t=q.getX(m+(c+1)%3),f[0]=Math.min(n,t),f[1]=Math.max(n,t),n=f[0]+\",\"+f[1],void 0===g[n]&&(g[n]={index1:f[0],index2:f[1]});for(n in g)m=g[n],h.fromBufferAttribute(k,m.index1),b.push(h.x,h.y,h.z),h.fromBufferAttribute(k,m.index2),b.push(h.x,h.y,h.z)}else for(k=a.attributes.position,m=0,d=k.count/3;m<d;m++)for(c=0;3>c;c++)g=3*m+c,h.fromBufferAttribute(k,g),b.push(h.x,\nh.y,h.z),g=3*m+(c+1)%3,h.fromBufferAttribute(k,g),b.push(h.x,h.y,h.z);this.addAttribute(\"position\",new A(b,3))}function Fc(a,b,c){R.call(this);this.type=\"ParametricGeometry\";this.parameters={func:a,slices:b,stacks:c};this.fromBufferGeometry(new Rb(a,b,c));this.mergeVertices()}function Rb(a,b,c){C.call(this);this.type=\"ParametricBufferGeometry\";this.parameters={func:a,slices:b,stacks:c};var d=[],e=[],f=[],g=[],h=new p,k=new p,m=new p,q=new p,n=new p,t,u;3>a.length&&console.error(\"THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.\");\nvar r=b+1;for(t=0;t<=c;t++){var l=t/c;for(u=0;u<=b;u++){var y=u/b;a(y,l,k);e.push(k.x,k.y,k.z);0<=y-1E-5?(a(y-1E-5,l,m),q.subVectors(k,m)):(a(y+1E-5,l,m),q.subVectors(m,k));0<=l-1E-5?(a(y,l-1E-5,m),n.subVectors(k,m)):(a(y,l+1E-5,m),n.subVectors(m,k));h.crossVectors(q,n).normalize();f.push(h.x,h.y,h.z);g.push(y,l)}}for(t=0;t<c;t++)for(u=0;u<b;u++)a=t*r+u+1,h=(t+1)*r+u+1,k=(t+1)*r+u,d.push(t*r+u,a,k),d.push(a,h,k);this.setIndex(d);this.addAttribute(\"position\",new A(e,3));this.addAttribute(\"normal\",\nnew A(f,3));this.addAttribute(\"uv\",new A(g,2))}function Gc(a,b,c,d){R.call(this);this.type=\"PolyhedronGeometry\";this.parameters={vertices:a,indices:b,radius:c,detail:d};this.fromBufferGeometry(new na(a,b,c,d));this.mergeVertices()}function na(a,b,c,d){function e(a){h.push(a.x,a.y,a.z)}function f(b,c){b*=3;c.x=a[b+0];c.y=a[b+1];c.z=a[b+2]}function g(a,b,c,d){0>d&&1===a.x&&(k[b]=a.x-1);0===c.x&&0===c.z&&(k[b]=d/2/Math.PI+.5)}C.call(this);this.type=\"PolyhedronBufferGeometry\";this.parameters={vertices:a,\nindices:b,radius:c,detail:d};c=c||1;d=d||0;var h=[],k=[];(function(a){for(var c=new p,d=new p,g=new p,h=0;h<b.length;h+=3){f(b[h+0],c);f(b[h+1],d);f(b[h+2],g);var k,m,l=c,x=d,w=g,B=Math.pow(2,a),E=[];for(m=0;m<=B;m++){E[m]=[];var P=l.clone().lerp(w,m/B),N=x.clone().lerp(w,m/B),O=B-m;for(k=0;k<=O;k++)E[m][k]=0===k&&m===B?P:P.clone().lerp(N,k/O)}for(m=0;m<B;m++)for(k=0;k<2*(B-m)-1;k++)l=Math.floor(k/2),0===k%2?(e(E[m][l+1]),e(E[m+1][l]),e(E[m][l])):(e(E[m][l+1]),e(E[m+1][l+1]),e(E[m+1][l]))}})(d);(function(a){for(var b=\nnew p,c=0;c<h.length;c+=3)b.x=h[c+0],b.y=h[c+1],b.z=h[c+2],b.normalize().multiplyScalar(a),h[c+0]=b.x,h[c+1]=b.y,h[c+2]=b.z})(c);(function(){for(var a=new p,b=0;b<h.length;b+=3)a.x=h[b+0],a.y=h[b+1],a.z=h[b+2],k.push(Math.atan2(a.z,-a.x)/2/Math.PI+.5,1-(Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))/Math.PI+.5));a=new p;b=new p;for(var c=new p,d=new p,e=new z,f=new z,l=new z,y=0,x=0;y<h.length;y+=9,x+=6){a.set(h[y+0],h[y+1],h[y+2]);b.set(h[y+3],h[y+4],h[y+5]);c.set(h[y+6],h[y+7],h[y+8]);e.set(k[x+0],\nk[x+1]);f.set(k[x+2],k[x+3]);l.set(k[x+4],k[x+5]);d.copy(a).add(b).add(c).divideScalar(3);var w=Math.atan2(d.z,-d.x);g(e,x+0,a,w);g(f,x+2,b,w);g(l,x+4,c,w)}for(a=0;a<k.length;a+=6)b=k[a+0],c=k[a+2],d=k[a+4],e=Math.min(b,c,d),.9<Math.max(b,c,d)&&.1>e&&(.2>b&&(k[a+0]+=1),.2>c&&(k[a+2]+=1),.2>d&&(k[a+4]+=1))})();this.addAttribute(\"position\",new A(h,3));this.addAttribute(\"normal\",new A(h.slice(),3));this.addAttribute(\"uv\",new A(k,2));0===d?this.computeVertexNormals():this.normalizeNormals()}function Hc(a,\nb){R.call(this);this.type=\"TetrahedronGeometry\";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new Sb(a,b));this.mergeVertices()}function Sb(a,b){na.call(this,[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],a,b);this.type=\"TetrahedronBufferGeometry\";this.parameters={radius:a,detail:b}}function Ic(a,b){R.call(this);this.type=\"OctahedronGeometry\";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new pb(a,b));this.mergeVertices()}function pb(a,b){na.call(this,[1,0,0,\n-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],a,b);this.type=\"OctahedronBufferGeometry\";this.parameters={radius:a,detail:b}}function Jc(a,b){R.call(this);this.type=\"IcosahedronGeometry\";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new Tb(a,b));this.mergeVertices()}function Tb(a,b){var c=(1+Math.sqrt(5))/2;na.call(this,[-1,c,0,1,c,0,-1,-c,0,1,-c,0,0,-1,c,0,1,c,0,-1,-c,0,1,-c,c,0,-1,c,0,1,-c,0,-1,-c,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,\n11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],a,b);this.type=\"IcosahedronBufferGeometry\";this.parameters={radius:a,detail:b}}function Kc(a,b){R.call(this);this.type=\"DodecahedronGeometry\";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new Ub(a,b));this.mergeVertices()}function Ub(a,b){var c=(1+Math.sqrt(5))/2,d=1/c;na.call(this,[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-d,-c,0,-d,c,0,d,-c,0,d,c,-d,-c,0,-d,c,0,d,-c,0,d,c,\n0,-c,0,-d,c,0,-d,-c,0,d,c,0,d],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],a,b);this.type=\"DodecahedronBufferGeometry\";this.parameters={radius:a,detail:b}}function Lc(a,b,c,d,e,f){R.call(this);this.type=\"TubeGeometry\";this.parameters={path:a,tubularSegments:b,radius:c,radialSegments:d,\nclosed:e};void 0!==f&&console.warn(\"THREE.TubeGeometry: taper has been removed.\");a=new Vb(a,b,c,d,e);this.tangents=a.tangents;this.normals=a.normals;this.binormals=a.binormals;this.fromBufferGeometry(a);this.mergeVertices()}function Vb(a,b,c,d,e){function f(e){q=a.getPointAt(e/b,q);var f=g.normals[e];e=g.binormals[e];for(t=0;t<=d;t++){var m=t/d*Math.PI*2,n=Math.sin(m);m=-Math.cos(m);k.x=m*f.x+n*e.x;k.y=m*f.y+n*e.y;k.z=m*f.z+n*e.z;k.normalize();r.push(k.x,k.y,k.z);h.x=q.x+c*k.x;h.y=q.y+c*k.y;h.z=\nq.z+c*k.z;l.push(h.x,h.y,h.z)}}C.call(this);this.type=\"TubeBufferGeometry\";this.parameters={path:a,tubularSegments:b,radius:c,radialSegments:d,closed:e};b=b||64;c=c||1;d=d||8;e=e||!1;var g=a.computeFrenetFrames(b,e);this.tangents=g.tangents;this.normals=g.normals;this.binormals=g.binormals;var h=new p,k=new p,m=new z,q=new p,n,t,l=[],r=[],v=[],y=[];for(n=0;n<b;n++)f(n);f(!1===e?b:0);for(n=0;n<=b;n++)for(t=0;t<=d;t++)m.x=n/b,m.y=t/d,v.push(m.x,m.y);(function(){for(t=1;t<=b;t++)for(n=1;n<=d;n++){var a=\n(d+1)*t+(n-1),c=(d+1)*t+n,e=(d+1)*(t-1)+n;y.push((d+1)*(t-1)+(n-1),a,e);y.push(a,c,e)}})();this.setIndex(y);this.addAttribute(\"position\",new A(l,3));this.addAttribute(\"normal\",new A(r,3));this.addAttribute(\"uv\",new A(v,2))}function Mc(a,b,c,d,e,f,g){R.call(this);this.type=\"TorusKnotGeometry\";this.parameters={radius:a,tube:b,tubularSegments:c,radialSegments:d,p:e,q:f};void 0!==g&&console.warn(\"THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.\");this.fromBufferGeometry(new Wb(a,\nb,c,d,e,f));this.mergeVertices()}function Wb(a,b,c,d,e,f){function g(a,b,c,d,e){var f=Math.sin(a);b=c/b*a;c=Math.cos(b);e.x=d*(2+c)*.5*Math.cos(a);e.y=d*(2+c)*f*.5;e.z=d*Math.sin(b)*.5}C.call(this);this.type=\"TorusKnotBufferGeometry\";this.parameters={radius:a,tube:b,tubularSegments:c,radialSegments:d,p:e,q:f};a=a||1;b=b||.4;c=Math.floor(c)||64;d=Math.floor(d)||8;e=e||2;f=f||3;var h=[],k=[],m=[],q=[],n,t=new p,l=new p,r=new p,v=new p,y=new p,x=new p,w=new p;for(n=0;n<=c;++n){var B=n/c*e*Math.PI*2;\ng(B,e,f,a,r);g(B+.01,e,f,a,v);x.subVectors(v,r);w.addVectors(v,r);y.crossVectors(x,w);w.crossVectors(y,x);y.normalize();w.normalize();for(B=0;B<=d;++B){var E=B/d*Math.PI*2,P=-b*Math.cos(E);E=b*Math.sin(E);t.x=r.x+(P*w.x+E*y.x);t.y=r.y+(P*w.y+E*y.y);t.z=r.z+(P*w.z+E*y.z);k.push(t.x,t.y,t.z);l.subVectors(t,r).normalize();m.push(l.x,l.y,l.z);q.push(n/c);q.push(B/d)}}for(B=1;B<=c;B++)for(n=1;n<=d;n++)a=(d+1)*B+(n-1),b=(d+1)*B+n,e=(d+1)*(B-1)+n,h.push((d+1)*(B-1)+(n-1),a,e),h.push(a,b,e);this.setIndex(h);\nthis.addAttribute(\"position\",new A(k,3));this.addAttribute(\"normal\",new A(m,3));this.addAttribute(\"uv\",new A(q,2))}function Nc(a,b,c,d,e){R.call(this);this.type=\"TorusGeometry\";this.parameters={radius:a,tube:b,radialSegments:c,tubularSegments:d,arc:e};this.fromBufferGeometry(new Xb(a,b,c,d,e));this.mergeVertices()}function Xb(a,b,c,d,e){C.call(this);this.type=\"TorusBufferGeometry\";this.parameters={radius:a,tube:b,radialSegments:c,tubularSegments:d,arc:e};a=a||1;b=b||.4;c=Math.floor(c)||8;d=Math.floor(d)||\n6;e=e||2*Math.PI;var f=[],g=[],h=[],k=[],m=new p,q=new p,n=new p,t,l;for(t=0;t<=c;t++)for(l=0;l<=d;l++){var r=l/d*e,v=t/c*Math.PI*2;q.x=(a+b*Math.cos(v))*Math.cos(r);q.y=(a+b*Math.cos(v))*Math.sin(r);q.z=b*Math.sin(v);g.push(q.x,q.y,q.z);m.x=a*Math.cos(r);m.y=a*Math.sin(r);n.subVectors(q,m).normalize();h.push(n.x,n.y,n.z);k.push(l/d);k.push(t/c)}for(t=1;t<=c;t++)for(l=1;l<=d;l++)a=(d+1)*(t-1)+l-1,b=(d+1)*(t-1)+l,e=(d+1)*t+l,f.push((d+1)*t+l-1,a,e),f.push(a,b,e);this.setIndex(f);this.addAttribute(\"position\",\nnew A(g,3));this.addAttribute(\"normal\",new A(h,3));this.addAttribute(\"uv\",new A(k,2))}function bf(a,b,c,d,e){for(var f,g=0,h=b,k=c-d;h<c;h+=d)g+=(a[k]-a[h])*(a[h+1]+a[k+1]),k=h;if(e===0<g)for(e=b;e<c;e+=d)f=cf(e,a[e],a[e+1],f);else for(e=c-d;e>=b;e-=d)f=cf(e,a[e],a[e+1],f);f&&qb(f,f.next)&&(Oc(f),f=f.next);return f}function Pc(a,b){if(!a)return a;b||(b=a);do{var c=!1;if(a.steiner||!qb(a,a.next)&&0!==ma(a.prev,a,a.next))a=a.next;else{Oc(a);a=b=a.prev;if(a===a.next)break;c=!0}}while(c||a!==b);return b}\nfunction Qc(a,b,c,d,e,f,g){if(a){if(!g&&f){var h=a,k=h;do null===k.z&&(k.z=ae(k.x,k.y,d,e,f)),k.prevZ=k.prev,k=k.nextZ=k.next;while(k!==h);k.prevZ.nextZ=null;k.prevZ=null;h=k;var m,q,n,t,l=1;do{k=h;var r=h=null;for(q=0;k;){q++;var v=k;for(m=n=0;m<l&&(n++,v=v.nextZ,v);m++);for(t=l;0<n||0<t&&v;)0!==n&&(0===t||!v||k.z<=v.z)?(m=k,k=k.nextZ,n--):(m=v,v=v.nextZ,t--),r?r.nextZ=m:h=m,m.prevZ=r,r=m;k=v}r.nextZ=null;l*=2}while(1<q)}for(h=a;a.prev!==a.next;){k=a.prev;v=a.next;if(f)a:{r=a;t=d;var p=e,x=f;q=r.prev;\nn=r;l=r.next;if(0<=ma(q,n,l))r=!1;else{var w=q.x>n.x?q.x>l.x?q.x:l.x:n.x>l.x?n.x:l.x,B=q.y>n.y?q.y>l.y?q.y:l.y:n.y>l.y?n.y:l.y;m=ae(q.x<n.x?q.x<l.x?q.x:l.x:n.x<l.x?n.x:l.x,q.y<n.y?q.y<l.y?q.y:l.y:n.y<l.y?n.y:l.y,t,p,x);t=ae(w,B,t,p,x);for(p=r.nextZ;p&&p.z<=t;){if(p!==r.prev&&p!==r.next&&ud(q.x,q.y,n.x,n.y,l.x,l.y,p.x,p.y)&&0<=ma(p.prev,p,p.next)){r=!1;break a}p=p.nextZ}for(p=r.prevZ;p&&p.z>=m;){if(p!==r.prev&&p!==r.next&&ud(q.x,q.y,n.x,n.y,l.x,l.y,p.x,p.y)&&0<=ma(p.prev,p,p.next)){r=!1;break a}p=\np.prevZ}r=!0}}else a:if(r=a,q=r.prev,n=r,l=r.next,0<=ma(q,n,l))r=!1;else{for(m=r.next.next;m!==r.prev;){if(ud(q.x,q.y,n.x,n.y,l.x,l.y,m.x,m.y)&&0<=ma(m.prev,m,m.next)){r=!1;break a}m=m.next}r=!0}if(r)b.push(k.i/c),b.push(a.i/c),b.push(v.i/c),Oc(a),h=a=v.next;else if(a=v,a===h){if(!g)Qc(Pc(a),b,c,d,e,f,1);else if(1===g){g=b;h=c;k=a;do v=k.prev,r=k.next.next,!qb(v,r)&&df(v,k,k.next,r)&&Rc(v,r)&&Rc(r,v)&&(g.push(v.i/h),g.push(k.i/h),g.push(r.i/h),Oc(k),Oc(k.next),k=a=r),k=k.next;while(k!==a);a=k;Qc(a,\nb,c,d,e,f,2)}else if(2===g)a:{g=a;do{for(h=g.next.next;h!==g.prev;){if(k=g.i!==h.i){k=g;v=h;if(r=k.next.i!==v.i&&k.prev.i!==v.i){b:{r=k;do{if(r.i!==k.i&&r.next.i!==k.i&&r.i!==v.i&&r.next.i!==v.i&&df(r,r.next,k,v)){r=!0;break b}r=r.next}while(r!==k);r=!1}r=!r}if(r=r&&Rc(k,v)&&Rc(v,k)){r=k;q=!1;n=(k.x+v.x)/2;v=(k.y+v.y)/2;do r.y>v!==r.next.y>v&&r.next.y!==r.y&&n<(r.next.x-r.x)*(v-r.y)/(r.next.y-r.y)+r.x&&(q=!q),r=r.next;while(r!==k);r=q}k=r}if(k){a=ef(g,h);g=Pc(g,g.next);a=Pc(a,a.next);Qc(g,b,c,d,e,\nf);Qc(a,b,c,d,e,f);break a}h=h.next}g=g.next}while(g!==a)}break}}}}function Ng(a,b){return a.x-b.x}function Og(a,b){var c=b,d=a.x,e=a.y,f=-Infinity;do{if(e<=c.y&&e>=c.next.y&&c.next.y!==c.y){var g=c.x+(e-c.y)*(c.next.x-c.x)/(c.next.y-c.y);if(g<=d&&g>f){f=g;if(g===d){if(e===c.y)return c;if(e===c.next.y)return c.next}var h=c.x<c.next.x?c:c.next}}c=c.next}while(c!==b);if(!h)return null;if(d===f)return h.prev;b=h;g=h.x;var k=h.y,m=Infinity;for(c=h.next;c!==b;){if(d>=c.x&&c.x>=g&&d!==c.x&&ud(e<k?d:f,e,\ng,k,e<k?f:d,e,c.x,c.y)){var q=Math.abs(e-c.y)/(d-c.x);(q<m||q===m&&c.x>h.x)&&Rc(c,a)&&(h=c,m=q)}c=c.next}return h}function ae(a,b,c,d,e){a=32767*(a-c)*e;b=32767*(b-d)*e;a=(a|a<<8)&16711935;a=(a|a<<4)&252645135;a=(a|a<<2)&858993459;b=(b|b<<8)&16711935;b=(b|b<<4)&252645135;b=(b|b<<2)&858993459;return(a|a<<1)&1431655765|((b|b<<1)&1431655765)<<1}function Pg(a){var b=a,c=a;do b.x<c.x&&(c=b),b=b.next;while(b!==a);return c}function ud(a,b,c,d,e,f,g,h){return 0<=(e-g)*(b-h)-(a-g)*(f-h)&&0<=(a-g)*(d-h)-(c-\ng)*(b-h)&&0<=(c-g)*(f-h)-(e-g)*(d-h)}function ma(a,b,c){return(b.y-a.y)*(c.x-b.x)-(b.x-a.x)*(c.y-b.y)}function qb(a,b){return a.x===b.x&&a.y===b.y}function df(a,b,c,d){return qb(a,b)&&qb(c,d)||qb(a,d)&&qb(c,b)?!0:0<ma(a,b,c)!==0<ma(a,b,d)&&0<ma(c,d,a)!==0<ma(c,d,b)}function Rc(a,b){return 0>ma(a.prev,a,a.next)?0<=ma(a,b,a.next)&&0<=ma(a,a.prev,b):0>ma(a,b,a.prev)||0>ma(a,a.next,b)}function ef(a,b){var c=new be(a.i,a.x,a.y),d=new be(b.i,b.x,b.y),e=a.next,f=b.prev;a.next=b;b.prev=a;c.next=e;e.prev=\nc;d.next=c;c.prev=d;f.next=d;d.prev=f;return d}function cf(a,b,c,d){a=new be(a,b,c);d?(a.next=d.next,a.prev=d,d.next.prev=a,d.next=a):(a.prev=a,a.next=a);return a}function Oc(a){a.next.prev=a.prev;a.prev.next=a.next;a.prevZ&&(a.prevZ.nextZ=a.nextZ);a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function be(a,b,c){this.i=a;this.x=b;this.y=c;this.nextZ=this.prevZ=this.z=this.next=this.prev=null;this.steiner=!1}function ff(a){var b=a.length;2<b&&a[b-1].equals(a[0])&&a.pop()}function gf(a,b){for(var c=0;c<b.length;c++)a.push(b[c].x),\na.push(b[c].y)}function rb(a,b){R.call(this);this.type=\"ExtrudeGeometry\";this.parameters={shapes:a,options:b};this.fromBufferGeometry(new Oa(a,b));this.mergeVertices()}function Oa(a,b){function c(a){function c(a,b,c){b||console.error(\"THREE.ExtrudeGeometry: vec does not exist\");return b.clone().multiplyScalar(c).add(a)}function g(a,b,c){var d=a.x-b.x;var e=a.y-b.y;var f=c.x-a.x;var g=c.y-a.y,h=d*d+e*e;if(Math.abs(d*g-e*f)>Number.EPSILON){var k=Math.sqrt(h),m=Math.sqrt(f*f+g*g);h=b.x-e/k;b=b.y+d/k;\ng=((c.x-g/m-h)*g-(c.y+f/m-b)*f)/(d*g-e*f);f=h+d*g-a.x;d=b+e*g-a.y;e=f*f+d*d;if(2>=e)return new z(f,d);e=Math.sqrt(e/2)}else a=!1,d>Number.EPSILON?f>Number.EPSILON&&(a=!0):d<-Number.EPSILON?f<-Number.EPSILON&&(a=!0):Math.sign(e)===Math.sign(g)&&(a=!0),a?(f=-e,e=Math.sqrt(h)):(f=d,d=e,e=Math.sqrt(h/2));return new z(f/e,d/e)}function h(a,b){for(M=a.length;0<=--M;){var c=M;var f=M-1;0>f&&(f=a.length-1);var g,h=w+2*O;for(g=0;g<h;g++){var k=Z*g,m=Z*(g+1),q=b+f+k,n=b+f+m;m=b+c+m;r(b+c+k);r(q);r(m);r(q);\nr(n);r(m);k=e.length/3;k=D.generateSideWallUV(d,e,k-6,k-3,k-2,k-1);v(k[0]);v(k[1]);v(k[3]);v(k[1]);v(k[2]);v(k[3])}}}function k(a,b,c){y.push(a);y.push(b);y.push(c)}function l(a,b,c){r(a);r(b);r(c);a=e.length/3;a=D.generateTopUV(d,e,a-3,a-2,a-1);v(a[0]);v(a[1]);v(a[2])}function r(a){e.push(y[3*a]);e.push(y[3*a+1]);e.push(y[3*a+2])}function v(a){f.push(a.x);f.push(a.y)}var y=[],x=void 0!==b.curveSegments?b.curveSegments:12,w=void 0!==b.steps?b.steps:1,B=void 0!==b.depth?b.depth:100,E=void 0!==b.bevelEnabled?\nb.bevelEnabled:!0,P=void 0!==b.bevelThickness?b.bevelThickness:6,N=void 0!==b.bevelSize?b.bevelSize:P-2,O=void 0!==b.bevelSegments?b.bevelSegments:3,A=b.extrudePath,D=void 0!==b.UVGenerator?b.UVGenerator:Qg;void 0!==b.amount&&(console.warn(\"THREE.ExtrudeBufferGeometry: amount has been renamed to depth.\"),B=b.amount);var C=!1;if(A){var G=A.getSpacedPoints(w);C=!0;E=!1;var K=A.computeFrenetFrames(w,!1);var L=new p;var R=new p;var Q=new p}E||(N=P=O=0);var I;x=a.extractPoints(x);a=x.shape;var J=x.holes;\nif(!Va.isClockWise(a)){a=a.reverse();var H=0;for(I=J.length;H<I;H++){var S=J[H];Va.isClockWise(S)&&(J[H]=S.reverse())}}var Y=Va.triangulateShape(a,J),W=a;H=0;for(I=J.length;H<I;H++)S=J[H],a=a.concat(S);var T,Z=a.length,V,ea=Y.length;x=[];var M=0;var U=W.length;var X=U-1;for(T=M+1;M<U;M++,X++,T++)X===U&&(X=0),T===U&&(T=0),x[M]=g(W[M],W[X],W[T]);A=[];var fa=x.concat();H=0;for(I=J.length;H<I;H++){S=J[H];var ca=[];M=0;U=S.length;X=U-1;for(T=M+1;M<U;M++,X++,T++)X===U&&(X=0),T===U&&(T=0),ca[M]=g(S[M],S[X],\nS[T]);A.push(ca);fa=fa.concat(ca)}for(X=0;X<O;X++){U=X/O;var da=P*Math.cos(U*Math.PI/2);T=N*Math.sin(U*Math.PI/2);M=0;for(U=W.length;M<U;M++){var aa=c(W[M],x[M],T);k(aa.x,aa.y,-da)}H=0;for(I=J.length;H<I;H++)for(S=J[H],ca=A[H],M=0,U=S.length;M<U;M++)aa=c(S[M],ca[M],T),k(aa.x,aa.y,-da)}T=N;for(M=0;M<Z;M++)aa=E?c(a[M],fa[M],T):a[M],C?(R.copy(K.normals[0]).multiplyScalar(aa.x),L.copy(K.binormals[0]).multiplyScalar(aa.y),Q.copy(G[0]).add(R).add(L),k(Q.x,Q.y,Q.z)):k(aa.x,aa.y,0);for(U=1;U<=w;U++)for(M=\n0;M<Z;M++)aa=E?c(a[M],fa[M],T):a[M],C?(R.copy(K.normals[U]).multiplyScalar(aa.x),L.copy(K.binormals[U]).multiplyScalar(aa.y),Q.copy(G[U]).add(R).add(L),k(Q.x,Q.y,Q.z)):k(aa.x,aa.y,B/w*U);for(X=O-1;0<=X;X--){U=X/O;da=P*Math.cos(U*Math.PI/2);T=N*Math.sin(U*Math.PI/2);M=0;for(U=W.length;M<U;M++)aa=c(W[M],x[M],T),k(aa.x,aa.y,B+da);H=0;for(I=J.length;H<I;H++)for(S=J[H],ca=A[H],M=0,U=S.length;M<U;M++)aa=c(S[M],ca[M],T),C?k(aa.x,aa.y+G[w-1].y,G[w-1].x+da):k(aa.x,aa.y,B+da)}(function(){var a=e.length/3;if(E){var b=\n0*Z;for(M=0;M<ea;M++)V=Y[M],l(V[2]+b,V[1]+b,V[0]+b);b=Z*(w+2*O);for(M=0;M<ea;M++)V=Y[M],l(V[0]+b,V[1]+b,V[2]+b)}else{for(M=0;M<ea;M++)V=Y[M],l(V[2],V[1],V[0]);for(M=0;M<ea;M++)V=Y[M],l(V[0]+Z*w,V[1]+Z*w,V[2]+Z*w)}d.addGroup(a,e.length/3-a,0)})();(function(){var a=e.length/3,b=0;h(W,b);b+=W.length;H=0;for(I=J.length;H<I;H++)S=J[H],h(S,b),b+=S.length;d.addGroup(a,e.length/3-a,1)})()}C.call(this);this.type=\"ExtrudeBufferGeometry\";this.parameters={shapes:a,options:b};a=Array.isArray(a)?a:[a];for(var d=\nthis,e=[],f=[],g=0,h=a.length;g<h;g++)c(a[g]);this.addAttribute(\"position\",new A(e,3));this.addAttribute(\"uv\",new A(f,2));this.computeVertexNormals()}function hf(a,b,c){c.shapes=[];if(Array.isArray(a))for(var d=0,e=a.length;d<e;d++)c.shapes.push(a[d].uuid);else c.shapes.push(a.uuid);void 0!==b.extrudePath&&(c.options.extrudePath=b.extrudePath.toJSON());return c}function Sc(a,b){R.call(this);this.type=\"TextGeometry\";this.parameters={text:a,parameters:b};this.fromBufferGeometry(new Yb(a,b));this.mergeVertices()}\nfunction Yb(a,b){b=b||{};var c=b.font;if(!c||!c.isFont)return console.error(\"THREE.TextGeometry: font parameter is not an instance of THREE.Font.\"),new R;a=c.generateShapes(a,b.size);b.depth=void 0!==b.height?b.height:50;void 0===b.bevelThickness&&(b.bevelThickness=10);void 0===b.bevelSize&&(b.bevelSize=8);void 0===b.bevelEnabled&&(b.bevelEnabled=!1);Oa.call(this,a,b);this.type=\"TextBufferGeometry\"}function Tc(a,b,c,d,e,f,g){R.call(this);this.type=\"SphereGeometry\";this.parameters={radius:a,widthSegments:b,\nheightSegments:c,phiStart:d,phiLength:e,thetaStart:f,thetaLength:g};this.fromBufferGeometry(new sb(a,b,c,d,e,f,g));this.mergeVertices()}function sb(a,b,c,d,e,f,g){C.call(this);this.type=\"SphereBufferGeometry\";this.parameters={radius:a,widthSegments:b,heightSegments:c,phiStart:d,phiLength:e,thetaStart:f,thetaLength:g};a=a||1;b=Math.max(3,Math.floor(b)||8);c=Math.max(2,Math.floor(c)||6);d=void 0!==d?d:0;e=void 0!==e?e:2*Math.PI;f=void 0!==f?f:0;g=void 0!==g?g:Math.PI;var h=f+g,k,m,q=0,n=[],l=new p,\nu=new p,r=[],v=[],y=[],x=[];for(m=0;m<=c;m++){var w=[],B=m/c;for(k=0;k<=b;k++){var E=k/b;l.x=-a*Math.cos(d+E*e)*Math.sin(f+B*g);l.y=a*Math.cos(f+B*g);l.z=a*Math.sin(d+E*e)*Math.sin(f+B*g);v.push(l.x,l.y,l.z);u.set(l.x,l.y,l.z).normalize();y.push(u.x,u.y,u.z);x.push(E,1-B);w.push(q++)}n.push(w)}for(m=0;m<c;m++)for(k=0;k<b;k++)a=n[m][k+1],d=n[m][k],e=n[m+1][k],g=n[m+1][k+1],(0!==m||0<f)&&r.push(a,d,g),(m!==c-1||h<Math.PI)&&r.push(d,e,g);this.setIndex(r);this.addAttribute(\"position\",new A(v,3));this.addAttribute(\"normal\",\nnew A(y,3));this.addAttribute(\"uv\",new A(x,2))}function Uc(a,b,c,d,e,f){R.call(this);this.type=\"RingGeometry\";this.parameters={innerRadius:a,outerRadius:b,thetaSegments:c,phiSegments:d,thetaStart:e,thetaLength:f};this.fromBufferGeometry(new Zb(a,b,c,d,e,f));this.mergeVertices()}function Zb(a,b,c,d,e,f){C.call(this);this.type=\"RingBufferGeometry\";this.parameters={innerRadius:a,outerRadius:b,thetaSegments:c,phiSegments:d,thetaStart:e,thetaLength:f};a=a||.5;b=b||1;e=void 0!==e?e:0;f=void 0!==f?f:2*Math.PI;\nc=void 0!==c?Math.max(3,c):8;d=void 0!==d?Math.max(1,d):1;var g=[],h=[],k=[],m=[],q=a,n=(b-a)/d,l=new p,u=new z,r,v;for(r=0;r<=d;r++){for(v=0;v<=c;v++)a=e+v/c*f,l.x=q*Math.cos(a),l.y=q*Math.sin(a),h.push(l.x,l.y,l.z),k.push(0,0,1),u.x=(l.x/b+1)/2,u.y=(l.y/b+1)/2,m.push(u.x,u.y);q+=n}for(r=0;r<d;r++)for(b=r*(c+1),v=0;v<c;v++)a=v+b,e=a+c+1,f=a+c+2,q=a+1,g.push(a,e,q),g.push(e,f,q);this.setIndex(g);this.addAttribute(\"position\",new A(h,3));this.addAttribute(\"normal\",new A(k,3));this.addAttribute(\"uv\",\nnew A(m,2))}function Vc(a,b,c,d){R.call(this);this.type=\"LatheGeometry\";this.parameters={points:a,segments:b,phiStart:c,phiLength:d};this.fromBufferGeometry(new $b(a,b,c,d));this.mergeVertices()}function $b(a,b,c,d){C.call(this);this.type=\"LatheBufferGeometry\";this.parameters={points:a,segments:b,phiStart:c,phiLength:d};b=Math.floor(b)||12;c=c||0;d=d||2*Math.PI;d=H.clamp(d,0,2*Math.PI);var e=[],f=[],g=[],h=1/b,k=new p,m=new z,q;for(q=0;q<=b;q++){var n=c+q*h*d;var l=Math.sin(n),u=Math.cos(n);for(n=\n0;n<=a.length-1;n++)k.x=a[n].x*l,k.y=a[n].y,k.z=a[n].x*u,f.push(k.x,k.y,k.z),m.x=q/b,m.y=n/(a.length-1),g.push(m.x,m.y)}for(q=0;q<b;q++)for(n=0;n<a.length-1;n++)c=n+q*a.length,h=c+a.length,k=c+a.length+1,m=c+1,e.push(c,h,m),e.push(h,k,m);this.setIndex(e);this.addAttribute(\"position\",new A(f,3));this.addAttribute(\"uv\",new A(g,2));this.computeVertexNormals();if(d===2*Math.PI)for(d=this.attributes.normal.array,e=new p,f=new p,g=new p,c=b*a.length*3,n=q=0;q<a.length;q++,n+=3)e.x=d[n+0],e.y=d[n+1],e.z=\nd[n+2],f.x=d[c+n+0],f.y=d[c+n+1],f.z=d[c+n+2],g.addVectors(e,f).normalize(),d[n+0]=d[c+n+0]=g.x,d[n+1]=d[c+n+1]=g.y,d[n+2]=d[c+n+2]=g.z}function tb(a,b){R.call(this);this.type=\"ShapeGeometry\";\"object\"===typeof b&&(console.warn(\"THREE.ShapeGeometry: Options parameter has been removed.\"),b=b.curveSegments);this.parameters={shapes:a,curveSegments:b};this.fromBufferGeometry(new ub(a,b));this.mergeVertices()}function ub(a,b){function c(a){var c,h=e.length/3;a=a.extractPoints(b);var m=a.shape,q=a.holes;\nif(!1===Va.isClockWise(m))for(m=m.reverse(),a=0,c=q.length;a<c;a++){var l=q[a];!0===Va.isClockWise(l)&&(q[a]=l.reverse())}var p=Va.triangulateShape(m,q);a=0;for(c=q.length;a<c;a++)l=q[a],m=m.concat(l);a=0;for(c=m.length;a<c;a++)l=m[a],e.push(l.x,l.y,0),f.push(0,0,1),g.push(l.x,l.y);a=0;for(c=p.length;a<c;a++)m=p[a],d.push(m[0]+h,m[1]+h,m[2]+h),k+=3}C.call(this);this.type=\"ShapeBufferGeometry\";this.parameters={shapes:a,curveSegments:b};b=b||12;var d=[],e=[],f=[],g=[],h=0,k=0;if(!1===Array.isArray(a))c(a);\nelse for(var m=0;m<a.length;m++)c(a[m]),this.addGroup(h,k,m),h+=k,k=0;this.setIndex(d);this.addAttribute(\"position\",new A(e,3));this.addAttribute(\"normal\",new A(f,3));this.addAttribute(\"uv\",new A(g,2))}function jf(a,b){b.shapes=[];if(Array.isArray(a))for(var c=0,d=a.length;c<d;c++)b.shapes.push(a[c].uuid);else b.shapes.push(a.uuid);return b}function ac(a,b){C.call(this);this.type=\"EdgesGeometry\";this.parameters={thresholdAngle:b};var c=[];b=Math.cos(H.DEG2RAD*(void 0!==b?b:1));var d=[0,0],e={},f=\n[\"a\",\"b\",\"c\"];if(a.isBufferGeometry){var g=new R;g.fromBufferGeometry(a)}else g=a.clone();g.mergeVertices();g.computeFaceNormals();a=g.vertices;g=g.faces;for(var h=0,k=g.length;h<k;h++)for(var m=g[h],q=0;3>q;q++){var n=m[f[q]];var l=m[f[(q+1)%3]];d[0]=Math.min(n,l);d[1]=Math.max(n,l);n=d[0]+\",\"+d[1];void 0===e[n]?e[n]={index1:d[0],index2:d[1],face1:h,face2:void 0}:e[n].face2=h}for(n in e)if(d=e[n],void 0===d.face2||g[d.face1].normal.dot(g[d.face2].normal)<=b)f=a[d.index1],c.push(f.x,f.y,f.z),f=a[d.index2],\nc.push(f.x,f.y,f.z);this.addAttribute(\"position\",new A(c,3))}function vb(a,b,c,d,e,f,g,h){R.call(this);this.type=\"CylinderGeometry\";this.parameters={radiusTop:a,radiusBottom:b,height:c,radialSegments:d,heightSegments:e,openEnded:f,thetaStart:g,thetaLength:h};this.fromBufferGeometry(new Wa(a,b,c,d,e,f,g,h));this.mergeVertices()}function Wa(a,b,c,d,e,f,g,h){function k(c){var e,f=new z,k=new p,t=0,v=!0===c?a:b,w=!0===c?1:-1;var A=r;for(e=1;e<=d;e++)n.push(0,y*w,0),l.push(0,w,0),u.push(.5,.5),r++;var C=\nr;for(e=0;e<=d;e++){var D=e/d*h+g,H=Math.cos(D);D=Math.sin(D);k.x=v*D;k.y=y*w;k.z=v*H;n.push(k.x,k.y,k.z);l.push(0,w,0);f.x=.5*H+.5;f.y=.5*D*w+.5;u.push(f.x,f.y);r++}for(e=0;e<d;e++)f=A+e,k=C+e,!0===c?q.push(k,k+1,f):q.push(k+1,k,f),t+=3;m.addGroup(x,t,!0===c?1:2);x+=t}C.call(this);this.type=\"CylinderBufferGeometry\";this.parameters={radiusTop:a,radiusBottom:b,height:c,radialSegments:d,heightSegments:e,openEnded:f,thetaStart:g,thetaLength:h};var m=this;a=void 0!==a?a:1;b=void 0!==b?b:1;c=c||1;d=Math.floor(d)||\n8;e=Math.floor(e)||1;f=void 0!==f?f:!1;g=void 0!==g?g:0;h=void 0!==h?h:2*Math.PI;var q=[],n=[],l=[],u=[],r=0,v=[],y=c/2,x=0;(function(){var f,k,t=new p,P=new p,N=0,z=(b-a)/c;for(k=0;k<=e;k++){var A=[],D=k/e,C=D*(b-a)+a;for(f=0;f<=d;f++){var H=f/d,G=H*h+g,K=Math.sin(G);G=Math.cos(G);P.x=C*K;P.y=-D*c+y;P.z=C*G;n.push(P.x,P.y,P.z);t.set(K,z,G).normalize();l.push(t.x,t.y,t.z);u.push(H,1-D);A.push(r++)}v.push(A)}for(f=0;f<d;f++)for(k=0;k<e;k++)t=v[k+1][f],P=v[k+1][f+1],z=v[k][f+1],q.push(v[k][f],t,z),\nq.push(t,P,z),N+=6;m.addGroup(x,N,0);x+=N})();!1===f&&(0<a&&k(!0),0<b&&k(!1));this.setIndex(q);this.addAttribute(\"position\",new A(n,3));this.addAttribute(\"normal\",new A(l,3));this.addAttribute(\"uv\",new A(u,2))}function Wc(a,b,c,d,e,f,g){vb.call(this,0,a,b,c,d,e,f,g);this.type=\"ConeGeometry\";this.parameters={radius:a,height:b,radialSegments:c,heightSegments:d,openEnded:e,thetaStart:f,thetaLength:g}}function Xc(a,b,c,d,e,f,g){Wa.call(this,0,a,b,c,d,e,f,g);this.type=\"ConeBufferGeometry\";this.parameters=\n{radius:a,height:b,radialSegments:c,heightSegments:d,openEnded:e,thetaStart:f,thetaLength:g}}function Yc(a,b,c,d){R.call(this);this.type=\"CircleGeometry\";this.parameters={radius:a,segments:b,thetaStart:c,thetaLength:d};this.fromBufferGeometry(new bc(a,b,c,d));this.mergeVertices()}function bc(a,b,c,d){C.call(this);this.type=\"CircleBufferGeometry\";this.parameters={radius:a,segments:b,thetaStart:c,thetaLength:d};a=a||1;b=void 0!==b?Math.max(3,b):8;c=void 0!==c?c:0;d=void 0!==d?d:2*Math.PI;var e=[],f=\n[],g=[],h=[],k,m=new p,q=new z;f.push(0,0,0);g.push(0,0,1);h.push(.5,.5);var n=0;for(k=3;n<=b;n++,k+=3){var l=c+n/b*d;m.x=a*Math.cos(l);m.y=a*Math.sin(l);f.push(m.x,m.y,m.z);g.push(0,0,1);q.x=(f[k]/a+1)/2;q.y=(f[k+1]/a+1)/2;h.push(q.x,q.y)}for(k=1;k<=b;k++)e.push(k,k+1,0);this.setIndex(e);this.addAttribute(\"position\",new A(f,3));this.addAttribute(\"normal\",new A(g,3));this.addAttribute(\"uv\",new A(h,2))}function wb(a){J.call(this);this.type=\"ShadowMaterial\";this.color=new G(0);this.transparent=!0;this.setValues(a)}\nfunction cc(a){ta.call(this,a);this.type=\"RawShaderMaterial\"}function Pa(a){J.call(this);this.defines={STANDARD:\"\"};this.type=\"MeshStandardMaterial\";this.color=new G(16777215);this.metalness=this.roughness=.5;this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new G(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=0;this.normalScale=new z(1,1);this.displacementMap=null;this.displacementScale=\n1;this.displacementBias=0;this.envMap=this.alphaMap=this.metalnessMap=this.roughnessMap=null;this.envMapIntensity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\"round\";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)}function xb(a){Pa.call(this);this.defines={PHYSICAL:\"\"};this.type=\"MeshPhysicalMaterial\";this.reflectivity=.5;this.clearCoatRoughness=this.clearCoat=0;this.setValues(a)}function Fa(a){J.call(this);\nthis.type=\"MeshPhongMaterial\";this.color=new G(16777215);this.specular=new G(1118481);this.shininess=30;this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new G(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=0;this.normalScale=new z(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.envMap=this.alphaMap=this.specularMap=null;this.combine=0;\nthis.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\"round\";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)}function yb(a){Fa.call(this);this.defines={TOON:\"\"};this.type=\"MeshToonMaterial\";this.gradientMap=null;this.setValues(a)}function zb(a){J.call(this);this.type=\"MeshNormalMaterial\";this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=0;this.normalScale=new z(1,1);this.displacementMap=\nnull;this.displacementScale=1;this.displacementBias=0;this.wireframe=!1;this.wireframeLinewidth=1;this.morphNormals=this.morphTargets=this.skinning=this.lights=this.fog=!1;this.setValues(a)}function Ab(a){J.call(this);this.type=\"MeshLambertMaterial\";this.color=new G(16777215);this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new G(0);this.emissiveIntensity=1;this.envMap=this.alphaMap=this.specularMap=this.emissiveMap=null;this.combine=0;this.reflectivity=\n1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\"round\";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)}function Bb(a){Y.call(this);this.type=\"LineDashedMaterial\";this.scale=1;this.dashSize=3;this.gapSize=1;this.setValues(a)}function ce(a,b,c){var d=this,e=!1,f=0,g=0,h=void 0;this.onStart=void 0;this.onLoad=a;this.onProgress=b;this.onError=c;this.itemStart=function(a){g++;if(!1===e&&void 0!==d.onStart)d.onStart(a,\nf,g);e=!0};this.itemEnd=function(a){f++;if(void 0!==d.onProgress)d.onProgress(a,f,g);if(f===g&&(e=!1,void 0!==d.onLoad))d.onLoad()};this.itemError=function(a){if(void 0!==d.onError)d.onError(a)};this.resolveURL=function(a){return h?h(a):a};this.setURLModifier=function(a){h=a;return this}}function Ga(a){this.manager=void 0!==a?a:ka}function kf(a){this.manager=void 0!==a?a:ka;this._parser=null}function de(a){this.manager=void 0!==a?a:ka;this._parser=null}function Zc(a){this.manager=void 0!==a?a:ka}\nfunction ee(a){this.manager=void 0!==a?a:ka}function vd(a){this.manager=void 0!==a?a:ka}function L(){this.type=\"Curve\";this.arcLengthDivisions=200}function za(a,b,c,d,e,f,g,h){L.call(this);this.type=\"EllipseCurve\";this.aX=a||0;this.aY=b||0;this.xRadius=c||1;this.yRadius=d||1;this.aStartAngle=e||0;this.aEndAngle=f||2*Math.PI;this.aClockwise=g||!1;this.aRotation=h||0}function dc(a,b,c,d,e,f){za.call(this,a,b,c,c,d,e,f);this.type=\"ArcCurve\"}function fe(){var a=0,b=0,c=0,d=0;return{initCatmullRom:function(e,\nf,g,h,k){e=k*(g-e);h=k*(h-f);a=f;b=e;c=-3*f+3*g-2*e-h;d=2*f-2*g+e+h},initNonuniformCatmullRom:function(e,f,g,h,k,m,q){e=((f-e)/k-(g-e)/(k+m)+(g-f)/m)*m;h=((g-f)/m-(h-f)/(m+q)+(h-g)/q)*m;a=f;b=e;c=-3*f+3*g-2*e-h;d=2*f-2*g+e+h},calc:function(e){var f=e*e;return a+b*e+c*f+d*f*e}}}function ca(a,b,c,d){L.call(this);this.type=\"CatmullRomCurve3\";this.points=a||[];this.closed=b||!1;this.curveType=c||\"centripetal\";this.tension=d||.5}function lf(a,b,c,d,e){b=.5*(d-b);e=.5*(e-c);var f=a*a;return(2*c-2*d+b+e)*\na*f+(-3*c+3*d-2*b-e)*f+b*a+c}function $c(a,b,c,d){var e=1-a;return e*e*b+2*(1-a)*a*c+a*a*d}function ad(a,b,c,d,e){var f=1-a,g=1-a;return f*f*f*b+3*g*g*a*c+3*(1-a)*a*a*d+a*a*a*e}function Ha(a,b,c,d){L.call(this);this.type=\"CubicBezierCurve\";this.v0=a||new z;this.v1=b||new z;this.v2=c||new z;this.v3=d||new z}function Qa(a,b,c,d){L.call(this);this.type=\"CubicBezierCurve3\";this.v0=a||new p;this.v1=b||new p;this.v2=c||new p;this.v3=d||new p}function va(a,b){L.call(this);this.type=\"LineCurve\";this.v1=a||\nnew z;this.v2=b||new z}function Ia(a,b){L.call(this);this.type=\"LineCurve3\";this.v1=a||new p;this.v2=b||new p}function Ja(a,b,c){L.call(this);this.type=\"QuadraticBezierCurve\";this.v0=a||new z;this.v1=b||new z;this.v2=c||new z}function Ra(a,b,c){L.call(this);this.type=\"QuadraticBezierCurve3\";this.v0=a||new p;this.v1=b||new p;this.v2=c||new p}function Ka(a){L.call(this);this.type=\"SplineCurve\";this.points=a||[]}function Xa(){L.call(this);this.type=\"CurvePath\";this.curves=[];this.autoClose=!1}function La(a){Xa.call(this);\nthis.type=\"Path\";this.currentPoint=new z;a&&this.setFromPoints(a)}function db(a){La.call(this,a);this.uuid=H.generateUUID();this.type=\"Shape\";this.holes=[]}function X(a,b){D.call(this);this.type=\"Light\";this.color=new G(a);this.intensity=void 0!==b?b:1;this.receiveShadow=void 0}function wd(a,b,c){X.call(this,a,c);this.type=\"HemisphereLight\";this.castShadow=void 0;this.position.copy(D.DefaultUp);this.updateMatrix();this.groundColor=new G(b)}function Cb(a){this.camera=a;this.bias=0;this.radius=1;this.mapSize=\nnew z(512,512);this.map=null;this.matrix=new I}function xd(){Cb.call(this,new Z(50,1,.5,500))}function yd(a,b,c,d,e,f){X.call(this,a,b);this.type=\"SpotLight\";this.position.copy(D.DefaultUp);this.updateMatrix();this.target=new D;Object.defineProperty(this,\"power\",{get:function(){return this.intensity*Math.PI},set:function(a){this.intensity=a/Math.PI}});this.distance=void 0!==c?c:0;this.angle=void 0!==d?d:Math.PI/3;this.penumbra=void 0!==e?e:0;this.decay=void 0!==f?f:1;this.shadow=new xd}function zd(a,\nb,c,d){X.call(this,a,b);this.type=\"PointLight\";Object.defineProperty(this,\"power\",{get:function(){return 4*this.intensity*Math.PI},set:function(a){this.intensity=a/(4*Math.PI)}});this.distance=void 0!==c?c:0;this.decay=void 0!==d?d:1;this.shadow=new Cb(new Z(90,1,.5,500))}function Ad(){Cb.call(this,new Hb(-5,5,5,-5,.5,500))}function Bd(a,b){X.call(this,a,b);this.type=\"DirectionalLight\";this.position.copy(D.DefaultUp);this.updateMatrix();this.target=new D;this.shadow=new Ad}function Cd(a,b){X.call(this,\na,b);this.type=\"AmbientLight\";this.castShadow=void 0}function Dd(a,b,c,d){X.call(this,a,b);this.type=\"RectAreaLight\";this.width=void 0!==c?c:10;this.height=void 0!==d?d:10}function wa(a,b,c,d){this.parameterPositions=a;this._cachedIndex=0;this.resultBuffer=void 0!==d?d:new b.constructor(c);this.sampleValues=b;this.valueSize=c}function Ed(a,b,c,d){wa.call(this,a,b,c,d);this._offsetNext=this._weightNext=this._offsetPrev=this._weightPrev=-0}function bd(a,b,c,d){wa.call(this,a,b,c,d)}function Fd(a,b,\nc,d){wa.call(this,a,b,c,d)}function oa(a,b,c,d){if(void 0===a)throw Error(\"THREE.KeyframeTrack: track name is undefined\");if(void 0===b||0===b.length)throw Error(\"THREE.KeyframeTrack: no keyframes in track named \"+a);this.name=a;this.times=ia.convertArray(b,this.TimeBufferType);this.values=ia.convertArray(c,this.ValueBufferType);this.setInterpolation(d||this.DefaultInterpolation)}function Gd(a,b,c){oa.call(this,a,b,c)}function Hd(a,b,c,d){oa.call(this,a,b,c,d)}function ec(a,b,c,d){oa.call(this,a,\nb,c,d)}function Id(a,b,c,d){wa.call(this,a,b,c,d)}function cd(a,b,c,d){oa.call(this,a,b,c,d)}function Jd(a,b,c,d){oa.call(this,a,b,c,d)}function fc(a,b,c,d){oa.call(this,a,b,c,d)}function Ca(a,b,c){this.name=a;this.tracks=c;this.duration=void 0!==b?b:-1;this.uuid=H.generateUUID();0>this.duration&&this.resetDuration()}function Rg(a){switch(a.toLowerCase()){case \"scalar\":case \"double\":case \"float\":case \"number\":case \"integer\":return ec;case \"vector\":case \"vector2\":case \"vector3\":case \"vector4\":return fc;\ncase \"color\":return Hd;case \"quaternion\":return cd;case \"bool\":case \"boolean\":return Gd;case \"string\":return Jd}throw Error(\"THREE.KeyframeTrack: Unsupported typeName: \"+a);}function Sg(a){if(void 0===a.type)throw Error(\"THREE.KeyframeTrack: track type undefined, can not parse\");var b=Rg(a.type);if(void 0===a.times){var c=[],d=[];ia.flattenJSON(a.keys,c,d,\"value\");a.times=c;a.values=d}return void 0!==b.parse?b.parse(a):new b(a.name,a.times,a.values,a.interpolation)}function Kd(a){this.manager=void 0!==\na?a:ka;this.textures={}}function ge(a){this.manager=void 0!==a?a:ka}function gc(){}function he(a){\"boolean\"===typeof a&&(console.warn(\"THREE.JSONLoader: showStatus parameter has been removed from constructor.\"),a=void 0);this.manager=void 0!==a?a:ka;this.withCredentials=!1}function mf(a){this.manager=void 0!==a?a:ka;this.texturePath=\"\"}function ie(a){\"undefined\"===typeof createImageBitmap&&console.warn(\"THREE.ImageBitmapLoader: createImageBitmap() not supported.\");\"undefined\"===typeof fetch&&console.warn(\"THREE.ImageBitmapLoader: fetch() not supported.\");\nthis.manager=void 0!==a?a:ka;this.options=void 0}function je(){this.type=\"ShapePath\";this.color=new G;this.subPaths=[];this.currentPath=null}function ke(a){this.type=\"Font\";this.data=a}function nf(a){this.manager=void 0!==a?a:ka}function le(a){this.manager=void 0!==a?a:ka}function of(){this.type=\"StereoCamera\";this.aspect=1;this.eyeSep=.064;this.cameraL=new Z;this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=!1;this.cameraR=new Z;this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=\n!1}function dd(a,b,c){D.call(this);this.type=\"CubeCamera\";var d=new Z(90,1,a,b);d.up.set(0,-1,0);d.lookAt(new p(1,0,0));this.add(d);var e=new Z(90,1,a,b);e.up.set(0,-1,0);e.lookAt(new p(-1,0,0));this.add(e);var f=new Z(90,1,a,b);f.up.set(0,0,1);f.lookAt(new p(0,1,0));this.add(f);var g=new Z(90,1,a,b);g.up.set(0,0,-1);g.lookAt(new p(0,-1,0));this.add(g);var h=new Z(90,1,a,b);h.up.set(0,-1,0);h.lookAt(new p(0,0,1));this.add(h);var k=new Z(90,1,a,b);k.up.set(0,-1,0);k.lookAt(new p(0,0,-1));this.add(k);\nthis.renderTarget=new Gb(c,c,{format:1022,magFilter:1006,minFilter:1006});this.renderTarget.texture.name=\"CubeCamera\";this.update=function(a,b){null===this.parent&&this.updateMatrixWorld();var c=this.renderTarget,m=c.texture.generateMipmaps;c.texture.generateMipmaps=!1;c.activeCubeFace=0;a.render(b,d,c);c.activeCubeFace=1;a.render(b,e,c);c.activeCubeFace=2;a.render(b,f,c);c.activeCubeFace=3;a.render(b,g,c);c.activeCubeFace=4;a.render(b,h,c);c.texture.generateMipmaps=m;c.activeCubeFace=5;a.render(b,\nk,c);a.setRenderTarget(null)};this.clear=function(a,b,c,d){for(var e=this.renderTarget,f=0;6>f;f++)e.activeCubeFace=f,a.setRenderTarget(e),a.clear(b,c,d);a.setRenderTarget(null)}}function me(){D.call(this);this.type=\"AudioListener\";this.context=ne.getContext();this.gain=this.context.createGain();this.gain.connect(this.context.destination);this.filter=null}function hc(a){D.call(this);this.type=\"Audio\";this.context=a.context;this.gain=this.context.createGain();this.gain.connect(a.getInput());this.autoplay=\n!1;this.buffer=null;this.loop=!1;this.offset=this.startTime=0;this.playbackRate=1;this.isPlaying=!1;this.hasPlaybackControl=!0;this.sourceType=\"empty\";this.filters=[]}function oe(a){hc.call(this,a);this.panner=this.context.createPanner();this.panner.connect(this.gain)}function pe(a,b){this.analyser=a.context.createAnalyser();this.analyser.fftSize=void 0!==b?b:2048;this.data=new Uint8Array(this.analyser.frequencyBinCount);a.getOutput().connect(this.analyser)}function qe(a,b,c){this.binding=a;this.valueSize=\nc;a=Float64Array;switch(b){case \"quaternion\":b=this._slerp;break;case \"string\":case \"bool\":a=Array;b=this._select;break;default:b=this._lerp}this.buffer=new a(4*c);this._mixBufferRegion=b;this.referenceCount=this.useCount=this.cumulativeWeight=0}function pf(a,b,c){c=c||pa.parseTrackName(b);this._targetGroup=a;this._bindings=a.subscribe_(b,c)}function pa(a,b,c){this.path=b;this.parsedPath=c||pa.parseTrackName(b);this.node=pa.findNode(a,this.parsedPath.nodeName)||a;this.rootNode=a}function qf(){this.uuid=\nH.generateUUID();this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;var a={};this._indicesByUUID=a;for(var b=0,c=arguments.length;b!==c;++b)a[arguments[b].uuid]=b;this._paths=[];this._parsedPaths=[];this._bindings=[];this._bindingsIndicesByPath={};var d=this;this.stats={objects:{get total(){return d._objects.length},get inUse(){return this.total-d.nCachedObjects_}},get bindingsPerObject(){return d._bindings.length}}}function rf(a,b,c){this._mixer=a;this._clip=b;this._localRoot=\nc||null;a=b.tracks;b=a.length;c=Array(b);for(var d={endingStart:2400,endingEnd:2400},e=0;e!==b;++e){var f=a[e].createInterpolant(null);c[e]=f;f.settings=d}this._interpolantSettings=d;this._interpolants=c;this._propertyBindings=Array(b);this._weightInterpolant=this._timeScaleInterpolant=this._byClipCacheIndex=this._cacheIndex=null;this.loop=2201;this._loopCount=-1;this._startTime=null;this.time=0;this._effectiveWeight=this.weight=this._effectiveTimeScale=this.timeScale=1;this.repetitions=Infinity;\nthis.paused=!1;this.enabled=!0;this.clampWhenFinished=!1;this.zeroSlopeAtEnd=this.zeroSlopeAtStart=!0}function re(a){this._root=a;this._initMemoryManager();this.time=this._accuIndex=0;this.timeScale=1}function Ld(a,b){\"string\"===typeof a&&(console.warn(\"THREE.Uniform: Type parameter is no longer needed.\"),a=b);this.value=a}function se(){C.call(this);this.type=\"InstancedBufferGeometry\";this.maxInstancedCount=void 0}function te(a,b,c){ob.call(this,a,b);this.meshPerAttribute=c||1}function ue(a,b,c){Q.call(this,\na,b);this.meshPerAttribute=c||1}function sf(a,b,c,d){this.ray=new mb(a,b);this.near=c||0;this.far=d||Infinity;this.params={Mesh:{},Line:{},LOD:{},Points:{threshold:1},Sprite:{}};Object.defineProperties(this.params,{PointCloud:{get:function(){console.warn(\"THREE.Raycaster: params.PointCloud has been renamed to params.Points.\");return this.Points}}})}function tf(a,b){return a.distance-b.distance}function ve(a,b,c,d){if(!1!==a.visible&&(a.raycast(b,c),!0===d)){a=a.children;d=0;for(var e=a.length;d<e;d++)ve(a[d],\nb,c,!0)}}function uf(a){this.autoStart=void 0!==a?a:!0;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1}function vf(a,b,c){this.radius=void 0!==a?a:1;this.phi=void 0!==b?b:0;this.theta=void 0!==c?c:0;return this}function wf(a,b,c){this.radius=void 0!==a?a:1;this.theta=void 0!==b?b:0;this.y=void 0!==c?c:0;return this}function we(a,b){this.min=void 0!==a?a:new z(Infinity,Infinity);this.max=void 0!==b?b:new z(-Infinity,-Infinity)}function xe(a,b){this.start=void 0!==a?a:new p;this.end=\nvoid 0!==b?b:new p}function ed(a){D.call(this);this.material=a;this.render=function(){}}function fd(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;a=void 0!==c?c:16711680;d=void 0!==d?d:1;b=0;(c=this.object.geometry)&&c.isGeometry?b=3*c.faces.length:c&&c.isBufferGeometry&&(b=c.attributes.normal.count);c=new C;b=new A(6*b,3);c.addAttribute(\"position\",b);W.call(this,c,new Y({color:a,linewidth:d}));this.matrixAutoUpdate=!1;this.update()}function ic(a,b){D.call(this);this.light=a;this.light.updateMatrixWorld();\nthis.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.color=b;a=new C;b=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(var c=0,d=1;32>c;c++,d++){var e=c/32*Math.PI*2,f=d/32*Math.PI*2;b.push(Math.cos(e),Math.sin(e),1,Math.cos(f),Math.sin(f),1)}a.addAttribute(\"position\",new A(b,3));b=new Y({fog:!1});this.cone=new W(a,b);this.add(this.cone);this.update()}function xf(a){var b=[];a&&a.isBone&&b.push(a);for(var c=0;c<a.children.length;c++)b.push.apply(b,xf(a.children[c]));return b}\nfunction jc(a){for(var b=xf(a),c=new C,d=[],e=[],f=new G(0,0,1),g=new G(0,1,0),h=0;h<b.length;h++){var k=b[h];k.parent&&k.parent.isBone&&(d.push(0,0,0),d.push(0,0,0),e.push(f.r,f.g,f.b),e.push(g.r,g.g,g.b))}c.addAttribute(\"position\",new A(d,3));c.addAttribute(\"color\",new A(e,3));d=new Y({vertexColors:2,depthTest:!1,depthWrite:!1,transparent:!0});W.call(this,c,d);this.root=a;this.bones=b;this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1}function kc(a,b,c){this.light=a;this.light.updateMatrixWorld();\nthis.color=c;a=new sb(b,4,2);b=new da({wireframe:!0,fog:!1});la.call(this,a,b);this.matrix=this.light.matrixWorld;this.matrixAutoUpdate=!1;this.update()}function lc(a,b){D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.color=b;a=new Y({fog:!1});b=new C;b.addAttribute(\"position\",new Q(new Float32Array(15),3));this.line=new sa(b,a);this.add(this.line);this.update()}function mc(a,b,c){D.call(this);this.light=a;this.light.updateMatrixWorld();\nthis.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.color=c;a=new pb(b);a.rotateY(.5*Math.PI);this.material=new da({wireframe:!0,fog:!1});void 0===this.color&&(this.material.vertexColors=2);b=a.getAttribute(\"position\");b=new Float32Array(3*b.count);a.addAttribute(\"color\",new Q(b,3));this.add(new la(a,this.material));this.update()}function gd(a,b,c,d){a=a||10;b=b||10;c=new G(void 0!==c?c:4473924);d=new G(void 0!==d?d:8947848);var e=b/2,f=a/b,g=a/2;a=[];for(var h=[],k=0,m=0,q=-g;k<=b;k++,q+=f){a.push(-g,\n0,q,g,0,q);a.push(q,0,-g,q,0,g);var n=k===e?c:d;n.toArray(h,m);m+=3;n.toArray(h,m);m+=3;n.toArray(h,m);m+=3;n.toArray(h,m);m+=3}b=new C;b.addAttribute(\"position\",new A(a,3));b.addAttribute(\"color\",new A(h,3));c=new Y({vertexColors:2});W.call(this,b,c)}function Md(a,b,c,d,e,f){a=a||10;b=b||16;c=c||8;d=d||64;e=new G(void 0!==e?e:4473924);f=new G(void 0!==f?f:8947848);var g=[],h=[],k;for(k=0;k<=b;k++){var m=k/b*2*Math.PI;var q=Math.sin(m)*a;m=Math.cos(m)*a;g.push(0,0,0);g.push(q,0,m);var n=k&1?e:f;h.push(n.r,\nn.g,n.b);h.push(n.r,n.g,n.b)}for(k=0;k<=c;k++){n=k&1?e:f;var l=a-a/c*k;for(b=0;b<d;b++)m=b/d*2*Math.PI,q=Math.sin(m)*l,m=Math.cos(m)*l,g.push(q,0,m),h.push(n.r,n.g,n.b),m=(b+1)/d*2*Math.PI,q=Math.sin(m)*l,m=Math.cos(m)*l,g.push(q,0,m),h.push(n.r,n.g,n.b)}a=new C;a.addAttribute(\"position\",new A(g,3));a.addAttribute(\"color\",new A(h,3));g=new Y({vertexColors:2});W.call(this,a,g)}function hd(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;a=void 0!==c?c:16776960;d=void 0!==d?d:1;b=0;(c=this.object.geometry)&&\nc.isGeometry?b=c.faces.length:console.warn(\"THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.\");c=new C;b=new A(6*b,3);c.addAttribute(\"position\",b);W.call(this,c,new Y({color:a,linewidth:d}));this.matrixAutoUpdate=!1;this.update()}function nc(a,b,c){D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.color=c;void 0===b&&(b=1);a=new C;a.addAttribute(\"position\",new A([-b,b,0,b,b,0,b,-b,0,-b,\n-b,0,-b,b,0],3));b=new Y({fog:!1});this.lightPlane=new sa(a,b);this.add(this.lightPlane);a=new C;a.addAttribute(\"position\",new A([0,0,0,0,0,1],3));this.targetLine=new sa(a,b);this.add(this.targetLine);this.update()}function id(a){function b(a,b,d){c(a,d);c(b,d)}function c(a,b){f.push(0,0,0);g.push(b.r,b.g,b.b);void 0===h[a]&&(h[a]=[]);h[a].push(f.length/3-1)}var d=new C,e=new Y({color:16777215,vertexColors:1}),f=[],g=[],h={},k=new G(16755200),m=new G(16711680),q=new G(43775),n=new G(16777215),l=new G(3355443);\nb(\"n1\",\"n2\",k);b(\"n2\",\"n4\",k);b(\"n4\",\"n3\",k);b(\"n3\",\"n1\",k);b(\"f1\",\"f2\",k);b(\"f2\",\"f4\",k);b(\"f4\",\"f3\",k);b(\"f3\",\"f1\",k);b(\"n1\",\"f1\",k);b(\"n2\",\"f2\",k);b(\"n3\",\"f3\",k);b(\"n4\",\"f4\",k);b(\"p\",\"n1\",m);b(\"p\",\"n2\",m);b(\"p\",\"n3\",m);b(\"p\",\"n4\",m);b(\"u1\",\"u2\",q);b(\"u2\",\"u3\",q);b(\"u3\",\"u1\",q);b(\"c\",\"t\",n);b(\"p\",\"c\",l);b(\"cn1\",\"cn2\",l);b(\"cn3\",\"cn4\",l);b(\"cf1\",\"cf2\",l);b(\"cf3\",\"cf4\",l);d.addAttribute(\"position\",new A(f,3));d.addAttribute(\"color\",new A(g,3));W.call(this,d,e);this.camera=a;this.camera.updateProjectionMatrix&&\nthis.camera.updateProjectionMatrix();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.pointMap=h;this.update()}function Db(a,b){this.object=a;void 0===b&&(b=16776960);a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var c=new Float32Array(24),d=new C;d.setIndex(new Q(a,1));d.addAttribute(\"position\",new Q(c,3));W.call(this,d,new Y({color:b}));this.matrixAutoUpdate=!1;this.update()}function jd(a,b){this.type=\"Box3Helper\";this.box=a;a=void 0!==b?b:16776960;b=new Uint16Array([0,\n1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var c=new C;c.setIndex(new Q(b,1));c.addAttribute(\"position\",new A([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3));W.call(this,c,new Y({color:a}));this.geometry.computeBoundingSphere()}function kd(a,b,c){this.type=\"PlaneHelper\";this.plane=a;this.size=void 0===b?1:b;a=void 0!==c?c:16776960;b=new C;b.addAttribute(\"position\",new A([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3));b.computeBoundingSphere();sa.call(this,\nb,new Y({color:a}));b=new C;b.addAttribute(\"position\",new A([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3));b.computeBoundingSphere();this.add(new la(b,new da({color:a,opacity:.2,transparent:!0,depthWrite:!1})))}function Eb(a,b,c,d,e,f){D.call(this);void 0===d&&(d=16776960);void 0===c&&(c=1);void 0===e&&(e=.2*c);void 0===f&&(f=.2*e);void 0===Nd&&(Nd=new C,Nd.addAttribute(\"position\",new A([0,0,0,0,1,0],3)),ye=new Wa(0,.5,1,5,1),ye.translate(0,-.5,0));this.position.copy(b);this.line=new sa(Nd,new Y({color:d}));\nthis.line.matrixAutoUpdate=!1;this.add(this.line);this.cone=new la(ye,new da({color:d}));this.cone.matrixAutoUpdate=!1;this.add(this.cone);this.setDirection(a);this.setLength(c,e,f)}function ld(a){a=a||1;var b=[0,0,0,a,0,0,0,0,0,0,a,0,0,0,0,0,0,a];a=new C;a.addAttribute(\"position\",new A(b,3));a.addAttribute(\"color\",new A([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));b=new Y({vertexColors:2});W.call(this,a,b)}function yf(a){console.warn(\"THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.\");\nca.call(this,a);this.type=\"catmullrom\";this.closed=!0}function zf(a){console.warn(\"THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.\");ca.call(this,a);this.type=\"catmullrom\"}function ze(a){console.warn(\"THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.\");ca.call(this,a);this.type=\"catmullrom\"}void 0===Number.EPSILON&&(Number.EPSILON=Math.pow(2,-52));void 0===Number.isInteger&&(Number.isInteger=function(a){return\"number\"===typeof a&&isFinite(a)&&Math.floor(a)===\na});void 0===Math.sign&&(Math.sign=function(a){return 0>a?-1:0<a?1:+a});!1===\"name\"in Function.prototype&&Object.defineProperty(Function.prototype,\"name\",{get:function(){return this.toString().match(/^\\s*function\\s*([^\\(\\s]*)/)[1]}});void 0===Object.assign&&function(){Object.assign=function(a){if(void 0===a||null===a)throw new TypeError(\"Cannot convert undefined or null to object\");for(var b=Object(a),c=1;c<arguments.length;c++){var d=arguments[c];if(void 0!==d&&null!==d)for(var e in d)Object.prototype.hasOwnProperty.call(d,\ne)&&(b[e]=d[e])}return b}}();Object.assign(ya.prototype,{addEventListener:function(a,b){void 0===this._listeners&&(this._listeners={});var c=this._listeners;void 0===c[a]&&(c[a]=[]);-1===c[a].indexOf(b)&&c[a].push(b)},hasEventListener:function(a,b){if(void 0===this._listeners)return!1;var c=this._listeners;return void 0!==c[a]&&-1!==c[a].indexOf(b)},removeEventListener:function(a,b){void 0!==this._listeners&&(a=this._listeners[a],void 0!==a&&(b=a.indexOf(b),-1!==b&&a.splice(b,1)))},dispatchEvent:function(a){if(void 0!==\nthis._listeners){var b=this._listeners[a.type];if(void 0!==b){a.target=this;b=b.slice(0);for(var c=0,d=b.length;c<d;c++)b[c].call(this,a)}}}});var H={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){for(var a=[],b=0;256>b;b++)a[b]=(16>b?\"0\":\"\")+b.toString(16);return function(){var b=4294967295*Math.random()|0,d=4294967295*Math.random()|0,e=4294967295*Math.random()|0,f=4294967295*Math.random()|0;return(a[b&255]+a[b>>8&255]+a[b>>16&255]+a[b>>24&255]+\"-\"+a[d&255]+a[d>>8&255]+\"-\"+a[d>>\n16&15|64]+a[d>>24&255]+\"-\"+a[e&63|128]+a[e>>8&255]+\"-\"+a[e>>16&255]+a[e>>24&255]+a[f&255]+a[f>>8&255]+a[f>>16&255]+a[f>>24&255]).toUpperCase()}}(),clamp:function(a,b,c){return Math.max(b,Math.min(c,a))},euclideanModulo:function(a,b){return(a%b+b)%b},mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},lerp:function(a,b,c){return(1-c)*a+c*b},smoothstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;\na=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(.5-Math.random())},degToRad:function(a){return a*H.DEG2RAD},radToDeg:function(a){return a*H.RAD2DEG},isPowerOfTwo:function(a){return 0===(a&a-1)&&0!==a},ceilPowerOfTwo:function(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))},floorPowerOfTwo:function(a){return Math.pow(2,Math.floor(Math.log(a)/\nMath.LN2))}};Object.defineProperties(z.prototype,{width:{get:function(){return this.x},set:function(a){this.x=a}},height:{get:function(){return this.y},set:function(a){this.y=a}}});Object.assign(z.prototype,{isVector2:!0,set:function(a,b){this.x=a;this.y=b;return this},setScalar:function(a){this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw Error(\"index is out of range: \"+\na);}return this},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;default:throw Error(\"index is out of range: \"+a);}},clone:function(){return new this.constructor(this.x,this.y)},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a,b){if(void 0!==b)return console.warn(\"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},addScalar:function(a){this.x+=a;this.y+=a;return this},\naddVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;return this},sub:function(a,b){if(void 0!==b)return console.warn(\"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;return this},subScalar:function(a){this.x-=a;this.y-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},multiply:function(a){this.x*=a.x;this.y*=\na.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divide:function(a){this.x/=a.x;this.y/=a.y;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},applyMatrix3:function(a){var b=this.x,c=this.y;a=a.elements;this.x=a[0]*b+a[3]*c+a[6];this.y=a[1]*b+a[4]*c+a[7];return this},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);return this},clamp:function(a,\nb){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));return this},clampScalar:function(){var a=new z,b=new z;return function(c,d){a.set(c,c);b.set(d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.divideScalar(c||1).multiplyScalar(Math.max(a,Math.min(b,c)))},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this},round:function(){this.x=\nMath.round(this.x);this.y=Math.round(this.y);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);return this},negate:function(){this.x=-this.x;this.y=-this.y;return this},dot:function(a){return this.x*a.x+this.y*a.y},cross:function(a){return this.x*a.y-this.y*a.x},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},manhattanLength:function(){return Math.abs(this.x)+\nMath.abs(this.y)},normalize:function(){return this.divideScalar(this.length()||1)},angle:function(){var a=Math.atan2(this.y,this.x);0>a&&(a+=2*Math.PI);return a},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x;a=this.y-a.y;return b*b+a*a},manhattanDistanceTo:function(a){return Math.abs(this.x-a.x)+Math.abs(this.y-a.y)},setLength:function(a){return this.normalize().multiplyScalar(a)},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=\n(a.y-this.y)*b;return this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;return a},fromBufferAttribute:function(a,b,c){void 0!==c&&console.warn(\"THREE.Vector2: offset has been removed from .fromBufferAttribute().\");this.x=a.getX(b);this.y=a.getY(b);\nreturn this},rotateAround:function(a,b){var c=Math.cos(b);b=Math.sin(b);var d=this.x-a.x,e=this.y-a.y;this.x=d*c-e*b+a.x;this.y=d*b+e*c+a.y;return this}});Object.assign(I.prototype,{isMatrix4:!0,set:function(a,b,c,d,e,f,g,h,k,m,q,n,l,u,r,p){var t=this.elements;t[0]=a;t[4]=b;t[8]=c;t[12]=d;t[1]=e;t[5]=f;t[9]=g;t[13]=h;t[2]=k;t[6]=m;t[10]=q;t[14]=n;t[3]=l;t[7]=u;t[11]=r;t[15]=p;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},clone:function(){return(new I).fromArray(this.elements)},\ncopy:function(a){var b=this.elements;a=a.elements;b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return this},copyPosition:function(a){var b=this.elements;a=a.elements;b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractBasis:function(a,b,c){a.setFromMatrixColumn(this,0);b.setFromMatrixColumn(this,1);c.setFromMatrixColumn(this,2);return this},makeBasis:function(a,b,c){this.set(a.x,\nb.x,c.x,0,a.y,b.y,c.y,0,a.z,b.z,c.z,0,0,0,0,1);return this},extractRotation:function(){var a=new p;return function(b){var c=this.elements,d=b.elements,e=1/a.setFromMatrixColumn(b,0).length(),f=1/a.setFromMatrixColumn(b,1).length();b=1/a.setFromMatrixColumn(b,2).length();c[0]=d[0]*e;c[1]=d[1]*e;c[2]=d[2]*e;c[3]=0;c[4]=d[4]*f;c[5]=d[5]*f;c[6]=d[6]*f;c[7]=0;c[8]=d[8]*b;c[9]=d[9]*b;c[10]=d[10]*b;c[11]=0;c[12]=0;c[13]=0;c[14]=0;c[15]=1;return this}}(),makeRotationFromEuler:function(a){a&&a.isEuler||console.error(\"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.\");\nvar b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c);c=Math.sin(c);var g=Math.cos(d);d=Math.sin(d);var h=Math.cos(e);e=Math.sin(e);if(\"XYZ\"===a.order){a=f*h;var k=f*e,m=c*h,q=c*e;b[0]=g*h;b[4]=-g*e;b[8]=d;b[1]=k+m*d;b[5]=a-q*d;b[9]=-c*g;b[2]=q-a*d;b[6]=m+k*d;b[10]=f*g}else\"YXZ\"===a.order?(a=g*h,k=g*e,m=d*h,q=d*e,b[0]=a+q*c,b[4]=m*c-k,b[8]=f*d,b[1]=f*e,b[5]=f*h,b[9]=-c,b[2]=k*c-m,b[6]=q+a*c,b[10]=f*g):\"ZXY\"===a.order?(a=g*h,k=g*e,m=d*h,q=d*e,b[0]=a-q*c,b[4]=-f*e,b[8]=m+k*c,b[1]=k+m*c,b[5]=f*h,b[9]=\nq-a*c,b[2]=-f*d,b[6]=c,b[10]=f*g):\"ZYX\"===a.order?(a=f*h,k=f*e,m=c*h,q=c*e,b[0]=g*h,b[4]=m*d-k,b[8]=a*d+q,b[1]=g*e,b[5]=q*d+a,b[9]=k*d-m,b[2]=-d,b[6]=c*g,b[10]=f*g):\"YZX\"===a.order?(a=f*g,k=f*d,m=c*g,q=c*d,b[0]=g*h,b[4]=q-a*e,b[8]=m*e+k,b[1]=e,b[5]=f*h,b[9]=-c*h,b[2]=-d*h,b[6]=k*e+m,b[10]=a-q*e):\"XZY\"===a.order&&(a=f*g,k=f*d,m=c*g,q=c*d,b[0]=g*h,b[4]=-e,b[8]=d*h,b[1]=a*e+q,b[5]=f*h,b[9]=k*e-m,b[2]=m*e-k,b[6]=c*h,b[10]=q*e+a);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},makeRotationFromQuaternion:function(){var a=\nnew p(0,0,0),b=new p(1,1,1);return function(c){return this.compose(a,c,b)}}(),lookAt:function(){var a=new p,b=new p,c=new p;return function(d,e,f){var g=this.elements;c.subVectors(d,e);0===c.lengthSq()&&(c.z=1);c.normalize();a.crossVectors(f,c);0===a.lengthSq()&&(1===Math.abs(f.z)?c.x+=1E-4:c.z+=1E-4,c.normalize(),a.crossVectors(f,c));a.normalize();b.crossVectors(c,a);g[0]=a.x;g[4]=b.x;g[8]=c.x;g[1]=a.y;g[5]=b.y;g[9]=c.y;g[2]=a.z;g[6]=b.z;g[10]=c.z;return this}}(),multiply:function(a,b){return void 0!==\nb?(console.warn(\"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\"),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},premultiply:function(a){return this.multiplyMatrices(a,this)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements;b=this.elements;a=c[0];var e=c[4],f=c[8],g=c[12],h=c[1],k=c[5],m=c[9],q=c[13],n=c[2],l=c[6],u=c[10],r=c[14],p=c[3],y=c[7],x=c[11];c=c[15];var w=d[0],B=d[4],E=d[8],P=d[12],N=d[1],z=d[5],A=d[9],D=d[13],C=d[2],\nH=d[6],G=d[10],K=d[14],L=d[3],I=d[7],J=d[11];d=d[15];b[0]=a*w+e*N+f*C+g*L;b[4]=a*B+e*z+f*H+g*I;b[8]=a*E+e*A+f*G+g*J;b[12]=a*P+e*D+f*K+g*d;b[1]=h*w+k*N+m*C+q*L;b[5]=h*B+k*z+m*H+q*I;b[9]=h*E+k*A+m*G+q*J;b[13]=h*P+k*D+m*K+q*d;b[2]=n*w+l*N+u*C+r*L;b[6]=n*B+l*z+u*H+r*I;b[10]=n*E+l*A+u*G+r*J;b[14]=n*P+l*D+u*K+r*d;b[3]=p*w+y*N+x*C+c*L;b[7]=p*B+y*z+x*H+c*I;b[11]=p*E+y*A+x*G+c*J;b[15]=p*P+y*D+x*K+c*d;return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=\na;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},applyToBufferAttribute:function(){var a=new p;return function(b){for(var c=0,d=b.count;c<d;c++)a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.applyMatrix4(this),b.setXYZ(c,a.x,a.y,a.z);return b}}(),determinant:function(){var a=this.elements,b=a[0],c=a[4],d=a[8],e=a[12],f=a[1],g=a[5],h=a[9],k=a[13],m=a[2],q=a[6],n=a[10],l=a[14];return a[3]*(+e*h*q-d*k*q-e*g*n+c*k*n+d*g*l-c*h*l)+a[7]*(+b*h*l-b*k*n+e*f*n-\nd*f*l+d*k*m-e*h*m)+a[11]*(+b*k*q-b*g*l-e*f*q+c*f*l+e*g*m-c*k*m)+a[15]*(-d*g*m-b*h*q+b*g*n+d*f*q-c*f*n+c*h*m)},transpose:function(){var a=this.elements;var b=a[1];a[1]=a[4];a[4]=b;b=a[2];a[2]=a[8];a[8]=b;b=a[6];a[6]=a[9];a[9]=b;b=a[3];a[3]=a[12];a[12]=b;b=a[7];a[7]=a[13];a[13]=b;b=a[11];a[11]=a[14];a[14]=b;return this},setPosition:function(a){var b=this.elements;b[12]=a.x;b[13]=a.y;b[14]=a.z;return this},getInverse:function(a,b){var c=this.elements,d=a.elements;a=d[0];var e=d[1],f=d[2],g=d[3],h=d[4],\nk=d[5],m=d[6],q=d[7],n=d[8],l=d[9],u=d[10],r=d[11],p=d[12],y=d[13],x=d[14];d=d[15];var w=l*x*q-y*u*q+y*m*r-k*x*r-l*m*d+k*u*d,B=p*u*q-n*x*q-p*m*r+h*x*r+n*m*d-h*u*d,E=n*y*q-p*l*q+p*k*r-h*y*r-n*k*d+h*l*d,z=p*l*m-n*y*m-p*k*u+h*y*u+n*k*x-h*l*x,N=a*w+e*B+f*E+g*z;if(0===N){if(!0===b)throw Error(\"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\");console.warn(\"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\");return this.identity()}b=1/N;c[0]=w*b;c[1]=(y*u*g-l*x*g-y*f*\nr+e*x*r+l*f*d-e*u*d)*b;c[2]=(k*x*g-y*m*g+y*f*q-e*x*q-k*f*d+e*m*d)*b;c[3]=(l*m*g-k*u*g-l*f*q+e*u*q+k*f*r-e*m*r)*b;c[4]=B*b;c[5]=(n*x*g-p*u*g+p*f*r-a*x*r-n*f*d+a*u*d)*b;c[6]=(p*m*g-h*x*g-p*f*q+a*x*q+h*f*d-a*m*d)*b;c[7]=(h*u*g-n*m*g+n*f*q-a*u*q-h*f*r+a*m*r)*b;c[8]=E*b;c[9]=(p*l*g-n*y*g-p*e*r+a*y*r+n*e*d-a*l*d)*b;c[10]=(h*y*g-p*k*g+p*e*q-a*y*q-h*e*d+a*k*d)*b;c[11]=(n*k*g-h*l*g-n*e*q+a*l*q+h*e*r-a*k*r)*b;c[12]=z*b;c[13]=(n*y*f-p*l*f+p*e*u-a*y*u-n*e*x+a*l*x)*b;c[14]=(p*k*f-h*y*f-p*e*m+a*y*m+h*e*x-a*k*x)*\nb;c[15]=(h*l*f-n*k*f+n*e*m-a*l*m-h*e*u+a*k*u)*b;return this},scale:function(a){var b=this.elements,c=a.x,d=a.y;a=a.z;b[0]*=c;b[4]*=d;b[8]*=a;b[1]*=c;b[5]*=d;b[9]*=a;b[2]*=c;b[6]*=d;b[10]*=a;b[3]*=c;b[7]*=d;b[11]*=a;return this},getMaxScaleOnAxis:function(){var a=this.elements;return Math.sqrt(Math.max(a[0]*a[0]+a[1]*a[1]+a[2]*a[2],a[4]*a[4]+a[5]*a[5]+a[6]*a[6],a[8]*a[8]+a[9]*a[9]+a[10]*a[10]))},makeTranslation:function(a,b,c){this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1);return this},makeRotationX:function(a){var b=\nMath.cos(a);a=Math.sin(a);this.set(1,0,0,0,0,b,-a,0,0,a,b,0,0,0,0,1);return this},makeRotationY:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,0,a,0,0,1,0,0,-a,0,b,0,0,0,0,1);return this},makeRotationZ:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,-a,0,0,a,b,0,0,0,0,1,0,0,0,0,1);return this},makeRotationAxis:function(a,b){var c=Math.cos(b);b=Math.sin(b);var d=1-c,e=a.x,f=a.y;a=a.z;var g=d*e,h=d*f;this.set(g*e+c,g*f-b*a,g*a+b*f,0,g*f+b*a,h*f+c,h*a-b*e,0,g*a-b*f,h*a+b*e,d*a*a+c,0,0,\n0,0,1);return this},makeScale:function(a,b,c){this.set(a,0,0,0,0,b,0,0,0,0,c,0,0,0,0,1);return this},makeShear:function(a,b,c){this.set(1,b,c,0,a,1,c,0,a,b,1,0,0,0,0,1);return this},compose:function(a,b,c){var d=this.elements,e=b._x,f=b._y,g=b._z,h=b._w,k=e+e,m=f+f,q=g+g;b=e*k;var l=e*m;e*=q;var t=f*m;f*=q;g*=q;k*=h;m*=h;h*=q;q=c.x;var u=c.y;c=c.z;d[0]=(1-(t+g))*q;d[1]=(l+h)*q;d[2]=(e-m)*q;d[3]=0;d[4]=(l-h)*u;d[5]=(1-(b+g))*u;d[6]=(f+k)*u;d[7]=0;d[8]=(e+m)*c;d[9]=(f-k)*c;d[10]=(1-(b+t))*c;d[11]=0;\nd[12]=a.x;d[13]=a.y;d[14]=a.z;d[15]=1;return this},decompose:function(){var a=new p,b=new I;return function(c,d,e){var f=this.elements,g=a.set(f[0],f[1],f[2]).length(),h=a.set(f[4],f[5],f[6]).length(),k=a.set(f[8],f[9],f[10]).length();0>this.determinant()&&(g=-g);c.x=f[12];c.y=f[13];c.z=f[14];b.copy(this);c=1/g;f=1/h;var m=1/k;b.elements[0]*=c;b.elements[1]*=c;b.elements[2]*=c;b.elements[4]*=f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=m;b.elements[9]*=m;b.elements[10]*=m;d.setFromRotationMatrix(b);\ne.x=g;e.y=h;e.z=k;return this}}(),makePerspective:function(a,b,c,d,e,f){void 0===f&&console.warn(\"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.\");var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(c-d);g[9]=(c+d)/(c-d);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=1/(b-a),k=1/(c-d),m=1/(f-e);g[0]=\n2*h;g[4]=0;g[8]=0;g[12]=-((b+a)*h);g[1]=0;g[5]=2*k;g[9]=0;g[13]=-((c+d)*k);g[2]=0;g[6]=0;g[10]=-2*m;g[14]=-((f+e)*m);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},equals:function(a){var b=this.elements;a=a.elements;for(var c=0;16>c;c++)if(b[c]!==a[c])return!1;return!0},fromArray:function(a,b){void 0===b&&(b=0);for(var c=0;16>c;c++)this.elements[c]=a[c+b];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];\na[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a}});Object.assign(fa,{slerp:function(a,b,c,d){return c.copy(a).slerp(b,d)},slerpFlat:function(a,b,c,d,e,f,g){var h=c[d+0],k=c[d+1],m=c[d+2];c=c[d+3];d=e[f+0];var q=e[f+1],l=e[f+2];e=e[f+3];if(c!==e||h!==d||k!==q||m!==l){f=1-g;var t=h*d+k*q+m*l+c*e,u=0<=t?1:-1,r=1-t*t;r>Number.EPSILON&&(r=Math.sqrt(r),t=Math.atan2(r,t*u),f=Math.sin(f*t)/r,g=Math.sin(g*\nt)/r);u*=g;h=h*f+d*u;k=k*f+q*u;m=m*f+l*u;c=c*f+e*u;f===1-g&&(g=1/Math.sqrt(h*h+k*k+m*m+c*c),h*=g,k*=g,m*=g,c*=g)}a[b]=h;a[b+1]=k;a[b+2]=m;a[b+3]=c}});Object.defineProperties(fa.prototype,{x:{get:function(){return this._x},set:function(a){this._x=a;this.onChangeCallback()}},y:{get:function(){return this._y},set:function(a){this._y=a;this.onChangeCallback()}},z:{get:function(){return this._z},set:function(a){this._z=a;this.onChangeCallback()}},w:{get:function(){return this._w},set:function(a){this._w=\na;this.onChangeCallback()}}});Object.assign(fa.prototype,{set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=d;this.onChangeCallback();return this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w)},copy:function(a){this._x=a.x;this._y=a.y;this._z=a.z;this._w=a.w;this.onChangeCallback();return this},setFromEuler:function(a,b){if(!a||!a.isEuler)throw Error(\"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.\");var c=\na._x,d=a._y,e=a._z;a=a.order;var f=Math.cos,g=Math.sin,h=f(c/2),k=f(d/2);f=f(e/2);c=g(c/2);d=g(d/2);e=g(e/2);\"XYZ\"===a?(this._x=c*k*f+h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f-c*d*e):\"YXZ\"===a?(this._x=c*k*f+h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f+c*d*e):\"ZXY\"===a?(this._x=c*k*f-h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f-c*d*e):\"ZYX\"===a?(this._x=c*k*f-h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f+c*d*e):\"YZX\"===a?(this._x=c*k*f+\nh*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f-c*d*e):\"XZY\"===a&&(this._x=c*k*f-h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f+c*d*e);if(!1!==b)this.onChangeCallback();return this},setFromAxisAngle:function(a,b){b/=2;var c=Math.sin(b);this._x=a.x*c;this._y=a.y*c;this._z=a.z*c;this._w=Math.cos(b);this.onChangeCallback();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0];a=b[4];var d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],k=b[6];b=b[10];var m=c+f+b;0<m?(c=.5/\nMath.sqrt(m+1),this._w=.25/c,this._x=(k-g)*c,this._y=(d-h)*c,this._z=(e-a)*c):c>f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(k-g)/c,this._x=.25*c,this._y=(a+e)/c,this._z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-h)/c,this._x=(a+e)/c,this._y=.25*c,this._z=(g+k)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+h)/c,this._y=(g+k)/c,this._z=.25*c);this.onChangeCallback();return this},setFromUnitVectors:function(){var a=new p,b;return function(c,d){void 0===a&&(a=new p);b=c.dot(d)+1;1E-6>b?(b=0,\nMath.abs(c.x)>Math.abs(c.z)?a.set(-c.y,c.x,0):a.set(0,-c.z,c.y)):a.crossVectors(c,d);this._x=a.x;this._y=a.y;this._z=a.z;this._w=b;return this.normalize()}}(),angleTo:function(a){return 2*Math.acos(Math.abs(H.clamp(this.dot(a),-1,1)))},rotateTowards:function(a,b){var c=this.angleTo(a);if(0===c)return this;this.slerp(a,Math.min(1,b/c));return this},inverse:function(){return this.conjugate()},conjugate:function(){this._x*=-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this},dot:function(a){return this._x*\na._x+this._y*a._y+this._z*a._z+this._w*a._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a=this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);this.onChangeCallback();return this},multiply:function(a,b){return void 0!==b?(console.warn(\"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\"),\nthis.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},premultiply:function(a){return this.multiplyQuaternions(a,this)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z;a=a._w;var f=b._x,g=b._y,h=b._z;b=b._w;this._x=c*b+a*f+d*h-e*g;this._y=d*b+a*g+e*f-c*h;this._z=e*b+a*h+c*g-d*f;this._w=a*b-c*f-d*g-e*h;this.onChangeCallback();return this},slerp:function(a,b){if(0===b)return this;if(1===b)return this.copy(a);var c=this._x,d=this._y,e=this._z,f=this._w,g=f*a._w+c*a._x+d*a._y+e*a._z;\n0>g?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=-a._z,g=-g):this.copy(a);if(1<=g)return this._w=f,this._x=c,this._y=d,this._z=e,this;a=1-g*g;if(a<=Number.EPSILON)return g=1-b,this._w=g*f+b*this._w,this._x=g*c+b*this._x,this._y=g*d+b*this._y,this._z=g*e+b*this._z,this.normalize();a=Math.sqrt(a);var h=Math.atan2(a,g);g=Math.sin((1-b)*h)/a;b=Math.sin(b*h)/a;this._w=f*g+this._w*b;this._x=c*g+this._x*b;this._y=d*g+this._y*b;this._z=e*g+this._z*b;this.onChangeCallback();return this},equals:function(a){return a._x===\nthis._x&&a._y===this._y&&a._z===this._z&&a._w===this._w},fromArray:function(a,b){void 0===b&&(b=0);this._x=a[b];this._y=a[b+1];this._z=a[b+2];this._w=a[b+3];this.onChangeCallback();return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this._x;a[b+1]=this._y;a[b+2]=this._z;a[b+3]=this._w;return a},onChange:function(a){this.onChangeCallback=a;return this},onChangeCallback:function(){}});Object.assign(p.prototype,{isVector3:!0,set:function(a,b,c){this.x=a;this.y=b;this.z=c;return this},\nsetScalar:function(a){this.z=this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw Error(\"index is out of range: \"+a);}return this},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error(\"index is out of range: \"+a);}},clone:function(){return new this.constructor(this.x,\nthis.y,this.z)},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},add:function(a,b){if(void 0!==b)return console.warn(\"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;this.z+=\na.z*b;return this},sub:function(a,b){if(void 0!==b)return console.warn(\"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;return this},subScalar:function(a){this.x-=a;this.y-=a;this.z-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this},multiply:function(a,b){if(void 0!==b)return console.warn(\"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\"),\nthis.multiplyVectors(a,b);this.x*=a.x;this.y*=a.y;this.z*=a.z;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;return this},multiplyVectors:function(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this},applyEuler:function(){var a=new fa;return function(b){b&&b.isEuler||console.error(\"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.\");return this.applyQuaternion(a.setFromEuler(b))}}(),applyAxisAngle:function(){var a=new fa;return function(b,\nc){return this.applyQuaternion(a.setFromAxisAngle(b,c))}}(),applyMatrix3:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[3]*c+a[6]*d;this.y=a[1]*b+a[4]*c+a[7]*d;this.z=a[2]*b+a[5]*c+a[8]*d;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;var e=1/(a[3]*b+a[7]*c+a[11]*d+a[15]);this.x=(a[0]*b+a[4]*c+a[8]*d+a[12])*e;this.y=(a[1]*b+a[5]*c+a[9]*d+a[13])*e;this.z=(a[2]*b+a[6]*c+a[10]*d+a[14])*e;return this},applyQuaternion:function(a){var b=this.x,\nc=this.y,d=this.z,e=a.x,f=a.y,g=a.z;a=a.w;var h=a*b+f*d-g*c,k=a*c+g*b-e*d,m=a*d+e*c-f*b;b=-e*b-f*c-g*d;this.x=h*a+b*-e+k*-g-m*-f;this.y=k*a+b*-f+m*-e-h*-g;this.z=m*a+b*-g+h*-f-k*-e;return this},project:function(){var a=new I;return function(b){a.multiplyMatrices(b.projectionMatrix,a.getInverse(b.matrixWorld));return this.applyMatrix4(a)}}(),unproject:function(){var a=new I;return function(b){a.multiplyMatrices(b.matrixWorld,a.getInverse(b.projectionMatrix));return this.applyMatrix4(a)}}(),transformDirection:function(a){var b=\nthis.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d;this.y=a[1]*b+a[5]*c+a[9]*d;this.z=a[2]*b+a[6]*c+a[10]*d;return this.normalize()},divide:function(a){this.x/=a.x;this.y/=a.y;this.z/=a.z;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);this.z=Math.min(this.z,a.z);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);this.z=Math.max(this.z,a.z);return this},clamp:function(a,\nb){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));this.z=Math.max(a.z,Math.min(b.z,this.z));return this},clampScalar:function(){var a=new p,b=new p;return function(c,d){a.set(c,c,c);b.set(d,d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.divideScalar(c||1).multiplyScalar(Math.max(a,Math.min(b,c)))},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this},ceil:function(){this.x=\nMath.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);return this},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this},dot:function(a){return this.x*a.x+this.y*\na.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(a){return this.normalize().multiplyScalar(a)},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this},lerpVectors:function(a,\nb,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},cross:function(a,b){return void 0!==b?(console.warn(\"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\"),this.crossVectors(a,b)):this.crossVectors(this,a)},crossVectors:function(a,b){var c=a.x,d=a.y;a=a.z;var e=b.x,f=b.y;b=b.z;this.x=d*b-a*f;this.y=a*e-c*b;this.z=c*f-d*e;return this},projectOnVector:function(a){var b=a.dot(this)/a.lengthSq();return this.copy(a).multiplyScalar(b)},projectOnPlane:function(){var a=\nnew p;return function(b){a.copy(this).projectOnVector(b);return this.sub(a)}}(),reflect:function(){var a=new p;return function(b){return this.sub(a.copy(b).multiplyScalar(2*this.dot(b)))}}(),angleTo:function(a){a=this.dot(a)/Math.sqrt(this.lengthSq()*a.lengthSq());return Math.acos(H.clamp(a,-1,1))},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y;a=this.z-a.z;return b*b+c*c+a*a},manhattanDistanceTo:function(a){return Math.abs(this.x-\na.x)+Math.abs(this.y-a.y)+Math.abs(this.z-a.z)},setFromSpherical:function(a){var b=Math.sin(a.phi)*a.radius;this.x=b*Math.sin(a.theta);this.y=Math.cos(a.phi)*a.radius;this.z=b*Math.cos(a.theta);return this},setFromCylindrical:function(a){this.x=a.radius*Math.sin(a.theta);this.y=a.y;this.z=a.radius*Math.cos(a.theta);return this},setFromMatrixPosition:function(a){a=a.elements;this.x=a[12];this.y=a[13];this.z=a[14];return this},setFromMatrixScale:function(a){var b=this.setFromMatrixColumn(a,0).length(),\nc=this.setFromMatrixColumn(a,1).length();a=this.setFromMatrixColumn(a,2).length();this.x=b;this.y=c;this.z=a;return this},setFromMatrixColumn:function(a,b){return this.fromArray(a.elements,4*b)},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];this.z=a[b+2];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;a[b+2]=this.z;return a},fromBufferAttribute:function(a,b,c){void 0!==\nc&&console.warn(\"THREE.Vector3: offset has been removed from .fromBufferAttribute().\");this.x=a.getX(b);this.y=a.getY(b);this.z=a.getZ(b);return this}});Object.assign(ra.prototype,{isMatrix3:!0,set:function(a,b,c,d,e,f,g,h,k){var m=this.elements;m[0]=a;m[1]=d;m[2]=g;m[3]=b;m[4]=e;m[5]=h;m[6]=c;m[7]=f;m[8]=k;return this},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this},clone:function(){return(new this.constructor).fromArray(this.elements)},copy:function(a){var b=this.elements;a=a.elements;\nb[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return this},setFromMatrix4:function(a){a=a.elements;this.set(a[0],a[4],a[8],a[1],a[5],a[9],a[2],a[6],a[10]);return this},applyToBufferAttribute:function(){var a=new p;return function(b){for(var c=0,d=b.count;c<d;c++)a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.applyMatrix3(this),b.setXYZ(c,a.x,a.y,a.z);return b}}(),multiply:function(a){return this.multiplyMatrices(this,a)},premultiply:function(a){return this.multiplyMatrices(a,\nthis)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements;b=this.elements;a=c[0];var e=c[3],f=c[6],g=c[1],h=c[4],k=c[7],m=c[2],q=c[5];c=c[8];var l=d[0],t=d[3],u=d[6],r=d[1],p=d[4],y=d[7],x=d[2],w=d[5];d=d[8];b[0]=a*l+e*r+f*x;b[3]=a*t+e*p+f*w;b[6]=a*u+e*y+f*d;b[1]=g*l+h*r+k*x;b[4]=g*t+h*p+k*w;b[7]=g*u+h*y+k*d;b[2]=m*l+q*r+c*x;b[5]=m*t+q*p+c*w;b[8]=m*u+q*y+c*d;return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[3]*=a;b[6]*=a;b[1]*=a;b[4]*=a;b[7]*=a;b[2]*=a;b[5]*=a;b[8]*=\na;return this},determinant:function(){var a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],k=a[7];a=a[8];return b*f*a-b*g*k-c*e*a+c*g*h+d*e*k-d*f*h},getInverse:function(a,b){a&&a.isMatrix4&&console.error(\"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\");var c=a.elements;a=this.elements;var d=c[0],e=c[1],f=c[2],g=c[3],h=c[4],k=c[5],m=c[6],q=c[7];c=c[8];var l=c*h-k*q,t=k*m-c*g,u=q*g-h*m,r=d*l+e*t+f*u;if(0===r){if(!0===b)throw Error(\"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\");\nconsole.warn(\"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\");return this.identity()}b=1/r;a[0]=l*b;a[1]=(f*q-c*e)*b;a[2]=(k*e-f*h)*b;a[3]=t*b;a[4]=(c*d-f*m)*b;a[5]=(f*g-k*d)*b;a[6]=u*b;a[7]=(e*m-q*d)*b;a[8]=(h*d-e*g)*b;return this},transpose:function(){var a=this.elements;var b=a[1];a[1]=a[3];a[3]=b;b=a[2];a[2]=a[6];a[6]=b;b=a[5];a[5]=a[7];a[7]=b;return this},getNormalMatrix:function(a){return this.setFromMatrix4(a).getInverse(this).transpose()},transposeIntoArray:function(a){var b=\nthis.elements;a[0]=b[0];a[1]=b[3];a[2]=b[6];a[3]=b[1];a[4]=b[4];a[5]=b[7];a[6]=b[2];a[7]=b[5];a[8]=b[8];return this},setUvTransform:function(a,b,c,d,e,f,g){var h=Math.cos(e);e=Math.sin(e);this.set(c*h,c*e,-c*(h*f+e*g)+f+a,-d*e,d*h,-d*(-e*f+h*g)+g+b,0,0,1)},scale:function(a,b){var c=this.elements;c[0]*=a;c[3]*=a;c[6]*=a;c[1]*=b;c[4]*=b;c[7]*=b;return this},rotate:function(a){var b=Math.cos(a);a=Math.sin(a);var c=this.elements,d=c[0],e=c[3],f=c[6],g=c[1],h=c[4],k=c[7];c[0]=b*d+a*g;c[3]=b*e+a*h;c[6]=\nb*f+a*k;c[1]=-a*d+b*g;c[4]=-a*e+b*h;c[7]=-a*f+b*k;return this},translate:function(a,b){var c=this.elements;c[0]+=a*c[2];c[3]+=a*c[5];c[6]+=a*c[8];c[1]+=b*c[2];c[4]+=b*c[5];c[7]+=b*c[8];return this},equals:function(a){var b=this.elements;a=a.elements;for(var c=0;9>c;c++)if(b[c]!==a[c])return!1;return!0},fromArray:function(a,b){void 0===b&&(b=0);for(var c=0;9>c;c++)this.elements[c]=a[c+b];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);var c=this.elements;a[b]=c[0];a[b+1]=c[1];\na[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];return a}});var eb={getDataURL:function(a){if(a instanceof HTMLCanvasElement)var b=a;else{\"undefined\"!==typeof OffscreenCanvas?b=new OffscreenCanvas(a.width,a.height):(b=document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"canvas\"),b.width=a.width,b.height=a.height);var c=b.getContext(\"2d\");a instanceof ImageData?c.putImageData(a,0,0):c.drawImage(a,0,0,a.width,a.height)}return 2048<b.width||2048<b.height?b.toDataURL(\"image/jpeg\",\n.6):b.toDataURL(\"image/png\")}},Ef=0;T.DEFAULT_IMAGE=void 0;T.DEFAULT_MAPPING=300;T.prototype=Object.assign(Object.create(ya.prototype),{constructor:T,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.name=a.name;this.image=a.image;this.mipmaps=a.mipmaps.slice(0);this.mapping=a.mapping;this.wrapS=a.wrapS;this.wrapT=\na.wrapT;this.magFilter=a.magFilter;this.minFilter=a.minFilter;this.anisotropy=a.anisotropy;this.format=a.format;this.type=a.type;this.offset.copy(a.offset);this.repeat.copy(a.repeat);this.center.copy(a.center);this.rotation=a.rotation;this.matrixAutoUpdate=a.matrixAutoUpdate;this.matrix.copy(a.matrix);this.generateMipmaps=a.generateMipmaps;this.premultiplyAlpha=a.premultiplyAlpha;this.flipY=a.flipY;this.unpackAlignment=a.unpackAlignment;this.encoding=a.encoding;return this},toJSON:function(a){var b=\nvoid 0===a||\"string\"===typeof a;if(!b&&void 0!==a.textures[this.uuid])return a.textures[this.uuid];var c={metadata:{version:4.5,type:\"Texture\",generator:\"Texture.toJSON\"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY};if(void 0!==\nthis.image){var d=this.image;void 0===d.uuid&&(d.uuid=H.generateUUID());if(!b&&void 0===a.images[d.uuid]){if(Array.isArray(d)){var e=[];for(var f=0,g=d.length;f<g;f++)e.push(eb.getDataURL(d[f]))}else e=eb.getDataURL(d);a.images[d.uuid]={uuid:d.uuid,url:e}}c.image=d.uuid}b||(a.textures[this.uuid]=c);return c},dispose:function(){this.dispatchEvent({type:\"dispose\"})},transformUv:function(a){if(300===this.mapping){a.applyMatrix3(this.matrix);if(0>a.x||1<a.x)switch(this.wrapS){case 1E3:a.x-=Math.floor(a.x);\nbreak;case 1001:a.x=0>a.x?0:1;break;case 1002:a.x=1===Math.abs(Math.floor(a.x)%2)?Math.ceil(a.x)-a.x:a.x-Math.floor(a.x)}if(0>a.y||1<a.y)switch(this.wrapT){case 1E3:a.y-=Math.floor(a.y);break;case 1001:a.y=0>a.y?0:1;break;case 1002:a.y=1===Math.abs(Math.floor(a.y)%2)?Math.ceil(a.y)-a.y:a.y-Math.floor(a.y)}this.flipY&&(a.y=1-a.y)}}});Object.defineProperty(T.prototype,\"needsUpdate\",{set:function(a){!0===a&&this.version++}});Object.assign(V.prototype,{isVector4:!0,set:function(a,b,c,d){this.x=a;this.y=\nb;this.z=c;this.w=d;return this},setScalar:function(a){this.w=this.z=this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setW:function(a){this.w=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;case 3:this.w=b;break;default:throw Error(\"index is out of range: \"+a);}return this},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;\ncase 2:return this.z;case 3:return this.w;default:throw Error(\"index is out of range: \"+a);}},clone:function(){return new this.constructor(this.x,this.y,this.z,this.w)},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=void 0!==a.w?a.w:1;return this},add:function(a,b){if(void 0!==b)return console.warn(\"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this},addScalar:function(a){this.x+=\na;this.y+=a;this.z+=a;this.w+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;this.z+=a.z*b;this.w+=a.w*b;return this},sub:function(a,b){if(void 0!==b)return console.warn(\"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this},subScalar:function(a){this.x-=a;this.y-=\na;this.z-=a;this.w-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;this.w*=a;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,e=this.w;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12]*e;this.y=a[1]*b+a[5]*c+a[9]*d+a[13]*e;this.z=a[2]*b+a[6]*c+a[10]*d+a[14]*e;this.w=a[3]*b+a[7]*c+a[11]*d+a[15]*e;return this},divideScalar:function(a){return this.multiplyScalar(1/\na)},setAxisAngleFromQuaternion:function(a){this.w=2*Math.acos(a.w);var b=Math.sqrt(1-a.w*a.w);1E-4>b?(this.x=1,this.z=this.y=0):(this.x=a.x/b,this.y=a.y/b,this.z=a.z/b);return this},setAxisAngleFromRotationMatrix:function(a){a=a.elements;var b=a[0];var c=a[4];var d=a[8],e=a[1],f=a[5],g=a[9];var h=a[2];var k=a[6];var m=a[10];if(.01>Math.abs(c-e)&&.01>Math.abs(d-h)&&.01>Math.abs(g-k)){if(.1>Math.abs(c+e)&&.1>Math.abs(d+h)&&.1>Math.abs(g+k)&&.1>Math.abs(b+f+m-3))return this.set(1,0,0,0),this;a=Math.PI;\nb=(b+1)/2;f=(f+1)/2;m=(m+1)/2;c=(c+e)/4;d=(d+h)/4;g=(g+k)/4;b>f&&b>m?.01>b?(k=0,c=h=.707106781):(k=Math.sqrt(b),h=c/k,c=d/k):f>m?.01>f?(k=.707106781,h=0,c=.707106781):(h=Math.sqrt(f),k=c/h,c=g/h):.01>m?(h=k=.707106781,c=0):(c=Math.sqrt(m),k=d/c,h=g/c);this.set(k,h,c,a);return this}a=Math.sqrt((k-g)*(k-g)+(d-h)*(d-h)+(e-c)*(e-c));.001>Math.abs(a)&&(a=1);this.x=(k-g)/a;this.y=(d-h)/a;this.z=(e-c)/a;this.w=Math.acos((b+f+m-1)/2);return this},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,\na.y);this.z=Math.min(this.z,a.z);this.w=Math.min(this.w,a.w);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);this.z=Math.max(this.z,a.z);this.w=Math.max(this.w,a.w);return this},clamp:function(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));this.z=Math.max(a.z,Math.min(b.z,this.z));this.w=Math.max(a.w,Math.min(b.w,this.w));return this},clampScalar:function(){var a,b;return function(c,d){void 0===a&&(a=new V,b=new V);a.set(c,\nc,c,c);b.set(d,d,d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.divideScalar(c||1).multiplyScalar(Math.max(a,Math.min(b,c)))},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);\nthis.z=Math.round(this.z);this.w=Math.round(this.w);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);this.w=0>this.w?Math.ceil(this.w):Math.floor(this.w);return this},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w},lengthSq:function(){return this.x*\nthis.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(a){return this.normalize().multiplyScalar(a)},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;this.w+=(a.w-this.w)*b;return this},lerpVectors:function(a,\nb,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z&&a.w===this.w},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];this.z=a[b+2];this.w=a[b+3];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;a[b+2]=this.z;a[b+3]=this.w;return a},fromBufferAttribute:function(a,b,c){void 0!==c&&console.warn(\"THREE.Vector4: offset has been removed from .fromBufferAttribute().\");\nthis.x=a.getX(b);this.y=a.getY(b);this.z=a.getZ(b);this.w=a.getW(b);return this}});fb.prototype=Object.assign(Object.create(ya.prototype),{constructor:fb,isWebGLRenderTarget:!0,setSize:function(a,b){if(this.width!==a||this.height!==b)this.width=a,this.height=b,this.dispose();this.viewport.set(0,0,a,b);this.scissor.set(0,0,a,b)},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.width=a.width;this.height=a.height;this.viewport.copy(a.viewport);this.texture=a.texture.clone();\nthis.depthBuffer=a.depthBuffer;this.stencilBuffer=a.stencilBuffer;this.depthTexture=a.depthTexture;return this},dispose:function(){this.dispatchEvent({type:\"dispose\"})}});Gb.prototype=Object.create(fb.prototype);Gb.prototype.constructor=Gb;Gb.prototype.isWebGLRenderTargetCube=!0;gb.prototype=Object.create(T.prototype);gb.prototype.constructor=gb;gb.prototype.isDataTexture=!0;Object.assign(Sa.prototype,{isBox3:!0,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromArray:function(a){for(var b=\nInfinity,c=Infinity,d=Infinity,e=-Infinity,f=-Infinity,g=-Infinity,h=0,k=a.length;h<k;h+=3){var m=a[h],q=a[h+1],l=a[h+2];m<b&&(b=m);q<c&&(c=q);l<d&&(d=l);m>e&&(e=m);q>f&&(f=q);l>g&&(g=l)}this.min.set(b,c,d);this.max.set(e,f,g);return this},setFromBufferAttribute:function(a){for(var b=Infinity,c=Infinity,d=Infinity,e=-Infinity,f=-Infinity,g=-Infinity,h=0,k=a.count;h<k;h++){var m=a.getX(h),l=a.getY(h),n=a.getZ(h);m<b&&(b=m);l<c&&(c=l);n<d&&(d=n);m>e&&(e=m);l>f&&(f=l);n>g&&(g=n)}this.min.set(b,c,d);\nthis.max.set(e,f,g);return this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=new p;return function(b,c){c=a.copy(c).multiplyScalar(.5);this.min.copy(b).sub(c);this.max.copy(b).add(c);return this}}(),setFromObject:function(a){this.makeEmpty();return this.expandByObject(a)},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},\nmakeEmpty:function(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},getCenter:function(a){void 0===a&&(console.warn(\"THREE.Box3: .getCenter() target is now required\"),a=new p);return this.isEmpty()?a.set(0,0,0):a.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(a){void 0===a&&(console.warn(\"THREE.Box3: .getSize() target is now required\"),\na=new p);return this.isEmpty()?a.set(0,0,0):a.subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},expandByObject:function(){function a(a){var f=a.geometry;if(void 0!==f)if(f.isGeometry)for(f=f.vertices,c=0,d=f.length;c<d;c++)e.copy(f[c]),e.applyMatrix4(a.matrixWorld),b.expandByPoint(e);else if(f.isBufferGeometry&&\n(f=f.attributes.position,void 0!==f))for(c=0,d=f.count;c<d;c++)e.fromBufferAttribute(f,c).applyMatrix4(a.matrixWorld),b.expandByPoint(e)}var b,c,d,e=new p;return function(c){b=this;c.updateMatrixWorld(!0);c.traverse(a);return this}}(),containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||a.z<this.min.z||a.z>this.max.z?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&\na.max.z<=this.max.z},getParameter:function(a,b){void 0===b&&(console.warn(\"THREE.Box3: .getParameter() target is now required\"),b=new p);return b.set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y),(a.z-this.min.z)/(this.max.z-this.min.z))},intersectsBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||a.max.z<this.min.z||a.min.z>this.max.z?!1:!0},intersectsSphere:function(){var a=new p;return function(b){this.clampPoint(b.center,\na);return a.distanceToSquared(b.center)<=b.radius*b.radius}}(),intersectsPlane:function(a){if(0<a.normal.x){var b=a.normal.x*this.min.x;var c=a.normal.x*this.max.x}else b=a.normal.x*this.max.x,c=a.normal.x*this.min.x;0<a.normal.y?(b+=a.normal.y*this.min.y,c+=a.normal.y*this.max.y):(b+=a.normal.y*this.max.y,c+=a.normal.y*this.min.y);0<a.normal.z?(b+=a.normal.z*this.min.z,c+=a.normal.z*this.max.z):(b+=a.normal.z*this.max.z,c+=a.normal.z*this.min.z);return b<=a.constant&&c>=a.constant},intersectsTriangle:function(){function a(a){var e;\nvar f=0;for(e=a.length-3;f<=e;f+=3){h.fromArray(a,f);var g=m.x*Math.abs(h.x)+m.y*Math.abs(h.y)+m.z*Math.abs(h.z),k=b.dot(h),l=c.dot(h),q=d.dot(h);if(Math.max(-Math.max(k,l,q),Math.min(k,l,q))>g)return!1}return!0}var b=new p,c=new p,d=new p,e=new p,f=new p,g=new p,h=new p,k=new p,m=new p,l=new p;return function(h){if(this.isEmpty())return!1;this.getCenter(k);m.subVectors(this.max,k);b.subVectors(h.a,k);c.subVectors(h.b,k);d.subVectors(h.c,k);e.subVectors(c,b);f.subVectors(d,c);g.subVectors(b,d);h=\n[0,-e.z,e.y,0,-f.z,f.y,0,-g.z,g.y,e.z,0,-e.x,f.z,0,-f.x,g.z,0,-g.x,-e.y,e.x,0,-f.y,f.x,0,-g.y,g.x,0];if(!a(h))return!1;h=[1,0,0,0,1,0,0,0,1];if(!a(h))return!1;l.crossVectors(e,f);h=[l.x,l.y,l.z];return a(h)}}(),clampPoint:function(a,b){void 0===b&&(console.warn(\"THREE.Box3: .clampPoint() target is now required\"),b=new p);return b.copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new p;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),getBoundingSphere:function(){var a=\nnew p;return function(b){void 0===b&&(console.warn(\"THREE.Box3: .getBoundingSphere() target is now required\"),b=new Da);this.getCenter(b.center);b.radius=.5*this.getSize(a).length();return b}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);this.isEmpty()&&this.makeEmpty();return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},applyMatrix4:function(a){if(this.isEmpty())return this;a=a.elements;var b=a[0]*this.min.x,c=a[1]*this.min.x,d=a[2]*this.min.x,e=\na[0]*this.max.x,f=a[1]*this.max.x,g=a[2]*this.max.x,h=a[4]*this.min.y,k=a[5]*this.min.y,m=a[6]*this.min.y,l=a[4]*this.max.y,n=a[5]*this.max.y,t=a[6]*this.max.y,u=a[8]*this.min.z,r=a[9]*this.min.z,p=a[10]*this.min.z,y=a[8]*this.max.z,x=a[9]*this.max.z,w=a[10]*this.max.z;this.min.x=Math.min(b,e)+Math.min(h,l)+Math.min(u,y)+a[12];this.min.y=Math.min(c,f)+Math.min(k,n)+Math.min(r,x)+a[13];this.min.z=Math.min(d,g)+Math.min(m,t)+Math.min(p,w)+a[14];this.max.x=Math.max(b,e)+Math.max(h,l)+Math.max(u,y)+a[12];\nthis.max.y=Math.max(c,f)+Math.max(k,n)+Math.max(r,x)+a[13];this.max.z=Math.max(d,g)+Math.max(m,t)+Math.max(p,w)+a[14];return this},translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)}});Object.assign(Da.prototype,{set:function(a,b){this.center.copy(a);this.radius=b;return this},setFromPoints:function(){var a=new Sa;return function(b,c){var d=this.center;void 0!==c?d.copy(c):a.setFromPoints(b).getCenter(d);for(var e=\nc=0,f=b.length;e<f;e++)c=Math.max(c,d.distanceToSquared(b[e]));this.radius=Math.sqrt(c);return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.center.copy(a.center);this.radius=a.radius;return this},empty:function(){return 0>=this.radius},containsPoint:function(a){return a.distanceToSquared(this.center)<=this.radius*this.radius},distanceToPoint:function(a){return a.distanceTo(this.center)-this.radius},intersectsSphere:function(a){var b=this.radius+a.radius;\nreturn a.center.distanceToSquared(this.center)<=b*b},intersectsBox:function(a){return a.intersectsSphere(this)},intersectsPlane:function(a){return Math.abs(a.distanceToPoint(this.center))<=this.radius},clampPoint:function(a,b){var c=this.center.distanceToSquared(a);void 0===b&&(console.warn(\"THREE.Sphere: .clampPoint() target is now required\"),b=new p);b.copy(a);c>this.radius*this.radius&&(b.sub(this.center).normalize(),b.multiplyScalar(this.radius).add(this.center));return b},getBoundingBox:function(a){void 0===\na&&(console.warn(\"THREE.Sphere: .getBoundingBox() target is now required\"),a=new Sa);a.set(this.center,this.center);a.expandByScalar(this.radius);return a},applyMatrix4:function(a){this.center.applyMatrix4(a);this.radius*=a.getMaxScaleOnAxis();return this},translate:function(a){this.center.add(a);return this},equals:function(a){return a.center.equals(this.center)&&a.radius===this.radius}});Object.assign(Ma.prototype,{set:function(a,b){this.normal.copy(a);this.constant=b;return this},setComponents:function(a,\nb,c,d){this.normal.set(a,b,c);this.constant=d;return this},setFromNormalAndCoplanarPoint:function(a,b){this.normal.copy(a);this.constant=-b.dot(this.normal);return this},setFromCoplanarPoints:function(){var a=new p,b=new p;return function(c,d,e){d=a.subVectors(e,d).cross(b.subVectors(c,d)).normalize();this.setFromNormalAndCoplanarPoint(d,c);return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.normal.copy(a.normal);this.constant=a.constant;return this},normalize:function(){var a=\n1/this.normal.length();this.normal.multiplyScalar(a);this.constant*=a;return this},negate:function(){this.constant*=-1;this.normal.negate();return this},distanceToPoint:function(a){return this.normal.dot(a)+this.constant},distanceToSphere:function(a){return this.distanceToPoint(a.center)-a.radius},projectPoint:function(a,b){void 0===b&&(console.warn(\"THREE.Plane: .projectPoint() target is now required\"),b=new p);return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a)},intersectLine:function(){var a=\nnew p;return function(b,c){void 0===c&&(console.warn(\"THREE.Plane: .intersectLine() target is now required\"),c=new p);var d=b.delta(a),e=this.normal.dot(d);if(0===e){if(0===this.distanceToPoint(b.start))return c.copy(b.start)}else if(e=-(b.start.dot(this.normal)+this.constant)/e,!(0>e||1<e))return c.copy(d).multiplyScalar(e).add(b.start)}}(),intersectsLine:function(a){var b=this.distanceToPoint(a.start);a=this.distanceToPoint(a.end);return 0>b&&0<a||0>a&&0<b},intersectsBox:function(a){return a.intersectsPlane(this)},\nintersectsSphere:function(a){return a.intersectsPlane(this)},coplanarPoint:function(a){void 0===a&&(console.warn(\"THREE.Plane: .coplanarPoint() target is now required\"),a=new p);return a.copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(){var a=new p,b=new ra;return function(c,d){d=d||b.getNormalMatrix(c);c=this.coplanarPoint(a).applyMatrix4(c);d=this.normal.applyMatrix3(d).normalize();this.constant=-c.dot(d);return this}}(),translate:function(a){this.constant-=a.dot(this.normal);\nreturn this},equals:function(a){return a.normal.equals(this.normal)&&a.constant===this.constant}});Object.assign(md.prototype,{set:function(a,b,c,d,e,f){var g=this.planes;g[0].copy(a);g[1].copy(b);g[2].copy(c);g[3].copy(d);g[4].copy(e);g[5].copy(f);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){for(var b=this.planes,c=0;6>c;c++)b[c].copy(a.planes[c]);return this},setFromMatrix:function(a){var b=this.planes,c=a.elements;a=c[0];var d=c[1],e=c[2],f=c[3],g=c[4],\nh=c[5],k=c[6],m=c[7],l=c[8],n=c[9],t=c[10],p=c[11],r=c[12],v=c[13],y=c[14];c=c[15];b[0].setComponents(f-a,m-g,p-l,c-r).normalize();b[1].setComponents(f+a,m+g,p+l,c+r).normalize();b[2].setComponents(f+d,m+h,p+n,c+v).normalize();b[3].setComponents(f-d,m-h,p-n,c-v).normalize();b[4].setComponents(f-e,m-k,p-t,c-y).normalize();b[5].setComponents(f+e,m+k,p+t,c+y).normalize();return this},intersectsObject:function(){var a=new Da;return function(b){var c=b.geometry;null===c.boundingSphere&&c.computeBoundingSphere();\na.copy(c.boundingSphere).applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSprite:function(){var a=new Da;return function(b){a.center.set(0,0,0);a.radius=.7071067811865476;a.applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSphere:function(a){var b=this.planes,c=a.center;a=-a.radius;for(var d=0;6>d;d++)if(b[d].distanceToPoint(c)<a)return!1;return!0},intersectsBox:function(){var a=new p;return function(b){for(var c=this.planes,d=0;6>d;d++){var e=c[d];\na.x=0<e.normal.x?b.max.x:b.min.x;a.y=0<e.normal.y?b.max.y:b.min.y;a.z=0<e.normal.z?b.max.z:b.min.z;if(0>e.distanceToPoint(a))return!1}return!0}}(),containsPoint:function(a){for(var b=this.planes,c=0;6>c;c++)if(0>b[c].distanceToPoint(a))return!1;return!0}});var S={alphamap_fragment:\"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\",alphamap_pars_fragment:\"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\",alphatest_fragment:\"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\",\naomap_fragment:\"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\",aomap_pars_fragment:\"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\",\nbegin_vertex:\"\\nvec3 transformed = vec3( position );\\n\",beginnormal_vertex:\"\\nvec3 objectNormal = vec3( normal );\\n\",bsdfs:\"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t}\\n\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\",\nbumpmap_pars_fragment:\"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\",\nclipping_planes_fragment:\"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\\n\",\nclipping_planes_pars_fragment:\"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\",clipping_planes_pars_vertex:\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\",clipping_planes_vertex:\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\",\ncolor_fragment:\"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\",color_pars_fragment:\"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\",color_pars_vertex:\"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\",color_vertex:\"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\",common:\"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\n\",\ncube_uv_reflection_fragment:\"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\",\ndefaultnormal_vertex:\"vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n\",displacementmap_pars_vertex:\"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\",displacementmap_vertex:\"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\",\nemissivemap_fragment:\"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\",emissivemap_pars_fragment:\"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\",encodings_fragment:\"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\",encodings_pars_fragment:\"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM            = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat D      = max( maxRange / maxRGB, 1.0 );\\n\\tD            = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract(Le);\\n\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n\\treturn vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\",\nenvmap_fragment:\"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\",\nenvmap_pars_fragment:\"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\",\nenvmap_pars_vertex:\"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\",envmap_physical_pars_fragment:\"#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\",\nenvmap_vertex:\"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\",\nfog_vertex:\"\\n#ifdef USE_FOG\\nfogDepth = -mvPosition.z;\\n#endif\",fog_pars_vertex:\"#ifdef USE_FOG\\n  varying float fogDepth;\\n#endif\\n\",fog_fragment:\"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\",fog_pars_fragment:\"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\\n\",\ngradientmap_pars_fragment:\"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\",lightmap_fragment:\"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\",\nlightmap_pars_fragment:\"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\",lights_lambert_vertex:\"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\",\nlights_pars_begin:\"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n\",\nlights_phong_fragment:\"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\",lights_phong_pars_fragment:\"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\",\nlights_physical_fragment:\"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\",\nlights_physical_pars_fragment:\"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\",\nlights_fragment_begin:\"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n#endif\\n\",\nlights_fragment_maps:\"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#ifndef STANDARD\\n\\t\\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#endif\\n#endif\\n\",\nlights_fragment_end:\"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\",logdepthbuf_fragment:\"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\",logdepthbuf_pars_fragment:\"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\",\nlogdepthbuf_pars_vertex:\"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\",logdepthbuf_vertex:\"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\tgl_Position.z *= gl_Position.w;\\n\\t#endif\\n#endif\\n\",map_fragment:\"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\",\nmap_pars_fragment:\"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\",map_particle_fragment:\"#ifdef USE_MAP\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\",map_particle_pars_fragment:\"#ifdef USE_MAP\\n\\tuniform mat3 uvTransform;\\n\\tuniform sampler2D map;\\n#endif\\n\",metalnessmap_fragment:\"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\\n\",\nmetalnessmap_pars_fragment:\"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\",morphnormal_vertex:\"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\",morphtarget_pars_vertex:\"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\",\nmorphtarget_vertex:\"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\",\nnormal_fragment_begin:\"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t#endif\\n#endif\\n\",normal_fragment_maps:\"#ifdef USE_NORMALMAP\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t#ifdef FLIP_SIDED\\n\\t\\t\\tnormal = - normal;\\n\\t\\t#endif\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t#endif\\n\\t\\tnormal = normalize( normalMatrix * normal );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\",\nnormalmap_pars_fragment:\"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tuniform mat3 normalMatrix;\\n\\t#else\\n\\t\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\t\\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\\n\\t\\t\\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\\n\\t\\t\\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\\n\\t\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t\\tmapN.xy *= normalScale;\\n\\t\\t\\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t\\treturn normalize( tsn * mapN );\\n\\t\\t}\\n\\t#endif\\n#endif\\n\",\npacking:\"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\",\npremultiplied_alpha_fragment:\"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\",project_vertex:\"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\n\",dithering_fragment:\"#if defined( DITHERING )\\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\\n\",dithering_pars_fragment:\"#if defined( DITHERING )\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\\n\",\nroughnessmap_fragment:\"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\\n\",roughnessmap_pars_fragment:\"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\",shadowmap_pars_fragment:\"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\",\nshadowmap_pars_vertex:\"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\",\nshadowmap_vertex:\"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\",\nshadowmask_pars_fragment:\"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\",\nskinbase_vertex:\"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\",skinning_pars_vertex:\"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\",\nskinning_vertex:\"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\\n\",skinnormal_vertex:\"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\",\nspecularmap_fragment:\"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\",specularmap_pars_fragment:\"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\",tonemapping_fragment:\"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\",tonemapping_pars_fragment:\"#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\",\nuv_pars_fragment:\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\",uv_pars_vertex:\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\\n\",\nuv_vertex:\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\",uv2_pars_fragment:\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\",uv2_pars_vertex:\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\",\nuv2_vertex:\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\",worldpos_vertex:\"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\\n\",cube_frag:\"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\",\ncube_vert:\"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\\n\",depth_frag:\"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\",\ndepth_vert:\"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\",\ndistanceRGBA_frag:\"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\\n\",\ndistanceRGBA_vert:\"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\\n\",\nequirect_frag:\"uniform sampler2D tEquirect;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\",equirect_vert:\"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\",\nlinedashed_frag:\"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\",\nlinedashed_vert:\"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\nmeshbasic_frag:\"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\",\nmeshbasic_vert:\"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\nmeshlambert_frag:\"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\",\nmeshlambert_vert:\"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\nmeshphong_frag:\"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\",\nmeshphong_vert:\"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\nmeshphysical_frag:\"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\",\nmeshphysical_vert:\"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\nnormal_frag:\"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\\n\",\nnormal_vert:\"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\\n\",\npoints_frag:\"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\",\npoints_vert:\"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\nshadow_frag:\"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <fog_fragment>\\n}\\n\",shadow_vert:\"#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\",\nsprite_frag:\"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\",\nsprite_vert:\"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tvec4 mvPosition;\\n\\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\\n\"},\nAa={merge:function(a){for(var b={},c=0;c<a.length;c++){var d=this.clone(a[c]),e;for(e in d)b[e]=d[e]}return b},clone:function(a){var b={},c;for(c in a){b[c]={};for(var d in a[c]){var e=a[c][d];e&&(e.isColor||e.isMatrix3||e.isMatrix4||e.isVector2||e.isVector3||e.isVector4||e.isTexture)?b[c][d]=e.clone():Array.isArray(e)?b[c][d]=e.slice():b[c][d]=e}}return b}},Tg={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,\nblue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,\ndarkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,\nlemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,\nmediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,\nrebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};Object.assign(G.prototype,\n{isColor:!0,r:1,g:1,b:1,set:function(a){a&&a.isColor?this.copy(a):\"number\"===typeof a?this.setHex(a):\"string\"===typeof a&&this.setStyle(a);return this},setScalar:function(a){this.b=this.g=this.r=a;return this},setHex:function(a){a=Math.floor(a);this.r=(a>>16&255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;return this},setRGB:function(a,b,c){this.r=a;this.g=b;this.b=c;return this},setHSL:function(){function a(a,c,d){0>d&&(d+=1);1<d&&--d;return d<1/6?a+6*(c-a)*d:.5>d?c:d<2/3?a+6*(c-a)*(2/3-d):a}return function(b,\nc,d){b=H.euclideanModulo(b,1);c=H.clamp(c,0,1);d=H.clamp(d,0,1);0===c?this.r=this.g=this.b=d:(c=.5>=d?d*(1+c):d+c-d*c,d=2*d-c,this.r=a(d,c,b+1/3),this.g=a(d,c,b),this.b=a(d,c,b-1/3));return this}}(),setStyle:function(a){function b(b){void 0!==b&&1>parseFloat(b)&&console.warn(\"THREE.Color: Alpha component of \"+a+\" will be ignored.\")}var c;if(c=/^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec(a)){var d=c[2];switch(c[1]){case \"rgb\":case \"rgba\":if(c=/^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(d))return this.r=\nMath.min(255,parseInt(c[1],10))/255,this.g=Math.min(255,parseInt(c[2],10))/255,this.b=Math.min(255,parseInt(c[3],10))/255,b(c[5]),this;if(c=/^(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(d))return this.r=Math.min(100,parseInt(c[1],10))/100,this.g=Math.min(100,parseInt(c[2],10))/100,this.b=Math.min(100,parseInt(c[3],10))/100,b(c[5]),this;break;case \"hsl\":case \"hsla\":if(c=/^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(d)){d=parseFloat(c[1])/\n360;var e=parseInt(c[2],10)/100,f=parseInt(c[3],10)/100;b(c[5]);return this.setHSL(d,e,f)}}}else if(c=/^#([A-Fa-f0-9]+)$/.exec(a)){c=c[1];d=c.length;if(3===d)return this.r=parseInt(c.charAt(0)+c.charAt(0),16)/255,this.g=parseInt(c.charAt(1)+c.charAt(1),16)/255,this.b=parseInt(c.charAt(2)+c.charAt(2),16)/255,this;if(6===d)return this.r=parseInt(c.charAt(0)+c.charAt(1),16)/255,this.g=parseInt(c.charAt(2)+c.charAt(3),16)/255,this.b=parseInt(c.charAt(4)+c.charAt(5),16)/255,this}a&&0<a.length&&(c=Tg[a],\nvoid 0!==c?this.setHex(c):console.warn(\"THREE.Color: Unknown color \"+a));return this},clone:function(){return new this.constructor(this.r,this.g,this.b)},copy:function(a){this.r=a.r;this.g=a.g;this.b=a.b;return this},copyGammaToLinear:function(a,b){void 0===b&&(b=2);this.r=Math.pow(a.r,b);this.g=Math.pow(a.g,b);this.b=Math.pow(a.b,b);return this},copyLinearToGamma:function(a,b){void 0===b&&(b=2);b=0<b?1/b:1;this.r=Math.pow(a.r,b);this.g=Math.pow(a.g,b);this.b=Math.pow(a.b,b);return this},convertGammaToLinear:function(a){this.copyGammaToLinear(this,\na);return this},convertLinearToGamma:function(a){this.copyLinearToGamma(this,a);return this},copySRGBToLinear:function(){function a(a){return.04045>a?.0773993808*a:Math.pow(.9478672986*a+.0521327014,2.4)}return function(b){this.r=a(b.r);this.g=a(b.g);this.b=a(b.b);return this}}(),copyLinearToSRGB:function(){function a(a){return.0031308>a?12.92*a:1.055*Math.pow(a,.41666)-.055}return function(b){this.r=a(b.r);this.g=a(b.g);this.b=a(b.b);return this}}(),convertSRGBToLinear:function(){this.copySRGBToLinear(this);\nreturn this},convertLinearToSRGB:function(){this.copyLinearToSRGB(this);return this},getHex:function(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0},getHexString:function(){return(\"000000\"+this.getHex().toString(16)).slice(-6)},getHSL:function(a){void 0===a&&(console.warn(\"THREE.Color: .getHSL() target is now required\"),a={h:0,s:0,l:0});var b=this.r,c=this.g,d=this.b,e=Math.max(b,c,d),f=Math.min(b,c,d),g,h=(f+e)/2;if(f===e)f=g=0;else{var k=e-f;f=.5>=h?k/(e+f):k/(2-e-f);switch(e){case b:g=(c-\nd)/k+(c<d?6:0);break;case c:g=(d-b)/k+2;break;case d:g=(b-c)/k+4}g/=6}a.h=g;a.s=f;a.l=h;return a},getStyle:function(){return\"rgb(\"+(255*this.r|0)+\",\"+(255*this.g|0)+\",\"+(255*this.b|0)+\")\"},offsetHSL:function(){var a={};return function(b,c,d){this.getHSL(a);a.h+=b;a.s+=c;a.l+=d;this.setHSL(a.h,a.s,a.l);return this}}(),add:function(a){this.r+=a.r;this.g+=a.g;this.b+=a.b;return this},addColors:function(a,b){this.r=a.r+b.r;this.g=a.g+b.g;this.b=a.b+b.b;return this},addScalar:function(a){this.r+=a;this.g+=\na;this.b+=a;return this},sub:function(a){this.r=Math.max(0,this.r-a.r);this.g=Math.max(0,this.g-a.g);this.b=Math.max(0,this.b-a.b);return this},multiply:function(a){this.r*=a.r;this.g*=a.g;this.b*=a.b;return this},multiplyScalar:function(a){this.r*=a;this.g*=a;this.b*=a;return this},lerp:function(a,b){this.r+=(a.r-this.r)*b;this.g+=(a.g-this.g)*b;this.b+=(a.b-this.b)*b;return this},equals:function(a){return a.r===this.r&&a.g===this.g&&a.b===this.b},fromArray:function(a,b){void 0===b&&(b=0);this.r=\na[b];this.g=a[b+1];this.b=a[b+2];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.r;a[b+1]=this.g;a[b+2]=this.b;return a},toJSON:function(){return this.getHex()}});var K={common:{diffuse:{value:new G(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new ra},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},\naoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new z(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:2.5E-4},fogNear:{value:1},\nfogFar:{value:2E3},fogColor:{value:new G(16777215)}},lights:{ambientLightColor:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},\npointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new G(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},uvTransform:{value:new ra}},\nsprite:{diffuse:{value:new G(15658734)},opacity:{value:1},center:{value:new z(.5,.5)},rotation:{value:0},map:{value:null},uvTransform:{value:new ra}}},nb={basic:{uniforms:Aa.merge([K.common,K.specularmap,K.envmap,K.aomap,K.lightmap,K.fog]),vertexShader:S.meshbasic_vert,fragmentShader:S.meshbasic_frag},lambert:{uniforms:Aa.merge([K.common,K.specularmap,K.envmap,K.aomap,K.lightmap,K.emissivemap,K.fog,K.lights,{emissive:{value:new G(0)}}]),vertexShader:S.meshlambert_vert,fragmentShader:S.meshlambert_frag},\nphong:{uniforms:Aa.merge([K.common,K.specularmap,K.envmap,K.aomap,K.lightmap,K.emissivemap,K.bumpmap,K.normalmap,K.displacementmap,K.gradientmap,K.fog,K.lights,{emissive:{value:new G(0)},specular:{value:new G(1118481)},shininess:{value:30}}]),vertexShader:S.meshphong_vert,fragmentShader:S.meshphong_frag},standard:{uniforms:Aa.merge([K.common,K.envmap,K.aomap,K.lightmap,K.emissivemap,K.bumpmap,K.normalmap,K.displacementmap,K.roughnessmap,K.metalnessmap,K.fog,K.lights,{emissive:{value:new G(0)},roughness:{value:.5},\nmetalness:{value:.5},envMapIntensity:{value:1}}]),vertexShader:S.meshphysical_vert,fragmentShader:S.meshphysical_frag},points:{uniforms:Aa.merge([K.points,K.fog]),vertexShader:S.points_vert,fragmentShader:S.points_frag},dashed:{uniforms:Aa.merge([K.common,K.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:S.linedashed_vert,fragmentShader:S.linedashed_frag},depth:{uniforms:Aa.merge([K.common,K.displacementmap]),vertexShader:S.depth_vert,fragmentShader:S.depth_frag},normal:{uniforms:Aa.merge([K.common,\nK.bumpmap,K.normalmap,K.displacementmap,{opacity:{value:1}}]),vertexShader:S.normal_vert,fragmentShader:S.normal_frag},sprite:{uniforms:Aa.merge([K.sprite,K.fog]),vertexShader:S.sprite_vert,fragmentShader:S.sprite_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:S.cube_vert,fragmentShader:S.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:S.equirect_vert,fragmentShader:S.equirect_frag},distanceRGBA:{uniforms:Aa.merge([K.common,K.displacementmap,\n{referencePosition:{value:new p},nearDistance:{value:1},farDistance:{value:1E3}}]),vertexShader:S.distanceRGBA_vert,fragmentShader:S.distanceRGBA_frag},shadow:{uniforms:Aa.merge([K.lights,K.fog,{color:{value:new G(0)},opacity:{value:1}}]),vertexShader:S.shadow_vert,fragmentShader:S.shadow_frag}};nb.physical={uniforms:Aa.merge([nb.standard.uniforms,{clearCoat:{value:0},clearCoatRoughness:{value:0}}]),vertexShader:S.meshphysical_vert,fragmentShader:S.meshphysical_frag};hb.RotationOrders=\"XYZ YZX ZXY XZY YXZ ZYX\".split(\" \");\nhb.DefaultOrder=\"XYZ\";Object.defineProperties(hb.prototype,{x:{get:function(){return this._x},set:function(a){this._x=a;this.onChangeCallback()}},y:{get:function(){return this._y},set:function(a){this._y=a;this.onChangeCallback()}},z:{get:function(){return this._z},set:function(a){this._z=a;this.onChangeCallback()}},order:{get:function(){return this._order},set:function(a){this._order=a;this.onChangeCallback()}}});Object.assign(hb.prototype,{isEuler:!0,set:function(a,b,c,d){this._x=a;this._y=b;this._z=\nc;this._order=d||this._order;this.onChangeCallback();return this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order)},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._order=a._order;this.onChangeCallback();return this},setFromRotationMatrix:function(a,b,c){var d=H.clamp,e=a.elements;a=e[0];var f=e[4],g=e[8],h=e[1],k=e[5],m=e[9],l=e[2],n=e[6];e=e[10];b=b||this._order;\"XYZ\"===b?(this._y=Math.asin(d(g,-1,1)),.99999>Math.abs(g)?(this._x=Math.atan2(-m,e),this._z=\nMath.atan2(-f,a)):(this._x=Math.atan2(n,k),this._z=0)):\"YXZ\"===b?(this._x=Math.asin(-d(m,-1,1)),.99999>Math.abs(m)?(this._y=Math.atan2(g,e),this._z=Math.atan2(h,k)):(this._y=Math.atan2(-l,a),this._z=0)):\"ZXY\"===b?(this._x=Math.asin(d(n,-1,1)),.99999>Math.abs(n)?(this._y=Math.atan2(-l,e),this._z=Math.atan2(-f,k)):(this._y=0,this._z=Math.atan2(h,a))):\"ZYX\"===b?(this._y=Math.asin(-d(l,-1,1)),.99999>Math.abs(l)?(this._x=Math.atan2(n,e),this._z=Math.atan2(h,a)):(this._x=0,this._z=Math.atan2(-f,k))):\"YZX\"===\nb?(this._z=Math.asin(d(h,-1,1)),.99999>Math.abs(h)?(this._x=Math.atan2(-m,k),this._y=Math.atan2(-l,a)):(this._x=0,this._y=Math.atan2(g,e))):\"XZY\"===b?(this._z=Math.asin(-d(f,-1,1)),.99999>Math.abs(f)?(this._x=Math.atan2(n,k),this._y=Math.atan2(g,a)):(this._x=Math.atan2(-m,e),this._y=0)):console.warn(\"THREE.Euler: .setFromRotationMatrix() given unsupported order: \"+b);this._order=b;if(!1!==c)this.onChangeCallback();return this},setFromQuaternion:function(){var a=new I;return function(b,c,d){a.makeRotationFromQuaternion(b);\nreturn this.setFromRotationMatrix(a,c,d)}}(),setFromVector3:function(a,b){return this.set(a.x,a.y,a.z,b||this._order)},reorder:function(){var a=new fa;return function(b){a.setFromEuler(this);return this.setFromQuaternion(a,b)}}(),equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._order===this._order},fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];void 0!==a[3]&&(this._order=a[3]);this.onChangeCallback();return this},toArray:function(a,b){void 0===a&&(a=[]);\nvoid 0===b&&(b=0);a[b]=this._x;a[b+1]=this._y;a[b+2]=this._z;a[b+3]=this._order;return a},toVector3:function(a){return a?a.set(this._x,this._y,this._z):new p(this._x,this._y,this._z)},onChange:function(a){this.onChangeCallback=a;return this},onChangeCallback:function(){}});Object.assign(Rd.prototype,{set:function(a){this.mask=1<<a|0},enable:function(a){this.mask=this.mask|1<<a|0},toggle:function(a){this.mask^=1<<a|0},disable:function(a){this.mask&=~(1<<a|0)},test:function(a){return 0!==(this.mask&\na.mask)}});var Gf=0;D.DefaultUp=new p(0,1,0);D.DefaultMatrixAutoUpdate=!0;D.prototype=Object.assign(Object.create(ya.prototype),{constructor:D,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix:function(a){this.matrix.multiplyMatrices(a,this.matrix);this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(a){this.quaternion.premultiply(a);return this},setRotationFromAxisAngle:function(a,b){this.quaternion.setFromAxisAngle(a,b)},setRotationFromEuler:function(a){this.quaternion.setFromEuler(a,\n!0)},setRotationFromMatrix:function(a){this.quaternion.setFromRotationMatrix(a)},setRotationFromQuaternion:function(a){this.quaternion.copy(a)},rotateOnAxis:function(){var a=new fa;return function(b,c){a.setFromAxisAngle(b,c);this.quaternion.multiply(a);return this}}(),rotateOnWorldAxis:function(){var a=new fa;return function(b,c){a.setFromAxisAngle(b,c);this.quaternion.premultiply(a);return this}}(),rotateX:function(){var a=new p(1,0,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateY:function(){var a=\nnew p(0,1,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateZ:function(){var a=new p(0,0,1);return function(b){return this.rotateOnAxis(a,b)}}(),translateOnAxis:function(){var a=new p;return function(b,c){a.copy(b).applyQuaternion(this.quaternion);this.position.add(a.multiplyScalar(c));return this}}(),translateX:function(){var a=new p(1,0,0);return function(b){return this.translateOnAxis(a,b)}}(),translateY:function(){var a=new p(0,1,0);return function(b){return this.translateOnAxis(a,\nb)}}(),translateZ:function(){var a=new p(0,0,1);return function(b){return this.translateOnAxis(a,b)}}(),localToWorld:function(a){return a.applyMatrix4(this.matrixWorld)},worldToLocal:function(){var a=new I;return function(b){return b.applyMatrix4(a.getInverse(this.matrixWorld))}}(),lookAt:function(){var a=new I,b=new p;return function(c,d,e){c.isVector3?b.copy(c):b.set(c,d,e);this.isCamera?a.lookAt(this.position,b,this.up):a.lookAt(b,this.position,this.up);this.quaternion.setFromRotationMatrix(a)}}(),\nadd:function(a){if(1<arguments.length){for(var b=0;b<arguments.length;b++)this.add(arguments[b]);return this}if(a===this)return console.error(\"THREE.Object3D.add: object can't be added as a child of itself.\",a),this;a&&a.isObject3D?(null!==a.parent&&a.parent.remove(a),a.parent=this,a.dispatchEvent({type:\"added\"}),this.children.push(a)):console.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\",a);return this},remove:function(a){if(1<arguments.length){for(var b=0;b<arguments.length;b++)this.remove(arguments[b]);\nreturn this}b=this.children.indexOf(a);-1!==b&&(a.parent=null,a.dispatchEvent({type:\"removed\"}),this.children.splice(b,1));return this},getObjectById:function(a){return this.getObjectByProperty(\"id\",a)},getObjectByName:function(a){return this.getObjectByProperty(\"name\",a)},getObjectByProperty:function(a,b){if(this[a]===b)return this;for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c].getObjectByProperty(a,b);if(void 0!==e)return e}},getWorldPosition:function(a){void 0===a&&(console.warn(\"THREE.Object3D: .getWorldPosition() target is now required\"),\na=new p);this.updateMatrixWorld(!0);return a.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(){var a=new p,b=new p;return function(c){void 0===c&&(console.warn(\"THREE.Object3D: .getWorldQuaternion() target is now required\"),c=new fa);this.updateMatrixWorld(!0);this.matrixWorld.decompose(a,c,b);return c}}(),getWorldScale:function(){var a=new p,b=new fa;return function(c){void 0===c&&(console.warn(\"THREE.Object3D: .getWorldScale() target is now required\"),c=new p);this.updateMatrixWorld(!0);\nthis.matrixWorld.decompose(a,b,c);return c}}(),getWorldDirection:function(){var a=new fa;return function(b){void 0===b&&(console.warn(\"THREE.Object3D: .getWorldDirection() target is now required\"),b=new p);this.getWorldQuaternion(a);return b.set(0,0,1).applyQuaternion(a)}}(),raycast:function(){},traverse:function(a){a(this);for(var b=this.children,c=0,d=b.length;c<d;c++)b[c].traverse(a)},traverseVisible:function(a){if(!1!==this.visible){a(this);for(var b=this.children,c=0,d=b.length;c<d;c++)b[c].traverseVisible(a)}},\ntraverseAncestors:function(a){var b=this.parent;null!==b&&(a(b),b.traverseAncestors(a))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(a){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||a)null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=this.children,c=\n0,d=b.length;c<d;c++)b[c].updateMatrixWorld(a)},toJSON:function(a){function b(b,c){void 0===b[c.uuid]&&(b[c.uuid]=c.toJSON(a));return c.uuid}function c(a){var b=[],c;for(c in a){var d=a[c];delete d.metadata;b.push(d)}return b}var d=void 0===a||\"string\"===typeof a,e={};d&&(a={geometries:{},materials:{},textures:{},images:{},shapes:{}},e.metadata={version:4.5,type:\"Object\",generator:\"Object3D.toJSON\"});var f={};f.uuid=this.uuid;f.type=this.type;\"\"!==this.name&&(f.name=this.name);!0===this.castShadow&&\n(f.castShadow=!0);!0===this.receiveShadow&&(f.receiveShadow=!0);!1===this.visible&&(f.visible=!1);!1===this.frustumCulled&&(f.frustumCulled=!1);0!==this.renderOrder&&(f.renderOrder=this.renderOrder);\"{}\"!==JSON.stringify(this.userData)&&(f.userData=this.userData);f.layers=this.layers.mask;f.matrix=this.matrix.toArray();!1===this.matrixAutoUpdate&&(f.matrixAutoUpdate=!1);if(this.isMesh||this.isLine||this.isPoints){f.geometry=b(a.geometries,this.geometry);var g=this.geometry.parameters;if(void 0!==\ng&&void 0!==g.shapes)if(g=g.shapes,Array.isArray(g))for(var h=0,k=g.length;h<k;h++)b(a.shapes,g[h]);else b(a.shapes,g)}if(void 0!==this.material)if(Array.isArray(this.material)){g=[];h=0;for(k=this.material.length;h<k;h++)g.push(b(a.materials,this.material[h]));f.material=g}else f.material=b(a.materials,this.material);if(0<this.children.length)for(f.children=[],h=0;h<this.children.length;h++)f.children.push(this.children[h].toJSON(a).object);if(d){d=c(a.geometries);h=c(a.materials);k=c(a.textures);\nvar m=c(a.images);g=c(a.shapes);0<d.length&&(e.geometries=d);0<h.length&&(e.materials=h);0<k.length&&(e.textures=k);0<m.length&&(e.images=m);0<g.length&&(e.shapes=g)}e.object=f;return e},clone:function(a){return(new this.constructor).copy(this,a)},copy:function(a,b){void 0===b&&(b=!0);this.name=a.name;this.up.copy(a.up);this.position.copy(a.position);this.quaternion.copy(a.quaternion);this.scale.copy(a.scale);this.matrix.copy(a.matrix);this.matrixWorld.copy(a.matrixWorld);this.matrixAutoUpdate=a.matrixAutoUpdate;\nthis.matrixWorldNeedsUpdate=a.matrixWorldNeedsUpdate;this.layers.mask=a.layers.mask;this.visible=a.visible;this.castShadow=a.castShadow;this.receiveShadow=a.receiveShadow;this.frustumCulled=a.frustumCulled;this.renderOrder=a.renderOrder;this.userData=JSON.parse(JSON.stringify(a.userData));if(!0===b)for(b=0;b<a.children.length;b++)this.add(a.children[b].clone());return this}});Na.prototype=Object.assign(Object.create(D.prototype),{constructor:Na,isCamera:!0,copy:function(a,b){D.prototype.copy.call(this,\na,b);this.matrixWorldInverse.copy(a.matrixWorldInverse);this.projectionMatrix.copy(a.projectionMatrix);return this},getWorldDirection:function(){var a=new fa;return function(b){void 0===b&&(console.warn(\"THREE.Camera: .getWorldDirection() target is now required\"),b=new p);this.getWorldQuaternion(a);return b.set(0,0,-1).applyQuaternion(a)}}(),updateMatrixWorld:function(a){D.prototype.updateMatrixWorld.call(this,a);this.matrixWorldInverse.getInverse(this.matrixWorld)},clone:function(){return(new this.constructor).copy(this)}});\nHb.prototype=Object.assign(Object.create(Na.prototype),{constructor:Hb,isOrthographicCamera:!0,copy:function(a,b){Na.prototype.copy.call(this,a,b);this.left=a.left;this.right=a.right;this.top=a.top;this.bottom=a.bottom;this.near=a.near;this.far=a.far;this.zoom=a.zoom;this.view=null===a.view?null:Object.assign({},a.view);return this},setViewOffset:function(a,b,c,d,e,f){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1});this.view.enabled=!0;this.view.fullWidth=\na;this.view.fullHeight=b;this.view.offsetX=c;this.view.offsetY=d;this.view.width=e;this.view.height=f;this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1);this.updateProjectionMatrix()},updateProjectionMatrix:function(){var a=(this.right-this.left)/(2*this.zoom),b=(this.top-this.bottom)/(2*this.zoom),c=(this.right+this.left)/2,d=(this.top+this.bottom)/2,e=c-a;c+=a;a=d+b;b=d-b;if(null!==this.view&&this.view.enabled){c=this.zoom/(this.view.width/this.view.fullWidth);\nb=this.zoom/(this.view.height/this.view.fullHeight);var f=(this.right-this.left)/this.view.width;d=(this.top-this.bottom)/this.view.height;e+=this.view.offsetX/c*f;c=e+this.view.width/c*f;a-=this.view.offsetY/b*d;b=a-this.view.height/b*d}this.projectionMatrix.makeOrthographic(e,c,a,b,this.near,this.far)},toJSON:function(a){a=D.prototype.toJSON.call(this,a);a.object.zoom=this.zoom;a.object.left=this.left;a.object.right=this.right;a.object.top=this.top;a.object.bottom=this.bottom;a.object.near=this.near;\na.object.far=this.far;null!==this.view&&(a.object.view=Object.assign({},this.view));return a}});Object.assign(Ta.prototype,{clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.a=a.a;this.b=a.b;this.c=a.c;this.normal.copy(a.normal);this.color.copy(a.color);this.materialIndex=a.materialIndex;for(var b=0,c=a.vertexNormals.length;b<c;b++)this.vertexNormals[b]=a.vertexNormals[b].clone();b=0;for(c=a.vertexColors.length;b<c;b++)this.vertexColors[b]=a.vertexColors[b].clone();return this}});\nvar Hf=0;R.prototype=Object.assign(Object.create(ya.prototype),{constructor:R,isGeometry:!0,applyMatrix:function(a){for(var b=(new ra).getNormalMatrix(a),c=0,d=this.vertices.length;c<d;c++)this.vertices[c].applyMatrix4(a);c=0;for(d=this.faces.length;c<d;c++){a=this.faces[c];a.normal.applyMatrix3(b).normalize();for(var e=0,f=a.vertexNormals.length;e<f;e++)a.vertexNormals[e].applyMatrix3(b).normalize()}null!==this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();\nthis.normalsNeedUpdate=this.verticesNeedUpdate=!0;return this},rotateX:function(){var a=new I;return function(b){a.makeRotationX(b);this.applyMatrix(a);return this}}(),rotateY:function(){var a=new I;return function(b){a.makeRotationY(b);this.applyMatrix(a);return this}}(),rotateZ:function(){var a=new I;return function(b){a.makeRotationZ(b);this.applyMatrix(a);return this}}(),translate:function(){var a=new I;return function(b,c,d){a.makeTranslation(b,c,d);this.applyMatrix(a);return this}}(),scale:function(){var a=\nnew I;return function(b,c,d){a.makeScale(b,c,d);this.applyMatrix(a);return this}}(),lookAt:function(){var a=new D;return function(b){a.lookAt(b);a.updateMatrix();this.applyMatrix(a.matrix)}}(),fromBufferGeometry:function(a){function b(a,b,d,e){var f=void 0!==g?[l[a].clone(),l[b].clone(),l[d].clone()]:[],q=void 0!==h?[c.colors[a].clone(),c.colors[b].clone(),c.colors[d].clone()]:[];e=new Ta(a,b,d,f,q,e);c.faces.push(e);void 0!==k&&c.faceVertexUvs[0].push([n[a].clone(),n[b].clone(),n[d].clone()]);void 0!==\nm&&c.faceVertexUvs[1].push([t[a].clone(),t[b].clone(),t[d].clone()])}var c=this,d=null!==a.index?a.index.array:void 0,e=a.attributes,f=e.position.array,g=void 0!==e.normal?e.normal.array:void 0,h=void 0!==e.color?e.color.array:void 0,k=void 0!==e.uv?e.uv.array:void 0,m=void 0!==e.uv2?e.uv2.array:void 0;void 0!==m&&(this.faceVertexUvs[1]=[]);for(var l=[],n=[],t=[],u=e=0;e<f.length;e+=3,u+=2)c.vertices.push(new p(f[e],f[e+1],f[e+2])),void 0!==g&&l.push(new p(g[e],g[e+1],g[e+2])),void 0!==h&&c.colors.push(new G(h[e],\nh[e+1],h[e+2])),void 0!==k&&n.push(new z(k[u],k[u+1])),void 0!==m&&t.push(new z(m[u],m[u+1]));var r=a.groups;if(0<r.length)for(e=0;e<r.length;e++){f=r[e];var v=f.start,y=f.count;u=v;for(v+=y;u<v;u+=3)void 0!==d?b(d[u],d[u+1],d[u+2],f.materialIndex):b(u,u+1,u+2,f.materialIndex)}else if(void 0!==d)for(e=0;e<d.length;e+=3)b(d[e],d[e+1],d[e+2]);else for(e=0;e<f.length/3;e+=3)b(e,e+1,e+2);this.computeFaceNormals();null!==a.boundingBox&&(this.boundingBox=a.boundingBox.clone());null!==a.boundingSphere&&\n(this.boundingSphere=a.boundingSphere.clone());return this},center:function(){var a=new p;return function(){this.computeBoundingBox();this.boundingBox.getCenter(a).negate();this.translate(a.x,a.y,a.z);return this}}(),normalize:function(){this.computeBoundingSphere();var a=this.boundingSphere.center,b=this.boundingSphere.radius;b=0===b?1:1/b;var c=new I;c.set(b,0,0,-b*a.x,0,b,0,-b*a.y,0,0,b,-b*a.z,0,0,0,1);this.applyMatrix(c);return this},computeFaceNormals:function(){for(var a=new p,b=new p,c=0,d=\nthis.faces.length;c<d;c++){var e=this.faces[c],f=this.vertices[e.a],g=this.vertices[e.b];a.subVectors(this.vertices[e.c],g);b.subVectors(f,g);a.cross(b);a.normalize();e.normal.copy(a)}},computeVertexNormals:function(a){void 0===a&&(a=!0);var b;var c=Array(this.vertices.length);var d=0;for(b=this.vertices.length;d<b;d++)c[d]=new p;if(a){var e=new p,f=new p;a=0;for(d=this.faces.length;a<d;a++){b=this.faces[a];var g=this.vertices[b.a];var h=this.vertices[b.b];var k=this.vertices[b.c];e.subVectors(k,\nh);f.subVectors(g,h);e.cross(f);c[b.a].add(e);c[b.b].add(e);c[b.c].add(e)}}else for(this.computeFaceNormals(),a=0,d=this.faces.length;a<d;a++)b=this.faces[a],c[b.a].add(b.normal),c[b.b].add(b.normal),c[b.c].add(b.normal);d=0;for(b=this.vertices.length;d<b;d++)c[d].normalize();a=0;for(d=this.faces.length;a<d;a++)b=this.faces[a],g=b.vertexNormals,3===g.length?(g[0].copy(c[b.a]),g[1].copy(c[b.b]),g[2].copy(c[b.c])):(g[0]=c[b.a].clone(),g[1]=c[b.b].clone(),g[2]=c[b.c].clone());0<this.faces.length&&(this.normalsNeedUpdate=\n!0)},computeFlatVertexNormals:function(){var a;this.computeFaceNormals();var b=0;for(a=this.faces.length;b<a;b++){var c=this.faces[b];var d=c.vertexNormals;3===d.length?(d[0].copy(c.normal),d[1].copy(c.normal),d[2].copy(c.normal)):(d[0]=c.normal.clone(),d[1]=c.normal.clone(),d[2]=c.normal.clone())}0<this.faces.length&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){var a,b;var c=0;for(b=this.faces.length;c<b;c++){var d=this.faces[c];d.__originalFaceNormal?d.__originalFaceNormal.copy(d.normal):\nd.__originalFaceNormal=d.normal.clone();d.__originalVertexNormals||(d.__originalVertexNormals=[]);var e=0;for(a=d.vertexNormals.length;e<a;e++)d.__originalVertexNormals[e]?d.__originalVertexNormals[e].copy(d.vertexNormals[e]):d.__originalVertexNormals[e]=d.vertexNormals[e].clone()}var f=new R;f.faces=this.faces;e=0;for(a=this.morphTargets.length;e<a;e++){if(!this.morphNormals[e]){this.morphNormals[e]={};this.morphNormals[e].faceNormals=[];this.morphNormals[e].vertexNormals=[];d=this.morphNormals[e].faceNormals;\nvar g=this.morphNormals[e].vertexNormals;c=0;for(b=this.faces.length;c<b;c++){var h=new p;var k={a:new p,b:new p,c:new p};d.push(h);g.push(k)}}g=this.morphNormals[e];f.vertices=this.morphTargets[e].vertices;f.computeFaceNormals();f.computeVertexNormals();c=0;for(b=this.faces.length;c<b;c++)d=this.faces[c],h=g.faceNormals[c],k=g.vertexNormals[c],h.copy(d.normal),k.a.copy(d.vertexNormals[0]),k.b.copy(d.vertexNormals[1]),k.c.copy(d.vertexNormals[2])}c=0;for(b=this.faces.length;c<b;c++)d=this.faces[c],\nd.normal=d.__originalFaceNormal,d.vertexNormals=d.__originalVertexNormals},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Sa);this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Da);this.boundingSphere.setFromPoints(this.vertices)},merge:function(a,b,c){if(a&&a.isGeometry){var d,e=this.vertices.length,f=this.vertices,g=a.vertices,h=this.faces,k=a.faces,m=this.faceVertexUvs[0],l=a.faceVertexUvs[0],\nn=this.colors,t=a.colors;void 0===c&&(c=0);void 0!==b&&(d=(new ra).getNormalMatrix(b));a=0;for(var p=g.length;a<p;a++){var r=g[a].clone();void 0!==b&&r.applyMatrix4(b);f.push(r)}a=0;for(p=t.length;a<p;a++)n.push(t[a].clone());a=0;for(p=k.length;a<p;a++){g=k[a];var v=g.vertexNormals;t=g.vertexColors;n=new Ta(g.a+e,g.b+e,g.c+e);n.normal.copy(g.normal);void 0!==d&&n.normal.applyMatrix3(d).normalize();b=0;for(f=v.length;b<f;b++)r=v[b].clone(),void 0!==d&&r.applyMatrix3(d).normalize(),n.vertexNormals.push(r);\nn.color.copy(g.color);b=0;for(f=t.length;b<f;b++)r=t[b],n.vertexColors.push(r.clone());n.materialIndex=g.materialIndex+c;h.push(n)}a=0;for(p=l.length;a<p;a++)if(c=l[a],d=[],void 0!==c){b=0;for(f=c.length;b<f;b++)d.push(c[b].clone());m.push(d)}}else console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\",a)},mergeMesh:function(a){a&&a.isMesh?(a.matrixAutoUpdate&&a.updateMatrix(),this.merge(a.geometry,a.matrix)):console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\",\na)},mergeVertices:function(){var a={},b=[],c=[],d=Math.pow(10,4),e;var f=0;for(e=this.vertices.length;f<e;f++){var g=this.vertices[f];g=Math.round(g.x*d)+\"_\"+Math.round(g.y*d)+\"_\"+Math.round(g.z*d);void 0===a[g]?(a[g]=f,b.push(this.vertices[f]),c[f]=b.length-1):c[f]=c[a[g]]}a=[];f=0;for(e=this.faces.length;f<e;f++)for(d=this.faces[f],d.a=c[d.a],d.b=c[d.b],d.c=c[d.c],d=[d.a,d.b,d.c],g=0;3>g;g++)if(d[g]===d[(g+1)%3]){a.push(f);break}for(f=a.length-1;0<=f;f--)for(d=a[f],this.faces.splice(d,1),c=0,e=\nthis.faceVertexUvs.length;c<e;c++)this.faceVertexUvs[c].splice(d,1);f=this.vertices.length-b.length;this.vertices=b;return f},setFromPoints:function(a){this.vertices=[];for(var b=0,c=a.length;b<c;b++){var d=a[b];this.vertices.push(new p(d.x,d.y,d.z||0))}return this},sortFacesByMaterialIndex:function(){for(var a=this.faces,b=a.length,c=0;c<b;c++)a[c]._id=c;a.sort(function(a,b){return a.materialIndex-b.materialIndex});var d=this.faceVertexUvs[0],e=this.faceVertexUvs[1],f,g;d&&d.length===b&&(f=[]);e&&\ne.length===b&&(g=[]);for(c=0;c<b;c++){var h=a[c]._id;f&&f.push(d[h]);g&&g.push(e[h])}f&&(this.faceVertexUvs[0]=f);g&&(this.faceVertexUvs[1]=g)},toJSON:function(){function a(a,b,c){return c?a|1<<b:a&~(1<<b)}function b(a){var b=a.x.toString()+a.y.toString()+a.z.toString();if(void 0!==m[b])return m[b];m[b]=k.length/3;k.push(a.x,a.y,a.z);return m[b]}function c(a){var b=a.r.toString()+a.g.toString()+a.b.toString();if(void 0!==n[b])return n[b];n[b]=l.length;l.push(a.getHex());return n[b]}function d(a){var b=\na.x.toString()+a.y.toString();if(void 0!==p[b])return p[b];p[b]=t.length/2;t.push(a.x,a.y);return p[b]}var e={metadata:{version:4.5,type:\"Geometry\",generator:\"Geometry.toJSON\"}};e.uuid=this.uuid;e.type=this.type;\"\"!==this.name&&(e.name=this.name);if(void 0!==this.parameters){var f=this.parameters,g;for(g in f)void 0!==f[g]&&(e[g]=f[g]);return e}f=[];for(g=0;g<this.vertices.length;g++){var h=this.vertices[g];f.push(h.x,h.y,h.z)}h=[];var k=[],m={},l=[],n={},t=[],p={};for(g=0;g<this.faces.length;g++){var r=\nthis.faces[g],v=void 0!==this.faceVertexUvs[0][g],y=0<r.normal.length(),x=0<r.vertexNormals.length,w=1!==r.color.r||1!==r.color.g||1!==r.color.b,B=0<r.vertexColors.length,E=0;E=a(E,0,0);E=a(E,1,!0);E=a(E,2,!1);E=a(E,3,v);E=a(E,4,y);E=a(E,5,x);E=a(E,6,w);E=a(E,7,B);h.push(E);h.push(r.a,r.b,r.c);h.push(r.materialIndex);v&&(v=this.faceVertexUvs[0][g],h.push(d(v[0]),d(v[1]),d(v[2])));y&&h.push(b(r.normal));x&&(y=r.vertexNormals,h.push(b(y[0]),b(y[1]),b(y[2])));w&&h.push(c(r.color));B&&(r=r.vertexColors,\nh.push(c(r[0]),c(r[1]),c(r[2])))}e.data={};e.data.vertices=f;e.data.normals=k;0<l.length&&(e.data.colors=l);0<t.length&&(e.data.uvs=[t]);e.data.faces=h;return e},clone:function(){return(new R).copy(this)},copy:function(a){var b,c,d;this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.name=a.name;var e=a.vertices;var f=0;for(b=e.length;f<\nb;f++)this.vertices.push(e[f].clone());e=a.colors;f=0;for(b=e.length;f<b;f++)this.colors.push(e[f].clone());e=a.faces;f=0;for(b=e.length;f<b;f++)this.faces.push(e[f].clone());f=0;for(b=a.faceVertexUvs.length;f<b;f++){var g=a.faceVertexUvs[f];void 0===this.faceVertexUvs[f]&&(this.faceVertexUvs[f]=[]);e=0;for(c=g.length;e<c;e++){var h=g[e],k=[];var m=0;for(d=h.length;m<d;m++)k.push(h[m].clone());this.faceVertexUvs[f].push(k)}}m=a.morphTargets;f=0;for(b=m.length;f<b;f++){d={};d.name=m[f].name;if(void 0!==\nm[f].vertices)for(d.vertices=[],e=0,c=m[f].vertices.length;e<c;e++)d.vertices.push(m[f].vertices[e].clone());if(void 0!==m[f].normals)for(d.normals=[],e=0,c=m[f].normals.length;e<c;e++)d.normals.push(m[f].normals[e].clone());this.morphTargets.push(d)}m=a.morphNormals;f=0;for(b=m.length;f<b;f++){d={};if(void 0!==m[f].vertexNormals)for(d.vertexNormals=[],e=0,c=m[f].vertexNormals.length;e<c;e++)g=m[f].vertexNormals[e],h={},h.a=g.a.clone(),h.b=g.b.clone(),h.c=g.c.clone(),d.vertexNormals.push(h);if(void 0!==\nm[f].faceNormals)for(d.faceNormals=[],e=0,c=m[f].faceNormals.length;e<c;e++)d.faceNormals.push(m[f].faceNormals[e].clone());this.morphNormals.push(d)}e=a.skinWeights;f=0;for(b=e.length;f<b;f++)this.skinWeights.push(e[f].clone());e=a.skinIndices;f=0;for(b=e.length;f<b;f++)this.skinIndices.push(e[f].clone());e=a.lineDistances;f=0;for(b=e.length;f<b;f++)this.lineDistances.push(e[f]);f=a.boundingBox;null!==f&&(this.boundingBox=f.clone());f=a.boundingSphere;null!==f&&(this.boundingSphere=f.clone());this.elementsNeedUpdate=\na.elementsNeedUpdate;this.verticesNeedUpdate=a.verticesNeedUpdate;this.uvsNeedUpdate=a.uvsNeedUpdate;this.normalsNeedUpdate=a.normalsNeedUpdate;this.colorsNeedUpdate=a.colorsNeedUpdate;this.lineDistancesNeedUpdate=a.lineDistancesNeedUpdate;this.groupsNeedUpdate=a.groupsNeedUpdate;return this},dispose:function(){this.dispatchEvent({type:\"dispose\"})}});Object.defineProperty(Q.prototype,\"needsUpdate\",{set:function(a){!0===a&&this.version++}});Object.assign(Q.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},\nsetArray:function(a){if(Array.isArray(a))throw new TypeError(\"THREE.BufferAttribute: array should be a Typed Array.\");this.count=void 0!==a?a.length/this.itemSize:0;this.array=a;return this},setDynamic:function(a){this.dynamic=a;return this},copy:function(a){this.name=a.name;this.array=new a.array.constructor(a.array);this.itemSize=a.itemSize;this.count=a.count;this.normalized=a.normalized;this.dynamic=a.dynamic;return this},copyAt:function(a,b,c){a*=this.itemSize;c*=b.itemSize;for(var d=0,e=this.itemSize;d<\ne;d++)this.array[a+d]=b.array[c+d];return this},copyArray:function(a){this.array.set(a);return this},copyColorsArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn(\"THREE.BufferAttribute.copyColorsArray(): color is undefined\",d),f=new G);b[c++]=f.r;b[c++]=f.g;b[c++]=f.b}return this},copyVector2sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn(\"THREE.BufferAttribute.copyVector2sArray(): vector is undefined\",\nd),f=new z);b[c++]=f.x;b[c++]=f.y}return this},copyVector3sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn(\"THREE.BufferAttribute.copyVector3sArray(): vector is undefined\",d),f=new p);b[c++]=f.x;b[c++]=f.y;b[c++]=f.z}return this},copyVector4sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn(\"THREE.BufferAttribute.copyVector4sArray(): vector is undefined\",d),f=new V);b[c++]=f.x;b[c++]=f.y;\nb[c++]=f.z;b[c++]=f.w}return this},set:function(a,b){void 0===b&&(b=0);this.array.set(a,b);return this},getX:function(a){return this.array[a*this.itemSize]},setX:function(a,b){this.array[a*this.itemSize]=b;return this},getY:function(a){return this.array[a*this.itemSize+1]},setY:function(a,b){this.array[a*this.itemSize+1]=b;return this},getZ:function(a){return this.array[a*this.itemSize+2]},setZ:function(a,b){this.array[a*this.itemSize+2]=b;return this},getW:function(a){return this.array[a*this.itemSize+\n3]},setW:function(a,b){this.array[a*this.itemSize+3]=b;return this},setXY:function(a,b,c){a*=this.itemSize;this.array[a+0]=b;this.array[a+1]=c;return this},setXYZ:function(a,b,c,d){a*=this.itemSize;this.array[a+0]=b;this.array[a+1]=c;this.array[a+2]=d;return this},setXYZW:function(a,b,c,d,e){a*=this.itemSize;this.array[a+0]=b;this.array[a+1]=c;this.array[a+2]=d;this.array[a+3]=e;return this},onUpload:function(a){this.onUploadCallback=a;return this},clone:function(){return(new this.constructor(this.array,\nthis.itemSize)).copy(this)}});oc.prototype=Object.create(Q.prototype);oc.prototype.constructor=oc;pc.prototype=Object.create(Q.prototype);pc.prototype.constructor=pc;qc.prototype=Object.create(Q.prototype);qc.prototype.constructor=qc;rc.prototype=Object.create(Q.prototype);rc.prototype.constructor=rc;ib.prototype=Object.create(Q.prototype);ib.prototype.constructor=ib;sc.prototype=Object.create(Q.prototype);sc.prototype.constructor=sc;jb.prototype=Object.create(Q.prototype);jb.prototype.constructor=\njb;A.prototype=Object.create(Q.prototype);A.prototype.constructor=A;tc.prototype=Object.create(Q.prototype);tc.prototype.constructor=tc;Object.assign(Ee.prototype,{computeGroups:function(a){var b=[],c=void 0;a=a.faces;for(var d=0;d<a.length;d++){var e=a[d];if(e.materialIndex!==c){c=e.materialIndex;void 0!==f&&(f.count=3*d-f.start,b.push(f));var f={start:3*d,materialIndex:c}}}void 0!==f&&(f.count=3*d-f.start,b.push(f));this.groups=b},fromGeometry:function(a){var b=a.faces,c=a.vertices,d=a.faceVertexUvs,\ne=d[0]&&0<d[0].length,f=d[1]&&0<d[1].length,g=a.morphTargets,h=g.length;if(0<h){var k=[];for(var m=0;m<h;m++)k[m]=[];this.morphTargets.position=k}var l=a.morphNormals,n=l.length;if(0<n){var t=[];for(m=0;m<n;m++)t[m]=[];this.morphTargets.normal=t}var p=a.skinIndices,r=a.skinWeights,v=p.length===c.length,y=r.length===c.length;0<c.length&&0===b.length&&console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");for(m=0;m<b.length;m++){var x=b[m];this.vertices.push(c[x.a],c[x.b],c[x.c]);\nvar w=x.vertexNormals;3===w.length?this.normals.push(w[0],w[1],w[2]):(w=x.normal,this.normals.push(w,w,w));w=x.vertexColors;3===w.length?this.colors.push(w[0],w[1],w[2]):(w=x.color,this.colors.push(w,w,w));!0===e&&(w=d[0][m],void 0!==w?this.uvs.push(w[0],w[1],w[2]):(console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \",m),this.uvs.push(new z,new z,new z)));!0===f&&(w=d[1][m],void 0!==w?this.uvs2.push(w[0],w[1],w[2]):(console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \",\nm),this.uvs2.push(new z,new z,new z)));for(w=0;w<h;w++){var B=g[w].vertices;k[w].push(B[x.a],B[x.b],B[x.c])}for(w=0;w<n;w++)B=l[w].vertexNormals[m],t[w].push(B.a,B.b,B.c);v&&this.skinIndices.push(p[x.a],p[x.b],p[x.c]);y&&this.skinWeights.push(r[x.a],r[x.b],r[x.c])}this.computeGroups(a);this.verticesNeedUpdate=a.verticesNeedUpdate;this.normalsNeedUpdate=a.normalsNeedUpdate;this.colorsNeedUpdate=a.colorsNeedUpdate;this.uvsNeedUpdate=a.uvsNeedUpdate;this.groupsNeedUpdate=a.groupsNeedUpdate;return this}});\nvar If=1;C.prototype=Object.assign(Object.create(ya.prototype),{constructor:C,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(a){Array.isArray(a)?this.index=new (65535<Fe(a)?jb:ib)(a,1):this.index=a},addAttribute:function(a,b,c){if(!(b&&b.isBufferAttribute||b&&b.isInterleavedBufferAttribute))return console.warn(\"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).\"),this.addAttribute(a,new Q(b,c));if(\"index\"===a)return console.warn(\"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.\"),\nthis.setIndex(b),this;this.attributes[a]=b;return this},getAttribute:function(a){return this.attributes[a]},removeAttribute:function(a){delete this.attributes[a];return this},addGroup:function(a,b,c){this.groups.push({start:a,count:b,materialIndex:void 0!==c?c:0})},clearGroups:function(){this.groups=[]},setDrawRange:function(a,b){this.drawRange.start=a;this.drawRange.count=b},applyMatrix:function(a){var b=this.attributes.position;void 0!==b&&(a.applyToBufferAttribute(b),b.needsUpdate=!0);b=this.attributes.normal;\nvoid 0!==b&&((new ra).getNormalMatrix(a).applyToBufferAttribute(b),b.needsUpdate=!0);null!==this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();return this},rotateX:function(){var a=new I;return function(b){a.makeRotationX(b);this.applyMatrix(a);return this}}(),rotateY:function(){var a=new I;return function(b){a.makeRotationY(b);this.applyMatrix(a);return this}}(),rotateZ:function(){var a=new I;return function(b){a.makeRotationZ(b);this.applyMatrix(a);\nreturn this}}(),translate:function(){var a=new I;return function(b,c,d){a.makeTranslation(b,c,d);this.applyMatrix(a);return this}}(),scale:function(){var a=new I;return function(b,c,d){a.makeScale(b,c,d);this.applyMatrix(a);return this}}(),lookAt:function(){var a=new D;return function(b){a.lookAt(b);a.updateMatrix();this.applyMatrix(a.matrix)}}(),center:function(){var a=new p;return function(){this.computeBoundingBox();this.boundingBox.getCenter(a).negate();this.translate(a.x,a.y,a.z);return this}}(),\nsetFromObject:function(a){var b=a.geometry;if(a.isPoints||a.isLine){a=new A(3*b.vertices.length,3);var c=new A(3*b.colors.length,3);this.addAttribute(\"position\",a.copyVector3sArray(b.vertices));this.addAttribute(\"color\",c.copyColorsArray(b.colors));b.lineDistances&&b.lineDistances.length===b.vertices.length&&(a=new A(b.lineDistances.length,1),this.addAttribute(\"lineDistance\",a.copyArray(b.lineDistances)));null!==b.boundingSphere&&(this.boundingSphere=b.boundingSphere.clone());null!==b.boundingBox&&\n(this.boundingBox=b.boundingBox.clone())}else a.isMesh&&b&&b.isGeometry&&this.fromGeometry(b);return this},setFromPoints:function(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c];b.push(e.x,e.y,e.z||0)}this.addAttribute(\"position\",new A(b,3));return this},updateFromObject:function(a){var b=a.geometry;if(a.isMesh){var c=b.__directGeometry;!0===b.elementsNeedUpdate&&(c=void 0,b.elementsNeedUpdate=!1);if(void 0===c)return this.fromGeometry(b);c.verticesNeedUpdate=b.verticesNeedUpdate;c.normalsNeedUpdate=\nb.normalsNeedUpdate;c.colorsNeedUpdate=b.colorsNeedUpdate;c.uvsNeedUpdate=b.uvsNeedUpdate;c.groupsNeedUpdate=b.groupsNeedUpdate;b.verticesNeedUpdate=!1;b.normalsNeedUpdate=!1;b.colorsNeedUpdate=!1;b.uvsNeedUpdate=!1;b.groupsNeedUpdate=!1;b=c}!0===b.verticesNeedUpdate&&(c=this.attributes.position,void 0!==c&&(c.copyVector3sArray(b.vertices),c.needsUpdate=!0),b.verticesNeedUpdate=!1);!0===b.normalsNeedUpdate&&(c=this.attributes.normal,void 0!==c&&(c.copyVector3sArray(b.normals),c.needsUpdate=!0),b.normalsNeedUpdate=\n!1);!0===b.colorsNeedUpdate&&(c=this.attributes.color,void 0!==c&&(c.copyColorsArray(b.colors),c.needsUpdate=!0),b.colorsNeedUpdate=!1);b.uvsNeedUpdate&&(c=this.attributes.uv,void 0!==c&&(c.copyVector2sArray(b.uvs),c.needsUpdate=!0),b.uvsNeedUpdate=!1);b.lineDistancesNeedUpdate&&(c=this.attributes.lineDistance,void 0!==c&&(c.copyArray(b.lineDistances),c.needsUpdate=!0),b.lineDistancesNeedUpdate=!1);b.groupsNeedUpdate&&(b.computeGroups(a.geometry),this.groups=b.groups,b.groupsNeedUpdate=!1);return this},\nfromGeometry:function(a){a.__directGeometry=(new Ee).fromGeometry(a);return this.fromDirectGeometry(a.__directGeometry)},fromDirectGeometry:function(a){var b=new Float32Array(3*a.vertices.length);this.addAttribute(\"position\",(new Q(b,3)).copyVector3sArray(a.vertices));0<a.normals.length&&(b=new Float32Array(3*a.normals.length),this.addAttribute(\"normal\",(new Q(b,3)).copyVector3sArray(a.normals)));0<a.colors.length&&(b=new Float32Array(3*a.colors.length),this.addAttribute(\"color\",(new Q(b,3)).copyColorsArray(a.colors)));\n0<a.uvs.length&&(b=new Float32Array(2*a.uvs.length),this.addAttribute(\"uv\",(new Q(b,2)).copyVector2sArray(a.uvs)));0<a.uvs2.length&&(b=new Float32Array(2*a.uvs2.length),this.addAttribute(\"uv2\",(new Q(b,2)).copyVector2sArray(a.uvs2)));this.groups=a.groups;for(var c in a.morphTargets){b=[];for(var d=a.morphTargets[c],e=0,f=d.length;e<f;e++){var g=d[e],h=new A(3*g.length,3);b.push(h.copyVector3sArray(g))}this.morphAttributes[c]=b}0<a.skinIndices.length&&(c=new A(4*a.skinIndices.length,4),this.addAttribute(\"skinIndex\",\nc.copyVector4sArray(a.skinIndices)));0<a.skinWeights.length&&(c=new A(4*a.skinWeights.length,4),this.addAttribute(\"skinWeight\",c.copyVector4sArray(a.skinWeights)));null!==a.boundingSphere&&(this.boundingSphere=a.boundingSphere.clone());null!==a.boundingBox&&(this.boundingBox=a.boundingBox.clone());return this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Sa);var a=this.attributes.position;void 0!==a?this.boundingBox.setFromBufferAttribute(a):this.boundingBox.makeEmpty();\n(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){var a=new Sa,b=new p;return function(){null===this.boundingSphere&&(this.boundingSphere=new Da);var c=this.attributes.position;if(c){var d=this.boundingSphere.center;a.setFromBufferAttribute(c);a.getCenter(d);for(var e=0,\nf=0,g=c.count;f<g;f++)b.x=c.getX(f),b.y=c.getY(f),b.z=c.getZ(f),e=Math.max(e,d.distanceToSquared(b));this.boundingSphere.radius=Math.sqrt(e);isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.',this)}}}(),computeFaceNormals:function(){},computeVertexNormals:function(){var a=this.index,b=this.attributes,c=this.groups;if(b.position){var d=b.position.array;if(void 0===b.normal)this.addAttribute(\"normal\",\nnew Q(new Float32Array(d.length),3));else for(var e=b.normal.array,f=0,g=e.length;f<g;f++)e[f]=0;e=b.normal.array;var h=new p,k=new p,m=new p,l=new p,n=new p;if(a){a=a.array;0===c.length&&this.addGroup(0,a.length);for(var t=0,u=c.length;t<u;++t){f=c[t];g=f.start;var r=f.count;f=g;for(g+=r;f<g;f+=3){r=3*a[f+0];var v=3*a[f+1];var y=3*a[f+2];h.fromArray(d,r);k.fromArray(d,v);m.fromArray(d,y);l.subVectors(m,k);n.subVectors(h,k);l.cross(n);e[r]+=l.x;e[r+1]+=l.y;e[r+2]+=l.z;e[v]+=l.x;e[v+1]+=l.y;e[v+2]+=\nl.z;e[y]+=l.x;e[y+1]+=l.y;e[y+2]+=l.z}}}else for(f=0,g=d.length;f<g;f+=9)h.fromArray(d,f),k.fromArray(d,f+3),m.fromArray(d,f+6),l.subVectors(m,k),n.subVectors(h,k),l.cross(n),e[f]=l.x,e[f+1]=l.y,e[f+2]=l.z,e[f+3]=l.x,e[f+4]=l.y,e[f+5]=l.z,e[f+6]=l.x,e[f+7]=l.y,e[f+8]=l.z;this.normalizeNormals();b.normal.needsUpdate=!0}},merge:function(a,b){if(a&&a.isBufferGeometry){void 0===b&&(b=0,console.warn(\"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.\"));\nvar c=this.attributes,d;for(d in c)if(void 0!==a.attributes[d]){var e=c[d].array,f=a.attributes[d],g=f.array,h=0;for(f=f.itemSize*b;h<g.length;h++,f++)e[f]=g[h]}return this}console.error(\"THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.\",a)},normalizeNormals:function(){var a=new p;return function(){for(var b=this.attributes.normal,c=0,d=b.count;c<d;c++)a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.normalize(),b.setXYZ(c,a.x,a.y,a.z)}}(),toNonIndexed:function(){if(null===\nthis.index)return console.warn(\"THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.\"),this;var a=new C,b=this.index.array,c=this.attributes,d;for(d in c){var e=c[d],f=e.array,g=e.itemSize,h=new f.constructor(b.length*g),k=0;e=0;for(var m=b.length;e<m;e++){var l=b[e]*g;for(var n=0;n<g;n++)h[k++]=f[l++]}a.addAttribute(d,new Q(h,g))}b=this.groups;e=0;for(m=b.length;e<m;e++)c=b[e],a.addGroup(c.start,c.count,c.materialIndex);return a},toJSON:function(){var a={metadata:{version:4.5,type:\"BufferGeometry\",\ngenerator:\"BufferGeometry.toJSON\"}};a.uuid=this.uuid;a.type=this.type;\"\"!==this.name&&(a.name=this.name);0<Object.keys(this.userData).length&&(a.userData=this.userData);if(void 0!==this.parameters){var b=this.parameters;for(e in b)void 0!==b[e]&&(a[e]=b[e]);return a}a.data={attributes:{}};var c=this.index;null!==c&&(b=Array.prototype.slice.call(c.array),a.data.index={type:c.array.constructor.name,array:b});c=this.attributes;for(e in c){var d=c[e];b=Array.prototype.slice.call(d.array);a.data.attributes[e]=\n{itemSize:d.itemSize,type:d.array.constructor.name,array:b,normalized:d.normalized}}var e=this.groups;0<e.length&&(a.data.groups=JSON.parse(JSON.stringify(e)));e=this.boundingSphere;null!==e&&(a.data.boundingSphere={center:e.center.toArray(),radius:e.radius});return a},clone:function(){return(new C).copy(this)},copy:function(a){var b;this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingSphere=this.boundingBox=null;this.name=a.name;var c=a.index;null!==c&&this.setIndex(c.clone());\nc=a.attributes;for(g in c)this.addAttribute(g,c[g].clone());var d=a.morphAttributes;for(g in d){var e=[],f=d[g];c=0;for(b=f.length;c<b;c++)e.push(f[c].clone());this.morphAttributes[g]=e}var g=a.groups;c=0;for(b=g.length;c<b;c++)d=g[c],this.addGroup(d.start,d.count,d.materialIndex);g=a.boundingBox;null!==g&&(this.boundingBox=g.clone());g=a.boundingSphere;null!==g&&(this.boundingSphere=g.clone());this.drawRange.start=a.drawRange.start;this.drawRange.count=a.drawRange.count;this.userData=a.userData;\nreturn this},dispose:function(){this.dispatchEvent({type:\"dispose\"})}});Ib.prototype=Object.create(R.prototype);Ib.prototype.constructor=Ib;kb.prototype=Object.create(C.prototype);kb.prototype.constructor=kb;uc.prototype=Object.create(R.prototype);uc.prototype.constructor=uc;lb.prototype=Object.create(C.prototype);lb.prototype.constructor=lb;var Kf=0;J.prototype=Object.assign(Object.create(ya.prototype),{constructor:J,isMaterial:!0,onBeforeCompile:function(){},setValues:function(a){if(void 0!==a)for(var b in a){var c=\na[b];if(void 0===c)console.warn(\"THREE.Material: '\"+b+\"' parameter is undefined.\");else if(\"shading\"===b)console.warn(\"THREE.\"+this.type+\": .shading has been removed. Use the boolean .flatShading instead.\"),this.flatShading=1===c?!0:!1;else{var d=this[b];void 0===d?console.warn(\"THREE.\"+this.type+\": '\"+b+\"' is not a property of this material.\"):d&&d.isColor?d.set(c):d&&d.isVector3&&c&&c.isVector3?d.copy(c):this[b]=\"overdraw\"===b?Number(c):c}}},toJSON:function(a){function b(a){var b=[],c;for(c in a){var d=\na[c];delete d.metadata;b.push(d)}return b}var c=void 0===a||\"string\"===typeof a;c&&(a={textures:{},images:{}});var d={metadata:{version:4.5,type:\"Material\",generator:\"Material.toJSON\"}};d.uuid=this.uuid;d.type=this.type;\"\"!==this.name&&(d.name=this.name);this.color&&this.color.isColor&&(d.color=this.color.getHex());void 0!==this.roughness&&(d.roughness=this.roughness);void 0!==this.metalness&&(d.metalness=this.metalness);this.emissive&&this.emissive.isColor&&(d.emissive=this.emissive.getHex());1!==\nthis.emissiveIntensity&&(d.emissiveIntensity=this.emissiveIntensity);this.specular&&this.specular.isColor&&(d.specular=this.specular.getHex());void 0!==this.shininess&&(d.shininess=this.shininess);void 0!==this.clearCoat&&(d.clearCoat=this.clearCoat);void 0!==this.clearCoatRoughness&&(d.clearCoatRoughness=this.clearCoatRoughness);this.map&&this.map.isTexture&&(d.map=this.map.toJSON(a).uuid);this.alphaMap&&this.alphaMap.isTexture&&(d.alphaMap=this.alphaMap.toJSON(a).uuid);this.lightMap&&this.lightMap.isTexture&&\n(d.lightMap=this.lightMap.toJSON(a).uuid);this.aoMap&&this.aoMap.isTexture&&(d.aoMap=this.aoMap.toJSON(a).uuid,d.aoMapIntensity=this.aoMapIntensity);this.bumpMap&&this.bumpMap.isTexture&&(d.bumpMap=this.bumpMap.toJSON(a).uuid,d.bumpScale=this.bumpScale);this.normalMap&&this.normalMap.isTexture&&(d.normalMap=this.normalMap.toJSON(a).uuid,d.normalMapType=this.normalMapType,d.normalScale=this.normalScale.toArray());this.displacementMap&&this.displacementMap.isTexture&&(d.displacementMap=this.displacementMap.toJSON(a).uuid,\nd.displacementScale=this.displacementScale,d.displacementBias=this.displacementBias);this.roughnessMap&&this.roughnessMap.isTexture&&(d.roughnessMap=this.roughnessMap.toJSON(a).uuid);this.metalnessMap&&this.metalnessMap.isTexture&&(d.metalnessMap=this.metalnessMap.toJSON(a).uuid);this.emissiveMap&&this.emissiveMap.isTexture&&(d.emissiveMap=this.emissiveMap.toJSON(a).uuid);this.specularMap&&this.specularMap.isTexture&&(d.specularMap=this.specularMap.toJSON(a).uuid);this.envMap&&this.envMap.isTexture&&\n(d.envMap=this.envMap.toJSON(a).uuid,d.reflectivity=this.reflectivity);this.gradientMap&&this.gradientMap.isTexture&&(d.gradientMap=this.gradientMap.toJSON(a).uuid);void 0!==this.size&&(d.size=this.size);void 0!==this.sizeAttenuation&&(d.sizeAttenuation=this.sizeAttenuation);1!==this.blending&&(d.blending=this.blending);!0===this.flatShading&&(d.flatShading=this.flatShading);0!==this.side&&(d.side=this.side);0!==this.vertexColors&&(d.vertexColors=this.vertexColors);1>this.opacity&&(d.opacity=this.opacity);\n!0===this.transparent&&(d.transparent=this.transparent);d.depthFunc=this.depthFunc;d.depthTest=this.depthTest;d.depthWrite=this.depthWrite;0!==this.rotation&&(d.rotation=this.rotation);1!==this.linewidth&&(d.linewidth=this.linewidth);void 0!==this.dashSize&&(d.dashSize=this.dashSize);void 0!==this.gapSize&&(d.gapSize=this.gapSize);void 0!==this.scale&&(d.scale=this.scale);!0===this.dithering&&(d.dithering=!0);0<this.alphaTest&&(d.alphaTest=this.alphaTest);!0===this.premultipliedAlpha&&(d.premultipliedAlpha=\nthis.premultipliedAlpha);!0===this.wireframe&&(d.wireframe=this.wireframe);1<this.wireframeLinewidth&&(d.wireframeLinewidth=this.wireframeLinewidth);\"round\"!==this.wireframeLinecap&&(d.wireframeLinecap=this.wireframeLinecap);\"round\"!==this.wireframeLinejoin&&(d.wireframeLinejoin=this.wireframeLinejoin);!0===this.morphTargets&&(d.morphTargets=!0);!0===this.skinning&&(d.skinning=!0);!1===this.visible&&(d.visible=!1);\"{}\"!==JSON.stringify(this.userData)&&(d.userData=this.userData);c&&(c=b(a.textures),\na=b(a.images),0<c.length&&(d.textures=c),0<a.length&&(d.images=a));return d},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.name=a.name;this.fog=a.fog;this.lights=a.lights;this.blending=a.blending;this.side=a.side;this.flatShading=a.flatShading;this.vertexColors=a.vertexColors;this.opacity=a.opacity;this.transparent=a.transparent;this.blendSrc=a.blendSrc;this.blendDst=a.blendDst;this.blendEquation=a.blendEquation;this.blendSrcAlpha=a.blendSrcAlpha;this.blendDstAlpha=\na.blendDstAlpha;this.blendEquationAlpha=a.blendEquationAlpha;this.depthFunc=a.depthFunc;this.depthTest=a.depthTest;this.depthWrite=a.depthWrite;this.colorWrite=a.colorWrite;this.precision=a.precision;this.polygonOffset=a.polygonOffset;this.polygonOffsetFactor=a.polygonOffsetFactor;this.polygonOffsetUnits=a.polygonOffsetUnits;this.dithering=a.dithering;this.alphaTest=a.alphaTest;this.premultipliedAlpha=a.premultipliedAlpha;this.overdraw=a.overdraw;this.visible=a.visible;this.userData=JSON.parse(JSON.stringify(a.userData));\nthis.clipShadows=a.clipShadows;this.clipIntersection=a.clipIntersection;var b=a.clippingPlanes,c=null;if(null!==b){var d=b.length;c=Array(d);for(var e=0;e!==d;++e)c[e]=b[e].clone()}this.clippingPlanes=c;this.shadowSide=a.shadowSide;return this},dispose:function(){this.dispatchEvent({type:\"dispose\"})}});da.prototype=Object.create(J.prototype);da.prototype.constructor=da;da.prototype.isMeshBasicMaterial=!0;da.prototype.copy=function(a){J.prototype.copy.call(this,a);this.color.copy(a.color);this.map=\na.map;this.lightMap=a.lightMap;this.lightMapIntensity=a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.combine=a.combine;this.reflectivity=a.reflectivity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=\na.morphTargets;return this};ta.prototype=Object.create(J.prototype);ta.prototype.constructor=ta;ta.prototype.isShaderMaterial=!0;ta.prototype.copy=function(a){J.prototype.copy.call(this,a);this.fragmentShader=a.fragmentShader;this.vertexShader=a.vertexShader;this.uniforms=Aa.clone(a.uniforms);this.defines=Object.assign({},a.defines);this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.lights=a.lights;this.clipping=a.clipping;this.skinning=a.skinning;this.morphTargets=a.morphTargets;\nthis.morphNormals=a.morphNormals;this.extensions=a.extensions;return this};ta.prototype.toJSON=function(a){a=J.prototype.toJSON.call(this,a);a.uniforms=this.uniforms;a.vertexShader=this.vertexShader;a.fragmentShader=this.fragmentShader;return a};Object.assign(mb.prototype,{set:function(a,b){this.origin.copy(a);this.direction.copy(b);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.origin.copy(a.origin);this.direction.copy(a.direction);return this},at:function(a,\nb){void 0===b&&(console.warn(\"THREE.Ray: .at() target is now required\"),b=new p);return b.copy(this.direction).multiplyScalar(a).add(this.origin)},lookAt:function(a){this.direction.copy(a).sub(this.origin).normalize();return this},recast:function(){var a=new p;return function(b){this.origin.copy(this.at(b,a));return this}}(),closestPointToPoint:function(a,b){void 0===b&&(console.warn(\"THREE.Ray: .closestPointToPoint() target is now required\"),b=new p);b.subVectors(a,this.origin);a=b.dot(this.direction);\nreturn 0>a?b.copy(this.origin):b.copy(this.direction).multiplyScalar(a).add(this.origin)},distanceToPoint:function(a){return Math.sqrt(this.distanceSqToPoint(a))},distanceSqToPoint:function(){var a=new p;return function(b){var c=a.subVectors(b,this.origin).dot(this.direction);if(0>c)return this.origin.distanceToSquared(b);a.copy(this.direction).multiplyScalar(c).add(this.origin);return a.distanceToSquared(b)}}(),distanceSqToSegment:function(){var a=new p,b=new p,c=new p;return function(d,e,f,g){a.copy(d).add(e).multiplyScalar(.5);\nb.copy(e).sub(d).normalize();c.copy(this.origin).sub(a);var h=.5*d.distanceTo(e),k=-this.direction.dot(b),m=c.dot(this.direction),l=-c.dot(b),n=c.lengthSq(),t=Math.abs(1-k*k);if(0<t){d=k*l-m;e=k*m-l;var p=h*t;0<=d?e>=-p?e<=p?(h=1/t,d*=h,e*=h,k=d*(d+k*e+2*m)+e*(k*d+e+2*l)+n):(e=h,d=Math.max(0,-(k*e+m)),k=-d*d+e*(e+2*l)+n):(e=-h,d=Math.max(0,-(k*e+m)),k=-d*d+e*(e+2*l)+n):e<=-p?(d=Math.max(0,-(-k*h+m)),e=0<d?-h:Math.min(Math.max(-h,-l),h),k=-d*d+e*(e+2*l)+n):e<=p?(d=0,e=Math.min(Math.max(-h,-l),h),k=\ne*(e+2*l)+n):(d=Math.max(0,-(k*h+m)),e=0<d?h:Math.min(Math.max(-h,-l),h),k=-d*d+e*(e+2*l)+n)}else e=0<k?-h:h,d=Math.max(0,-(k*e+m)),k=-d*d+e*(e+2*l)+n;f&&f.copy(this.direction).multiplyScalar(d).add(this.origin);g&&g.copy(b).multiplyScalar(e).add(a);return k}}(),intersectSphere:function(){var a=new p;return function(b,c){a.subVectors(b.center,this.origin);var d=a.dot(this.direction),e=a.dot(a)-d*d;b=b.radius*b.radius;if(e>b)return null;b=Math.sqrt(b-e);e=d-b;d+=b;return 0>e&&0>d?null:0>e?this.at(d,\nc):this.at(e,c)}}(),intersectsSphere:function(a){return this.distanceToPoint(a.center)<=a.radius},distanceToPlane:function(a){var b=a.normal.dot(this.direction);if(0===b)return 0===a.distanceToPoint(this.origin)?0:null;a=-(this.origin.dot(a.normal)+a.constant)/b;return 0<=a?a:null},intersectPlane:function(a,b){a=this.distanceToPlane(a);return null===a?null:this.at(a,b)},intersectsPlane:function(a){var b=a.distanceToPoint(this.origin);return 0===b||0>a.normal.dot(this.direction)*b?!0:!1},intersectBox:function(a,\nb){var c=1/this.direction.x;var d=1/this.direction.y;var e=1/this.direction.z,f=this.origin;if(0<=c){var g=(a.min.x-f.x)*c;c*=a.max.x-f.x}else g=(a.max.x-f.x)*c,c*=a.min.x-f.x;if(0<=d){var h=(a.min.y-f.y)*d;d*=a.max.y-f.y}else h=(a.max.y-f.y)*d,d*=a.min.y-f.y;if(g>d||h>c)return null;if(h>g||g!==g)g=h;if(d<c||c!==c)c=d;0<=e?(h=(a.min.z-f.z)*e,a=(a.max.z-f.z)*e):(h=(a.max.z-f.z)*e,a=(a.min.z-f.z)*e);if(g>a||h>c)return null;if(h>g||g!==g)g=h;if(a<c||c!==c)c=a;return 0>c?null:this.at(0<=g?g:c,b)},intersectsBox:function(){var a=\nnew p;return function(b){return null!==this.intersectBox(b,a)}}(),intersectTriangle:function(){var a=new p,b=new p,c=new p,d=new p;return function(e,f,g,h,k){b.subVectors(f,e);c.subVectors(g,e);d.crossVectors(b,c);f=this.direction.dot(d);if(0<f){if(h)return null;h=1}else if(0>f)h=-1,f=-f;else return null;a.subVectors(this.origin,e);e=h*this.direction.dot(c.crossVectors(a,c));if(0>e)return null;g=h*this.direction.dot(b.cross(a));if(0>g||e+g>f)return null;e=-h*a.dot(d);return 0>e?null:this.at(e/f,k)}}(),\napplyMatrix4:function(a){this.origin.applyMatrix4(a);this.direction.transformDirection(a);return this},equals:function(a){return a.origin.equals(this.origin)&&a.direction.equals(this.direction)}});Object.assign(ja,{getNormal:function(){var a=new p;return function(b,c,d,e){void 0===e&&(console.warn(\"THREE.Triangle: .getNormal() target is now required\"),e=new p);e.subVectors(d,c);a.subVectors(b,c);e.cross(a);b=e.lengthSq();return 0<b?e.multiplyScalar(1/Math.sqrt(b)):e.set(0,0,0)}}(),getBarycoord:function(){var a=\nnew p,b=new p,c=new p;return function(d,e,f,g,h){a.subVectors(g,e);b.subVectors(f,e);c.subVectors(d,e);d=a.dot(a);e=a.dot(b);f=a.dot(c);var k=b.dot(b);g=b.dot(c);var m=d*k-e*e;void 0===h&&(console.warn(\"THREE.Triangle: .getBarycoord() target is now required\"),h=new p);if(0===m)return h.set(-2,-1,-1);m=1/m;k=(k*f-e*g)*m;d=(d*g-e*f)*m;return h.set(1-k-d,d,k)}}(),containsPoint:function(){var a=new p;return function(b,c,d,e){ja.getBarycoord(b,c,d,e,a);return 0<=a.x&&0<=a.y&&1>=a.x+a.y}}()});Object.assign(ja.prototype,\n{set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this},setFromPointsAndIndices:function(a,b,c,d){this.a.copy(a[b]);this.b.copy(a[c]);this.c.copy(a[d]);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.a.copy(a.a);this.b.copy(a.b);this.c.copy(a.c);return this},getArea:function(){var a=new p,b=new p;return function(){a.subVectors(this.c,this.b);b.subVectors(this.a,this.b);return.5*a.cross(b).length()}}(),getMidpoint:function(a){void 0===\na&&(console.warn(\"THREE.Triangle: .getMidpoint() target is now required\"),a=new p);return a.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},getNormal:function(a){return ja.getNormal(this.a,this.b,this.c,a)},getPlane:function(a){void 0===a&&(console.warn(\"THREE.Triangle: .getPlane() target is now required\"),a=new p);return a.setFromCoplanarPoints(this.a,this.b,this.c)},getBarycoord:function(a,b){return ja.getBarycoord(a,this.a,this.b,this.c,b)},containsPoint:function(a){return ja.containsPoint(a,\nthis.a,this.b,this.c)},intersectsBox:function(a){return a.intersectsTriangle(this)},closestPointToPoint:function(){var a=new p,b=new p,c=new p,d=new p,e=new p,f=new p;return function(g,h){void 0===h&&(console.warn(\"THREE.Triangle: .closestPointToPoint() target is now required\"),h=new p);var k=this.a,m=this.b,l=this.c;a.subVectors(m,k);b.subVectors(l,k);d.subVectors(g,k);var n=a.dot(d),t=b.dot(d);if(0>=n&&0>=t)return h.copy(k);e.subVectors(g,m);var u=a.dot(e),r=b.dot(e);if(0<=u&&r<=u)return h.copy(m);\nvar v=n*r-u*t;if(0>=v&&0<=n&&0>=u)return m=n/(n-u),h.copy(k).addScaledVector(a,m);f.subVectors(g,l);g=a.dot(f);var y=b.dot(f);if(0<=y&&g<=y)return h.copy(l);n=g*t-n*y;if(0>=n&&0<=t&&0>=y)return v=t/(t-y),h.copy(k).addScaledVector(b,v);t=u*y-g*r;if(0>=t&&0<=r-u&&0<=g-y)return c.subVectors(l,m),v=(r-u)/(r-u+(g-y)),h.copy(m).addScaledVector(c,v);l=1/(t+n+v);m=n*l;v*=l;return h.copy(k).addScaledVector(a,m).addScaledVector(b,v)}}(),equals:function(a){return a.a.equals(this.a)&&a.b.equals(this.b)&&a.c.equals(this.c)}});\nla.prototype=Object.assign(Object.create(D.prototype),{constructor:la,isMesh:!0,setDrawMode:function(a){this.drawMode=a},copy:function(a){D.prototype.copy.call(this,a);this.drawMode=a.drawMode;void 0!==a.morphTargetInfluences&&(this.morphTargetInfluences=a.morphTargetInfluences.slice());void 0!==a.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},a.morphTargetDictionary));return this},updateMorphTargets:function(){var a=this.geometry;if(a.isBufferGeometry){a=a.morphAttributes;var b=\nObject.keys(a);if(0<b.length){var c=a[b[0]];if(void 0!==c)for(this.morphTargetInfluences=[],this.morphTargetDictionary={},a=0,b=c.length;a<b;a++){var d=c[a].name||String(a);this.morphTargetInfluences.push(0);this.morphTargetDictionary[d]=a}}}else if(c=a.morphTargets,void 0!==c&&0<c.length)for(this.morphTargetInfluences=[],this.morphTargetDictionary={},a=0,b=c.length;a<b;a++)d=c[a].name||String(a),this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=a},raycast:function(){function a(a,b,\nc,d,e,f,g){ja.getBarycoord(a,b,c,d,v);e.multiplyScalar(v.x);f.multiplyScalar(v.y);g.multiplyScalar(v.z);e.add(f).add(g);return e.clone()}function b(a,b,c,d,e,f,g,h){if(null===(1===b.side?d.intersectTriangle(g,f,e,!0,h):d.intersectTriangle(e,f,g,2!==b.side,h)))return null;x.copy(h);x.applyMatrix4(a.matrixWorld);b=c.ray.origin.distanceTo(x);return b<c.near||b>c.far?null:{distance:b,point:x.clone(),object:a}}function c(c,d,e,f,m,l,n,q,p){g.fromBufferAttribute(m,n);h.fromBufferAttribute(m,q);k.fromBufferAttribute(m,\np);if(c=b(c,d,e,f,g,h,k,y))l&&(t.fromBufferAttribute(l,n),u.fromBufferAttribute(l,q),r.fromBufferAttribute(l,p),c.uv=a(y,g,h,k,t,u,r)),l=new Ta(n,q,p),ja.getNormal(g,h,k,l.normal),c.face=l;return c}var d=new I,e=new mb,f=new Da,g=new p,h=new p,k=new p,m=new p,l=new p,n=new p,t=new z,u=new z,r=new z,v=new p,y=new p,x=new p;return function(q,p){var v=this.geometry,w=this.material,x=this.matrixWorld;if(void 0!==w&&(null===v.boundingSphere&&v.computeBoundingSphere(),f.copy(v.boundingSphere),f.applyMatrix4(x),\n!1!==q.ray.intersectsSphere(f)&&(d.getInverse(x),e.copy(q.ray).applyMatrix4(d),null===v.boundingBox||!1!==e.intersectsBox(v.boundingBox))))if(v.isBufferGeometry){var z=v.index,B=v.attributes.position,A=v.attributes.uv,D=v.groups;v=v.drawRange;var C;if(null!==z)if(Array.isArray(w)){var H=0;for(C=D.length;H<C;H++){var G=D[H];var K=w[G.materialIndex];x=Math.max(G.start,v.start);var L=Math.min(G.start+G.count,v.start+v.count);for(G=x;G<L;G+=3){x=z.getX(G);var I=z.getX(G+1);var J=z.getX(G+2);if(x=c(this,\nK,q,e,B,A,x,I,J))x.faceIndex=Math.floor(G/3),p.push(x)}}}else for(x=Math.max(0,v.start),L=Math.min(z.count,v.start+v.count),H=x,C=L;H<C;H+=3){if(x=z.getX(H),I=z.getX(H+1),J=z.getX(H+2),x=c(this,w,q,e,B,A,x,I,J))x.faceIndex=Math.floor(H/3),p.push(x)}else if(void 0!==B)if(Array.isArray(w))for(H=0,C=D.length;H<C;H++)for(G=D[H],K=w[G.materialIndex],x=Math.max(G.start,v.start),L=Math.min(G.start+G.count,v.start+v.count),G=x;G<L;G+=3){if(x=G,I=G+1,J=G+2,x=c(this,K,q,e,B,A,x,I,J))x.faceIndex=Math.floor(G/\n3),p.push(x)}else for(x=Math.max(0,v.start),L=Math.min(B.count,v.start+v.count),H=x,C=L;H<C;H+=3)if(x=H,I=H+1,J=H+2,x=c(this,w,q,e,B,A,x,I,J))x.faceIndex=Math.floor(H/3),p.push(x)}else if(v.isGeometry)for(B=Array.isArray(w),A=v.vertices,D=v.faces,x=v.faceVertexUvs[0],0<x.length&&(z=x),G=0,L=D.length;G<L;G++)if(I=D[G],x=B?w[I.materialIndex]:w,void 0!==x){H=A[I.a];C=A[I.b];K=A[I.c];if(!0===x.morphTargets){J=v.morphTargets;var R=this.morphTargetInfluences;g.set(0,0,0);h.set(0,0,0);k.set(0,0,0);for(var Q=\n0,S=J.length;Q<S;Q++){var T=R[Q];if(0!==T){var V=J[Q].vertices;g.addScaledVector(m.subVectors(V[I.a],H),T);h.addScaledVector(l.subVectors(V[I.b],C),T);k.addScaledVector(n.subVectors(V[I.c],K),T)}}g.add(H);h.add(C);k.add(K);H=g;C=h;K=k}if(x=b(this,x,q,e,H,C,K,y))z&&z[G]&&(J=z[G],t.copy(J[0]),u.copy(J[1]),r.copy(J[2]),x.uv=a(y,H,C,K,t,u,r)),x.face=I,x.faceIndex=G,p.push(x)}}}(),clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});Ua.prototype=Object.create(T.prototype);\nUa.prototype.constructor=Ua;Ua.prototype.isCubeTexture=!0;Object.defineProperty(Ua.prototype,\"images\",{get:function(){return this.image},set:function(a){this.image=a}});var Me=new T,Ne=new Ua,Ge=[],Ie=[],Le=new Float32Array(16),Ke=new Float32Array(9),Je=new Float32Array(4);Re.prototype.updateCache=function(a){var b=this.cache;a instanceof Float32Array&&b.length!==a.length&&(this.cache=new Float32Array(a.length));qa(b,a)};Se.prototype.setValue=function(a,b,c){for(var d=this.seq,e=0,f=d.length;e!==\nf;++e){var g=d[e];g.setValue(a,b[g.id],c)}};var Vd=/([\\w\\d_]+)(\\])?(\\[|\\.)?/g;Za.prototype.setValue=function(a,b,c){b=this.map[b];void 0!==b&&b.setValue(a,c,this.renderer)};Za.prototype.setOptional=function(a,b,c){b=b[c];void 0!==b&&this.setValue(a,c,b)};Za.upload=function(a,b,c,d){for(var e=0,f=b.length;e!==f;++e){var g=b[e],h=c[g.id];!1!==h.needsUpdate&&g.setValue(a,h.value,d)}};Za.seqWithValue=function(a,b){for(var c=[],d=0,e=a.length;d!==e;++d){var f=a[d];f.id in b&&c.push(f)}return c};var yg=\n0,Hg=0;$a.prototype=Object.create(J.prototype);$a.prototype.constructor=$a;$a.prototype.isMeshDepthMaterial=!0;$a.prototype.copy=function(a){J.prototype.copy.call(this,a);this.depthPacking=a.depthPacking;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.map=a.map;this.alphaMap=a.alphaMap;this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;return this};\nab.prototype=Object.create(J.prototype);ab.prototype.constructor=ab;ab.prototype.isMeshDistanceMaterial=!0;ab.prototype.copy=function(a){J.prototype.copy.call(this,a);this.referencePosition.copy(a.referencePosition);this.nearDistance=a.nearDistance;this.farDistance=a.farDistance;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.map=a.map;this.alphaMap=a.alphaMap;this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;\nreturn this};Kb.prototype=Object.assign(Object.create(D.prototype),{constructor:Kb,isGroup:!0});Z.prototype=Object.assign(Object.create(Na.prototype),{constructor:Z,isPerspectiveCamera:!0,copy:function(a,b){Na.prototype.copy.call(this,a,b);this.fov=a.fov;this.zoom=a.zoom;this.near=a.near;this.far=a.far;this.focus=a.focus;this.aspect=a.aspect;this.view=null===a.view?null:Object.assign({},a.view);this.filmGauge=a.filmGauge;this.filmOffset=a.filmOffset;return this},setFocalLength:function(a){a=.5*this.getFilmHeight()/\na;this.fov=2*H.RAD2DEG*Math.atan(a);this.updateProjectionMatrix()},getFocalLength:function(){var a=Math.tan(.5*H.DEG2RAD*this.fov);return.5*this.getFilmHeight()/a},getEffectiveFOV:function(){return 2*H.RAD2DEG*Math.atan(Math.tan(.5*H.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(a,b,c,d,e,f){this.aspect=a/b;null===this.view&&(this.view={enabled:!0,fullWidth:1,\nfullHeight:1,offsetX:0,offsetY:0,width:1,height:1});this.view.enabled=!0;this.view.fullWidth=a;this.view.fullHeight=b;this.view.offsetX=c;this.view.offsetY=d;this.view.width=e;this.view.height=f;this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1);this.updateProjectionMatrix()},updateProjectionMatrix:function(){var a=this.near,b=a*Math.tan(.5*H.DEG2RAD*this.fov)/this.zoom,c=2*b,d=this.aspect*c,e=-.5*d,f=this.view;if(null!==this.view&&this.view.enabled){var g=\nf.fullWidth,h=f.fullHeight;e+=f.offsetX*d/g;b-=f.offsetY*c/h;d*=f.width/g;c*=f.height/h}f=this.filmOffset;0!==f&&(e+=a*f/this.getFilmWidth());this.projectionMatrix.makePerspective(e,e+d,b,b-c,a,this.far)},toJSON:function(a){a=D.prototype.toJSON.call(this,a);a.object.fov=this.fov;a.object.zoom=this.zoom;a.object.near=this.near;a.object.far=this.far;a.object.focus=this.focus;a.object.aspect=this.aspect;null!==this.view&&(a.object.view=Object.assign({},this.view));a.object.filmGauge=this.filmGauge;a.object.filmOffset=\nthis.filmOffset;return a}});yc.prototype=Object.assign(Object.create(Z.prototype),{constructor:yc,isArrayCamera:!0});Lb.prototype.isFogExp2=!0;Lb.prototype.clone=function(){return new Lb(this.color,this.density)};Lb.prototype.toJSON=function(){return{type:\"FogExp2\",color:this.color.getHex(),density:this.density}};Mb.prototype.isFog=!0;Mb.prototype.clone=function(){return new Mb(this.color,this.near,this.far)};Mb.prototype.toJSON=function(){return{type:\"Fog\",color:this.color.getHex(),near:this.near,\nfar:this.far}};qd.prototype=Object.assign(Object.create(D.prototype),{constructor:qd,copy:function(a,b){D.prototype.copy.call(this,a,b);null!==a.background&&(this.background=a.background.clone());null!==a.fog&&(this.fog=a.fog.clone());null!==a.overrideMaterial&&(this.overrideMaterial=a.overrideMaterial.clone());this.autoUpdate=a.autoUpdate;this.matrixAutoUpdate=a.matrixAutoUpdate;return this},toJSON:function(a){var b=D.prototype.toJSON.call(this,a);null!==this.background&&(b.object.background=this.background.toJSON(a));\nnull!==this.fog&&(b.object.fog=this.fog.toJSON());return b}});Object.defineProperty(ob.prototype,\"needsUpdate\",{set:function(a){!0===a&&this.version++}});Object.assign(ob.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setArray:function(a){if(Array.isArray(a))throw new TypeError(\"THREE.BufferAttribute: array should be a Typed Array.\");this.count=void 0!==a?a.length/this.stride:0;this.array=a;return this},setDynamic:function(a){this.dynamic=a;return this},copy:function(a){this.array=\nnew a.array.constructor(a.array);this.count=a.count;this.stride=a.stride;this.dynamic=a.dynamic;return this},copyAt:function(a,b,c){a*=this.stride;c*=b.stride;for(var d=0,e=this.stride;d<e;d++)this.array[a+d]=b.array[c+d];return this},set:function(a,b){void 0===b&&(b=0);this.array.set(a,b);return this},clone:function(){return(new this.constructor).copy(this)},onUpload:function(a){this.onUploadCallback=a;return this}});Object.defineProperties(zc.prototype,{count:{get:function(){return this.data.count}},\narray:{get:function(){return this.data.array}}});Object.assign(zc.prototype,{isInterleavedBufferAttribute:!0,setX:function(a,b){this.data.array[a*this.data.stride+this.offset]=b;return this},setY:function(a,b){this.data.array[a*this.data.stride+this.offset+1]=b;return this},setZ:function(a,b){this.data.array[a*this.data.stride+this.offset+2]=b;return this},setW:function(a,b){this.data.array[a*this.data.stride+this.offset+3]=b;return this},getX:function(a){return this.data.array[a*this.data.stride+\nthis.offset]},getY:function(a){return this.data.array[a*this.data.stride+this.offset+1]},getZ:function(a){return this.data.array[a*this.data.stride+this.offset+2]},getW:function(a){return this.data.array[a*this.data.stride+this.offset+3]},setXY:function(a,b,c){a=a*this.data.stride+this.offset;this.data.array[a+0]=b;this.data.array[a+1]=c;return this},setXYZ:function(a,b,c,d){a=a*this.data.stride+this.offset;this.data.array[a+0]=b;this.data.array[a+1]=c;this.data.array[a+2]=d;return this},setXYZW:function(a,\nb,c,d,e){a=a*this.data.stride+this.offset;this.data.array[a+0]=b;this.data.array[a+1]=c;this.data.array[a+2]=d;this.data.array[a+3]=e;return this}});cb.prototype=Object.create(J.prototype);cb.prototype.constructor=cb;cb.prototype.isSpriteMaterial=!0;cb.prototype.copy=function(a){J.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.rotation=a.rotation;return this};var Nb;Ac.prototype=Object.assign(Object.create(D.prototype),{constructor:Ac,isSprite:!0,raycast:function(){function a(a,\nb,c,d,h,k){e.subVectors(a,c).addScalar(.5).multiply(d);void 0!==h?(f.x=k*e.x-h*e.y,f.y=h*e.x+k*e.y):f.copy(e);a.copy(b);a.x+=f.x;a.y+=f.y;a.applyMatrix4(g)}var b=new p,c=new p,d=new p,e=new z,f=new z,g=new I,h=new p,k=new p,m=new p;return function(e,f){c.setFromMatrixScale(this.matrixWorld);g.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);d.setFromMatrixPosition(this.modelViewMatrix);var l=this.material.rotation;if(0!==l){var n=Math.cos(l);var q=Math.sin(l)}l=this.center;a(h.set(-.5,\n-.5,0),d,l,c,q,n);a(k.set(.5,-.5,0),d,l,c,q,n);a(m.set(.5,.5,0),d,l,c,q,n);var p=e.ray.intersectTriangle(h,k,m,!1,b);if(null===p&&(a(k.set(-.5,.5,0),d,l,c,q,n),p=e.ray.intersectTriangle(h,m,k,!1,b),null===p))return;q=e.ray.origin.distanceTo(b);q<e.near||q>e.far||f.push({distance:q,point:b.clone(),face:null,object:this})}}(),clone:function(){return(new this.constructor(this.material)).copy(this)},copy:function(a){D.prototype.copy.call(this,a);void 0!==a.center&&this.center.copy(a.center);return this}});\nBc.prototype=Object.assign(Object.create(D.prototype),{constructor:Bc,copy:function(a){D.prototype.copy.call(this,a,!1);a=a.levels;for(var b=0,c=a.length;b<c;b++){var d=a[b];this.addLevel(d.object.clone(),d.distance)}return this},addLevel:function(a,b){void 0===b&&(b=0);b=Math.abs(b);for(var c=this.levels,d=0;d<c.length&&!(b<c[d].distance);d++);c.splice(d,0,{distance:b,object:a});this.add(a)},getObjectForDistance:function(a){for(var b=this.levels,c=1,d=b.length;c<d&&!(a<b[c].distance);c++);return b[c-\n1].object},raycast:function(){var a=new p;return function(b,c){a.setFromMatrixPosition(this.matrixWorld);var d=b.ray.origin.distanceTo(a);this.getObjectForDistance(d).raycast(b,c)}}(),update:function(){var a=new p,b=new p;return function(c){var d=this.levels;if(1<d.length){a.setFromMatrixPosition(c.matrixWorld);b.setFromMatrixPosition(this.matrixWorld);c=a.distanceTo(b);d[0].object.visible=!0;for(var e=1,f=d.length;e<f;e++)if(c>=d[e].distance)d[e-1].object.visible=!1,d[e].object.visible=!0;else break;\nfor(;e<f;e++)d[e].object.visible=!1}}}(),toJSON:function(a){a=D.prototype.toJSON.call(this,a);a.object.levels=[];for(var b=this.levels,c=0,d=b.length;c<d;c++){var e=b[c];a.object.levels.push({object:e.object.uuid,distance:e.distance})}return a}});Object.assign(Cc.prototype,{calculateInverses:function(){this.boneInverses=[];for(var a=0,b=this.bones.length;a<b;a++){var c=new I;this.bones[a]&&c.getInverse(this.bones[a].matrixWorld);this.boneInverses.push(c)}},pose:function(){var a,b;var c=0;for(b=this.bones.length;c<\nb;c++)(a=this.bones[c])&&a.matrixWorld.getInverse(this.boneInverses[c]);c=0;for(b=this.bones.length;c<b;c++)if(a=this.bones[c])a.parent&&a.parent.isBone?(a.matrix.getInverse(a.parent.matrixWorld),a.matrix.multiply(a.matrixWorld)):a.matrix.copy(a.matrixWorld),a.matrix.decompose(a.position,a.quaternion,a.scale)},update:function(){var a=new I,b=new I;return function(){for(var c=this.bones,d=this.boneInverses,e=this.boneMatrices,f=this.boneTexture,g=0,h=c.length;g<h;g++)a.multiplyMatrices(c[g]?c[g].matrixWorld:\nb,d[g]),a.toArray(e,16*g);void 0!==f&&(f.needsUpdate=!0)}}(),clone:function(){return new Cc(this.bones,this.boneInverses)},getBoneByName:function(a){for(var b=0,c=this.bones.length;b<c;b++){var d=this.bones[b];if(d.name===a)return d}}});rd.prototype=Object.assign(Object.create(D.prototype),{constructor:rd,isBone:!0});sd.prototype=Object.assign(Object.create(la.prototype),{constructor:sd,isSkinnedMesh:!0,initBones:function(){var a=[],b;if(this.geometry&&void 0!==this.geometry.bones){var c=0;for(b=\nthis.geometry.bones.length;c<b;c++){var d=this.geometry.bones[c];var e=new rd;a.push(e);e.name=d.name;e.position.fromArray(d.pos);e.quaternion.fromArray(d.rotq);void 0!==d.scl&&e.scale.fromArray(d.scl)}c=0;for(b=this.geometry.bones.length;c<b;c++)d=this.geometry.bones[c],-1!==d.parent&&null!==d.parent&&void 0!==a[d.parent]?a[d.parent].add(a[c]):this.add(a[c])}this.updateMatrixWorld(!0);return a},bind:function(a,b){this.skeleton=a;void 0===b&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),\nb=this.matrixWorld);this.bindMatrix.copy(b);this.bindMatrixInverse.getInverse(b)},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){var a;if(this.geometry&&this.geometry.isGeometry)for(a=0;a<this.geometry.skinWeights.length;a++){var b=this.geometry.skinWeights[a];var c=1/b.manhattanLength();Infinity!==c?b.multiplyScalar(c):b.set(1,0,0,0)}else if(this.geometry&&this.geometry.isBufferGeometry){b=new V;var d=this.geometry.attributes.skinWeight;for(a=0;a<d.count;a++)b.x=d.getX(a),\nb.y=d.getY(a),b.z=d.getZ(a),b.w=d.getW(a),c=1/b.manhattanLength(),Infinity!==c?b.multiplyScalar(c):b.set(1,0,0,0),d.setXYZW(a,b.x,b.y,b.z,b.w)}},updateMatrixWorld:function(a){la.prototype.updateMatrixWorld.call(this,a);\"attached\"===this.bindMode?this.bindMatrixInverse.getInverse(this.matrixWorld):\"detached\"===this.bindMode?this.bindMatrixInverse.getInverse(this.bindMatrix):console.warn(\"THREE.SkinnedMesh: Unrecognized bindMode: \"+this.bindMode)},clone:function(){return(new this.constructor(this.geometry,\nthis.material)).copy(this)}});Y.prototype=Object.create(J.prototype);Y.prototype.constructor=Y;Y.prototype.isLineBasicMaterial=!0;Y.prototype.copy=function(a){J.prototype.copy.call(this,a);this.color.copy(a.color);this.linewidth=a.linewidth;this.linecap=a.linecap;this.linejoin=a.linejoin;return this};sa.prototype=Object.assign(Object.create(D.prototype),{constructor:sa,isLine:!0,computeLineDistances:function(){var a=new p,b=new p;return function(){var c=this.geometry;if(c.isBufferGeometry)if(null===\nc.index){for(var d=c.attributes.position,e=[0],f=1,g=d.count;f<g;f++)a.fromBufferAttribute(d,f-1),b.fromBufferAttribute(d,f),e[f]=e[f-1],e[f]+=a.distanceTo(b);c.addAttribute(\"lineDistance\",new A(e,1))}else console.warn(\"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.\");else if(c.isGeometry)for(d=c.vertices,e=c.lineDistances,e[0]=0,f=1,g=d.length;f<g;f++)e[f]=e[f-1],e[f]+=d[f-1].distanceTo(d[f]);return this}}(),raycast:function(){var a=new I,b=new mb,c=\nnew Da;return function(d,e){var f=d.linePrecision;f*=f;var g=this.geometry,h=this.matrixWorld;null===g.boundingSphere&&g.computeBoundingSphere();c.copy(g.boundingSphere);c.applyMatrix4(h);if(!1!==d.ray.intersectsSphere(c)){a.getInverse(h);b.copy(d.ray).applyMatrix4(a);var k=new p,m=new p;h=new p;var l=new p,n=this&&this.isLineSegments?2:1;if(g.isBufferGeometry){var t=g.index,u=g.attributes.position.array;if(null!==t){t=t.array;g=0;for(var r=t.length-1;g<r;g+=n){var v=t[g+1];k.fromArray(u,3*t[g]);\nm.fromArray(u,3*v);v=b.distanceSqToSegment(k,m,l,h);v>f||(l.applyMatrix4(this.matrixWorld),v=d.ray.origin.distanceTo(l),v<d.near||v>d.far||e.push({distance:v,point:h.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this}))}}else for(g=0,r=u.length/3-1;g<r;g+=n)k.fromArray(u,3*g),m.fromArray(u,3*g+3),v=b.distanceSqToSegment(k,m,l,h),v>f||(l.applyMatrix4(this.matrixWorld),v=d.ray.origin.distanceTo(l),v<d.near||v>d.far||e.push({distance:v,point:h.clone().applyMatrix4(this.matrixWorld),\nindex:g,face:null,faceIndex:null,object:this}))}else if(g.isGeometry)for(k=g.vertices,m=k.length,g=0;g<m-1;g+=n)v=b.distanceSqToSegment(k[g],k[g+1],l,h),v>f||(l.applyMatrix4(this.matrixWorld),v=d.ray.origin.distanceTo(l),v<d.near||v>d.far||e.push({distance:v,point:h.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this}))}}}(),clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});W.prototype=Object.assign(Object.create(sa.prototype),\n{constructor:W,isLineSegments:!0,computeLineDistances:function(){var a=new p,b=new p;return function(){var c=this.geometry;if(c.isBufferGeometry)if(null===c.index){for(var d=c.attributes.position,e=[],f=0,g=d.count;f<g;f+=2)a.fromBufferAttribute(d,f),b.fromBufferAttribute(d,f+1),e[f]=0===f?0:e[f-1],e[f+1]=e[f]+a.distanceTo(b);c.addAttribute(\"lineDistance\",new A(e,1))}else console.warn(\"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.\");else if(c.isGeometry)for(d=\nc.vertices,e=c.lineDistances,f=0,g=d.length;f<g;f+=2)a.copy(d[f]),b.copy(d[f+1]),e[f]=0===f?0:e[f-1],e[f+1]=e[f]+a.distanceTo(b);return this}}()});td.prototype=Object.assign(Object.create(sa.prototype),{constructor:td,isLineLoop:!0});Ea.prototype=Object.create(J.prototype);Ea.prototype.constructor=Ea;Ea.prototype.isPointsMaterial=!0;Ea.prototype.copy=function(a){J.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.size=a.size;this.sizeAttenuation=a.sizeAttenuation;this.morphTargets=\na.morphTargets;return this};Ob.prototype=Object.assign(Object.create(D.prototype),{constructor:Ob,isPoints:!0,raycast:function(){var a=new I,b=new mb,c=new Da;return function(d,e){function f(a,c){var f=b.distanceSqToPoint(a);f<l&&(b.closestPointToPoint(a,n),n.applyMatrix4(k),a=d.ray.origin.distanceTo(n),a<d.near||a>d.far||e.push({distance:a,distanceToRay:Math.sqrt(f),point:n.clone(),index:c,face:null,object:g}))}var g=this,h=this.geometry,k=this.matrixWorld,m=d.params.Points.threshold;null===h.boundingSphere&&\nh.computeBoundingSphere();c.copy(h.boundingSphere);c.applyMatrix4(k);c.radius+=m;if(!1!==d.ray.intersectsSphere(c)){a.getInverse(k);b.copy(d.ray).applyMatrix4(a);m/=(this.scale.x+this.scale.y+this.scale.z)/3;var l=m*m;m=new p;var n=new p;if(h.isBufferGeometry){var t=h.index;h=h.attributes.position.array;if(null!==t){var u=t.array;t=0;for(var r=u.length;t<r;t++){var v=u[t];m.fromArray(h,3*v);f(m,v)}}else for(t=0,u=h.length/3;t<u;t++)m.fromArray(h,3*t),f(m,t)}else for(m=h.vertices,t=0,u=m.length;t<\nu;t++)f(m[t],t)}}}(),clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});$d.prototype=Object.assign(Object.create(T.prototype),{constructor:$d,isVideoTexture:!0,update:function(){var a=this.image;a.readyState>=a.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}});Pb.prototype=Object.create(T.prototype);Pb.prototype.constructor=Pb;Pb.prototype.isCompressedTexture=!0;Dc.prototype=Object.create(T.prototype);Dc.prototype.constructor=Dc;Dc.prototype.isCanvasTexture=!0;Ec.prototype=\nObject.create(T.prototype);Ec.prototype.constructor=Ec;Ec.prototype.isDepthTexture=!0;Qb.prototype=Object.create(C.prototype);Qb.prototype.constructor=Qb;Fc.prototype=Object.create(R.prototype);Fc.prototype.constructor=Fc;Rb.prototype=Object.create(C.prototype);Rb.prototype.constructor=Rb;Gc.prototype=Object.create(R.prototype);Gc.prototype.constructor=Gc;na.prototype=Object.create(C.prototype);na.prototype.constructor=na;Hc.prototype=Object.create(R.prototype);Hc.prototype.constructor=Hc;Sb.prototype=\nObject.create(na.prototype);Sb.prototype.constructor=Sb;Ic.prototype=Object.create(R.prototype);Ic.prototype.constructor=Ic;pb.prototype=Object.create(na.prototype);pb.prototype.constructor=pb;Jc.prototype=Object.create(R.prototype);Jc.prototype.constructor=Jc;Tb.prototype=Object.create(na.prototype);Tb.prototype.constructor=Tb;Kc.prototype=Object.create(R.prototype);Kc.prototype.constructor=Kc;Ub.prototype=Object.create(na.prototype);Ub.prototype.constructor=Ub;Lc.prototype=Object.create(R.prototype);\nLc.prototype.constructor=Lc;Vb.prototype=Object.create(C.prototype);Vb.prototype.constructor=Vb;Mc.prototype=Object.create(R.prototype);Mc.prototype.constructor=Mc;Wb.prototype=Object.create(C.prototype);Wb.prototype.constructor=Wb;Nc.prototype=Object.create(R.prototype);Nc.prototype.constructor=Nc;Xb.prototype=Object.create(C.prototype);Xb.prototype.constructor=Xb;var Ug={triangulate:function(a,b,c){c=c||2;var d=b&&b.length,e=d?b[0]*c:a.length,f=bf(a,0,e,c,!0),g=[];if(!f)return g;var h;if(d){var k=\nc;d=[];var m;var l=0;for(m=b.length;l<m;l++){var n=b[l]*k;var t=l<m-1?b[l+1]*k:a.length;n=bf(a,n,t,k,!1);n===n.next&&(n.steiner=!0);d.push(Pg(n))}d.sort(Ng);for(l=0;l<d.length;l++){b=d[l];k=f;if(k=Og(b,k))b=ef(k,b),Pc(b,b.next);f=Pc(f,f.next)}}if(a.length>80*c){var p=h=a[0];var r=d=a[1];for(k=c;k<e;k+=c)l=a[k],b=a[k+1],l<p&&(p=l),b<r&&(r=b),l>h&&(h=l),b>d&&(d=b);h=Math.max(h-p,d-r);h=0!==h?1/h:0}Qc(f,g,c,p,r,h);return g}},Va={area:function(a){for(var b=a.length,c=0,d=b-1,e=0;e<b;d=e++)c+=a[d].x*a[e].y-\na[e].x*a[d].y;return.5*c},isClockWise:function(a){return 0>Va.area(a)},triangulateShape:function(a,b){var c=[],d=[],e=[];ff(a);gf(c,a);var f=a.length;b.forEach(ff);for(a=0;a<b.length;a++)d.push(f),f+=b[a].length,gf(c,b[a]);b=Ug.triangulate(c,d);for(a=0;a<b.length;a+=3)e.push(b.slice(a,a+3));return e}};rb.prototype=Object.create(R.prototype);rb.prototype.constructor=rb;rb.prototype.toJSON=function(){var a=R.prototype.toJSON.call(this);return hf(this.parameters.shapes,this.parameters.options,a)};Oa.prototype=\nObject.create(C.prototype);Oa.prototype.constructor=Oa;Oa.prototype.toJSON=function(){var a=C.prototype.toJSON.call(this);return hf(this.parameters.shapes,this.parameters.options,a)};var Qg={generateTopUV:function(a,b,c,d,e){a=b[3*d];d=b[3*d+1];var f=b[3*e];e=b[3*e+1];return[new z(b[3*c],b[3*c+1]),new z(a,d),new z(f,e)]},generateSideWallUV:function(a,b,c,d,e,f){a=b[3*c];var g=b[3*c+1];c=b[3*c+2];var h=b[3*d],k=b[3*d+1];d=b[3*d+2];var m=b[3*e],l=b[3*e+1];e=b[3*e+2];var n=b[3*f],t=b[3*f+1];b=b[3*f+\n2];return.01>Math.abs(g-k)?[new z(a,1-c),new z(h,1-d),new z(m,1-e),new z(n,1-b)]:[new z(g,1-c),new z(k,1-d),new z(l,1-e),new z(t,1-b)]}};Sc.prototype=Object.create(R.prototype);Sc.prototype.constructor=Sc;Yb.prototype=Object.create(Oa.prototype);Yb.prototype.constructor=Yb;Tc.prototype=Object.create(R.prototype);Tc.prototype.constructor=Tc;sb.prototype=Object.create(C.prototype);sb.prototype.constructor=sb;Uc.prototype=Object.create(R.prototype);Uc.prototype.constructor=Uc;Zb.prototype=Object.create(C.prototype);\nZb.prototype.constructor=Zb;Vc.prototype=Object.create(R.prototype);Vc.prototype.constructor=Vc;$b.prototype=Object.create(C.prototype);$b.prototype.constructor=$b;tb.prototype=Object.create(R.prototype);tb.prototype.constructor=tb;tb.prototype.toJSON=function(){var a=R.prototype.toJSON.call(this);return jf(this.parameters.shapes,a)};ub.prototype=Object.create(C.prototype);ub.prototype.constructor=ub;ub.prototype.toJSON=function(){var a=C.prototype.toJSON.call(this);return jf(this.parameters.shapes,\na)};ac.prototype=Object.create(C.prototype);ac.prototype.constructor=ac;vb.prototype=Object.create(R.prototype);vb.prototype.constructor=vb;Wa.prototype=Object.create(C.prototype);Wa.prototype.constructor=Wa;Wc.prototype=Object.create(vb.prototype);Wc.prototype.constructor=Wc;Xc.prototype=Object.create(Wa.prototype);Xc.prototype.constructor=Xc;Yc.prototype=Object.create(R.prototype);Yc.prototype.constructor=Yc;bc.prototype=Object.create(C.prototype);bc.prototype.constructor=bc;var xa=Object.freeze({WireframeGeometry:Qb,\nParametricGeometry:Fc,ParametricBufferGeometry:Rb,TetrahedronGeometry:Hc,TetrahedronBufferGeometry:Sb,OctahedronGeometry:Ic,OctahedronBufferGeometry:pb,IcosahedronGeometry:Jc,IcosahedronBufferGeometry:Tb,DodecahedronGeometry:Kc,DodecahedronBufferGeometry:Ub,PolyhedronGeometry:Gc,PolyhedronBufferGeometry:na,TubeGeometry:Lc,TubeBufferGeometry:Vb,TorusKnotGeometry:Mc,TorusKnotBufferGeometry:Wb,TorusGeometry:Nc,TorusBufferGeometry:Xb,TextGeometry:Sc,TextBufferGeometry:Yb,SphereGeometry:Tc,SphereBufferGeometry:sb,\nRingGeometry:Uc,RingBufferGeometry:Zb,PlaneGeometry:uc,PlaneBufferGeometry:lb,LatheGeometry:Vc,LatheBufferGeometry:$b,ShapeGeometry:tb,ShapeBufferGeometry:ub,ExtrudeGeometry:rb,ExtrudeBufferGeometry:Oa,EdgesGeometry:ac,ConeGeometry:Wc,ConeBufferGeometry:Xc,CylinderGeometry:vb,CylinderBufferGeometry:Wa,CircleGeometry:Yc,CircleBufferGeometry:bc,BoxGeometry:Ib,BoxBufferGeometry:kb});wb.prototype=Object.create(J.prototype);wb.prototype.constructor=wb;wb.prototype.isShadowMaterial=!0;wb.prototype.copy=\nfunction(a){J.prototype.copy.call(this,a);this.color.copy(a.color);return this};cc.prototype=Object.create(ta.prototype);cc.prototype.constructor=cc;cc.prototype.isRawShaderMaterial=!0;Pa.prototype=Object.create(J.prototype);Pa.prototype.constructor=Pa;Pa.prototype.isMeshStandardMaterial=!0;Pa.prototype.copy=function(a){J.prototype.copy.call(this,a);this.defines={STANDARD:\"\"};this.color.copy(a.color);this.roughness=a.roughness;this.metalness=a.metalness;this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=\na.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);this.emissiveMap=a.emissiveMap;this.emissiveIntensity=a.emissiveIntensity;this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=a.normalMap;this.normalMapType=a.normalMapType;this.normalScale.copy(a.normalScale);this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.roughnessMap=a.roughnessMap;this.metalnessMap=\na.metalnessMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.envMapIntensity=a.envMapIntensity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};xb.prototype=Object.create(Pa.prototype);xb.prototype.constructor=xb;xb.prototype.isMeshPhysicalMaterial=\n!0;xb.prototype.copy=function(a){Pa.prototype.copy.call(this,a);this.defines={PHYSICAL:\"\"};this.reflectivity=a.reflectivity;this.clearCoat=a.clearCoat;this.clearCoatRoughness=a.clearCoatRoughness;return this};Fa.prototype=Object.create(J.prototype);Fa.prototype.constructor=Fa;Fa.prototype.isMeshPhongMaterial=!0;Fa.prototype.copy=function(a){J.prototype.copy.call(this,a);this.color.copy(a.color);this.specular.copy(a.specular);this.shininess=a.shininess;this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=\na.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);this.emissiveMap=a.emissiveMap;this.emissiveIntensity=a.emissiveIntensity;this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=a.normalMap;this.normalMapType=a.normalMapType;this.normalScale.copy(a.normalScale);this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;\nthis.envMap=a.envMap;this.combine=a.combine;this.reflectivity=a.reflectivity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};yb.prototype=Object.create(Fa.prototype);yb.prototype.constructor=yb;yb.prototype.isMeshToonMaterial=!0;yb.prototype.copy=function(a){Fa.prototype.copy.call(this,\na);this.gradientMap=a.gradientMap;return this};zb.prototype=Object.create(J.prototype);zb.prototype.constructor=zb;zb.prototype.isMeshNormalMaterial=!0;zb.prototype.copy=function(a){J.prototype.copy.call(this,a);this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=a.normalMap;this.normalMapType=a.normalMapType;this.normalScale.copy(a.normalScale);this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.wireframe=a.wireframe;\nthis.wireframeLinewidth=a.wireframeLinewidth;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};Ab.prototype=Object.create(J.prototype);Ab.prototype.constructor=Ab;Ab.prototype.isMeshLambertMaterial=!0;Ab.prototype.copy=function(a){J.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);\nthis.emissiveMap=a.emissiveMap;this.emissiveIntensity=a.emissiveIntensity;this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.combine=a.combine;this.reflectivity=a.reflectivity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};\nBb.prototype=Object.create(Y.prototype);Bb.prototype.constructor=Bb;Bb.prototype.isLineDashedMaterial=!0;Bb.prototype.copy=function(a){Y.prototype.copy.call(this,a);this.scale=a.scale;this.dashSize=a.dashSize;this.gapSize=a.gapSize;return this};var Vg=Object.freeze({ShadowMaterial:wb,SpriteMaterial:cb,RawShaderMaterial:cc,ShaderMaterial:ta,PointsMaterial:Ea,MeshPhysicalMaterial:xb,MeshStandardMaterial:Pa,MeshPhongMaterial:Fa,MeshToonMaterial:yb,MeshNormalMaterial:zb,MeshLambertMaterial:Ab,MeshDepthMaterial:$a,\nMeshDistanceMaterial:ab,MeshBasicMaterial:da,LineDashedMaterial:Bb,LineBasicMaterial:Y,Material:J}),Fb={enabled:!1,files:{},add:function(a,b){!1!==this.enabled&&(this.files[a]=b)},get:function(a){if(!1!==this.enabled)return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}},ka=new ce,Ya={};Object.assign(Ga.prototype,{load:function(a,b,c,d){void 0===a&&(a=\"\");void 0!==this.path&&(a=this.path+a);a=this.manager.resolveURL(a);var e=this,f=Fb.get(a);if(void 0!==f)return e.manager.itemStart(a),\nsetTimeout(function(){b&&b(f);e.manager.itemEnd(a)},0),f;if(void 0!==Ya[a])Ya[a].push({onLoad:b,onProgress:c,onError:d});else{var g=a.match(/^data:(.*?)(;base64)?,(.*)$/);if(g){c=g[1];var h=!!g[2];g=g[3];g=window.decodeURIComponent(g);h&&(g=window.atob(g));try{var k=(this.responseType||\"\").toLowerCase();switch(k){case \"arraybuffer\":case \"blob\":var m=new Uint8Array(g.length);for(h=0;h<g.length;h++)m[h]=g.charCodeAt(h);var l=\"blob\"===k?new Blob([m.buffer],{type:c}):m.buffer;break;case \"document\":l=\n(new DOMParser).parseFromString(g,c);break;case \"json\":l=JSON.parse(g);break;default:l=g}window.setTimeout(function(){b&&b(l);e.manager.itemEnd(a)},0)}catch(t){window.setTimeout(function(){d&&d(t);e.manager.itemEnd(a);e.manager.itemError(a)},0)}}else{Ya[a]=[];Ya[a].push({onLoad:b,onProgress:c,onError:d});var n=new XMLHttpRequest;n.open(\"GET\",a,!0);n.addEventListener(\"load\",function(b){var c=this.response;Fb.add(a,c);var d=Ya[a];delete Ya[a];if(200===this.status||0===this.status){0===this.status&&\nconsole.warn(\"THREE.FileLoader: HTTP Status 0 received.\");for(var f=0,g=d.length;f<g;f++){var h=d[f];if(h.onLoad)h.onLoad(c)}e.manager.itemEnd(a)}else{f=0;for(g=d.length;f<g;f++)if(h=d[f],h.onError)h.onError(b);e.manager.itemEnd(a);e.manager.itemError(a)}},!1);n.addEventListener(\"progress\",function(b){for(var c=Ya[a],d=0,e=c.length;d<e;d++){var f=c[d];if(f.onProgress)f.onProgress(b)}},!1);n.addEventListener(\"error\",function(b){var c=Ya[a];delete Ya[a];for(var d=0,f=c.length;d<f;d++){var g=c[d];if(g.onError)g.onError(b)}e.manager.itemEnd(a);\ne.manager.itemError(a)},!1);void 0!==this.responseType&&(n.responseType=this.responseType);void 0!==this.withCredentials&&(n.withCredentials=this.withCredentials);n.overrideMimeType&&n.overrideMimeType(void 0!==this.mimeType?this.mimeType:\"text/plain\");for(h in this.requestHeader)n.setRequestHeader(h,this.requestHeader[h]);n.send(null)}e.manager.itemStart(a);return n}},setPath:function(a){this.path=a;return this},setResponseType:function(a){this.responseType=a;return this},setWithCredentials:function(a){this.withCredentials=\na;return this},setMimeType:function(a){this.mimeType=a;return this},setRequestHeader:function(a){this.requestHeader=a;return this}});Object.assign(kf.prototype,{load:function(a,b,c,d){function e(e){k.load(a[e],function(a){a=f._parser(a,!0);g[e]={width:a.width,height:a.height,format:a.format,mipmaps:a.mipmaps};m+=1;6===m&&(1===a.mipmapCount&&(h.minFilter=1006),h.format=a.format,h.needsUpdate=!0,b&&b(h))},c,d)}var f=this,g=[],h=new Pb;h.image=g;var k=new Ga(this.manager);k.setPath(this.path);k.setResponseType(\"arraybuffer\");\nif(Array.isArray(a))for(var m=0,l=0,n=a.length;l<n;++l)e(l);else k.load(a,function(a){a=f._parser(a,!0);if(a.isCubemap)for(var c=a.mipmaps.length/a.mipmapCount,d=0;d<c;d++){g[d]={mipmaps:[]};for(var e=0;e<a.mipmapCount;e++)g[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+e]),g[d].format=a.format,g[d].width=a.width,g[d].height=a.height}else h.image.width=a.width,h.image.height=a.height,h.mipmaps=a.mipmaps;1===a.mipmapCount&&(h.minFilter=1006);h.format=a.format;h.needsUpdate=!0;b&&b(h)},c,d);return h},setPath:function(a){this.path=\na;return this}});Object.assign(de.prototype,{load:function(a,b,c,d){var e=this,f=new gb,g=new Ga(this.manager);g.setResponseType(\"arraybuffer\");g.load(a,function(a){if(a=e._parser(a))void 0!==a.image?f.image=a.image:void 0!==a.data&&(f.image.width=a.width,f.image.height=a.height,f.image.data=a.data),f.wrapS=void 0!==a.wrapS?a.wrapS:1001,f.wrapT=void 0!==a.wrapT?a.wrapT:1001,f.magFilter=void 0!==a.magFilter?a.magFilter:1006,f.minFilter=void 0!==a.minFilter?a.minFilter:1008,f.anisotropy=void 0!==a.anisotropy?\na.anisotropy:1,void 0!==a.format&&(f.format=a.format),void 0!==a.type&&(f.type=a.type),void 0!==a.mipmaps&&(f.mipmaps=a.mipmaps),1===a.mipmapCount&&(f.minFilter=1006),f.needsUpdate=!0,b&&b(f,a)},c,d);return f}});Object.assign(Zc.prototype,{crossOrigin:\"anonymous\",load:function(a,b,c,d){function e(){k.removeEventListener(\"load\",e,!1);k.removeEventListener(\"error\",f,!1);Fb.add(a,this);b&&b(this);g.manager.itemEnd(a)}function f(b){k.removeEventListener(\"load\",e,!1);k.removeEventListener(\"error\",f,!1);\nd&&d(b);g.manager.itemEnd(a);g.manager.itemError(a)}void 0===a&&(a=\"\");void 0!==this.path&&(a=this.path+a);a=this.manager.resolveURL(a);var g=this,h=Fb.get(a);if(void 0!==h)return g.manager.itemStart(a),setTimeout(function(){b&&b(h);g.manager.itemEnd(a)},0),h;var k=document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"img\");k.addEventListener(\"load\",e,!1);k.addEventListener(\"error\",f,!1);\"data:\"!==a.substr(0,5)&&void 0!==this.crossOrigin&&(k.crossOrigin=this.crossOrigin);g.manager.itemStart(a);\nk.src=a;return k},setCrossOrigin:function(a){this.crossOrigin=a;return this},setPath:function(a){this.path=a;return this}});Object.assign(ee.prototype,{crossOrigin:\"anonymous\",load:function(a,b,c,d){function e(c){g.load(a[c],function(a){f.images[c]=a;h++;6===h&&(f.needsUpdate=!0,b&&b(f))},void 0,d)}var f=new Ua,g=new Zc(this.manager);g.setCrossOrigin(this.crossOrigin);g.setPath(this.path);var h=0;for(c=0;c<a.length;++c)e(c);return f},setCrossOrigin:function(a){this.crossOrigin=a;return this},setPath:function(a){this.path=\na;return this}});Object.assign(vd.prototype,{crossOrigin:\"anonymous\",load:function(a,b,c,d){var e=new T,f=new Zc(this.manager);f.setCrossOrigin(this.crossOrigin);f.setPath(this.path);f.load(a,function(c){e.image=c;c=0<a.search(/\\.(jpg|jpeg)$/)||0===a.search(/^data:image\\/jpeg/);e.format=c?1022:1023;e.needsUpdate=!0;void 0!==b&&b(e)},c,d);return e},setCrossOrigin:function(a){this.crossOrigin=a;return this},setPath:function(a){this.path=a;return this}});Object.assign(L.prototype,{getPoint:function(){console.warn(\"THREE.Curve: .getPoint() not implemented.\");\nreturn null},getPointAt:function(a,b){a=this.getUtoTmapping(a);return this.getPoint(a,b)},getPoints:function(a){void 0===a&&(a=5);for(var b=[],c=0;c<=a;c++)b.push(this.getPoint(c/a));return b},getSpacedPoints:function(a){void 0===a&&(a=5);for(var b=[],c=0;c<=a;c++)b.push(this.getPointAt(c/a));return b},getLength:function(){var a=this.getLengths();return a[a.length-1]},getLengths:function(a){void 0===a&&(a=this.arcLengthDivisions);if(this.cacheArcLengths&&this.cacheArcLengths.length===a+1&&!this.needsUpdate)return this.cacheArcLengths;\nthis.needsUpdate=!1;var b=[],c=this.getPoint(0),d,e=0;b.push(0);for(d=1;d<=a;d++){var f=this.getPoint(d/a);e+=f.distanceTo(c);b.push(e);c=f}return this.cacheArcLengths=b},updateArcLengths:function(){this.needsUpdate=!0;this.getLengths()},getUtoTmapping:function(a,b){var c=this.getLengths(),d=c.length;b=b?b:a*c[d-1];for(var e=0,f=d-1,g;e<=f;)if(a=Math.floor(e+(f-e)/2),g=c[a]-b,0>g)e=a+1;else if(0<g)f=a-1;else{f=a;break}a=f;if(c[a]===b)return a/(d-1);e=c[a];return(a+(b-e)/(c[a+1]-e))/(d-1)},getTangent:function(a){var b=\na-1E-4;a+=1E-4;0>b&&(b=0);1<a&&(a=1);b=this.getPoint(b);return this.getPoint(a).clone().sub(b).normalize()},getTangentAt:function(a){a=this.getUtoTmapping(a);return this.getTangent(a)},computeFrenetFrames:function(a,b){var c=new p,d=[],e=[],f=[],g=new p,h=new I,k;for(k=0;k<=a;k++){var m=k/a;d[k]=this.getTangentAt(m);d[k].normalize()}e[0]=new p;f[0]=new p;k=Number.MAX_VALUE;m=Math.abs(d[0].x);var l=Math.abs(d[0].y),n=Math.abs(d[0].z);m<=k&&(k=m,c.set(1,0,0));l<=k&&(k=l,c.set(0,1,0));n<=k&&c.set(0,\n0,1);g.crossVectors(d[0],c).normalize();e[0].crossVectors(d[0],g);f[0].crossVectors(d[0],e[0]);for(k=1;k<=a;k++)e[k]=e[k-1].clone(),f[k]=f[k-1].clone(),g.crossVectors(d[k-1],d[k]),g.length()>Number.EPSILON&&(g.normalize(),c=Math.acos(H.clamp(d[k-1].dot(d[k]),-1,1)),e[k].applyMatrix4(h.makeRotationAxis(g,c))),f[k].crossVectors(d[k],e[k]);if(!0===b)for(c=Math.acos(H.clamp(e[0].dot(e[a]),-1,1)),c/=a,0<d[0].dot(g.crossVectors(e[0],e[a]))&&(c=-c),k=1;k<=a;k++)e[k].applyMatrix4(h.makeRotationAxis(d[k],\nc*k)),f[k].crossVectors(d[k],e[k]);return{tangents:d,normals:e,binormals:f}},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.arcLengthDivisions=a.arcLengthDivisions;return this},toJSON:function(){var a={metadata:{version:4.5,type:\"Curve\",generator:\"Curve.toJSON\"}};a.arcLengthDivisions=this.arcLengthDivisions;a.type=this.type;return a},fromJSON:function(a){this.arcLengthDivisions=a.arcLengthDivisions;return this}});za.prototype=Object.create(L.prototype);za.prototype.constructor=\nza;za.prototype.isEllipseCurve=!0;za.prototype.getPoint=function(a,b){b=b||new z;for(var c=2*Math.PI,d=this.aEndAngle-this.aStartAngle,e=Math.abs(d)<Number.EPSILON;0>d;)d+=c;for(;d>c;)d-=c;d<Number.EPSILON&&(d=e?0:c);!0!==this.aClockwise||e||(d=d===c?-c:d-c);c=this.aStartAngle+a*d;a=this.aX+this.xRadius*Math.cos(c);var f=this.aY+this.yRadius*Math.sin(c);0!==this.aRotation&&(c=Math.cos(this.aRotation),d=Math.sin(this.aRotation),e=a-this.aX,f-=this.aY,a=e*c-f*d+this.aX,f=e*d+f*c+this.aY);return b.set(a,\nf)};za.prototype.copy=function(a){L.prototype.copy.call(this,a);this.aX=a.aX;this.aY=a.aY;this.xRadius=a.xRadius;this.yRadius=a.yRadius;this.aStartAngle=a.aStartAngle;this.aEndAngle=a.aEndAngle;this.aClockwise=a.aClockwise;this.aRotation=a.aRotation;return this};za.prototype.toJSON=function(){var a=L.prototype.toJSON.call(this);a.aX=this.aX;a.aY=this.aY;a.xRadius=this.xRadius;a.yRadius=this.yRadius;a.aStartAngle=this.aStartAngle;a.aEndAngle=this.aEndAngle;a.aClockwise=this.aClockwise;a.aRotation=\nthis.aRotation;return a};za.prototype.fromJSON=function(a){L.prototype.fromJSON.call(this,a);this.aX=a.aX;this.aY=a.aY;this.xRadius=a.xRadius;this.yRadius=a.yRadius;this.aStartAngle=a.aStartAngle;this.aEndAngle=a.aEndAngle;this.aClockwise=a.aClockwise;this.aRotation=a.aRotation;return this};dc.prototype=Object.create(za.prototype);dc.prototype.constructor=dc;dc.prototype.isArcCurve=!0;var Od=new p,Ae=new fe,Be=new fe,Ce=new fe;ca.prototype=Object.create(L.prototype);ca.prototype.constructor=ca;ca.prototype.isCatmullRomCurve3=\n!0;ca.prototype.getPoint=function(a,b){b=b||new p;var c=this.points,d=c.length;a*=d-(this.closed?0:1);var e=Math.floor(a);a-=e;this.closed?e+=0<e?0:(Math.floor(Math.abs(e)/d)+1)*d:0===a&&e===d-1&&(e=d-2,a=1);if(this.closed||0<e)var f=c[(e-1)%d];else Od.subVectors(c[0],c[1]).add(c[0]),f=Od;var g=c[e%d];var h=c[(e+1)%d];this.closed||e+2<d?c=c[(e+2)%d]:(Od.subVectors(c[d-1],c[d-2]).add(c[d-1]),c=Od);if(\"centripetal\"===this.curveType||\"chordal\"===this.curveType){var k=\"chordal\"===this.curveType?.5:.25;\nd=Math.pow(f.distanceToSquared(g),k);e=Math.pow(g.distanceToSquared(h),k);k=Math.pow(h.distanceToSquared(c),k);1E-4>e&&(e=1);1E-4>d&&(d=e);1E-4>k&&(k=e);Ae.initNonuniformCatmullRom(f.x,g.x,h.x,c.x,d,e,k);Be.initNonuniformCatmullRom(f.y,g.y,h.y,c.y,d,e,k);Ce.initNonuniformCatmullRom(f.z,g.z,h.z,c.z,d,e,k)}else\"catmullrom\"===this.curveType&&(Ae.initCatmullRom(f.x,g.x,h.x,c.x,this.tension),Be.initCatmullRom(f.y,g.y,h.y,c.y,this.tension),Ce.initCatmullRom(f.z,g.z,h.z,c.z,this.tension));b.set(Ae.calc(a),\nBe.calc(a),Ce.calc(a));return b};ca.prototype.copy=function(a){L.prototype.copy.call(this,a);this.points=[];for(var b=0,c=a.points.length;b<c;b++)this.points.push(a.points[b].clone());this.closed=a.closed;this.curveType=a.curveType;this.tension=a.tension;return this};ca.prototype.toJSON=function(){var a=L.prototype.toJSON.call(this);a.points=[];for(var b=0,c=this.points.length;b<c;b++)a.points.push(this.points[b].toArray());a.closed=this.closed;a.curveType=this.curveType;a.tension=this.tension;return a};\nca.prototype.fromJSON=function(a){L.prototype.fromJSON.call(this,a);this.points=[];for(var b=0,c=a.points.length;b<c;b++){var d=a.points[b];this.points.push((new p).fromArray(d))}this.closed=a.closed;this.curveType=a.curveType;this.tension=a.tension;return this};Ha.prototype=Object.create(L.prototype);Ha.prototype.constructor=Ha;Ha.prototype.isCubicBezierCurve=!0;Ha.prototype.getPoint=function(a,b){b=b||new z;var c=this.v0,d=this.v1,e=this.v2,f=this.v3;b.set(ad(a,c.x,d.x,e.x,f.x),ad(a,c.y,d.y,e.y,\nf.y));return b};Ha.prototype.copy=function(a){L.prototype.copy.call(this,a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);this.v3.copy(a.v3);return this};Ha.prototype.toJSON=function(){var a=L.prototype.toJSON.call(this);a.v0=this.v0.toArray();a.v1=this.v1.toArray();a.v2=this.v2.toArray();a.v3=this.v3.toArray();return a};Ha.prototype.fromJSON=function(a){L.prototype.fromJSON.call(this,a);this.v0.fromArray(a.v0);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);this.v3.fromArray(a.v3);return this};\nQa.prototype=Object.create(L.prototype);Qa.prototype.constructor=Qa;Qa.prototype.isCubicBezierCurve3=!0;Qa.prototype.getPoint=function(a,b){b=b||new p;var c=this.v0,d=this.v1,e=this.v2,f=this.v3;b.set(ad(a,c.x,d.x,e.x,f.x),ad(a,c.y,d.y,e.y,f.y),ad(a,c.z,d.z,e.z,f.z));return b};Qa.prototype.copy=function(a){L.prototype.copy.call(this,a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);this.v3.copy(a.v3);return this};Qa.prototype.toJSON=function(){var a=L.prototype.toJSON.call(this);a.v0=this.v0.toArray();\na.v1=this.v1.toArray();a.v2=this.v2.toArray();a.v3=this.v3.toArray();return a};Qa.prototype.fromJSON=function(a){L.prototype.fromJSON.call(this,a);this.v0.fromArray(a.v0);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);this.v3.fromArray(a.v3);return this};va.prototype=Object.create(L.prototype);va.prototype.constructor=va;va.prototype.isLineCurve=!0;va.prototype.getPoint=function(a,b){b=b||new z;1===a?b.copy(this.v2):(b.copy(this.v2).sub(this.v1),b.multiplyScalar(a).add(this.v1));return b};va.prototype.getPointAt=\nfunction(a,b){return this.getPoint(a,b)};va.prototype.getTangent=function(){return this.v2.clone().sub(this.v1).normalize()};va.prototype.copy=function(a){L.prototype.copy.call(this,a);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};va.prototype.toJSON=function(){var a=L.prototype.toJSON.call(this);a.v1=this.v1.toArray();a.v2=this.v2.toArray();return a};va.prototype.fromJSON=function(a){L.prototype.fromJSON.call(this,a);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);return this};Ia.prototype=\nObject.create(L.prototype);Ia.prototype.constructor=Ia;Ia.prototype.isLineCurve3=!0;Ia.prototype.getPoint=function(a,b){b=b||new p;1===a?b.copy(this.v2):(b.copy(this.v2).sub(this.v1),b.multiplyScalar(a).add(this.v1));return b};Ia.prototype.getPointAt=function(a,b){return this.getPoint(a,b)};Ia.prototype.copy=function(a){L.prototype.copy.call(this,a);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};Ia.prototype.toJSON=function(){var a=L.prototype.toJSON.call(this);a.v1=this.v1.toArray();a.v2=this.v2.toArray();\nreturn a};Ia.prototype.fromJSON=function(a){L.prototype.fromJSON.call(this,a);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);return this};Ja.prototype=Object.create(L.prototype);Ja.prototype.constructor=Ja;Ja.prototype.isQuadraticBezierCurve=!0;Ja.prototype.getPoint=function(a,b){b=b||new z;var c=this.v0,d=this.v1,e=this.v2;b.set($c(a,c.x,d.x,e.x),$c(a,c.y,d.y,e.y));return b};Ja.prototype.copy=function(a){L.prototype.copy.call(this,a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};\nJa.prototype.toJSON=function(){var a=L.prototype.toJSON.call(this);a.v0=this.v0.toArray();a.v1=this.v1.toArray();a.v2=this.v2.toArray();return a};Ja.prototype.fromJSON=function(a){L.prototype.fromJSON.call(this,a);this.v0.fromArray(a.v0);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);return this};Ra.prototype=Object.create(L.prototype);Ra.prototype.constructor=Ra;Ra.prototype.isQuadraticBezierCurve3=!0;Ra.prototype.getPoint=function(a,b){b=b||new p;var c=this.v0,d=this.v1,e=this.v2;b.set($c(a,c.x,\nd.x,e.x),$c(a,c.y,d.y,e.y),$c(a,c.z,d.z,e.z));return b};Ra.prototype.copy=function(a){L.prototype.copy.call(this,a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};Ra.prototype.toJSON=function(){var a=L.prototype.toJSON.call(this);a.v0=this.v0.toArray();a.v1=this.v1.toArray();a.v2=this.v2.toArray();return a};Ra.prototype.fromJSON=function(a){L.prototype.fromJSON.call(this,a);this.v0.fromArray(a.v0);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);return this};Ka.prototype=Object.create(L.prototype);\nKa.prototype.constructor=Ka;Ka.prototype.isSplineCurve=!0;Ka.prototype.getPoint=function(a,b){b=b||new z;var c=this.points,d=(c.length-1)*a;a=Math.floor(d);d-=a;var e=c[0===a?a:a-1],f=c[a],g=c[a>c.length-2?c.length-1:a+1];c=c[a>c.length-3?c.length-1:a+2];b.set(lf(d,e.x,f.x,g.x,c.x),lf(d,e.y,f.y,g.y,c.y));return b};Ka.prototype.copy=function(a){L.prototype.copy.call(this,a);this.points=[];for(var b=0,c=a.points.length;b<c;b++)this.points.push(a.points[b].clone());return this};Ka.prototype.toJSON=function(){var a=\nL.prototype.toJSON.call(this);a.points=[];for(var b=0,c=this.points.length;b<c;b++)a.points.push(this.points[b].toArray());return a};Ka.prototype.fromJSON=function(a){L.prototype.fromJSON.call(this,a);this.points=[];for(var b=0,c=a.points.length;b<c;b++){var d=a.points[b];this.points.push((new z).fromArray(d))}return this};var Af=Object.freeze({ArcCurve:dc,CatmullRomCurve3:ca,CubicBezierCurve:Ha,CubicBezierCurve3:Qa,EllipseCurve:za,LineCurve:va,LineCurve3:Ia,QuadraticBezierCurve:Ja,QuadraticBezierCurve3:Ra,\nSplineCurve:Ka});Xa.prototype=Object.assign(Object.create(L.prototype),{constructor:Xa,add:function(a){this.curves.push(a)},closePath:function(){var a=this.curves[0].getPoint(0),b=this.curves[this.curves.length-1].getPoint(1);a.equals(b)||this.curves.push(new va(b,a))},getPoint:function(a){var b=a*this.getLength(),c=this.getCurveLengths();for(a=0;a<c.length;){if(c[a]>=b)return b=c[a]-b,a=this.curves[a],c=a.getLength(),a.getPointAt(0===c?0:1-b/c);a++}return null},getLength:function(){var a=this.getCurveLengths();\nreturn a[a.length-1]},updateArcLengths:function(){this.needsUpdate=!0;this.cacheLengths=null;this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;for(var a=[],b=0,c=0,d=this.curves.length;c<d;c++)b+=this.curves[c].getLength(),a.push(b);return this.cacheLengths=a},getSpacedPoints:function(a){void 0===a&&(a=40);for(var b=[],c=0;c<=a;c++)b.push(this.getPoint(c/a));this.autoClose&&b.push(b[0]);return b},getPoints:function(a){a=\na||12;for(var b=[],c,d=0,e=this.curves;d<e.length;d++){var f=e[d];f=f.getPoints(f&&f.isEllipseCurve?2*a:f&&(f.isLineCurve||f.isLineCurve3)?1:f&&f.isSplineCurve?a*f.points.length:a);for(var g=0;g<f.length;g++){var h=f[g];c&&c.equals(h)||(b.push(h),c=h)}}this.autoClose&&1<b.length&&!b[b.length-1].equals(b[0])&&b.push(b[0]);return b},copy:function(a){L.prototype.copy.call(this,a);this.curves=[];for(var b=0,c=a.curves.length;b<c;b++)this.curves.push(a.curves[b].clone());this.autoClose=a.autoClose;return this},\ntoJSON:function(){var a=L.prototype.toJSON.call(this);a.autoClose=this.autoClose;a.curves=[];for(var b=0,c=this.curves.length;b<c;b++)a.curves.push(this.curves[b].toJSON());return a},fromJSON:function(a){L.prototype.fromJSON.call(this,a);this.autoClose=a.autoClose;this.curves=[];for(var b=0,c=a.curves.length;b<c;b++){var d=a.curves[b];this.curves.push((new Af[d.type]).fromJSON(d))}return this}});La.prototype=Object.assign(Object.create(Xa.prototype),{constructor:La,setFromPoints:function(a){this.moveTo(a[0].x,\na[0].y);for(var b=1,c=a.length;b<c;b++)this.lineTo(a[b].x,a[b].y)},moveTo:function(a,b){this.currentPoint.set(a,b)},lineTo:function(a,b){var c=new va(this.currentPoint.clone(),new z(a,b));this.curves.push(c);this.currentPoint.set(a,b)},quadraticCurveTo:function(a,b,c,d){a=new Ja(this.currentPoint.clone(),new z(a,b),new z(c,d));this.curves.push(a);this.currentPoint.set(c,d)},bezierCurveTo:function(a,b,c,d,e,f){a=new Ha(this.currentPoint.clone(),new z(a,b),new z(c,d),new z(e,f));this.curves.push(a);\nthis.currentPoint.set(e,f)},splineThru:function(a){var b=[this.currentPoint.clone()].concat(a);b=new Ka(b);this.curves.push(b);this.currentPoint.copy(a[a.length-1])},arc:function(a,b,c,d,e,f){this.absarc(a+this.currentPoint.x,b+this.currentPoint.y,c,d,e,f)},absarc:function(a,b,c,d,e,f){this.absellipse(a,b,c,c,d,e,f)},ellipse:function(a,b,c,d,e,f,g,h){this.absellipse(a+this.currentPoint.x,b+this.currentPoint.y,c,d,e,f,g,h)},absellipse:function(a,b,c,d,e,f,g,h){a=new za(a,b,c,d,e,f,g,h);0<this.curves.length&&\n(b=a.getPoint(0),b.equals(this.currentPoint)||this.lineTo(b.x,b.y));this.curves.push(a);a=a.getPoint(1);this.currentPoint.copy(a)},copy:function(a){Xa.prototype.copy.call(this,a);this.currentPoint.copy(a.currentPoint);return this},toJSON:function(){var a=Xa.prototype.toJSON.call(this);a.currentPoint=this.currentPoint.toArray();return a},fromJSON:function(a){Xa.prototype.fromJSON.call(this,a);this.currentPoint.fromArray(a.currentPoint);return this}});db.prototype=Object.assign(Object.create(La.prototype),\n{constructor:db,getPointsHoles:function(a){for(var b=[],c=0,d=this.holes.length;c<d;c++)b[c]=this.holes[c].getPoints(a);return b},extractPoints:function(a){return{shape:this.getPoints(a),holes:this.getPointsHoles(a)}},copy:function(a){La.prototype.copy.call(this,a);this.holes=[];for(var b=0,c=a.holes.length;b<c;b++)this.holes.push(a.holes[b].clone());return this},toJSON:function(){var a=La.prototype.toJSON.call(this);a.uuid=this.uuid;a.holes=[];for(var b=0,c=this.holes.length;b<c;b++)a.holes.push(this.holes[b].toJSON());\nreturn a},fromJSON:function(a){La.prototype.fromJSON.call(this,a);this.uuid=a.uuid;this.holes=[];for(var b=0,c=a.holes.length;b<c;b++){var d=a.holes[b];this.holes.push((new La).fromJSON(d))}return this}});X.prototype=Object.assign(Object.create(D.prototype),{constructor:X,isLight:!0,copy:function(a){D.prototype.copy.call(this,a);this.color.copy(a.color);this.intensity=a.intensity;return this},toJSON:function(a){a=D.prototype.toJSON.call(this,a);a.object.color=this.color.getHex();a.object.intensity=\nthis.intensity;void 0!==this.groundColor&&(a.object.groundColor=this.groundColor.getHex());void 0!==this.distance&&(a.object.distance=this.distance);void 0!==this.angle&&(a.object.angle=this.angle);void 0!==this.decay&&(a.object.decay=this.decay);void 0!==this.penumbra&&(a.object.penumbra=this.penumbra);void 0!==this.shadow&&(a.object.shadow=this.shadow.toJSON());return a}});wd.prototype=Object.assign(Object.create(X.prototype),{constructor:wd,isHemisphereLight:!0,copy:function(a){X.prototype.copy.call(this,\na);this.groundColor.copy(a.groundColor);return this}});Object.assign(Cb.prototype,{copy:function(a){this.camera=a.camera.clone();this.bias=a.bias;this.radius=a.radius;this.mapSize.copy(a.mapSize);return this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){var a={};0!==this.bias&&(a.bias=this.bias);1!==this.radius&&(a.radius=this.radius);if(512!==this.mapSize.x||512!==this.mapSize.y)a.mapSize=this.mapSize.toArray();a.camera=this.camera.toJSON(!1).object;delete a.camera.matrix;\nreturn a}});xd.prototype=Object.assign(Object.create(Cb.prototype),{constructor:xd,isSpotLightShadow:!0,update:function(a){var b=this.camera,c=2*H.RAD2DEG*a.angle,d=this.mapSize.width/this.mapSize.height;a=a.distance||b.far;if(c!==b.fov||d!==b.aspect||a!==b.far)b.fov=c,b.aspect=d,b.far=a,b.updateProjectionMatrix()}});yd.prototype=Object.assign(Object.create(X.prototype),{constructor:yd,isSpotLight:!0,copy:function(a){X.prototype.copy.call(this,a);this.distance=a.distance;this.angle=a.angle;this.penumbra=\na.penumbra;this.decay=a.decay;this.target=a.target.clone();this.shadow=a.shadow.clone();return this}});zd.prototype=Object.assign(Object.create(X.prototype),{constructor:zd,isPointLight:!0,copy:function(a){X.prototype.copy.call(this,a);this.distance=a.distance;this.decay=a.decay;this.shadow=a.shadow.clone();return this}});Ad.prototype=Object.assign(Object.create(Cb.prototype),{constructor:Ad});Bd.prototype=Object.assign(Object.create(X.prototype),{constructor:Bd,isDirectionalLight:!0,copy:function(a){X.prototype.copy.call(this,\na);this.target=a.target.clone();this.shadow=a.shadow.clone();return this}});Cd.prototype=Object.assign(Object.create(X.prototype),{constructor:Cd,isAmbientLight:!0});Dd.prototype=Object.assign(Object.create(X.prototype),{constructor:Dd,isRectAreaLight:!0,copy:function(a){X.prototype.copy.call(this,a);this.width=a.width;this.height=a.height;return this},toJSON:function(a){a=X.prototype.toJSON.call(this,a);a.object.width=this.width;a.object.height=this.height;return a}});var ia={arraySlice:function(a,\nb,c){return ia.isTypedArray(a)?new a.constructor(a.subarray(b,void 0!==c?c:a.length)):a.slice(b,c)},convertArray:function(a,b,c){return!a||!c&&a.constructor===b?a:\"number\"===typeof b.BYTES_PER_ELEMENT?new b(a):Array.prototype.slice.call(a)},isTypedArray:function(a){return ArrayBuffer.isView(a)&&!(a instanceof DataView)},getKeyframeOrder:function(a){for(var b=a.length,c=Array(b),d=0;d!==b;++d)c[d]=d;c.sort(function(b,c){return a[b]-a[c]});return c},sortedArray:function(a,b,c){for(var d=a.length,e=\nnew a.constructor(d),f=0,g=0;g!==d;++f)for(var h=c[f]*b,k=0;k!==b;++k)e[g++]=a[h+k];return e},flattenJSON:function(a,b,c,d){for(var e=1,f=a[0];void 0!==f&&void 0===f[d];)f=a[e++];if(void 0!==f){var g=f[d];if(void 0!==g)if(Array.isArray(g)){do g=f[d],void 0!==g&&(b.push(f.time),c.push.apply(c,g)),f=a[e++];while(void 0!==f)}else if(void 0!==g.toArray){do g=f[d],void 0!==g&&(b.push(f.time),g.toArray(c,c.length)),f=a[e++];while(void 0!==f)}else{do g=f[d],void 0!==g&&(b.push(f.time),c.push(g)),f=a[e++];\nwhile(void 0!==f)}}}};Object.assign(wa.prototype,{evaluate:function(a){var b=this.parameterPositions,c=this._cachedIndex,d=b[c],e=b[c-1];a:{b:{c:{d:if(!(a<d)){for(var f=c+2;;){if(void 0===d){if(a<e)break d;this._cachedIndex=c=b.length;return this.afterEnd_(c-1,a,e)}if(c===f)break;e=d;d=b[++c];if(a<d)break b}d=b.length;break c}if(a>=e)break a;else{f=b[1];a<f&&(c=2,e=f);for(f=c-2;;){if(void 0===e)return this._cachedIndex=0,this.beforeStart_(0,a,d);if(c===f)break;d=e;e=b[--c-1];if(a>=e)break b}d=c;c=\n0}}for(;c<d;)e=c+d>>>1,a<b[e]?d=e:c=e+1;d=b[c];e=b[c-1];if(void 0===e)return this._cachedIndex=0,this.beforeStart_(0,a,d);if(void 0===d)return this._cachedIndex=c=b.length,this.afterEnd_(c-1,e,a)}this._cachedIndex=c;this.intervalChanged_(c,e,d)}return this.interpolate_(c,e,a,d)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(a){var b=this.resultBuffer,c=this.sampleValues,d=this.valueSize;a*=d;for(var e=0;e!==d;++e)b[e]=\nc[a+e];return b},interpolate_:function(){throw Error(\"call to abstract method\");},intervalChanged_:function(){}});Object.assign(wa.prototype,{beforeStart_:wa.prototype.copySampleValue_,afterEnd_:wa.prototype.copySampleValue_});Ed.prototype=Object.assign(Object.create(wa.prototype),{constructor:Ed,DefaultSettings_:{endingStart:2400,endingEnd:2400},intervalChanged_:function(a,b,c){var d=this.parameterPositions,e=a-2,f=a+1,g=d[e],h=d[f];if(void 0===g)switch(this.getSettings_().endingStart){case 2401:e=\na;g=2*b-c;break;case 2402:e=d.length-2;g=b+d[e]-d[e+1];break;default:e=a,g=c}if(void 0===h)switch(this.getSettings_().endingEnd){case 2401:f=a;h=2*c-b;break;case 2402:f=1;h=c+d[1]-d[0];break;default:f=a-1,h=b}a=.5*(c-b);d=this.valueSize;this._weightPrev=a/(b-g);this._weightNext=a/(h-c);this._offsetPrev=e*d;this._offsetNext=f*d},interpolate_:function(a,b,c,d){var e=this.resultBuffer,f=this.sampleValues,g=this.valueSize;a*=g;var h=a-g,k=this._offsetPrev,m=this._offsetNext,l=this._weightPrev,n=this._weightNext,\np=(c-b)/(d-b);c=p*p;d=c*p;b=-l*d+2*l*c-l*p;l=(1+l)*d+(-1.5-2*l)*c+(-.5+l)*p+1;p=(-1-n)*d+(1.5+n)*c+.5*p;n=n*d-n*c;for(c=0;c!==g;++c)e[c]=b*f[k+c]+l*f[h+c]+p*f[a+c]+n*f[m+c];return e}});bd.prototype=Object.assign(Object.create(wa.prototype),{constructor:bd,interpolate_:function(a,b,c,d){var e=this.resultBuffer,f=this.sampleValues,g=this.valueSize;a*=g;var h=a-g;b=(c-b)/(d-b);c=1-b;for(d=0;d!==g;++d)e[d]=f[h+d]*c+f[a+d]*b;return e}});Fd.prototype=Object.assign(Object.create(wa.prototype),{constructor:Fd,\ninterpolate_:function(a){return this.copySampleValue_(a-1)}});Object.assign(oa,{toJSON:function(a){var b=a.constructor;if(void 0!==b.toJSON)b=b.toJSON(a);else{b={name:a.name,times:ia.convertArray(a.times,Array),values:ia.convertArray(a.values,Array)};var c=a.getInterpolation();c!==a.DefaultInterpolation&&(b.interpolation=c)}b.type=a.ValueTypeName;return b}});Object.assign(oa.prototype,{constructor:oa,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:2301,InterpolantFactoryMethodDiscrete:function(a){return new Fd(this.times,\nthis.values,this.getValueSize(),a)},InterpolantFactoryMethodLinear:function(a){return new bd(this.times,this.values,this.getValueSize(),a)},InterpolantFactoryMethodSmooth:function(a){return new Ed(this.times,this.values,this.getValueSize(),a)},setInterpolation:function(a){switch(a){case 2300:var b=this.InterpolantFactoryMethodDiscrete;break;case 2301:b=this.InterpolantFactoryMethodLinear;break;case 2302:b=this.InterpolantFactoryMethodSmooth}if(void 0===b){b=\"unsupported interpolation for \"+this.ValueTypeName+\n\" keyframe track named \"+this.name;if(void 0===this.createInterpolant)if(a!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw Error(b);console.warn(\"THREE.KeyframeTrack:\",b);return this}this.createInterpolant=b;return this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}},getValueSize:function(){return this.values.length/\nthis.times.length},shift:function(a){if(0!==a)for(var b=this.times,c=0,d=b.length;c!==d;++c)b[c]+=a;return this},scale:function(a){if(1!==a)for(var b=this.times,c=0,d=b.length;c!==d;++c)b[c]*=a;return this},trim:function(a,b){for(var c=this.times,d=c.length,e=0,f=d-1;e!==d&&c[e]<a;)++e;for(;-1!==f&&c[f]>b;)--f;++f;if(0!==e||f!==d)e>=f&&(f=Math.max(f,1),e=f-1),a=this.getValueSize(),this.times=ia.arraySlice(c,e,f),this.values=ia.arraySlice(this.values,e*a,f*a);return this},validate:function(){var a=\n!0,b=this.getValueSize();0!==b-Math.floor(b)&&(console.error(\"THREE.KeyframeTrack: Invalid value size in track.\",this),a=!1);var c=this.times;b=this.values;var d=c.length;0===d&&(console.error(\"THREE.KeyframeTrack: Track is empty.\",this),a=!1);for(var e=null,f=0;f!==d;f++){var g=c[f];if(\"number\"===typeof g&&isNaN(g)){console.error(\"THREE.KeyframeTrack: Time is not a valid number.\",this,f,g);a=!1;break}if(null!==e&&e>g){console.error(\"THREE.KeyframeTrack: Out of order keys.\",this,f,g,e);a=!1;break}e=\ng}if(void 0!==b&&ia.isTypedArray(b))for(f=0,c=b.length;f!==c;++f)if(d=b[f],isNaN(d)){console.error(\"THREE.KeyframeTrack: Value is not a valid number.\",this,f,d);a=!1;break}return a},optimize:function(){for(var a=this.times,b=this.values,c=this.getValueSize(),d=2302===this.getInterpolation(),e=1,f=a.length-1,g=1;g<f;++g){var h=!1,k=a[g];if(k!==a[g+1]&&(1!==g||k!==k[0]))if(d)h=!0;else{var m=g*c,l=m-c,n=m+c;for(k=0;k!==c;++k){var p=b[m+k];if(p!==b[l+k]||p!==b[n+k]){h=!0;break}}}if(h){if(g!==e)for(a[e]=\na[g],h=g*c,m=e*c,k=0;k!==c;++k)b[m+k]=b[h+k];++e}}if(0<f){a[e]=a[f];h=f*c;m=e*c;for(k=0;k!==c;++k)b[m+k]=b[h+k];++e}e!==a.length&&(this.times=ia.arraySlice(a,0,e),this.values=ia.arraySlice(b,0,e*c));return this}});Gd.prototype=Object.assign(Object.create(oa.prototype),{constructor:Gd,ValueTypeName:\"bool\",ValueBufferType:Array,DefaultInterpolation:2300,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});Hd.prototype=Object.assign(Object.create(oa.prototype),{constructor:Hd,\nValueTypeName:\"color\"});ec.prototype=Object.assign(Object.create(oa.prototype),{constructor:ec,ValueTypeName:\"number\"});Id.prototype=Object.assign(Object.create(wa.prototype),{constructor:Id,interpolate_:function(a,b,c,d){var e=this.resultBuffer,f=this.sampleValues,g=this.valueSize;a*=g;b=(c-b)/(d-b);for(c=a+g;a!==c;a+=4)fa.slerpFlat(e,0,f,a-g,f,a,b);return e}});cd.prototype=Object.assign(Object.create(oa.prototype),{constructor:cd,ValueTypeName:\"quaternion\",DefaultInterpolation:2301,InterpolantFactoryMethodLinear:function(a){return new Id(this.times,\nthis.values,this.getValueSize(),a)},InterpolantFactoryMethodSmooth:void 0});Jd.prototype=Object.assign(Object.create(oa.prototype),{constructor:Jd,ValueTypeName:\"string\",ValueBufferType:Array,DefaultInterpolation:2300,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});fc.prototype=Object.assign(Object.create(oa.prototype),{constructor:fc,ValueTypeName:\"vector\"});Object.assign(Ca,{parse:function(a){for(var b=[],c=a.tracks,d=1/(a.fps||1),e=0,f=c.length;e!==f;++e)b.push(Sg(c[e]).scale(d));\nreturn new Ca(a.name,a.duration,b)},toJSON:function(a){var b=[],c=a.tracks;a={name:a.name,duration:a.duration,tracks:b,uuid:a.uuid};for(var d=0,e=c.length;d!==e;++d)b.push(oa.toJSON(c[d]));return a},CreateFromMorphTargetSequence:function(a,b,c,d){for(var e=b.length,f=[],g=0;g<e;g++){var h=[],k=[];h.push((g+e-1)%e,g,(g+1)%e);k.push(0,1,0);var m=ia.getKeyframeOrder(h);h=ia.sortedArray(h,1,m);k=ia.sortedArray(k,1,m);d||0!==h[0]||(h.push(e),k.push(k[0]));f.push((new ec(\".morphTargetInfluences[\"+b[g].name+\n\"]\",h,k)).scale(1/c))}return new Ca(a,-1,f)},findByName:function(a,b){var c=a;Array.isArray(a)||(c=a.geometry&&a.geometry.animations||a.animations);for(a=0;a<c.length;a++)if(c[a].name===b)return c[a];return null},CreateClipsFromMorphTargetSequences:function(a,b,c){for(var d={},e=/^([\\w-]*?)([\\d]+)$/,f=0,g=a.length;f<g;f++){var h=a[f],k=h.name.match(e);if(k&&1<k.length){var m=k[1];(k=d[m])||(d[m]=k=[]);k.push(h)}}a=[];for(m in d)a.push(Ca.CreateFromMorphTargetSequence(m,d[m],b,c));return a},parseAnimation:function(a,\nb){if(!a)return console.error(\"THREE.AnimationClip: No animation in JSONLoader data.\"),null;var c=function(a,b,c,d,e){if(0!==c.length){var f=[],g=[];ia.flattenJSON(c,f,g,d);0!==f.length&&e.push(new a(b,f,g))}},d=[],e=a.name||\"default\",f=a.length||-1,g=a.fps||30;a=a.hierarchy||[];for(var h=0;h<a.length;h++){var k=a[h].keys;if(k&&0!==k.length)if(k[0].morphTargets){f={};for(var m=0;m<k.length;m++)if(k[m].morphTargets)for(var l=0;l<k[m].morphTargets.length;l++)f[k[m].morphTargets[l]]=-1;for(var n in f){var p=\n[],u=[];for(l=0;l!==k[m].morphTargets.length;++l){var r=k[m];p.push(r.time);u.push(r.morphTarget===n?1:0)}d.push(new ec(\".morphTargetInfluence[\"+n+\"]\",p,u))}f=f.length*(g||1)}else m=\".bones[\"+b[h].name+\"]\",c(fc,m+\".position\",k,\"pos\",d),c(cd,m+\".quaternion\",k,\"rot\",d),c(fc,m+\".scale\",k,\"scl\",d)}return 0===d.length?null:new Ca(e,f,d)}});Object.assign(Ca.prototype,{resetDuration:function(){for(var a=0,b=0,c=this.tracks.length;b!==c;++b){var d=this.tracks[b];a=Math.max(a,d.times[d.times.length-1])}this.duration=\na;return this},trim:function(){for(var a=0;a<this.tracks.length;a++)this.tracks[a].trim(0,this.duration);return this},validate:function(){for(var a=!0,b=0;b<this.tracks.length;b++)a=a&&this.tracks[b].validate();return a},optimize:function(){for(var a=0;a<this.tracks.length;a++)this.tracks[a].optimize();return this}});Object.assign(Kd.prototype,{load:function(a,b,c,d){var e=this;(new Ga(e.manager)).load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},setTextures:function(a){this.textures=a},parse:function(a){function b(a){void 0===\nc[a]&&console.warn(\"THREE.MaterialLoader: Undefined texture\",a);return c[a]}var c=this.textures,d=new Vg[a.type];void 0!==a.uuid&&(d.uuid=a.uuid);void 0!==a.name&&(d.name=a.name);void 0!==a.color&&d.color.setHex(a.color);void 0!==a.roughness&&(d.roughness=a.roughness);void 0!==a.metalness&&(d.metalness=a.metalness);void 0!==a.emissive&&d.emissive.setHex(a.emissive);void 0!==a.specular&&d.specular.setHex(a.specular);void 0!==a.shininess&&(d.shininess=a.shininess);void 0!==a.clearCoat&&(d.clearCoat=\na.clearCoat);void 0!==a.clearCoatRoughness&&(d.clearCoatRoughness=a.clearCoatRoughness);void 0!==a.uniforms&&(d.uniforms=a.uniforms);void 0!==a.vertexShader&&(d.vertexShader=a.vertexShader);void 0!==a.fragmentShader&&(d.fragmentShader=a.fragmentShader);void 0!==a.vertexColors&&(d.vertexColors=a.vertexColors);void 0!==a.fog&&(d.fog=a.fog);void 0!==a.flatShading&&(d.flatShading=a.flatShading);void 0!==a.blending&&(d.blending=a.blending);void 0!==a.side&&(d.side=a.side);void 0!==a.opacity&&(d.opacity=\na.opacity);void 0!==a.transparent&&(d.transparent=a.transparent);void 0!==a.alphaTest&&(d.alphaTest=a.alphaTest);void 0!==a.depthTest&&(d.depthTest=a.depthTest);void 0!==a.depthWrite&&(d.depthWrite=a.depthWrite);void 0!==a.colorWrite&&(d.colorWrite=a.colorWrite);void 0!==a.wireframe&&(d.wireframe=a.wireframe);void 0!==a.wireframeLinewidth&&(d.wireframeLinewidth=a.wireframeLinewidth);void 0!==a.wireframeLinecap&&(d.wireframeLinecap=a.wireframeLinecap);void 0!==a.wireframeLinejoin&&(d.wireframeLinejoin=\na.wireframeLinejoin);void 0!==a.rotation&&(d.rotation=a.rotation);1!==a.linewidth&&(d.linewidth=a.linewidth);void 0!==a.dashSize&&(d.dashSize=a.dashSize);void 0!==a.gapSize&&(d.gapSize=a.gapSize);void 0!==a.scale&&(d.scale=a.scale);void 0!==a.polygonOffset&&(d.polygonOffset=a.polygonOffset);void 0!==a.polygonOffsetFactor&&(d.polygonOffsetFactor=a.polygonOffsetFactor);void 0!==a.polygonOffsetUnits&&(d.polygonOffsetUnits=a.polygonOffsetUnits);void 0!==a.skinning&&(d.skinning=a.skinning);void 0!==a.morphTargets&&\n(d.morphTargets=a.morphTargets);void 0!==a.dithering&&(d.dithering=a.dithering);void 0!==a.visible&&(d.visible=a.visible);void 0!==a.userData&&(d.userData=a.userData);void 0!==a.shading&&(d.flatShading=1===a.shading);void 0!==a.size&&(d.size=a.size);void 0!==a.sizeAttenuation&&(d.sizeAttenuation=a.sizeAttenuation);void 0!==a.map&&(d.map=b(a.map));void 0!==a.alphaMap&&(d.alphaMap=b(a.alphaMap),d.transparent=!0);void 0!==a.bumpMap&&(d.bumpMap=b(a.bumpMap));void 0!==a.bumpScale&&(d.bumpScale=a.bumpScale);\nvoid 0!==a.normalMap&&(d.normalMap=b(a.normalMap));void 0!==a.normalMapType&&(d.normalMapType=a.normalMapType);if(void 0!==a.normalScale){var e=a.normalScale;!1===Array.isArray(e)&&(e=[e,e]);d.normalScale=(new z).fromArray(e)}void 0!==a.displacementMap&&(d.displacementMap=b(a.displacementMap));void 0!==a.displacementScale&&(d.displacementScale=a.displacementScale);void 0!==a.displacementBias&&(d.displacementBias=a.displacementBias);void 0!==a.roughnessMap&&(d.roughnessMap=b(a.roughnessMap));void 0!==\na.metalnessMap&&(d.metalnessMap=b(a.metalnessMap));void 0!==a.emissiveMap&&(d.emissiveMap=b(a.emissiveMap));void 0!==a.emissiveIntensity&&(d.emissiveIntensity=a.emissiveIntensity);void 0!==a.specularMap&&(d.specularMap=b(a.specularMap));void 0!==a.envMap&&(d.envMap=b(a.envMap));void 0!==a.reflectivity&&(d.reflectivity=a.reflectivity);void 0!==a.lightMap&&(d.lightMap=b(a.lightMap));void 0!==a.lightMapIntensity&&(d.lightMapIntensity=a.lightMapIntensity);void 0!==a.aoMap&&(d.aoMap=b(a.aoMap));void 0!==\na.aoMapIntensity&&(d.aoMapIntensity=a.aoMapIntensity);void 0!==a.gradientMap&&(d.gradientMap=b(a.gradientMap));return d}});Object.assign(ge.prototype,{load:function(a,b,c,d){var e=this;(new Ga(e.manager)).load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},parse:function(a){var b=new C,c=a.data.index;void 0!==c&&(c=new Bf[c.type](c.array),b.setIndex(new Q(c,1)));var d=a.data.attributes;for(f in d){var e=d[f];c=new Bf[e.type](e.array);b.addAttribute(f,new Q(c,e.itemSize,e.normalized))}var f=a.data.groups||\na.data.drawcalls||a.data.offsets;if(void 0!==f)for(c=0,d=f.length;c!==d;++c)e=f[c],b.addGroup(e.start,e.count,e.materialIndex);a=a.data.boundingSphere;void 0!==a&&(f=new p,void 0!==a.center&&f.fromArray(a.center),b.boundingSphere=new Da(f,a.radius));return b}});var Bf={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:\"undefined\"!==typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,\nFloat64Array:Float64Array};gc.Handlers={handlers:[],add:function(a,b){this.handlers.push(a,b)},get:function(a){for(var b=this.handlers,c=0,d=b.length;c<d;c+=2){var e=b[c+1];if(b[c].test(a))return e}return null}};Object.assign(gc.prototype,{crossOrigin:\"anonymous\",onLoadStart:function(){},onLoadProgress:function(){},onLoadComplete:function(){},initMaterials:function(a,b,c){for(var d=[],e=0;e<a.length;++e)d[e]=this.createMaterial(a[e],b,c);return d},createMaterial:function(){var a={NoBlending:0,NormalBlending:1,\nAdditiveBlending:2,SubtractiveBlending:3,MultiplyBlending:4,CustomBlending:5},b=new G,c=new vd,d=new Kd;return function(e,f,g){function h(a,b,d,e,h){a=f+a;var m=gc.Handlers.get(a);null!==m?a=m.load(a):(c.setCrossOrigin(g),a=c.load(a));void 0!==b&&(a.repeat.fromArray(b),1!==b[0]&&(a.wrapS=1E3),1!==b[1]&&(a.wrapT=1E3));void 0!==d&&a.offset.fromArray(d);void 0!==e&&(\"repeat\"===e[0]&&(a.wrapS=1E3),\"mirror\"===e[0]&&(a.wrapS=1002),\"repeat\"===e[1]&&(a.wrapT=1E3),\"mirror\"===e[1]&&(a.wrapT=1002));void 0!==\nh&&(a.anisotropy=h);b=H.generateUUID();k[b]=a;return b}var k={},m={uuid:H.generateUUID(),type:\"MeshLambertMaterial\"},l;for(l in e){var n=e[l];switch(l){case \"DbgColor\":case \"DbgIndex\":case \"opticalDensity\":case \"illumination\":break;case \"DbgName\":m.name=n;break;case \"blending\":m.blending=a[n];break;case \"colorAmbient\":case \"mapAmbient\":console.warn(\"THREE.Loader.createMaterial:\",l,\"is no longer supported.\");break;case \"colorDiffuse\":m.color=b.fromArray(n).getHex();break;case \"colorSpecular\":m.specular=\nb.fromArray(n).getHex();break;case \"colorEmissive\":m.emissive=b.fromArray(n).getHex();break;case \"specularCoef\":m.shininess=n;break;case \"shading\":\"basic\"===n.toLowerCase()&&(m.type=\"MeshBasicMaterial\");\"phong\"===n.toLowerCase()&&(m.type=\"MeshPhongMaterial\");\"standard\"===n.toLowerCase()&&(m.type=\"MeshStandardMaterial\");break;case \"mapDiffuse\":m.map=h(n,e.mapDiffuseRepeat,e.mapDiffuseOffset,e.mapDiffuseWrap,e.mapDiffuseAnisotropy);break;case \"mapDiffuseRepeat\":case \"mapDiffuseOffset\":case \"mapDiffuseWrap\":case \"mapDiffuseAnisotropy\":break;\ncase \"mapEmissive\":m.emissiveMap=h(n,e.mapEmissiveRepeat,e.mapEmissiveOffset,e.mapEmissiveWrap,e.mapEmissiveAnisotropy);break;case \"mapEmissiveRepeat\":case \"mapEmissiveOffset\":case \"mapEmissiveWrap\":case \"mapEmissiveAnisotropy\":break;case \"mapLight\":m.lightMap=h(n,e.mapLightRepeat,e.mapLightOffset,e.mapLightWrap,e.mapLightAnisotropy);break;case \"mapLightRepeat\":case \"mapLightOffset\":case \"mapLightWrap\":case \"mapLightAnisotropy\":break;case \"mapAO\":m.aoMap=h(n,e.mapAORepeat,e.mapAOOffset,e.mapAOWrap,\ne.mapAOAnisotropy);break;case \"mapAORepeat\":case \"mapAOOffset\":case \"mapAOWrap\":case \"mapAOAnisotropy\":break;case \"mapBump\":m.bumpMap=h(n,e.mapBumpRepeat,e.mapBumpOffset,e.mapBumpWrap,e.mapBumpAnisotropy);break;case \"mapBumpScale\":m.bumpScale=n;break;case \"mapBumpRepeat\":case \"mapBumpOffset\":case \"mapBumpWrap\":case \"mapBumpAnisotropy\":break;case \"mapNormal\":m.normalMap=h(n,e.mapNormalRepeat,e.mapNormalOffset,e.mapNormalWrap,e.mapNormalAnisotropy);break;case \"mapNormalFactor\":m.normalScale=n;break;\ncase \"mapNormalRepeat\":case \"mapNormalOffset\":case \"mapNormalWrap\":case \"mapNormalAnisotropy\":break;case \"mapSpecular\":m.specularMap=h(n,e.mapSpecularRepeat,e.mapSpecularOffset,e.mapSpecularWrap,e.mapSpecularAnisotropy);break;case \"mapSpecularRepeat\":case \"mapSpecularOffset\":case \"mapSpecularWrap\":case \"mapSpecularAnisotropy\":break;case \"mapMetalness\":m.metalnessMap=h(n,e.mapMetalnessRepeat,e.mapMetalnessOffset,e.mapMetalnessWrap,e.mapMetalnessAnisotropy);break;case \"mapMetalnessRepeat\":case \"mapMetalnessOffset\":case \"mapMetalnessWrap\":case \"mapMetalnessAnisotropy\":break;\ncase \"mapRoughness\":m.roughnessMap=h(n,e.mapRoughnessRepeat,e.mapRoughnessOffset,e.mapRoughnessWrap,e.mapRoughnessAnisotropy);break;case \"mapRoughnessRepeat\":case \"mapRoughnessOffset\":case \"mapRoughnessWrap\":case \"mapRoughnessAnisotropy\":break;case \"mapAlpha\":m.alphaMap=h(n,e.mapAlphaRepeat,e.mapAlphaOffset,e.mapAlphaWrap,e.mapAlphaAnisotropy);break;case \"mapAlphaRepeat\":case \"mapAlphaOffset\":case \"mapAlphaWrap\":case \"mapAlphaAnisotropy\":break;case \"flipSided\":m.side=1;break;case \"doubleSided\":m.side=\n2;break;case \"transparency\":console.warn(\"THREE.Loader.createMaterial: transparency has been renamed to opacity\");m.opacity=n;break;case \"depthTest\":case \"depthWrite\":case \"colorWrite\":case \"opacity\":case \"reflectivity\":case \"transparent\":case \"visible\":case \"wireframe\":m[l]=n;break;case \"vertexColors\":!0===n&&(m.vertexColors=2);\"face\"===n&&(m.vertexColors=1);break;default:console.error(\"THREE.Loader.createMaterial: Unsupported\",l,n)}}\"MeshBasicMaterial\"===m.type&&delete m.emissive;\"MeshPhongMaterial\"!==\nm.type&&delete m.specular;1>m.opacity&&(m.transparent=!0);d.setTextures(k);return d.parse(m)}}()});var De={decodeText:function(a){if(\"undefined\"!==typeof TextDecoder)return(new TextDecoder).decode(a);for(var b=\"\",c=0,d=a.length;c<d;c++)b+=String.fromCharCode(a[c]);return decodeURIComponent(escape(b))},extractUrlBase:function(a){var b=a.lastIndexOf(\"/\");return-1===b?\"./\":a.substr(0,b+1)}};Object.assign(he.prototype,{crossOrigin:\"anonymous\",load:function(a,b,c,d){var e=this,f=this.texturePath&&\"string\"===\ntypeof this.texturePath?this.texturePath:De.extractUrlBase(a),g=new Ga(this.manager);g.setWithCredentials(this.withCredentials);g.load(a,function(c){c=JSON.parse(c);var d=c.metadata;if(void 0!==d&&(d=d.type,void 0!==d&&\"object\"===d.toLowerCase())){console.error(\"THREE.JSONLoader: \"+a+\" should be loaded with THREE.ObjectLoader instead.\");return}c=e.parse(c,f);b(c.geometry,c.materials)},c,d)},setCrossOrigin:function(a){this.crossOrigin=a;return this},setTexturePath:function(a){this.texturePath=a;return this},\nparse:function(){return function(a,b){void 0!==a.data&&(a=a.data);a.scale=void 0!==a.scale?1/a.scale:1;var c=new R,d=a,e,f,g,h=d.faces;var k=d.vertices;var m=d.normals,l=d.colors;var n=d.scale;var t=0;if(void 0!==d.uvs){for(e=0;e<d.uvs.length;e++)d.uvs[e].length&&t++;for(e=0;e<t;e++)c.faceVertexUvs[e]=[]}var u=0;for(g=k.length;u<g;)e=new p,e.x=k[u++]*n,e.y=k[u++]*n,e.z=k[u++]*n,c.vertices.push(e);u=0;for(g=h.length;u<g;){k=h[u++];var r=k&1;var v=k&2;e=k&8;var y=k&16;var x=k&32;n=k&64;k&=128;if(r){r=\nnew Ta;r.a=h[u];r.b=h[u+1];r.c=h[u+3];var w=new Ta;w.a=h[u+1];w.b=h[u+2];w.c=h[u+3];u+=4;v&&(v=h[u++],r.materialIndex=v,w.materialIndex=v);v=c.faces.length;if(e)for(e=0;e<t;e++){var B=d.uvs[e];c.faceVertexUvs[e][v]=[];c.faceVertexUvs[e][v+1]=[];for(f=0;4>f;f++){var E=h[u++];var A=B[2*E];E=B[2*E+1];A=new z(A,E);2!==f&&c.faceVertexUvs[e][v].push(A);0!==f&&c.faceVertexUvs[e][v+1].push(A)}}y&&(y=3*h[u++],r.normal.set(m[y++],m[y++],m[y]),w.normal.copy(r.normal));if(x)for(e=0;4>e;e++)y=3*h[u++],x=new p(m[y++],\nm[y++],m[y]),2!==e&&r.vertexNormals.push(x),0!==e&&w.vertexNormals.push(x);n&&(n=h[u++],n=l[n],r.color.setHex(n),w.color.setHex(n));if(k)for(e=0;4>e;e++)n=h[u++],n=l[n],2!==e&&r.vertexColors.push(new G(n)),0!==e&&w.vertexColors.push(new G(n));c.faces.push(r);c.faces.push(w)}else{r=new Ta;r.a=h[u++];r.b=h[u++];r.c=h[u++];v&&(v=h[u++],r.materialIndex=v);v=c.faces.length;if(e)for(e=0;e<t;e++)for(B=d.uvs[e],c.faceVertexUvs[e][v]=[],f=0;3>f;f++)E=h[u++],A=B[2*E],E=B[2*E+1],A=new z(A,E),c.faceVertexUvs[e][v].push(A);\ny&&(y=3*h[u++],r.normal.set(m[y++],m[y++],m[y]));if(x)for(e=0;3>e;e++)y=3*h[u++],x=new p(m[y++],m[y++],m[y]),r.vertexNormals.push(x);n&&(n=h[u++],r.color.setHex(l[n]));if(k)for(e=0;3>e;e++)n=h[u++],r.vertexColors.push(new G(l[n]));c.faces.push(r)}}d=a;u=void 0!==d.influencesPerVertex?d.influencesPerVertex:2;if(d.skinWeights)for(g=0,h=d.skinWeights.length;g<h;g+=u)c.skinWeights.push(new V(d.skinWeights[g],1<u?d.skinWeights[g+1]:0,2<u?d.skinWeights[g+2]:0,3<u?d.skinWeights[g+3]:0));if(d.skinIndices)for(g=\n0,h=d.skinIndices.length;g<h;g+=u)c.skinIndices.push(new V(d.skinIndices[g],1<u?d.skinIndices[g+1]:0,2<u?d.skinIndices[g+2]:0,3<u?d.skinIndices[g+3]:0));c.bones=d.bones;c.bones&&0<c.bones.length&&(c.skinWeights.length!==c.skinIndices.length||c.skinIndices.length!==c.vertices.length)&&console.warn(\"When skinning, number of vertices (\"+c.vertices.length+\"), skinIndices (\"+c.skinIndices.length+\"), and skinWeights (\"+c.skinWeights.length+\") should match.\");g=a;h=g.scale;if(void 0!==g.morphTargets)for(d=\n0,u=g.morphTargets.length;d<u;d++)for(c.morphTargets[d]={},c.morphTargets[d].name=g.morphTargets[d].name,c.morphTargets[d].vertices=[],m=c.morphTargets[d].vertices,l=g.morphTargets[d].vertices,t=0,k=l.length;t<k;t+=3)n=new p,n.x=l[t]*h,n.y=l[t+1]*h,n.z=l[t+2]*h,m.push(n);if(void 0!==g.morphColors&&0<g.morphColors.length)for(console.warn('THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.'),h=c.faces,g=g.morphColors[0].colors,d=0,u=h.length;d<u;d++)h[d].color.fromArray(g,\n3*d);g=a;d=[];u=[];void 0!==g.animation&&u.push(g.animation);void 0!==g.animations&&(g.animations.length?u=u.concat(g.animations):u.push(g.animations));for(g=0;g<u.length;g++)(h=Ca.parseAnimation(u[g],c.bones))&&d.push(h);c.morphTargets&&(u=Ca.CreateClipsFromMorphTargetSequences(c.morphTargets,10),d=d.concat(u));0<d.length&&(c.animations=d);c.computeFaceNormals();c.computeBoundingSphere();if(void 0===a.materials||0===a.materials.length)return{geometry:c};a=gc.prototype.initMaterials(a.materials,b,\nthis.crossOrigin);return{geometry:c,materials:a}}}()});Object.assign(mf.prototype,{crossOrigin:\"anonymous\",load:function(a,b,c,d){\"\"===this.texturePath&&(this.texturePath=a.substring(0,a.lastIndexOf(\"/\")+1));var e=this;(new Ga(e.manager)).load(a,function(c){var f=null;try{f=JSON.parse(c)}catch(h){void 0!==d&&d(h);console.error(\"THREE:ObjectLoader: Can't parse \"+a+\".\",h.message);return}c=f.metadata;void 0===c||void 0===c.type||\"geometry\"===c.type.toLowerCase()?console.error(\"THREE.ObjectLoader: Can't load \"+\na+\". Use THREE.JSONLoader instead.\"):e.parse(f,b)},c,d)},setTexturePath:function(a){this.texturePath=a;return this},setCrossOrigin:function(a){this.crossOrigin=a;return this},parse:function(a,b){var c=this.parseShape(a.shapes);c=this.parseGeometries(a.geometries,c);var d=this.parseImages(a.images,function(){void 0!==b&&b(e)});d=this.parseTextures(a.textures,d);d=this.parseMaterials(a.materials,d);var e=this.parseObject(a.object,c,d);a.animations&&(e.animations=this.parseAnimations(a.animations));\nvoid 0!==a.images&&0!==a.images.length||void 0===b||b(e);return e},parseShape:function(a){var b={};if(void 0!==a)for(var c=0,d=a.length;c<d;c++){var e=(new db).fromJSON(a[c]);b[e.uuid]=e}return b},parseGeometries:function(a,b){var c={};if(void 0!==a)for(var d=new he,e=new ge,f=0,g=a.length;f<g;f++){var h=a[f];switch(h.type){case \"PlaneGeometry\":case \"PlaneBufferGeometry\":var k=new xa[h.type](h.width,h.height,h.widthSegments,h.heightSegments);break;case \"BoxGeometry\":case \"BoxBufferGeometry\":case \"CubeGeometry\":k=\nnew xa[h.type](h.width,h.height,h.depth,h.widthSegments,h.heightSegments,h.depthSegments);break;case \"CircleGeometry\":case \"CircleBufferGeometry\":k=new xa[h.type](h.radius,h.segments,h.thetaStart,h.thetaLength);break;case \"CylinderGeometry\":case \"CylinderBufferGeometry\":k=new xa[h.type](h.radiusTop,h.radiusBottom,h.height,h.radialSegments,h.heightSegments,h.openEnded,h.thetaStart,h.thetaLength);break;case \"ConeGeometry\":case \"ConeBufferGeometry\":k=new xa[h.type](h.radius,h.height,h.radialSegments,\nh.heightSegments,h.openEnded,h.thetaStart,h.thetaLength);break;case \"SphereGeometry\":case \"SphereBufferGeometry\":k=new xa[h.type](h.radius,h.widthSegments,h.heightSegments,h.phiStart,h.phiLength,h.thetaStart,h.thetaLength);break;case \"DodecahedronGeometry\":case \"DodecahedronBufferGeometry\":case \"IcosahedronGeometry\":case \"IcosahedronBufferGeometry\":case \"OctahedronGeometry\":case \"OctahedronBufferGeometry\":case \"TetrahedronGeometry\":case \"TetrahedronBufferGeometry\":k=new xa[h.type](h.radius,h.detail);\nbreak;case \"RingGeometry\":case \"RingBufferGeometry\":k=new xa[h.type](h.innerRadius,h.outerRadius,h.thetaSegments,h.phiSegments,h.thetaStart,h.thetaLength);break;case \"TorusGeometry\":case \"TorusBufferGeometry\":k=new xa[h.type](h.radius,h.tube,h.radialSegments,h.tubularSegments,h.arc);break;case \"TorusKnotGeometry\":case \"TorusKnotBufferGeometry\":k=new xa[h.type](h.radius,h.tube,h.tubularSegments,h.radialSegments,h.p,h.q);break;case \"LatheGeometry\":case \"LatheBufferGeometry\":k=new xa[h.type](h.points,\nh.segments,h.phiStart,h.phiLength);break;case \"PolyhedronGeometry\":case \"PolyhedronBufferGeometry\":k=new xa[h.type](h.vertices,h.indices,h.radius,h.details);break;case \"ShapeGeometry\":case \"ShapeBufferGeometry\":k=[];for(var m=0,l=h.shapes.length;m<l;m++){var n=b[h.shapes[m]];k.push(n)}k=new xa[h.type](k,h.curveSegments);break;case \"ExtrudeGeometry\":case \"ExtrudeBufferGeometry\":k=[];m=0;for(l=h.shapes.length;m<l;m++)n=b[h.shapes[m]],k.push(n);m=h.options.extrudePath;void 0!==m&&(h.options.extrudePath=\n(new Af[m.type]).fromJSON(m));k=new xa[h.type](k,h.options);break;case \"BufferGeometry\":k=e.parse(h);break;case \"Geometry\":k=d.parse(h,this.texturePath).geometry;break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type \"'+h.type+'\"');continue}k.uuid=h.uuid;void 0!==h.name&&(k.name=h.name);!0===k.isBufferGeometry&&void 0!==h.userData&&(k.userData=h.userData);c[h.uuid]=k}return c},parseMaterials:function(a,b){var c={};if(void 0!==a){var d=new Kd;d.setTextures(b);b=0;for(var e=a.length;b<\ne;b++){var f=a[b];if(\"MultiMaterial\"===f.type){for(var g=[],h=0;h<f.materials.length;h++)g.push(d.parse(f.materials[h]));c[f.uuid]=g}else c[f.uuid]=d.parse(f)}}return c},parseAnimations:function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c],e=Ca.parse(d);void 0!==d.uuid&&(e.uuid=d.uuid);b.push(e)}return b},parseImages:function(a,b){function c(a){d.manager.itemStart(a);return f.load(a,function(){d.manager.itemEnd(a)},void 0,function(){d.manager.itemEnd(a);d.manager.itemError(a)})}var d=this,e={};\nif(void 0!==a&&0<a.length){b=new ce(b);var f=new Zc(b);f.setCrossOrigin(this.crossOrigin);b=0;for(var g=a.length;b<g;b++){var h=a[b],k=h.url;if(Array.isArray(k)){e[h.uuid]=[];for(var m=0,l=k.length;m<l;m++){var n=k[m];n=/^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(n)?n:d.texturePath+n;e[h.uuid].push(c(n))}}else n=/^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(h.url)?h.url:d.texturePath+h.url,e[h.uuid]=c(n)}}return e},parseTextures:function(a,b){function c(a,b){if(\"number\"===typeof a)return a;console.warn(\"THREE.ObjectLoader.parseTexture: Constant should be in numeric form.\",\na);return b[a]}var d={};if(void 0!==a)for(var e=0,f=a.length;e<f;e++){var g=a[e];void 0===g.image&&console.warn('THREE.ObjectLoader: No \"image\" specified for',g.uuid);void 0===b[g.image]&&console.warn(\"THREE.ObjectLoader: Undefined image\",g.image);var h=Array.isArray(b[g.image])?new Ua(b[g.image]):new T(b[g.image]);h.needsUpdate=!0;h.uuid=g.uuid;void 0!==g.name&&(h.name=g.name);void 0!==g.mapping&&(h.mapping=c(g.mapping,Wg));void 0!==g.offset&&h.offset.fromArray(g.offset);void 0!==g.repeat&&h.repeat.fromArray(g.repeat);\nvoid 0!==g.center&&h.center.fromArray(g.center);void 0!==g.rotation&&(h.rotation=g.rotation);void 0!==g.wrap&&(h.wrapS=c(g.wrap[0],Cf),h.wrapT=c(g.wrap[1],Cf));void 0!==g.format&&(h.format=g.format);void 0!==g.minFilter&&(h.minFilter=c(g.minFilter,Df));void 0!==g.magFilter&&(h.magFilter=c(g.magFilter,Df));void 0!==g.anisotropy&&(h.anisotropy=g.anisotropy);void 0!==g.flipY&&(h.flipY=g.flipY);d[g.uuid]=h}return d},parseObject:function(a,b,c){function d(a){void 0===b[a]&&console.warn(\"THREE.ObjectLoader: Undefined geometry\",\na);return b[a]}function e(a){if(void 0!==a){if(Array.isArray(a)){for(var b=[],d=0,e=a.length;d<e;d++){var f=a[d];void 0===c[f]&&console.warn(\"THREE.ObjectLoader: Undefined material\",f);b.push(c[f])}return b}void 0===c[a]&&console.warn(\"THREE.ObjectLoader: Undefined material\",a);return c[a]}}switch(a.type){case \"Scene\":var f=new qd;void 0!==a.background&&Number.isInteger(a.background)&&(f.background=new G(a.background));void 0!==a.fog&&(\"Fog\"===a.fog.type?f.fog=new Mb(a.fog.color,a.fog.near,a.fog.far):\n\"FogExp2\"===a.fog.type&&(f.fog=new Lb(a.fog.color,a.fog.density)));break;case \"PerspectiveCamera\":f=new Z(a.fov,a.aspect,a.near,a.far);void 0!==a.focus&&(f.focus=a.focus);void 0!==a.zoom&&(f.zoom=a.zoom);void 0!==a.filmGauge&&(f.filmGauge=a.filmGauge);void 0!==a.filmOffset&&(f.filmOffset=a.filmOffset);void 0!==a.view&&(f.view=Object.assign({},a.view));break;case \"OrthographicCamera\":f=new Hb(a.left,a.right,a.top,a.bottom,a.near,a.far);void 0!==a.zoom&&(f.zoom=a.zoom);void 0!==a.view&&(f.view=Object.assign({},\na.view));break;case \"AmbientLight\":f=new Cd(a.color,a.intensity);break;case \"DirectionalLight\":f=new Bd(a.color,a.intensity);break;case \"PointLight\":f=new zd(a.color,a.intensity,a.distance,a.decay);break;case \"RectAreaLight\":f=new Dd(a.color,a.intensity,a.width,a.height);break;case \"SpotLight\":f=new yd(a.color,a.intensity,a.distance,a.angle,a.penumbra,a.decay);break;case \"HemisphereLight\":f=new wd(a.color,a.groundColor,a.intensity);break;case \"SkinnedMesh\":console.warn(\"THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.\");\ncase \"Mesh\":f=d(a.geometry);var g=e(a.material);f=f.bones&&0<f.bones.length?new sd(f,g):new la(f,g);break;case \"LOD\":f=new Bc;break;case \"Line\":f=new sa(d(a.geometry),e(a.material),a.mode);break;case \"LineLoop\":f=new td(d(a.geometry),e(a.material));break;case \"LineSegments\":f=new W(d(a.geometry),e(a.material));break;case \"PointCloud\":case \"Points\":f=new Ob(d(a.geometry),e(a.material));break;case \"Sprite\":f=new Ac(e(a.material));break;case \"Group\":f=new Kb;break;default:f=new D}f.uuid=a.uuid;void 0!==\na.name&&(f.name=a.name);void 0!==a.matrix?(f.matrix.fromArray(a.matrix),void 0!==a.matrixAutoUpdate&&(f.matrixAutoUpdate=a.matrixAutoUpdate),f.matrixAutoUpdate&&f.matrix.decompose(f.position,f.quaternion,f.scale)):(void 0!==a.position&&f.position.fromArray(a.position),void 0!==a.rotation&&f.rotation.fromArray(a.rotation),void 0!==a.quaternion&&f.quaternion.fromArray(a.quaternion),void 0!==a.scale&&f.scale.fromArray(a.scale));void 0!==a.castShadow&&(f.castShadow=a.castShadow);void 0!==a.receiveShadow&&\n(f.receiveShadow=a.receiveShadow);a.shadow&&(void 0!==a.shadow.bias&&(f.shadow.bias=a.shadow.bias),void 0!==a.shadow.radius&&(f.shadow.radius=a.shadow.radius),void 0!==a.shadow.mapSize&&f.shadow.mapSize.fromArray(a.shadow.mapSize),void 0!==a.shadow.camera&&(f.shadow.camera=this.parseObject(a.shadow.camera)));void 0!==a.visible&&(f.visible=a.visible);void 0!==a.frustumCulled&&(f.frustumCulled=a.frustumCulled);void 0!==a.renderOrder&&(f.renderOrder=a.renderOrder);void 0!==a.userData&&(f.userData=a.userData);\nvoid 0!==a.layers&&(f.layers.mask=a.layers);if(void 0!==a.children){g=a.children;for(var h=0;h<g.length;h++)f.add(this.parseObject(g[h],b,c))}if(\"LOD\"===a.type)for(a=a.levels,g=0;g<a.length;g++){h=a[g];var k=f.getObjectByProperty(\"uuid\",h.object);void 0!==k&&f.addLevel(k,h.distance)}return f}});var Wg={UVMapping:300,CubeReflectionMapping:301,CubeRefractionMapping:302,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,SphericalReflectionMapping:305,CubeUVReflectionMapping:306,\nCubeUVRefractionMapping:307},Cf={RepeatWrapping:1E3,ClampToEdgeWrapping:1001,MirroredRepeatWrapping:1002},Df={NearestFilter:1003,NearestMipMapNearestFilter:1004,NearestMipMapLinearFilter:1005,LinearFilter:1006,LinearMipMapNearestFilter:1007,LinearMipMapLinearFilter:1008};ie.prototype={constructor:ie,setOptions:function(a){this.options=a;return this},load:function(a,b,c,d){void 0===a&&(a=\"\");void 0!==this.path&&(a=this.path+a);a=this.manager.resolveURL(a);var e=this,f=Fb.get(a);if(void 0!==f)return e.manager.itemStart(a),\nsetTimeout(function(){b&&b(f);e.manager.itemEnd(a)},0),f;fetch(a).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,e.options)}).then(function(c){Fb.add(a,c);b&&b(c);e.manager.itemEnd(a)}).catch(function(b){d&&d(b);e.manager.itemEnd(a);e.manager.itemError(a)})},setCrossOrigin:function(){return this},setPath:function(a){this.path=a;return this}};Object.assign(je.prototype,{moveTo:function(a,b){this.currentPath=new La;this.subPaths.push(this.currentPath);this.currentPath.moveTo(a,\nb)},lineTo:function(a,b){this.currentPath.lineTo(a,b)},quadraticCurveTo:function(a,b,c,d){this.currentPath.quadraticCurveTo(a,b,c,d)},bezierCurveTo:function(a,b,c,d,e,f){this.currentPath.bezierCurveTo(a,b,c,d,e,f)},splineThru:function(a){this.currentPath.splineThru(a)},toShapes:function(a,b){function c(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c],f=new db;f.curves=e.curves;b.push(f)}return b}function d(a,b){for(var c=b.length,d=!1,e=c-1,f=0;f<c;e=f++){var g=b[e],h=b[f],k=h.x-g.x,m=h.y-g.y;if(Math.abs(m)>\nNumber.EPSILON){if(0>m&&(g=b[f],k=-k,h=b[e],m=-m),!(a.y<g.y||a.y>h.y))if(a.y===g.y){if(a.x===g.x)return!0}else{e=m*(a.x-g.x)-k*(a.y-g.y);if(0===e)return!0;0>e||(d=!d)}}else if(a.y===g.y&&(h.x<=a.x&&a.x<=g.x||g.x<=a.x&&a.x<=h.x))return!0}return d}var e=Va.isClockWise,f=this.subPaths;if(0===f.length)return[];if(!0===b)return c(f);b=[];if(1===f.length){var g=f[0];var h=new db;h.curves=g.curves;b.push(h);return b}var k=!e(f[0].getPoints());k=a?!k:k;h=[];var m=[],l=[],n=0;m[n]=void 0;l[n]=[];for(var p=\n0,u=f.length;p<u;p++){g=f[p];var r=g.getPoints();var v=e(r);(v=a?!v:v)?(!k&&m[n]&&n++,m[n]={s:new db,p:r},m[n].s.curves=g.curves,k&&n++,l[n]=[]):l[n].push({h:g,p:r[0]})}if(!m[0])return c(f);if(1<m.length){p=!1;a=[];e=0;for(f=m.length;e<f;e++)h[e]=[];e=0;for(f=m.length;e<f;e++)for(g=l[e],v=0;v<g.length;v++){k=g[v];n=!0;for(r=0;r<m.length;r++)d(k.p,m[r].p)&&(e!==r&&a.push({froms:e,tos:r,hole:v}),n?(n=!1,h[r].push(k)):p=!0);n&&h[e].push(k)}0<a.length&&(p||(l=h))}p=0;for(e=m.length;p<e;p++)for(h=m[p].s,\nb.push(h),a=l[p],f=0,g=a.length;f<g;f++)h.holes.push(a[f].h);return b}});Object.assign(ke.prototype,{isFont:!0,generateShapes:function(a,b){void 0===b&&(b=100);var c=[],d=b;b=this.data;var e=Array.from?Array.from(a):String(a).split(\"\");d/=b.resolution;var f=(b.boundingBox.yMax-b.boundingBox.yMin+b.underlineThickness)*d;a=[];for(var g=0,h=0,k=0;k<e.length;k++){var m=e[k];if(\"\\n\"===m)g=0,h-=f;else{var l=d;var n=g,p=h;if(m=b.glyphs[m]||b.glyphs[\"?\"]){var u=new je;if(m.o)for(var r=m._cachedOutline||(m._cachedOutline=\nm.o.split(\" \")),v=0,y=r.length;v<y;)switch(r[v++]){case \"m\":var x=r[v++]*l+n;var w=r[v++]*l+p;u.moveTo(x,w);break;case \"l\":x=r[v++]*l+n;w=r[v++]*l+p;u.lineTo(x,w);break;case \"q\":var z=r[v++]*l+n;var A=r[v++]*l+p;var C=r[v++]*l+n;var D=r[v++]*l+p;u.quadraticCurveTo(C,D,z,A);break;case \"b\":z=r[v++]*l+n,A=r[v++]*l+p,C=r[v++]*l+n,D=r[v++]*l+p,x=r[v++]*l+n,w=r[v++]*l+p,u.bezierCurveTo(C,D,x,w,z,A)}l={offsetX:m.ha*l,path:u}}else l=void 0;g+=l.offsetX;a.push(l.path)}}b=0;for(e=a.length;b<e;b++)Array.prototype.push.apply(c,\na[b].toShapes());return c}});Object.assign(nf.prototype,{load:function(a,b,c,d){var e=this,f=new Ga(this.manager);f.setPath(this.path);f.load(a,function(a){try{var c=JSON.parse(a)}catch(k){console.warn(\"THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.\"),c=JSON.parse(a.substring(65,a.length-2))}a=e.parse(c);b&&b(a)},c,d)},parse:function(a){return new ke(a)},setPath:function(a){this.path=a;return this}});var Pd,ne={getContext:function(){void 0===Pd&&(Pd=new (window.AudioContext||\nwindow.webkitAudioContext));return Pd},setContext:function(a){Pd=a}};Object.assign(le.prototype,{load:function(a,b,c,d){var e=new Ga(this.manager);e.setResponseType(\"arraybuffer\");e.load(a,function(a){a=a.slice(0);ne.getContext().decodeAudioData(a,function(a){b(a)})},c,d)}});Object.assign(of.prototype,{update:function(){var a,b,c,d,e,f,g,h,k=new I,l=new I;return function(m){if(a!==this||b!==m.focus||c!==m.fov||d!==m.aspect*this.aspect||e!==m.near||f!==m.far||g!==m.zoom||h!==this.eyeSep){a=this;b=\nm.focus;c=m.fov;d=m.aspect*this.aspect;e=m.near;f=m.far;g=m.zoom;var n=m.projectionMatrix.clone();h=this.eyeSep/2;var p=h*e/b,q=e*Math.tan(H.DEG2RAD*c*.5)/g;l.elements[12]=-h;k.elements[12]=h;var r=-q*d+p;var v=q*d+p;n.elements[0]=2*e/(v-r);n.elements[8]=(v+r)/(v-r);this.cameraL.projectionMatrix.copy(n);r=-q*d-p;v=q*d-p;n.elements[0]=2*e/(v-r);n.elements[8]=(v+r)/(v-r);this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(m.matrixWorld).multiply(l);this.cameraR.matrixWorld.copy(m.matrixWorld).multiply(k)}}()});\ndd.prototype=Object.create(D.prototype);dd.prototype.constructor=dd;me.prototype=Object.assign(Object.create(D.prototype),{constructor:me,getInput:function(){return this.gain},removeFilter:function(){null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null);return this},getFilter:function(){return this.filter},setFilter:function(a){null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):\nthis.gain.disconnect(this.context.destination);this.filter=a;this.gain.connect(this.filter);this.filter.connect(this.context.destination);return this},getMasterVolume:function(){return this.gain.gain.value},setMasterVolume:function(a){this.gain.gain.setTargetAtTime(a,this.context.currentTime,.01);return this},updateMatrixWorld:function(){var a=new p,b=new fa,c=new p,d=new p;return function(e){D.prototype.updateMatrixWorld.call(this,e);e=this.context.listener;var f=this.up;this.matrixWorld.decompose(a,\nb,c);d.set(0,0,-1).applyQuaternion(b);e.positionX?(e.positionX.setValueAtTime(a.x,this.context.currentTime),e.positionY.setValueAtTime(a.y,this.context.currentTime),e.positionZ.setValueAtTime(a.z,this.context.currentTime),e.forwardX.setValueAtTime(d.x,this.context.currentTime),e.forwardY.setValueAtTime(d.y,this.context.currentTime),e.forwardZ.setValueAtTime(d.z,this.context.currentTime),e.upX.setValueAtTime(f.x,this.context.currentTime),e.upY.setValueAtTime(f.y,this.context.currentTime),e.upZ.setValueAtTime(f.z,\nthis.context.currentTime)):(e.setPosition(a.x,a.y,a.z),e.setOrientation(d.x,d.y,d.z,f.x,f.y,f.z))}}()});hc.prototype=Object.assign(Object.create(D.prototype),{constructor:hc,getOutput:function(){return this.gain},setNodeSource:function(a){this.hasPlaybackControl=!1;this.sourceType=\"audioNode\";this.source=a;this.connect();return this},setMediaElementSource:function(a){this.hasPlaybackControl=!1;this.sourceType=\"mediaNode\";this.source=this.context.createMediaElementSource(a);this.connect();return this},\nsetBuffer:function(a){this.buffer=a;this.sourceType=\"buffer\";this.autoplay&&this.play();return this},play:function(){if(!0===this.isPlaying)console.warn(\"THREE.Audio: Audio is already playing.\");else if(!1===this.hasPlaybackControl)console.warn(\"THREE.Audio: this Audio has no playback control.\");else{var a=this.context.createBufferSource();a.buffer=this.buffer;a.loop=this.loop;a.onended=this.onEnded.bind(this);a.playbackRate.setValueAtTime(this.playbackRate,this.startTime);this.startTime=this.context.currentTime;\na.start(this.startTime,this.offset);this.isPlaying=!0;this.source=a;return this.connect()}},pause:function(){if(!1===this.hasPlaybackControl)console.warn(\"THREE.Audio: this Audio has no playback control.\");else return!0===this.isPlaying&&(this.source.stop(),this.source.onended=null,this.offset+=(this.context.currentTime-this.startTime)*this.playbackRate,this.isPlaying=!1),this},stop:function(){if(!1===this.hasPlaybackControl)console.warn(\"THREE.Audio: this Audio has no playback control.\");else return this.source.stop(),\nthis.source.onended=null,this.offset=0,this.isPlaying=!1,this},connect:function(){if(0<this.filters.length){this.source.connect(this.filters[0]);for(var a=1,b=this.filters.length;a<b;a++)this.filters[a-1].connect(this.filters[a]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this},disconnect:function(){if(0<this.filters.length){this.source.disconnect(this.filters[0]);for(var a=1,b=this.filters.length;a<b;a++)this.filters[a-1].disconnect(this.filters[a]);\nthis.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this},getFilters:function(){return this.filters},setFilters:function(a){a||(a=[]);!0===this.isPlaying?(this.disconnect(),this.filters=a,this.connect()):this.filters=a;return this},getFilter:function(){return this.getFilters()[0]},setFilter:function(a){return this.setFilters(a?[a]:[])},setPlaybackRate:function(a){if(!1===this.hasPlaybackControl)console.warn(\"THREE.Audio: this Audio has no playback control.\");\nelse return this.playbackRate=a,!0===this.isPlaying&&this.source.playbackRate.setValueAtTime(this.playbackRate,this.context.currentTime),this},getPlaybackRate:function(){return this.playbackRate},onEnded:function(){this.isPlaying=!1},getLoop:function(){return!1===this.hasPlaybackControl?(console.warn(\"THREE.Audio: this Audio has no playback control.\"),!1):this.loop},setLoop:function(a){if(!1===this.hasPlaybackControl)console.warn(\"THREE.Audio: this Audio has no playback control.\");else return this.loop=\na,!0===this.isPlaying&&(this.source.loop=this.loop),this},getVolume:function(){return this.gain.gain.value},setVolume:function(a){this.gain.gain.setTargetAtTime(a,this.context.currentTime,.01);return this}});oe.prototype=Object.assign(Object.create(hc.prototype),{constructor:oe,getOutput:function(){return this.panner},getRefDistance:function(){return this.panner.refDistance},setRefDistance:function(a){this.panner.refDistance=a;return this},getRolloffFactor:function(){return this.panner.rolloffFactor},\nsetRolloffFactor:function(a){this.panner.rolloffFactor=a;return this},getDistanceModel:function(){return this.panner.distanceModel},setDistanceModel:function(a){this.panner.distanceModel=a;return this},getMaxDistance:function(){return this.panner.maxDistance},setMaxDistance:function(a){this.panner.maxDistance=a;return this},setDirectionalCone:function(a,b,c){this.panner.coneInnerAngle=a;this.panner.coneOuterAngle=b;this.panner.coneOuterGain=c;return this},updateMatrixWorld:function(){var a=new p,\nb=new fa,c=new p,d=new p;return function(e){D.prototype.updateMatrixWorld.call(this,e);e=this.panner;this.matrixWorld.decompose(a,b,c);d.set(0,0,1).applyQuaternion(b);e.setPosition(a.x,a.y,a.z);e.setOrientation(d.x,d.y,d.z)}}()});Object.assign(pe.prototype,{getFrequencyData:function(){this.analyser.getByteFrequencyData(this.data);return this.data},getAverageFrequency:function(){for(var a=0,b=this.getFrequencyData(),c=0;c<b.length;c++)a+=b[c];return a/b.length}});Object.assign(qe.prototype,{accumulate:function(a,\nb){var c=this.buffer,d=this.valueSize;a=a*d+d;var e=this.cumulativeWeight;if(0===e){for(e=0;e!==d;++e)c[a+e]=c[e];e=b}else e+=b,this._mixBufferRegion(c,a,0,b/e,d);this.cumulativeWeight=e},apply:function(a){var b=this.valueSize,c=this.buffer;a=a*b+b;var d=this.cumulativeWeight,e=this.binding;this.cumulativeWeight=0;1>d&&this._mixBufferRegion(c,a,3*b,1-d,b);d=b;for(var f=b+b;d!==f;++d)if(c[d]!==c[d+b]){e.setValue(c,a);break}},saveOriginalState:function(){var a=this.buffer,b=this.valueSize,c=3*b;this.binding.getValue(a,\nc);for(var d=b;d!==c;++d)a[d]=a[c+d%b];this.cumulativeWeight=0},restoreOriginalState:function(){this.binding.setValue(this.buffer,3*this.valueSize)},_select:function(a,b,c,d,e){if(.5<=d)for(d=0;d!==e;++d)a[b+d]=a[c+d]},_slerp:function(a,b,c,d){fa.slerpFlat(a,b,a,b,a,c,d)},_lerp:function(a,b,c,d,e){for(var f=1-d,g=0;g!==e;++g){var h=b+g;a[h]=a[h]*f+a[c+g]*d}}});Object.assign(pf.prototype,{getValue:function(a,b){this.bind();var c=this._bindings[this._targetGroup.nCachedObjects_];void 0!==c&&c.getValue(a,\nb)},setValue:function(a,b){for(var c=this._bindings,d=this._targetGroup.nCachedObjects_,e=c.length;d!==e;++d)c[d].setValue(a,b)},bind:function(){for(var a=this._bindings,b=this._targetGroup.nCachedObjects_,c=a.length;b!==c;++b)a[b].bind()},unbind:function(){for(var a=this._bindings,b=this._targetGroup.nCachedObjects_,c=a.length;b!==c;++b)a[b].unbind()}});Object.assign(pa,{Composite:pf,create:function(a,b,c){return a&&a.isAnimationObjectGroup?new pa.Composite(a,b,c):new pa(a,b,c)},sanitizeNodeName:function(){var a=\n/[\\[\\]\\.:\\/]/g;return function(b){return b.replace(/\\s/g,\"_\").replace(a,\"\")}}(),parseTrackName:function(){var a=\"[^\"+\"\\\\[\\\\]\\\\.:\\\\/\".replace(\"\\\\.\",\"\")+\"]\",b=/((?:WC+[\\/:])*)/.source.replace(\"WC\",\"[^\\\\[\\\\]\\\\.:\\\\/]\");a=/(WCOD+)?/.source.replace(\"WCOD\",a);var c=/(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace(\"WC\",\"[^\\\\[\\\\]\\\\.:\\\\/]\"),d=/\\.(WC+)(?:\\[(.+)\\])?/.source.replace(\"WC\",\"[^\\\\[\\\\]\\\\.:\\\\/]\"),e=new RegExp(\"^\"+b+a+c+d+\"$\"),f=[\"material\",\"materials\",\"bones\"];return function(a){var b=e.exec(a);if(!b)throw Error(\"PropertyBinding: Cannot parse trackName: \"+\na);b={nodeName:b[2],objectName:b[3],objectIndex:b[4],propertyName:b[5],propertyIndex:b[6]};var c=b.nodeName&&b.nodeName.lastIndexOf(\".\");if(void 0!==c&&-1!==c){var d=b.nodeName.substring(c+1);-1!==f.indexOf(d)&&(b.nodeName=b.nodeName.substring(0,c),b.objectName=d)}if(null===b.propertyName||0===b.propertyName.length)throw Error(\"PropertyBinding: can not parse propertyName from trackName: \"+a);return b}}(),findNode:function(a,b){if(!b||\"\"===b||\"root\"===b||\".\"===b||-1===b||b===a.name||b===a.uuid)return a;\nif(a.skeleton){var c=a.skeleton.getBoneByName(b);if(void 0!==c)return c}if(a.children){var d=function(a){for(var c=0;c<a.length;c++){var e=a[c];if(e.name===b||e.uuid===b||(e=d(e.children)))return e}return null};if(a=d(a.children))return a}return null}});Object.assign(pa.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(a,\nb){a[b]=this.node[this.propertyName]},function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)a[b++]=c[d]},function(a,b){a[b]=this.resolvedProperty[this.propertyIndex]},function(a,b){this.resolvedProperty.toArray(a,b)}],SetterByBindingTypeAndVersioning:[[function(a,b){this.targetObject[this.propertyName]=a[b]},function(a,b){this.targetObject[this.propertyName]=a[b];this.targetObject.needsUpdate=!0},function(a,b){this.targetObject[this.propertyName]=a[b];this.targetObject.matrixWorldNeedsUpdate=\n!0}],[function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)c[d]=a[b++]},function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)c[d]=a[b++];this.targetObject.needsUpdate=!0},function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)c[d]=a[b++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(a,b){this.resolvedProperty[this.propertyIndex]=a[b]},function(a,b){this.resolvedProperty[this.propertyIndex]=a[b];this.targetObject.needsUpdate=!0},function(a,\nb){this.resolvedProperty[this.propertyIndex]=a[b];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(a,b){this.resolvedProperty.fromArray(a,b)},function(a,b){this.resolvedProperty.fromArray(a,b);this.targetObject.needsUpdate=!0},function(a,b){this.resolvedProperty.fromArray(a,b);this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(a,b){this.bind();this.getValue(a,b)},setValue:function(a,b){this.bind();this.setValue(a,b)},bind:function(){var a=this.node,b=this.parsedPath,c=b.objectName,\nd=b.propertyName,e=b.propertyIndex;a||(this.node=a=pa.findNode(this.rootNode,b.nodeName)||this.rootNode);this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;if(a){if(c){var f=b.objectIndex;switch(c){case \"materials\":if(!a.material){console.error(\"THREE.PropertyBinding: Can not bind to material as node does not have a material.\",this);return}if(!a.material.materials){console.error(\"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.\",\nthis);return}a=a.material.materials;break;case \"bones\":if(!a.skeleton){console.error(\"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.\",this);return}a=a.skeleton.bones;for(c=0;c<a.length;c++)if(a[c].name===f){f=c;break}break;default:if(void 0===a[c]){console.error(\"THREE.PropertyBinding: Can not bind to objectName of node undefined.\",this);return}a=a[c]}if(void 0!==f){if(void 0===a[f]){console.error(\"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.\",\nthis,a);return}a=a[f]}}f=a[d];if(void 0===f)console.error(\"THREE.PropertyBinding: Trying to update property for track: \"+b.nodeName+\".\"+d+\" but it wasn't found.\",a);else{b=this.Versioning.None;void 0!==a.needsUpdate?(b=this.Versioning.NeedsUpdate,this.targetObject=a):void 0!==a.matrixWorldNeedsUpdate&&(b=this.Versioning.MatrixWorldNeedsUpdate,this.targetObject=a);c=this.BindingType.Direct;if(void 0!==e){if(\"morphTargetInfluences\"===d){if(!a.geometry){console.error(\"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.\",\nthis);return}if(a.geometry.isBufferGeometry){if(!a.geometry.morphAttributes){console.error(\"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.\",this);return}for(c=0;c<this.node.geometry.morphAttributes.position.length;c++)if(a.geometry.morphAttributes.position[c].name===e){e=c;break}}else{if(!a.geometry.morphTargets){console.error(\"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.\",\nthis);return}for(c=0;c<this.node.geometry.morphTargets.length;c++)if(a.geometry.morphTargets[c].name===e){e=c;break}}}c=this.BindingType.ArrayElement;this.resolvedProperty=f;this.propertyIndex=e}else void 0!==f.fromArray&&void 0!==f.toArray?(c=this.BindingType.HasFromToArray,this.resolvedProperty=f):Array.isArray(f)?(c=this.BindingType.EntireArray,this.resolvedProperty=f):this.propertyName=d;this.getValue=this.GetterByBindingType[c];this.setValue=this.SetterByBindingTypeAndVersioning[c][b]}}else console.error(\"THREE.PropertyBinding: Trying to update node for track: \"+\nthis.path+\" but it wasn't found.\")},unbind:function(){this.node=null;this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound}});Object.assign(pa.prototype,{_getValue_unbound:pa.prototype.getValue,_setValue_unbound:pa.prototype.setValue});Object.assign(qf.prototype,{isAnimationObjectGroup:!0,add:function(){for(var a=this._objects,b=a.length,c=this.nCachedObjects_,d=this._indicesByUUID,e=this._paths,f=this._parsedPaths,g=this._bindings,h=g.length,k=void 0,l=0,p=arguments.length;l!==\np;++l){var n=arguments[l],t=n.uuid,u=d[t];if(void 0===u){u=b++;d[t]=u;a.push(n);t=0;for(var r=h;t!==r;++t)g[t].push(new pa(n,e[t],f[t]))}else if(u<c){k=a[u];var v=--c;r=a[v];d[r.uuid]=u;a[u]=r;d[t]=v;a[v]=n;t=0;for(r=h;t!==r;++t){var y=g[t],x=y[u];y[u]=y[v];void 0===x&&(x=new pa(n,e[t],f[t]));y[v]=x}}else a[u]!==k&&console.error(\"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.\")}this.nCachedObjects_=\nc},remove:function(){for(var a=this._objects,b=this.nCachedObjects_,c=this._indicesByUUID,d=this._bindings,e=d.length,f=0,g=arguments.length;f!==g;++f){var h=arguments[f],k=h.uuid,l=c[k];if(void 0!==l&&l>=b){var p=b++,n=a[p];c[n.uuid]=l;a[l]=n;c[k]=p;a[p]=h;h=0;for(k=e;h!==k;++h){n=d[h];var t=n[l];n[l]=n[p];n[p]=t}}}this.nCachedObjects_=b},uncache:function(){for(var a=this._objects,b=a.length,c=this.nCachedObjects_,d=this._indicesByUUID,e=this._bindings,f=e.length,g=0,h=arguments.length;g!==h;++g){var k=\narguments[g].uuid,l=d[k];if(void 0!==l)if(delete d[k],l<c){k=--c;var p=a[k],n=--b,t=a[n];d[p.uuid]=l;a[l]=p;d[t.uuid]=k;a[k]=t;a.pop();p=0;for(t=f;p!==t;++p){var u=e[p],r=u[n];u[l]=u[k];u[k]=r;u.pop()}}else for(n=--b,t=a[n],d[t.uuid]=l,a[l]=t,a.pop(),p=0,t=f;p!==t;++p)u=e[p],u[l]=u[n],u.pop()}this.nCachedObjects_=c},subscribe_:function(a,b){var c=this._bindingsIndicesByPath,d=c[a],e=this._bindings;if(void 0!==d)return e[d];var f=this._paths,g=this._parsedPaths,h=this._objects,k=this.nCachedObjects_,\nl=Array(h.length);d=e.length;c[a]=d;f.push(a);g.push(b);e.push(l);c=k;for(d=h.length;c!==d;++c)l[c]=new pa(h[c],a,b);return l},unsubscribe_:function(a){var b=this._bindingsIndicesByPath,c=b[a];if(void 0!==c){var d=this._paths,e=this._parsedPaths,f=this._bindings,g=f.length-1,h=f[g];b[a[g]]=c;f[c]=h;f.pop();e[c]=e[g];e.pop();d[c]=d[g];d.pop()}}});Object.assign(rf.prototype,{play:function(){this._mixer._activateAction(this);return this},stop:function(){this._mixer._deactivateAction(this);return this.reset()},\nreset:function(){this.paused=!1;this.enabled=!0;this.time=0;this._loopCount=-1;this._startTime=null;return this.stopFading().stopWarping()},isRunning:function(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)},isScheduled:function(){return this._mixer._isActiveAction(this)},startAt:function(a){this._startTime=a;return this},setLoop:function(a,b){this.loop=a;this.repetitions=b;return this},setEffectiveWeight:function(a){this.weight=a;\nthis._effectiveWeight=this.enabled?a:0;return this.stopFading()},getEffectiveWeight:function(){return this._effectiveWeight},fadeIn:function(a){return this._scheduleFading(a,0,1)},fadeOut:function(a){return this._scheduleFading(a,1,0)},crossFadeFrom:function(a,b,c){a.fadeOut(b);this.fadeIn(b);if(c){c=this._clip.duration;var d=a._clip.duration,e=c/d;a.warp(1,d/c,b);this.warp(e,1,b)}return this},crossFadeTo:function(a,b,c){return a.crossFadeFrom(this,b,c)},stopFading:function(){var a=this._weightInterpolant;\nnull!==a&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(a));return this},setEffectiveTimeScale:function(a){this.timeScale=a;this._effectiveTimeScale=this.paused?0:a;return this.stopWarping()},getEffectiveTimeScale:function(){return this._effectiveTimeScale},setDuration:function(a){this.timeScale=this._clip.duration/a;return this.stopWarping()},syncWith:function(a){this.time=a.time;this.timeScale=a.timeScale;return this.stopWarping()},halt:function(a){return this.warp(this._effectiveTimeScale,\n0,a)},warp:function(a,b,c){var d=this._mixer,e=d.time,f=this._timeScaleInterpolant,g=this.timeScale;null===f&&(this._timeScaleInterpolant=f=d._lendControlInterpolant());d=f.parameterPositions;f=f.sampleValues;d[0]=e;d[1]=e+c;f[0]=a/g;f[1]=b/g;return this},stopWarping:function(){var a=this._timeScaleInterpolant;null!==a&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(a));return this},getMixer:function(){return this._mixer},getClip:function(){return this._clip},getRoot:function(){return this._localRoot||\nthis._mixer._root},_update:function(a,b,c,d){if(this.enabled){var e=this._startTime;if(null!==e){b=(a-e)*c;if(0>b||0===c)return;this._startTime=null;b*=c}b*=this._updateTimeScale(a);c=this._updateTime(b);a=this._updateWeight(a);if(0<a){b=this._interpolants;e=this._propertyBindings;for(var f=0,g=b.length;f!==g;++f)b[f].evaluate(c),e[f].accumulate(d,a)}}else this._updateWeight(a)},_updateWeight:function(a){var b=0;if(this.enabled){b=this.weight;var c=this._weightInterpolant;if(null!==c){var d=c.evaluate(a)[0];\nb*=d;a>c.parameterPositions[1]&&(this.stopFading(),0===d&&(this.enabled=!1))}}return this._effectiveWeight=b},_updateTimeScale:function(a){var b=0;if(!this.paused){b=this.timeScale;var c=this._timeScaleInterpolant;if(null!==c){var d=c.evaluate(a)[0];b*=d;a>c.parameterPositions[1]&&(this.stopWarping(),0===b?this.paused=!0:this.timeScale=b)}}return this._effectiveTimeScale=b},_updateTime:function(a){var b=this.time+a,c=this._clip.duration,d=this.loop,e=this._loopCount,f=2202===d;if(0===a)return-1===\ne?b:f&&1===(e&1)?c-b:b;if(2200===d)a:{if(-1===e&&(this._loopCount=0,this._setEndings(!0,!0,!1)),b>=c)b=c;else if(0>b)b=0;else break a;this.clampWhenFinished?this.paused=!0:this.enabled=!1;this._mixer.dispatchEvent({type:\"finished\",action:this,direction:0>a?-1:1})}else{-1===e&&(0<=a?(e=0,this._setEndings(!0,0===this.repetitions,f)):this._setEndings(0===this.repetitions,!0,f));if(b>=c||0>b){d=Math.floor(b/c);b-=c*d;e+=Math.abs(d);var g=this.repetitions-e;0>=g?(this.clampWhenFinished?this.paused=!0:\nthis.enabled=!1,b=0<a?c:0,this._mixer.dispatchEvent({type:\"finished\",action:this,direction:0<a?1:-1})):(1===g?(a=0>a,this._setEndings(a,!a,f)):this._setEndings(!1,!1,f),this._loopCount=e,this._mixer.dispatchEvent({type:\"loop\",action:this,loopDelta:d}))}if(f&&1===(e&1))return this.time=b,c-b}return this.time=b},_setEndings:function(a,b,c){var d=this._interpolantSettings;c?(d.endingStart=2401,d.endingEnd=2401):(d.endingStart=a?this.zeroSlopeAtStart?2401:2400:2402,d.endingEnd=b?this.zeroSlopeAtEnd?2401:\n2400:2402)},_scheduleFading:function(a,b,c){var d=this._mixer,e=d.time,f=this._weightInterpolant;null===f&&(this._weightInterpolant=f=d._lendControlInterpolant());d=f.parameterPositions;f=f.sampleValues;d[0]=e;f[0]=b;d[1]=e+a;f[1]=c;return this}});re.prototype=Object.assign(Object.create(ya.prototype),{constructor:re,_bindAction:function(a,b){var c=a._localRoot||this._root,d=a._clip.tracks,e=d.length,f=a._propertyBindings;a=a._interpolants;var g=c.uuid,h=this._bindingsByRootAndName,k=h[g];void 0===\nk&&(k={},h[g]=k);for(h=0;h!==e;++h){var l=d[h],p=l.name,n=k[p];if(void 0===n){n=f[h];if(void 0!==n){null===n._cacheIndex&&(++n.referenceCount,this._addInactiveBinding(n,g,p));continue}n=new qe(pa.create(c,p,b&&b._propertyBindings[h].binding.parsedPath),l.ValueTypeName,l.getValueSize());++n.referenceCount;this._addInactiveBinding(n,g,p)}f[h]=n;a[h].resultBuffer=n.buffer}},_activateAction:function(a){if(!this._isActiveAction(a)){if(null===a._cacheIndex){var b=(a._localRoot||this._root).uuid,c=a._clip.uuid,\nd=this._actionsByClip[c];this._bindAction(a,d&&d.knownActions[0]);this._addInactiveAction(a,c,b)}b=a._propertyBindings;c=0;for(d=b.length;c!==d;++c){var e=b[c];0===e.useCount++&&(this._lendBinding(e),e.saveOriginalState())}this._lendAction(a)}},_deactivateAction:function(a){if(this._isActiveAction(a)){for(var b=a._propertyBindings,c=0,d=b.length;c!==d;++c){var e=b[c];0===--e.useCount&&(e.restoreOriginalState(),this._takeBackBinding(e))}this._takeBackAction(a)}},_initMemoryManager:function(){this._actions=\n[];this._nActiveActions=0;this._actionsByClip={};this._bindings=[];this._nActiveBindings=0;this._bindingsByRootAndName={};this._controlInterpolants=[];this._nActiveControlInterpolants=0;var a=this;this.stats={actions:{get total(){return a._actions.length},get inUse(){return a._nActiveActions}},bindings:{get total(){return a._bindings.length},get inUse(){return a._nActiveBindings}},controlInterpolants:{get total(){return a._controlInterpolants.length},get inUse(){return a._nActiveControlInterpolants}}}},\n_isActiveAction:function(a){a=a._cacheIndex;return null!==a&&a<this._nActiveActions},_addInactiveAction:function(a,b,c){var d=this._actions,e=this._actionsByClip,f=e[b];void 0===f?(f={knownActions:[a],actionByRoot:{}},a._byClipCacheIndex=0,e[b]=f):(b=f.knownActions,a._byClipCacheIndex=b.length,b.push(a));a._cacheIndex=d.length;d.push(a);f.actionByRoot[c]=a},_removeInactiveAction:function(a){var b=this._actions,c=b[b.length-1],d=a._cacheIndex;c._cacheIndex=d;b[d]=c;b.pop();a._cacheIndex=null;b=a._clip.uuid;\nc=this._actionsByClip;d=c[b];var e=d.knownActions,f=e[e.length-1],g=a._byClipCacheIndex;f._byClipCacheIndex=g;e[g]=f;e.pop();a._byClipCacheIndex=null;delete d.actionByRoot[(a._localRoot||this._root).uuid];0===e.length&&delete c[b];this._removeInactiveBindingsForAction(a)},_removeInactiveBindingsForAction:function(a){a=a._propertyBindings;for(var b=0,c=a.length;b!==c;++b){var d=a[b];0===--d.referenceCount&&this._removeInactiveBinding(d)}},_lendAction:function(a){var b=this._actions,c=a._cacheIndex,\nd=this._nActiveActions++,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_takeBackAction:function(a){var b=this._actions,c=a._cacheIndex,d=--this._nActiveActions,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_addInactiveBinding:function(a,b,c){var d=this._bindingsByRootAndName,e=d[b],f=this._bindings;void 0===e&&(e={},d[b]=e);e[c]=a;a._cacheIndex=f.length;f.push(a)},_removeInactiveBinding:function(a){var b=this._bindings,c=a.binding,d=c.rootNode.uuid;c=c.path;var e=this._bindingsByRootAndName,\nf=e[d],g=b[b.length-1];a=a._cacheIndex;g._cacheIndex=a;b[a]=g;b.pop();delete f[c];a:{for(var h in f)break a;delete e[d]}},_lendBinding:function(a){var b=this._bindings,c=a._cacheIndex,d=this._nActiveBindings++,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_takeBackBinding:function(a){var b=this._bindings,c=a._cacheIndex,d=--this._nActiveBindings,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_lendControlInterpolant:function(){var a=this._controlInterpolants,b=this._nActiveControlInterpolants++,\nc=a[b];void 0===c&&(c=new bd(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),c.__cacheIndex=b,a[b]=c);return c},_takeBackControlInterpolant:function(a){var b=this._controlInterpolants,c=a.__cacheIndex,d=--this._nActiveControlInterpolants,e=b[d];a.__cacheIndex=d;b[d]=a;e.__cacheIndex=c;b[c]=e},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(a,b){var c=b||this._root,d=c.uuid;c=\"string\"===typeof a?Ca.findByName(c,a):a;a=null!==c?c.uuid:a;var e=\nthis._actionsByClip[a],f=null;if(void 0!==e){f=e.actionByRoot[d];if(void 0!==f)return f;f=e.knownActions[0];null===c&&(c=f._clip)}if(null===c)return null;b=new rf(this,c,b);this._bindAction(b,f);this._addInactiveAction(b,a,d);return b},existingAction:function(a,b){var c=b||this._root;b=c.uuid;c=\"string\"===typeof a?Ca.findByName(c,a):a;a=this._actionsByClip[c?c.uuid:a];return void 0!==a?a.actionByRoot[b]||null:null},stopAllAction:function(){for(var a=this._actions,b=this._nActiveActions,c=this._bindings,\nd=this._nActiveBindings,e=this._nActiveBindings=this._nActiveActions=0;e!==b;++e)a[e].reset();for(e=0;e!==d;++e)c[e].useCount=0;return this},update:function(a){a*=this.timeScale;for(var b=this._actions,c=this._nActiveActions,d=this.time+=a,e=Math.sign(a),f=this._accuIndex^=1,g=0;g!==c;++g)b[g]._update(d,a,e,f);a=this._bindings;b=this._nActiveBindings;for(g=0;g!==b;++g)a[g].apply(f);return this},getRoot:function(){return this._root},uncacheClip:function(a){var b=this._actions;a=a.uuid;var c=this._actionsByClip,\nd=c[a];if(void 0!==d){d=d.knownActions;for(var e=0,f=d.length;e!==f;++e){var g=d[e];this._deactivateAction(g);var h=g._cacheIndex,k=b[b.length-1];g._cacheIndex=null;g._byClipCacheIndex=null;k._cacheIndex=h;b[h]=k;b.pop();this._removeInactiveBindingsForAction(g)}delete c[a]}},uncacheRoot:function(a){a=a.uuid;var b=this._actionsByClip;for(d in b){var c=b[d].actionByRoot[a];void 0!==c&&(this._deactivateAction(c),this._removeInactiveAction(c))}var d=this._bindingsByRootAndName[a];if(void 0!==d)for(var e in d)a=\nd[e],a.restoreOriginalState(),this._removeInactiveBinding(a)},uncacheAction:function(a,b){a=this.existingAction(a,b);null!==a&&(this._deactivateAction(a),this._removeInactiveAction(a))}});Ld.prototype.clone=function(){return new Ld(void 0===this.value.clone?this.value:this.value.clone())};se.prototype=Object.assign(Object.create(C.prototype),{constructor:se,isInstancedBufferGeometry:!0,copy:function(a){C.prototype.copy.call(this,a);this.maxInstancedCount=a.maxInstancedCount;return this},clone:function(){return(new this.constructor).copy(this)}});\nte.prototype=Object.assign(Object.create(ob.prototype),{constructor:te,isInstancedInterleavedBuffer:!0,copy:function(a){ob.prototype.copy.call(this,a);this.meshPerAttribute=a.meshPerAttribute;return this}});ue.prototype=Object.assign(Object.create(Q.prototype),{constructor:ue,isInstancedBufferAttribute:!0,copy:function(a){Q.prototype.copy.call(this,a);this.meshPerAttribute=a.meshPerAttribute;return this}});Object.assign(sf.prototype,{linePrecision:1,set:function(a,b){this.ray.set(a,b)},setFromCamera:function(a,\nb){b&&b.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(b.matrixWorld),this.ray.direction.set(a.x,a.y,.5).unproject(b).sub(this.ray.origin).normalize()):b&&b.isOrthographicCamera?(this.ray.origin.set(a.x,a.y,(b.near+b.far)/(b.near-b.far)).unproject(b),this.ray.direction.set(0,0,-1).transformDirection(b.matrixWorld)):console.error(\"THREE.Raycaster: Unsupported camera type.\")},intersectObject:function(a,b,c){c=c||[];ve(a,this,c,b);c.sort(tf);return c},intersectObjects:function(a,b,c){c=c||\n[];if(!1===Array.isArray(a))return console.warn(\"THREE.Raycaster.intersectObjects: objects is not an Array.\"),c;for(var d=0,e=a.length;d<e;d++)ve(a[d],this,c,b);c.sort(tf);return c}});Object.assign(uf.prototype,{start:function(){this.oldTime=this.startTime=(\"undefined\"===typeof performance?Date:performance).now();this.elapsedTime=0;this.running=!0},stop:function(){this.getElapsedTime();this.autoStart=this.running=!1},getElapsedTime:function(){this.getDelta();return this.elapsedTime},getDelta:function(){var a=\n0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){var b=(\"undefined\"===typeof performance?Date:performance).now();a=(b-this.oldTime)/1E3;this.oldTime=b;this.elapsedTime+=a}return a}});Object.assign(vf.prototype,{set:function(a,b,c){this.radius=a;this.phi=b;this.theta=c;return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.radius=a.radius;this.phi=a.phi;this.theta=a.theta;return this},makeSafe:function(){this.phi=Math.max(1E-6,Math.min(Math.PI-\n1E-6,this.phi));return this},setFromVector3:function(a){this.radius=a.length();0===this.radius?this.phi=this.theta=0:(this.theta=Math.atan2(a.x,a.z),this.phi=Math.acos(H.clamp(a.y/this.radius,-1,1)));return this}});Object.assign(wf.prototype,{set:function(a,b,c){this.radius=a;this.theta=b;this.y=c;return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.radius=a.radius;this.theta=a.theta;this.y=a.y;return this},setFromVector3:function(a){this.radius=Math.sqrt(a.x*\na.x+a.z*a.z);this.theta=Math.atan2(a.x,a.z);this.y=a.y;return this}});Object.assign(we.prototype,{set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=new z;return function(b,c){c=a.copy(c).multiplyScalar(.5);this.min.copy(b).sub(c);this.max.copy(b).add(c);return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.min.copy(a.min);\nthis.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=Infinity;this.max.x=this.max.y=-Infinity;return this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},getCenter:function(a){void 0===a&&(console.warn(\"THREE.Box2: .getCenter() target is now required\"),a=new z);return this.isEmpty()?a.set(0,0):a.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(a){void 0===a&&(console.warn(\"THREE.Box2: .getSize() target is now required\"),a=new z);return this.isEmpty()?\na.set(0,0):a.subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y},getParameter:function(a,\nb){void 0===b&&(console.warn(\"THREE.Box2: .getParameter() target is now required\"),b=new z);return b.set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y))},intersectsBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y?!1:!0},clampPoint:function(a,b){void 0===b&&(console.warn(\"THREE.Box2: .clampPoint() target is now required\"),b=new z);return b.copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new z;\nreturn function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)}});Object.assign(xe.prototype,{set:function(a,b){this.start.copy(a);this.end.copy(b);return this},clone:function(){return(new this.constructor).copy(this)},\ncopy:function(a){this.start.copy(a.start);this.end.copy(a.end);return this},getCenter:function(a){void 0===a&&(console.warn(\"THREE.Line3: .getCenter() target is now required\"),a=new p);return a.addVectors(this.start,this.end).multiplyScalar(.5)},delta:function(a){void 0===a&&(console.warn(\"THREE.Line3: .delta() target is now required\"),a=new p);return a.subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},\nat:function(a,b){void 0===b&&(console.warn(\"THREE.Line3: .at() target is now required\"),b=new p);return this.delta(b).multiplyScalar(a).add(this.start)},closestPointToPointParameter:function(){var a=new p,b=new p;return function(c,d){a.subVectors(c,this.start);b.subVectors(this.end,this.start);c=b.dot(b);c=b.dot(a)/c;d&&(c=H.clamp(c,0,1));return c}}(),closestPointToPoint:function(a,b,c){a=this.closestPointToPointParameter(a,b);void 0===c&&(console.warn(\"THREE.Line3: .closestPointToPoint() target is now required\"),\nc=new p);return this.delta(c).multiplyScalar(a).add(this.start)},applyMatrix4:function(a){this.start.applyMatrix4(a);this.end.applyMatrix4(a);return this},equals:function(a){return a.start.equals(this.start)&&a.end.equals(this.end)}});ed.prototype=Object.create(D.prototype);ed.prototype.constructor=ed;ed.prototype.isImmediateRenderObject=!0;fd.prototype=Object.create(W.prototype);fd.prototype.constructor=fd;fd.prototype.update=function(){var a=new p,b=new p,c=new ra;return function(){var d=[\"a\",\"b\",\n\"c\"];this.object.updateMatrixWorld(!0);c.getNormalMatrix(this.object.matrixWorld);var e=this.object.matrixWorld,f=this.geometry.attributes.position,g=this.object.geometry;if(g&&g.isGeometry)for(var h=g.vertices,k=g.faces,l=g=0,p=k.length;l<p;l++)for(var n=k[l],t=0,u=n.vertexNormals.length;t<u;t++){var r=n.vertexNormals[t];a.copy(h[n[d[t]]]).applyMatrix4(e);b.copy(r).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);f.setXYZ(g,a.x,a.y,a.z);g+=1;f.setXYZ(g,b.x,b.y,b.z);g+=1}else if(g&&g.isBufferGeometry)for(d=\ng.attributes.position,h=g.attributes.normal,t=g=0,u=d.count;t<u;t++)a.set(d.getX(t),d.getY(t),d.getZ(t)).applyMatrix4(e),b.set(h.getX(t),h.getY(t),h.getZ(t)),b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a),f.setXYZ(g,a.x,a.y,a.z),g+=1,f.setXYZ(g,b.x,b.y,b.z),g+=1;f.needsUpdate=!0}}();ic.prototype=Object.create(D.prototype);ic.prototype.constructor=ic;ic.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose()};ic.prototype.update=function(){var a=new p,\nb=new p;return function(){this.light.updateMatrixWorld();var c=this.light.distance?this.light.distance:1E3,d=c*Math.tan(this.light.angle);this.cone.scale.set(d,d,c);a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(b.sub(a));void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}();jc.prototype=Object.create(W.prototype);jc.prototype.constructor=jc;jc.prototype.updateMatrixWorld=\nfunction(){var a=new p,b=new I,c=new I;return function(d){var e=this.bones,f=this.geometry,g=f.getAttribute(\"position\");c.getInverse(this.root.matrixWorld);for(var h=0,k=0;h<e.length;h++){var l=e[h];l.parent&&l.parent.isBone&&(b.multiplyMatrices(c,l.matrixWorld),a.setFromMatrixPosition(b),g.setXYZ(k,a.x,a.y,a.z),b.multiplyMatrices(c,l.parent.matrixWorld),a.setFromMatrixPosition(b),g.setXYZ(k+1,a.x,a.y,a.z),k+=2)}f.getAttribute(\"position\").needsUpdate=!0;D.prototype.updateMatrixWorld.call(this,d)}}();\nkc.prototype=Object.create(la.prototype);kc.prototype.constructor=kc;kc.prototype.dispose=function(){this.geometry.dispose();this.material.dispose()};kc.prototype.update=function(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)};lc.prototype=Object.create(D.prototype);lc.prototype.constructor=lc;lc.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose()};lc.prototype.update=function(){var a=.5*this.light.width,\nb=.5*this.light.height,c=this.line.geometry.attributes.position,d=c.array;d[0]=a;d[1]=-b;d[2]=0;d[3]=a;d[4]=b;d[5]=0;d[6]=-a;d[7]=b;d[8]=0;d[9]=-a;d[10]=-b;d[11]=0;d[12]=a;d[13]=-b;d[14]=0;c.needsUpdate=!0;void 0!==this.color?this.line.material.color.set(this.color):this.line.material.color.copy(this.light.color)};mc.prototype=Object.create(D.prototype);mc.prototype.constructor=mc;mc.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose()};mc.prototype.update=\nfunction(){var a=new p,b=new G,c=new G;return function(){var d=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{var e=d.geometry.getAttribute(\"color\");b.copy(this.light.color);c.copy(this.light.groundColor);for(var f=0,g=e.count;f<g;f++){var h=f<g/2?b:c;e.setXYZ(f,h.r,h.g,h.b)}e.needsUpdate=!0}d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate())}}();gd.prototype=Object.create(W.prototype);gd.prototype.constructor=gd;Md.prototype=Object.create(W.prototype);\nMd.prototype.constructor=Md;hd.prototype=Object.create(W.prototype);hd.prototype.constructor=hd;hd.prototype.update=function(){var a=new p,b=new p,c=new ra;return function(){this.object.updateMatrixWorld(!0);c.getNormalMatrix(this.object.matrixWorld);var d=this.object.matrixWorld,e=this.geometry.attributes.position,f=this.object.geometry,g=f.vertices;f=f.faces;for(var h=0,k=0,l=f.length;k<l;k++){var p=f[k],n=p.normal;a.copy(g[p.a]).add(g[p.b]).add(g[p.c]).divideScalar(3).applyMatrix4(d);b.copy(n).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);\ne.setXYZ(h,a.x,a.y,a.z);h+=1;e.setXYZ(h,b.x,b.y,b.z);h+=1}e.needsUpdate=!0}}();nc.prototype=Object.create(D.prototype);nc.prototype.constructor=nc;nc.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose()};nc.prototype.update=function(){var a=new p,b=new p,c=new p;return function(){a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);c.subVectors(b,\na);this.lightPlane.lookAt(c);void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color));this.targetLine.lookAt(c);this.targetLine.scale.z=c.length()}}();id.prototype=Object.create(W.prototype);id.prototype.constructor=id;id.prototype.update=function(){function a(a,g,h,k){d.set(g,h,k).unproject(e);a=c[a];if(void 0!==a)for(g=b.getAttribute(\"position\"),\nh=0,k=a.length;h<k;h++)g.setXYZ(a[h],d.x,d.y,d.z)}var b,c,d=new p,e=new Na;return function(){b=this.geometry;c=this.pointMap;e.projectionMatrix.copy(this.camera.projectionMatrix);a(\"c\",0,0,-1);a(\"t\",0,0,1);a(\"n1\",-1,-1,-1);a(\"n2\",1,-1,-1);a(\"n3\",-1,1,-1);a(\"n4\",1,1,-1);a(\"f1\",-1,-1,1);a(\"f2\",1,-1,1);a(\"f3\",-1,1,1);a(\"f4\",1,1,1);a(\"u1\",.7,1.1,-1);a(\"u2\",-.7,1.1,-1);a(\"u3\",0,2,-1);a(\"cf1\",-1,0,1);a(\"cf2\",1,0,1);a(\"cf3\",0,-1,1);a(\"cf4\",0,1,1);a(\"cn1\",-1,0,-1);a(\"cn2\",1,0,-1);a(\"cn3\",0,-1,-1);a(\"cn4\",\n0,1,-1);b.getAttribute(\"position\").needsUpdate=!0}}();Db.prototype=Object.create(W.prototype);Db.prototype.constructor=Db;Db.prototype.update=function(){var a=new Sa;return function(b){void 0!==b&&console.warn(\"THREE.BoxHelper: .update() has no longer arguments.\");void 0!==this.object&&a.setFromObject(this.object);if(!a.isEmpty()){b=a.min;var c=a.max,d=this.geometry.attributes.position,e=d.array;e[0]=c.x;e[1]=c.y;e[2]=c.z;e[3]=b.x;e[4]=c.y;e[5]=c.z;e[6]=b.x;e[7]=b.y;e[8]=c.z;e[9]=c.x;e[10]=b.y;e[11]=\nc.z;e[12]=c.x;e[13]=c.y;e[14]=b.z;e[15]=b.x;e[16]=c.y;e[17]=b.z;e[18]=b.x;e[19]=b.y;e[20]=b.z;e[21]=c.x;e[22]=b.y;e[23]=b.z;d.needsUpdate=!0;this.geometry.computeBoundingSphere()}}}();Db.prototype.setFromObject=function(a){this.object=a;this.update();return this};jd.prototype=Object.create(W.prototype);jd.prototype.constructor=jd;jd.prototype.updateMatrixWorld=function(a){var b=this.box;b.isEmpty()||(b.getCenter(this.position),b.getSize(this.scale),this.scale.multiplyScalar(.5),D.prototype.updateMatrixWorld.call(this,\na))};kd.prototype=Object.create(sa.prototype);kd.prototype.constructor=kd;kd.prototype.updateMatrixWorld=function(a){var b=-this.plane.constant;1E-8>Math.abs(b)&&(b=1E-8);this.scale.set(.5*this.size,.5*this.size,b);this.children[0].material.side=0>b?1:0;this.lookAt(this.plane.normal);D.prototype.updateMatrixWorld.call(this,a)};var Nd,ye;Eb.prototype=Object.create(D.prototype);Eb.prototype.constructor=Eb;Eb.prototype.setDirection=function(){var a=new p,b;return function(c){.99999<c.y?this.quaternion.set(0,\n0,0,1):-.99999>c.y?this.quaternion.set(1,0,0,0):(a.set(c.z,0,-c.x).normalize(),b=Math.acos(c.y),this.quaternion.setFromAxisAngle(a,b))}}();Eb.prototype.setLength=function(a,b,c){void 0===b&&(b=.2*a);void 0===c&&(c=.2*b);this.line.scale.set(1,Math.max(0,a-b),1);this.line.updateMatrix();this.cone.scale.set(c,b,c);this.cone.position.y=a;this.cone.updateMatrix()};Eb.prototype.setColor=function(a){this.line.material.color.copy(a);this.cone.material.color.copy(a)};ld.prototype=Object.create(W.prototype);\nld.prototype.constructor=ld;L.create=function(a,b){console.log(\"THREE.Curve.create() has been deprecated\");a.prototype=Object.create(L.prototype);a.prototype.constructor=a;a.prototype.getPoint=b;return a};Object.assign(Xa.prototype,{createPointsGeometry:function(a){console.warn(\"THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.\");a=this.getPoints(a);return this.createGeometry(a)},createSpacedPointsGeometry:function(a){console.warn(\"THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.\");\na=this.getSpacedPoints(a);return this.createGeometry(a)},createGeometry:function(a){console.warn(\"THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.\");for(var b=new R,c=0,d=a.length;c<d;c++){var e=a[c];b.vertices.push(new p(e.x,e.y,e.z||0))}return b}});Object.assign(La.prototype,{fromPoints:function(a){console.warn(\"THREE.Path: .fromPoints() has been renamed to .setFromPoints().\");this.setFromPoints(a)}});yf.prototype=Object.create(ca.prototype);\nzf.prototype=Object.create(ca.prototype);ze.prototype=Object.create(ca.prototype);Object.assign(ze.prototype,{initFromArray:function(){console.error(\"THREE.Spline: .initFromArray() has been removed.\")},getControlPointsArray:function(){console.error(\"THREE.Spline: .getControlPointsArray() has been removed.\")},reparametrizeByArcLength:function(){console.error(\"THREE.Spline: .reparametrizeByArcLength() has been removed.\")}});gd.prototype.setColors=function(){console.error(\"THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.\")};\njc.prototype.update=function(){console.error(\"THREE.SkeletonHelper: update() no longer needs to be called.\")};Object.assign(gc.prototype,{extractUrlBase:function(a){console.warn(\"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.\");return De.extractUrlBase(a)}});Object.assign(we.prototype,{center:function(a){console.warn(\"THREE.Box2: .center() has been renamed to .getCenter().\");return this.getCenter(a)},empty:function(){console.warn(\"THREE.Box2: .empty() has been renamed to .isEmpty().\");\nreturn this.isEmpty()},isIntersectionBox:function(a){console.warn(\"THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().\");return this.intersectsBox(a)},size:function(a){console.warn(\"THREE.Box2: .size() has been renamed to .getSize().\");return this.getSize(a)}});Object.assign(Sa.prototype,{center:function(a){console.warn(\"THREE.Box3: .center() has been renamed to .getCenter().\");return this.getCenter(a)},empty:function(){console.warn(\"THREE.Box3: .empty() has been renamed to .isEmpty().\");\nreturn this.isEmpty()},isIntersectionBox:function(a){console.warn(\"THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().\");return this.intersectsBox(a)},isIntersectionSphere:function(a){console.warn(\"THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().\");return this.intersectsSphere(a)},size:function(a){console.warn(\"THREE.Box3: .size() has been renamed to .getSize().\");return this.getSize(a)}});xe.prototype.center=function(a){console.warn(\"THREE.Line3: .center() has been renamed to .getCenter().\");\nreturn this.getCenter(a)};Object.assign(H,{random16:function(){console.warn(\"THREE.Math: .random16() has been deprecated. Use Math.random() instead.\");return Math.random()},nearestPowerOfTwo:function(a){console.warn(\"THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().\");return H.floorPowerOfTwo(a)},nextPowerOfTwo:function(a){console.warn(\"THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().\");return H.ceilPowerOfTwo(a)}});Object.assign(ra.prototype,{flattenToArrayOffset:function(a,\nb){console.warn(\"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\");return this.toArray(a,b)},multiplyVector3:function(a){console.warn(\"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.\");return a.applyMatrix3(this)},multiplyVector3Array:function(){console.error(\"THREE.Matrix3: .multiplyVector3Array() has been removed.\")},applyToBuffer:function(a){console.warn(\"THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.\");\nreturn this.applyToBufferAttribute(a)},applyToVector3Array:function(){console.error(\"THREE.Matrix3: .applyToVector3Array() has been removed.\")}});Object.assign(I.prototype,{extractPosition:function(a){console.warn(\"THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().\");return this.copyPosition(a)},flattenToArrayOffset:function(a,b){console.warn(\"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\");return this.toArray(a,b)},getPosition:function(){var a;\nreturn function(){void 0===a&&(a=new p);console.warn(\"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.\");return a.setFromMatrixColumn(this,3)}}(),setRotationFromQuaternion:function(a){console.warn(\"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().\");return this.makeRotationFromQuaternion(a)},multiplyToArray:function(){console.warn(\"THREE.Matrix4: .multiplyToArray() has been removed.\")},multiplyVector3:function(a){console.warn(\"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.\");\nreturn a.applyMatrix4(this)},multiplyVector4:function(a){console.warn(\"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.\");return a.applyMatrix4(this)},multiplyVector3Array:function(){console.error(\"THREE.Matrix4: .multiplyVector3Array() has been removed.\")},rotateAxis:function(a){console.warn(\"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.\");a.transformDirection(this)},crossVector:function(a){console.warn(\"THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.\");\nreturn a.applyMatrix4(this)},translate:function(){console.error(\"THREE.Matrix4: .translate() has been removed.\")},rotateX:function(){console.error(\"THREE.Matrix4: .rotateX() has been removed.\")},rotateY:function(){console.error(\"THREE.Matrix4: .rotateY() has been removed.\")},rotateZ:function(){console.error(\"THREE.Matrix4: .rotateZ() has been removed.\")},rotateByAxis:function(){console.error(\"THREE.Matrix4: .rotateByAxis() has been removed.\")},applyToBuffer:function(a){console.warn(\"THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.\");\nreturn this.applyToBufferAttribute(a)},applyToVector3Array:function(){console.error(\"THREE.Matrix4: .applyToVector3Array() has been removed.\")},makeFrustum:function(a,b,c,d,e,f){console.warn(\"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.\");return this.makePerspective(a,b,d,c,e,f)}});Ma.prototype.isIntersectionLine=function(a){console.warn(\"THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().\");return this.intersectsLine(a)};\nfa.prototype.multiplyVector3=function(a){console.warn(\"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.\");return a.applyQuaternion(this)};Object.assign(mb.prototype,{isIntersectionBox:function(a){console.warn(\"THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().\");return this.intersectsBox(a)},isIntersectionPlane:function(a){console.warn(\"THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().\");return this.intersectsPlane(a)},\nisIntersectionSphere:function(a){console.warn(\"THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().\");return this.intersectsSphere(a)}});Object.assign(ja.prototype,{area:function(){console.warn(\"THREE.Triangle: .area() has been renamed to .getArea().\");return this.getArea()},barycoordFromPoint:function(a,b){console.warn(\"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().\");return this.getBarycoord(a,b)},midpoint:function(a){console.warn(\"THREE.Triangle: .midpoint() has been renamed to .getMidpoint().\");\nreturn this.getMidpoint(a)},normal:function(a){console.warn(\"THREE.Triangle: .normal() has been renamed to .getNormal().\");return this.getNormal(a)},plane:function(a){console.warn(\"THREE.Triangle: .plane() has been renamed to .getPlane().\");return this.getPlane(a)}});Object.assign(ja,{barycoordFromPoint:function(a,b,c,d,e){console.warn(\"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().\");return ja.getBarycoord(a,b,c,d,e)},normal:function(a,b,c,d){console.warn(\"THREE.Triangle: .normal() has been renamed to .getNormal().\");\nreturn ja.getNormal(a,b,c,d)}});Object.assign(db.prototype,{extractAllPoints:function(a){console.warn(\"THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.\");return this.extractPoints(a)},extrude:function(a){console.warn(\"THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.\");return new rb(this,a)},makeGeometry:function(a){console.warn(\"THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.\");return new tb(this,a)}});Object.assign(z.prototype,\n{fromAttribute:function(a,b,c){console.warn(\"THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().\");return this.fromBufferAttribute(a,b,c)},distanceToManhattan:function(a){console.warn(\"THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().\");return this.manhattanDistanceTo(a)},lengthManhattan:function(){console.warn(\"THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().\");return this.manhattanLength()}});Object.assign(p.prototype,\n{setEulerFromRotationMatrix:function(){console.error(\"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.\")},setEulerFromQuaternion:function(){console.error(\"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.\")},getPositionFromMatrix:function(a){console.warn(\"THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().\");return this.setFromMatrixPosition(a)},getScaleFromMatrix:function(a){console.warn(\"THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().\");\nreturn this.setFromMatrixScale(a)},getColumnFromMatrix:function(a,b){console.warn(\"THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().\");return this.setFromMatrixColumn(b,a)},applyProjection:function(a){console.warn(\"THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.\");return this.applyMatrix4(a)},fromAttribute:function(a,b,c){console.warn(\"THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().\");return this.fromBufferAttribute(a,\nb,c)},distanceToManhattan:function(a){console.warn(\"THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().\");return this.manhattanDistanceTo(a)},lengthManhattan:function(){console.warn(\"THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().\");return this.manhattanLength()}});Object.assign(V.prototype,{fromAttribute:function(a,b,c){console.warn(\"THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().\");return this.fromBufferAttribute(a,\nb,c)},lengthManhattan:function(){console.warn(\"THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().\");return this.manhattanLength()}});Object.assign(R.prototype,{computeTangents:function(){console.error(\"THREE.Geometry: .computeTangents() has been removed.\")},computeLineDistances:function(){console.error(\"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\")}});Object.assign(D.prototype,{getChildByName:function(a){console.warn(\"THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().\");\nreturn this.getObjectByName(a)},renderDepth:function(){console.warn(\"THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.\")},translate:function(a,b){console.warn(\"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.\");return this.translateOnAxis(b,a)},getWorldRotation:function(){console.error(\"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.\")}});Object.defineProperties(D.prototype,\n{eulerOrder:{get:function(){console.warn(\"THREE.Object3D: .eulerOrder is now .rotation.order.\");return this.rotation.order},set:function(a){console.warn(\"THREE.Object3D: .eulerOrder is now .rotation.order.\");this.rotation.order=a}},useQuaternion:{get:function(){console.warn(\"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.\")},set:function(){console.warn(\"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.\")}}});\nObject.defineProperties(Bc.prototype,{objects:{get:function(){console.warn(\"THREE.LOD: .objects has been renamed to .levels.\");return this.levels}}});Object.defineProperty(Cc.prototype,\"useVertexTexture\",{get:function(){console.warn(\"THREE.Skeleton: useVertexTexture has been removed.\")},set:function(){console.warn(\"THREE.Skeleton: useVertexTexture has been removed.\")}});Object.defineProperty(L.prototype,\"__arcLengthDivisions\",{get:function(){console.warn(\"THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.\");\nreturn this.arcLengthDivisions},set:function(a){console.warn(\"THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.\");this.arcLengthDivisions=a}});Z.prototype.setLens=function(a,b){console.warn(\"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.\");void 0!==b&&(this.filmGauge=b);this.setFocalLength(a)};Object.defineProperties(X.prototype,{onlyShadow:{set:function(){console.warn(\"THREE.Light: .onlyShadow has been removed.\")}},shadowCameraFov:{set:function(a){console.warn(\"THREE.Light: .shadowCameraFov is now .shadow.camera.fov.\");\nthis.shadow.camera.fov=a}},shadowCameraLeft:{set:function(a){console.warn(\"THREE.Light: .shadowCameraLeft is now .shadow.camera.left.\");this.shadow.camera.left=a}},shadowCameraRight:{set:function(a){console.warn(\"THREE.Light: .shadowCameraRight is now .shadow.camera.right.\");this.shadow.camera.right=a}},shadowCameraTop:{set:function(a){console.warn(\"THREE.Light: .shadowCameraTop is now .shadow.camera.top.\");this.shadow.camera.top=a}},shadowCameraBottom:{set:function(a){console.warn(\"THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.\");\nthis.shadow.camera.bottom=a}},shadowCameraNear:{set:function(a){console.warn(\"THREE.Light: .shadowCameraNear is now .shadow.camera.near.\");this.shadow.camera.near=a}},shadowCameraFar:{set:function(a){console.warn(\"THREE.Light: .shadowCameraFar is now .shadow.camera.far.\");this.shadow.camera.far=a}},shadowCameraVisible:{set:function(){console.warn(\"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.\")}},shadowBias:{set:function(a){console.warn(\"THREE.Light: .shadowBias is now .shadow.bias.\");\nthis.shadow.bias=a}},shadowDarkness:{set:function(){console.warn(\"THREE.Light: .shadowDarkness has been removed.\")}},shadowMapWidth:{set:function(a){console.warn(\"THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.\");this.shadow.mapSize.width=a}},shadowMapHeight:{set:function(a){console.warn(\"THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.\");this.shadow.mapSize.height=a}}});Object.defineProperties(Q.prototype,{length:{get:function(){console.warn(\"THREE.BufferAttribute: .length has been deprecated. Use .count instead.\");\nreturn this.array.length}},copyIndicesArray:function(){console.error(\"THREE.BufferAttribute: .copyIndicesArray() has been removed.\")}});Object.assign(C.prototype,{addIndex:function(a){console.warn(\"THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().\");this.setIndex(a)},addDrawCall:function(a,b,c){void 0!==c&&console.warn(\"THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.\");console.warn(\"THREE.BufferGeometry: .addDrawCall() is now .addGroup().\");this.addGroup(a,b)},\nclearDrawCalls:function(){console.warn(\"THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().\");this.clearGroups()},computeTangents:function(){console.warn(\"THREE.BufferGeometry: .computeTangents() has been removed.\")},computeOffsets:function(){console.warn(\"THREE.BufferGeometry: .computeOffsets() has been removed.\")}});Object.defineProperties(C.prototype,{drawcalls:{get:function(){console.error(\"THREE.BufferGeometry: .drawcalls has been renamed to .groups.\");return this.groups}},offsets:{get:function(){console.warn(\"THREE.BufferGeometry: .offsets has been renamed to .groups.\");\nreturn this.groups}}});Object.assign(Oa.prototype,{getArrays:function(){console.error(\"THREE.ExtrudeBufferGeometry: .getArrays() has been removed.\")},addShapeList:function(){console.error(\"THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.\")},addShape:function(){console.error(\"THREE.ExtrudeBufferGeometry: .addShape() has been removed.\")}});Object.defineProperties(Ld.prototype,{dynamic:{set:function(){console.warn(\"THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.\")}},\nonUpdate:{value:function(){console.warn(\"THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.\");return this}}});Object.defineProperties(J.prototype,{wrapAround:{get:function(){console.warn(\"THREE.Material: .wrapAround has been removed.\")},set:function(){console.warn(\"THREE.Material: .wrapAround has been removed.\")}},wrapRGB:{get:function(){console.warn(\"THREE.Material: .wrapRGB has been removed.\");return new G}},shading:{get:function(){console.error(\"THREE.\"+this.type+\n\": .shading has been removed. Use the boolean .flatShading instead.\")},set:function(a){console.warn(\"THREE.\"+this.type+\": .shading has been removed. Use the boolean .flatShading instead.\");this.flatShading=1===a}}});Object.defineProperties(Fa.prototype,{metal:{get:function(){console.warn(\"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.\");return!1},set:function(){console.warn(\"THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead\")}}});\nObject.defineProperties(ta.prototype,{derivatives:{get:function(){console.warn(\"THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.\");return this.extensions.derivatives},set:function(a){console.warn(\"THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.\");this.extensions.derivatives=a}}});Object.assign(Zd.prototype,{animate:function(a){console.warn(\"THREE.WebGLRenderer: .animate() is now .setAnimationLoop().\");this.setAnimationLoop(a)},getCurrentRenderTarget:function(){console.warn(\"THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().\");\nreturn this.getRenderTarget()},getMaxAnisotropy:function(){console.warn(\"THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().\");return this.capabilities.getMaxAnisotropy()},getPrecision:function(){console.warn(\"THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.\");return this.capabilities.precision},resetGLState:function(){console.warn(\"THREE.WebGLRenderer: .resetGLState() is now .state.reset().\");return this.state.reset()},supportsFloatTextures:function(){console.warn(\"THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).\");\nreturn this.extensions.get(\"OES_texture_float\")},supportsHalfFloatTextures:function(){console.warn(\"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).\");return this.extensions.get(\"OES_texture_half_float\")},supportsStandardDerivatives:function(){console.warn(\"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).\");return this.extensions.get(\"OES_standard_derivatives\")},supportsCompressedTextureS3TC:function(){console.warn(\"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).\");\nreturn this.extensions.get(\"WEBGL_compressed_texture_s3tc\")},supportsCompressedTexturePVRTC:function(){console.warn(\"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).\");return this.extensions.get(\"WEBGL_compressed_texture_pvrtc\")},supportsBlendMinMax:function(){console.warn(\"THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).\");return this.extensions.get(\"EXT_blend_minmax\")},supportsVertexTextures:function(){console.warn(\"THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.\");\nreturn this.capabilities.vertexTextures},supportsInstancedArrays:function(){console.warn(\"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).\");return this.extensions.get(\"ANGLE_instanced_arrays\")},enableScissorTest:function(a){console.warn(\"THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().\");this.setScissorTest(a)},initMaterial:function(){console.warn(\"THREE.WebGLRenderer: .initMaterial() has been removed.\")},addPrePlugin:function(){console.warn(\"THREE.WebGLRenderer: .addPrePlugin() has been removed.\")},\naddPostPlugin:function(){console.warn(\"THREE.WebGLRenderer: .addPostPlugin() has been removed.\")},updateShadowMap:function(){console.warn(\"THREE.WebGLRenderer: .updateShadowMap() has been removed.\")},setFaceCulling:function(){console.warn(\"THREE.WebGLRenderer: .setFaceCulling() has been removed.\")}});Object.defineProperties(Zd.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(a){console.warn(\"THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.\");\nthis.shadowMap.enabled=a}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(a){console.warn(\"THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.\");this.shadowMap.type=a}},shadowMapCullFace:{get:function(){console.warn(\"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.\")},set:function(){console.warn(\"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.\")}}});Object.defineProperties(Ze.prototype,\n{cullFace:{get:function(){console.warn(\"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.\")},set:function(){console.warn(\"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.\")}},renderReverseSided:{get:function(){console.warn(\"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.\")},set:function(){console.warn(\"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.\")}},\nrenderSingleSided:{get:function(){console.warn(\"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.\")},set:function(){console.warn(\"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.\")}}});Object.defineProperties(fb.prototype,{wrapS:{get:function(){console.warn(\"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.\");return this.texture.wrapS},set:function(a){console.warn(\"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.\");\nthis.texture.wrapS=a}},wrapT:{get:function(){console.warn(\"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.\");return this.texture.wrapT},set:function(a){console.warn(\"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.\");this.texture.wrapT=a}},magFilter:{get:function(){console.warn(\"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.\");return this.texture.magFilter},set:function(a){console.warn(\"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.\");this.texture.magFilter=\na}},minFilter:{get:function(){console.warn(\"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.\");return this.texture.minFilter},set:function(a){console.warn(\"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.\");this.texture.minFilter=a}},anisotropy:{get:function(){console.warn(\"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.\");return this.texture.anisotropy},set:function(a){console.warn(\"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.\");this.texture.anisotropy=\na}},offset:{get:function(){console.warn(\"THREE.WebGLRenderTarget: .offset is now .texture.offset.\");return this.texture.offset},set:function(a){console.warn(\"THREE.WebGLRenderTarget: .offset is now .texture.offset.\");this.texture.offset=a}},repeat:{get:function(){console.warn(\"THREE.WebGLRenderTarget: .repeat is now .texture.repeat.\");return this.texture.repeat},set:function(a){console.warn(\"THREE.WebGLRenderTarget: .repeat is now .texture.repeat.\");this.texture.repeat=a}},format:{get:function(){console.warn(\"THREE.WebGLRenderTarget: .format is now .texture.format.\");\nreturn this.texture.format},set:function(a){console.warn(\"THREE.WebGLRenderTarget: .format is now .texture.format.\");this.texture.format=a}},type:{get:function(){console.warn(\"THREE.WebGLRenderTarget: .type is now .texture.type.\");return this.texture.type},set:function(a){console.warn(\"THREE.WebGLRenderTarget: .type is now .texture.type.\");this.texture.type=a}},generateMipmaps:{get:function(){console.warn(\"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.\");return this.texture.generateMipmaps},\nset:function(a){console.warn(\"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.\");this.texture.generateMipmaps=a}}});Object.defineProperties(af.prototype,{standing:{set:function(){console.warn(\"THREE.WebVRManager: .standing has been removed.\")}}});hc.prototype.load=function(a){console.warn(\"THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.\");var b=this;(new le).load(a,function(a){b.setBuffer(a)});return this};pe.prototype.getData=function(){console.warn(\"THREE.AudioAnalyser: .getData() is now .getFrequencyData().\");\nreturn this.getFrequencyData()};dd.prototype.updateCubeMap=function(a,b){console.warn(\"THREE.CubeCamera: .updateCubeMap() is now .update().\");return this.update(a,b)};eb.crossOrigin=void 0;eb.loadTexture=function(a,b,c,d){console.warn(\"THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.\");var e=new vd;e.setCrossOrigin(this.crossOrigin);a=e.load(a,c,void 0,d);b&&(a.mapping=b);return a};eb.loadTextureCube=function(a,b,c,d){console.warn(\"THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.\");\nvar e=new ee;e.setCrossOrigin(this.crossOrigin);a=e.load(a,c,void 0,d);b&&(a.mapping=b);return a};eb.loadCompressedTexture=function(){console.error(\"THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.\")};eb.loadCompressedTextureCube=function(){console.error(\"THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.\")};l.WebGLRenderTargetCube=Gb;l.WebGLRenderTarget=fb;l.WebGLRenderer=Zd;l.ShaderLib=nb;l.UniformsLib=K;l.UniformsUtils=\nAa;l.ShaderChunk=S;l.FogExp2=Lb;l.Fog=Mb;l.Scene=qd;l.Sprite=Ac;l.LOD=Bc;l.SkinnedMesh=sd;l.Skeleton=Cc;l.Bone=rd;l.Mesh=la;l.LineSegments=W;l.LineLoop=td;l.Line=sa;l.Points=Ob;l.Group=Kb;l.VideoTexture=$d;l.DataTexture=gb;l.CompressedTexture=Pb;l.CubeTexture=Ua;l.CanvasTexture=Dc;l.DepthTexture=Ec;l.Texture=T;l.CompressedTextureLoader=kf;l.DataTextureLoader=de;l.CubeTextureLoader=ee;l.TextureLoader=vd;l.ObjectLoader=mf;l.MaterialLoader=Kd;l.BufferGeometryLoader=ge;l.DefaultLoadingManager=ka;l.LoadingManager=\nce;l.JSONLoader=he;l.ImageLoader=Zc;l.ImageBitmapLoader=ie;l.FontLoader=nf;l.FileLoader=Ga;l.Loader=gc;l.LoaderUtils=De;l.Cache=Fb;l.AudioLoader=le;l.SpotLightShadow=xd;l.SpotLight=yd;l.PointLight=zd;l.RectAreaLight=Dd;l.HemisphereLight=wd;l.DirectionalLightShadow=Ad;l.DirectionalLight=Bd;l.AmbientLight=Cd;l.LightShadow=Cb;l.Light=X;l.StereoCamera=of;l.PerspectiveCamera=Z;l.OrthographicCamera=Hb;l.CubeCamera=dd;l.ArrayCamera=yc;l.Camera=Na;l.AudioListener=me;l.PositionalAudio=oe;l.AudioContext=ne;\nl.AudioAnalyser=pe;l.Audio=hc;l.VectorKeyframeTrack=fc;l.StringKeyframeTrack=Jd;l.QuaternionKeyframeTrack=cd;l.NumberKeyframeTrack=ec;l.ColorKeyframeTrack=Hd;l.BooleanKeyframeTrack=Gd;l.PropertyMixer=qe;l.PropertyBinding=pa;l.KeyframeTrack=oa;l.AnimationUtils=ia;l.AnimationObjectGroup=qf;l.AnimationMixer=re;l.AnimationClip=Ca;l.Uniform=Ld;l.InstancedBufferGeometry=se;l.BufferGeometry=C;l.Geometry=R;l.InterleavedBufferAttribute=zc;l.InstancedInterleavedBuffer=te;l.InterleavedBuffer=ob;l.InstancedBufferAttribute=\nue;l.Face3=Ta;l.Object3D=D;l.Raycaster=sf;l.Layers=Rd;l.EventDispatcher=ya;l.Clock=uf;l.QuaternionLinearInterpolant=Id;l.LinearInterpolant=bd;l.DiscreteInterpolant=Fd;l.CubicInterpolant=Ed;l.Interpolant=wa;l.Triangle=ja;l.Math=H;l.Spherical=vf;l.Cylindrical=wf;l.Plane=Ma;l.Frustum=md;l.Sphere=Da;l.Ray=mb;l.Matrix4=I;l.Matrix3=ra;l.Box3=Sa;l.Box2=we;l.Line3=xe;l.Euler=hb;l.Vector4=V;l.Vector3=p;l.Vector2=z;l.Quaternion=fa;l.Color=G;l.ImmediateRenderObject=ed;l.VertexNormalsHelper=fd;l.SpotLightHelper=\nic;l.SkeletonHelper=jc;l.PointLightHelper=kc;l.RectAreaLightHelper=lc;l.HemisphereLightHelper=mc;l.GridHelper=gd;l.PolarGridHelper=Md;l.FaceNormalsHelper=hd;l.DirectionalLightHelper=nc;l.CameraHelper=id;l.BoxHelper=Db;l.Box3Helper=jd;l.PlaneHelper=kd;l.ArrowHelper=Eb;l.AxesHelper=ld;l.Shape=db;l.Path=La;l.ShapePath=je;l.Font=ke;l.CurvePath=Xa;l.Curve=L;l.ImageUtils=eb;l.ShapeUtils=Va;l.WebGLUtils=$e;l.WireframeGeometry=Qb;l.ParametricGeometry=Fc;l.ParametricBufferGeometry=Rb;l.TetrahedronGeometry=\nHc;l.TetrahedronBufferGeometry=Sb;l.OctahedronGeometry=Ic;l.OctahedronBufferGeometry=pb;l.IcosahedronGeometry=Jc;l.IcosahedronBufferGeometry=Tb;l.DodecahedronGeometry=Kc;l.DodecahedronBufferGeometry=Ub;l.PolyhedronGeometry=Gc;l.PolyhedronBufferGeometry=na;l.TubeGeometry=Lc;l.TubeBufferGeometry=Vb;l.TorusKnotGeometry=Mc;l.TorusKnotBufferGeometry=Wb;l.TorusGeometry=Nc;l.TorusBufferGeometry=Xb;l.TextGeometry=Sc;l.TextBufferGeometry=Yb;l.SphereGeometry=Tc;l.SphereBufferGeometry=sb;l.RingGeometry=Uc;l.RingBufferGeometry=\nZb;l.PlaneGeometry=uc;l.PlaneBufferGeometry=lb;l.LatheGeometry=Vc;l.LatheBufferGeometry=$b;l.ShapeGeometry=tb;l.ShapeBufferGeometry=ub;l.ExtrudeGeometry=rb;l.ExtrudeBufferGeometry=Oa;l.EdgesGeometry=ac;l.ConeGeometry=Wc;l.ConeBufferGeometry=Xc;l.CylinderGeometry=vb;l.CylinderBufferGeometry=Wa;l.CircleGeometry=Yc;l.CircleBufferGeometry=bc;l.BoxGeometry=Ib;l.BoxBufferGeometry=kb;l.ShadowMaterial=wb;l.SpriteMaterial=cb;l.RawShaderMaterial=cc;l.ShaderMaterial=ta;l.PointsMaterial=Ea;l.MeshPhysicalMaterial=\nxb;l.MeshStandardMaterial=Pa;l.MeshPhongMaterial=Fa;l.MeshToonMaterial=yb;l.MeshNormalMaterial=zb;l.MeshLambertMaterial=Ab;l.MeshDepthMaterial=$a;l.MeshDistanceMaterial=ab;l.MeshBasicMaterial=da;l.LineDashedMaterial=Bb;l.LineBasicMaterial=Y;l.Material=J;l.Float64BufferAttribute=tc;l.Float32BufferAttribute=A;l.Uint32BufferAttribute=jb;l.Int32BufferAttribute=sc;l.Uint16BufferAttribute=ib;l.Int16BufferAttribute=rc;l.Uint8ClampedBufferAttribute=qc;l.Uint8BufferAttribute=pc;l.Int8BufferAttribute=oc;l.BufferAttribute=\nQ;l.ArcCurve=dc;l.CatmullRomCurve3=ca;l.CubicBezierCurve=Ha;l.CubicBezierCurve3=Qa;l.EllipseCurve=za;l.LineCurve=va;l.LineCurve3=Ia;l.QuadraticBezierCurve=Ja;l.QuadraticBezierCurve3=Ra;l.SplineCurve=Ka;l.REVISION=\"95\";l.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2};l.CullFaceNone=0;l.CullFaceBack=1;l.CullFaceFront=2;l.CullFaceFrontBack=3;l.FrontFaceDirectionCW=0;l.FrontFaceDirectionCCW=1;l.BasicShadowMap=0;l.PCFShadowMap=1;l.PCFSoftShadowMap=2;l.FrontSide=0;l.BackSide=1;l.DoubleSide=2;l.FlatShading=1;l.SmoothShading=\n2;l.NoColors=0;l.FaceColors=1;l.VertexColors=2;l.NoBlending=0;l.NormalBlending=1;l.AdditiveBlending=2;l.SubtractiveBlending=3;l.MultiplyBlending=4;l.CustomBlending=5;l.AddEquation=100;l.SubtractEquation=101;l.ReverseSubtractEquation=102;l.MinEquation=103;l.MaxEquation=104;l.ZeroFactor=200;l.OneFactor=201;l.SrcColorFactor=202;l.OneMinusSrcColorFactor=203;l.SrcAlphaFactor=204;l.OneMinusSrcAlphaFactor=205;l.DstAlphaFactor=206;l.OneMinusDstAlphaFactor=207;l.DstColorFactor=208;l.OneMinusDstColorFactor=\n209;l.SrcAlphaSaturateFactor=210;l.NeverDepth=0;l.AlwaysDepth=1;l.LessDepth=2;l.LessEqualDepth=3;l.EqualDepth=4;l.GreaterEqualDepth=5;l.GreaterDepth=6;l.NotEqualDepth=7;l.MultiplyOperation=0;l.MixOperation=1;l.AddOperation=2;l.NoToneMapping=0;l.LinearToneMapping=1;l.ReinhardToneMapping=2;l.Uncharted2ToneMapping=3;l.CineonToneMapping=4;l.UVMapping=300;l.CubeReflectionMapping=301;l.CubeRefractionMapping=302;l.EquirectangularReflectionMapping=303;l.EquirectangularRefractionMapping=304;l.SphericalReflectionMapping=\n305;l.CubeUVReflectionMapping=306;l.CubeUVRefractionMapping=307;l.RepeatWrapping=1E3;l.ClampToEdgeWrapping=1001;l.MirroredRepeatWrapping=1002;l.NearestFilter=1003;l.NearestMipMapNearestFilter=1004;l.NearestMipMapLinearFilter=1005;l.LinearFilter=1006;l.LinearMipMapNearestFilter=1007;l.LinearMipMapLinearFilter=1008;l.UnsignedByteType=1009;l.ByteType=1010;l.ShortType=1011;l.UnsignedShortType=1012;l.IntType=1013;l.UnsignedIntType=1014;l.FloatType=1015;l.HalfFloatType=1016;l.UnsignedShort4444Type=1017;\nl.UnsignedShort5551Type=1018;l.UnsignedShort565Type=1019;l.UnsignedInt248Type=1020;l.AlphaFormat=1021;l.RGBFormat=1022;l.RGBAFormat=1023;l.LuminanceFormat=1024;l.LuminanceAlphaFormat=1025;l.RGBEFormat=1023;l.DepthFormat=1026;l.DepthStencilFormat=1027;l.RGB_S3TC_DXT1_Format=33776;l.RGBA_S3TC_DXT1_Format=33777;l.RGBA_S3TC_DXT3_Format=33778;l.RGBA_S3TC_DXT5_Format=33779;l.RGB_PVRTC_4BPPV1_Format=35840;l.RGB_PVRTC_2BPPV1_Format=35841;l.RGBA_PVRTC_4BPPV1_Format=35842;l.RGBA_PVRTC_2BPPV1_Format=35843;l.RGB_ETC1_Format=\n36196;l.RGBA_ASTC_4x4_Format=37808;l.RGBA_ASTC_5x4_Format=37809;l.RGBA_ASTC_5x5_Format=37810;l.RGBA_ASTC_6x5_Format=37811;l.RGBA_ASTC_6x6_Format=37812;l.RGBA_ASTC_8x5_Format=37813;l.RGBA_ASTC_8x6_Format=37814;l.RGBA_ASTC_8x8_Format=37815;l.RGBA_ASTC_10x5_Format=37816;l.RGBA_ASTC_10x6_Format=37817;l.RGBA_ASTC_10x8_Format=37818;l.RGBA_ASTC_10x10_Format=37819;l.RGBA_ASTC_12x10_Format=37820;l.RGBA_ASTC_12x12_Format=37821;l.LoopOnce=2200;l.LoopRepeat=2201;l.LoopPingPong=2202;l.InterpolateDiscrete=2300;\nl.InterpolateLinear=2301;l.InterpolateSmooth=2302;l.ZeroCurvatureEnding=2400;l.ZeroSlopeEnding=2401;l.WrapAroundEnding=2402;l.TrianglesDrawMode=0;l.TriangleStripDrawMode=1;l.TriangleFanDrawMode=2;l.LinearEncoding=3E3;l.sRGBEncoding=3001;l.GammaEncoding=3007;l.RGBEEncoding=3002;l.LogLuvEncoding=3003;l.RGBM7Encoding=3004;l.RGBM16Encoding=3005;l.RGBDEncoding=3006;l.BasicDepthPacking=3200;l.RGBADepthPacking=3201;l.TangentSpaceNormalMap=0;l.ObjectSpaceNormalMap=1;l.CubeGeometry=Ib;l.Face4=function(a,b,\nc,d,e,f,g){console.warn(\"THREE.Face4 has been removed. A THREE.Face3 will be created instead.\");return new Ta(a,b,c,e,f,g)};l.LineStrip=0;l.LinePieces=1;l.MeshFaceMaterial=function(a){console.warn(\"THREE.MeshFaceMaterial has been removed. Use an Array instead.\");return a};l.MultiMaterial=function(a){void 0===a&&(a=[]);console.warn(\"THREE.MultiMaterial has been removed. Use an Array instead.\");a.isMultiMaterial=!0;a.materials=a;a.clone=function(){return a.slice()};return a};l.PointCloud=function(a,\nb){console.warn(\"THREE.PointCloud has been renamed to THREE.Points.\");return new Ob(a,b)};l.Particle=function(a){console.warn(\"THREE.Particle has been renamed to THREE.Sprite.\");return new Ac(a)};l.ParticleSystem=function(a,b){console.warn(\"THREE.ParticleSystem has been renamed to THREE.Points.\");return new Ob(a,b)};l.PointCloudMaterial=function(a){console.warn(\"THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.\");return new Ea(a)};l.ParticleBasicMaterial=function(a){console.warn(\"THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.\");\nreturn new Ea(a)};l.ParticleSystemMaterial=function(a){console.warn(\"THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.\");return new Ea(a)};l.Vertex=function(a,b,c){console.warn(\"THREE.Vertex has been removed. Use THREE.Vector3 instead.\");return new p(a,b,c)};l.DynamicBufferAttribute=function(a,b){console.warn(\"THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.\");return(new Q(a,b)).setDynamic(!0)};l.Int8Attribute=function(a,\nb){console.warn(\"THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.\");return new oc(a,b)};l.Uint8Attribute=function(a,b){console.warn(\"THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.\");return new pc(a,b)};l.Uint8ClampedAttribute=function(a,b){console.warn(\"THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.\");return new qc(a,b)};l.Int16Attribute=function(a,b){console.warn(\"THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.\");\nreturn new rc(a,b)};l.Uint16Attribute=function(a,b){console.warn(\"THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.\");return new ib(a,b)};l.Int32Attribute=function(a,b){console.warn(\"THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.\");return new sc(a,b)};l.Uint32Attribute=function(a,b){console.warn(\"THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.\");return new jb(a,b)};l.Float32Attribute=\nfunction(a,b){console.warn(\"THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.\");return new A(a,b)};l.Float64Attribute=function(a,b){console.warn(\"THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.\");return new tc(a,b)};l.ClosedSplineCurve3=yf;l.SplineCurve3=zf;l.Spline=ze;l.AxisHelper=function(a){console.warn(\"THREE.AxisHelper has been renamed to THREE.AxesHelper.\");return new ld(a)};l.BoundingBoxHelper=function(a,b){console.warn(\"THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.\");\nreturn new Db(a,b)};l.EdgesHelper=function(a,b){console.warn(\"THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.\");return new W(new ac(a.geometry),new Y({color:void 0!==b?b:16777215}))};l.WireframeHelper=function(a,b){console.warn(\"THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.\");return new W(new Qb(a.geometry),new Y({color:void 0!==b?b:16777215}))};l.XHRLoader=function(a){console.warn(\"THREE.XHRLoader has been renamed to THREE.FileLoader.\");return new Ga(a)};\nl.BinaryTextureLoader=function(a){console.warn(\"THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.\");return new de(a)};l.GeometryUtils={merge:function(a,b,c){console.warn(\"THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.\");if(b.isMesh){b.matrixAutoUpdate&&b.updateMatrix();var d=b.matrix;b=b.geometry}a.merge(b,d,c)},center:function(a){console.warn(\"THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.\");\nreturn a.center()}};l.Projector=function(){console.error(\"THREE.Projector has been moved to /examples/js/renderers/Projector.js.\");this.projectVector=function(a,b){console.warn(\"THREE.Projector: .projectVector() is now vector.project().\");a.project(b)};this.unprojectVector=function(a,b){console.warn(\"THREE.Projector: .unprojectVector() is now vector.unproject().\");a.unproject(b)};this.pickingRay=function(){console.error(\"THREE.Projector: .pickingRay() is now raycaster.setFromCamera().\")}};l.CanvasRenderer=\nfunction(){console.error(\"THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js\");this.domElement=document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"canvas\");this.clear=function(){};this.render=function(){};this.setClearColor=function(){};this.setSize=function(){}};l.SceneUtils={createMultiMaterialObject:function(){console.error(\"THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js\")},detach:function(){console.error(\"THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js\")},\nattach:function(){console.error(\"THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js\")}};l.LensFlare=function(){console.error(\"THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js\")};Object.defineProperty(l,\"__esModule\",{value:!0})});\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/three/build/three.min.js?");

/***/ }),

/***/ "./node_modules/tinyqueue/index.js":
/*!*****************************************!*\
  !*** ./node_modules/tinyqueue/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1); i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n        var top = this.data[0];\n        this.length--;\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var len = this.length;\n        var halfLen = len >> 1;\n        var item = data[pos];\n\n        while (pos < halfLen) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < len && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/tinyqueue/index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\n\tthrow new Error(\"define cannot be used indirect\");\n};\n\n\n//# sourceURL=webpack://Mapillary/(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://Mapillary/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/when/when.js":
/*!***********************************!*\
  !*** ./node_modules/when/when.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/**\n * Promises/A+ and when() implementation\n * when is part of the cujoJS family of libraries (http://cujojs.com/)\n * @author Brian Cavalier\n * @author John Hann\n */\n(function(define) { 'use strict';\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n\n\tvar timed = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/decorators/timed'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\tvar array = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/decorators/array'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\tvar flow = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/decorators/flow'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\tvar fold = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/decorators/fold'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\tvar inspect = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/decorators/inspect'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\tvar generate = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/decorators/iterate'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\tvar progress = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/decorators/progress'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\tvar withThis = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/decorators/with'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\tvar unhandledRejection = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/decorators/unhandledRejection'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\tvar TimeoutError = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/TimeoutError'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n\tvar Promise = [array, flow, fold, generate, progress,\n\t\tinspect, withThis, timed, unhandledRejection]\n\t\t.reduce(function(Promise, feature) {\n\t\t\treturn feature(Promise);\n\t\t}, __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/Promise'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\n\tvar apply = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module './lib/apply'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))(Promise);\n\n\t// Public API\n\n\twhen.promise     = promise;              // Create a pending promise\n\twhen.resolve     = Promise.resolve;      // Create a resolved promise\n\twhen.reject      = Promise.reject;       // Create a rejected promise\n\n\twhen.lift        = lift;                 // lift a function to return promises\n\twhen['try']      = attempt;              // call a function and return a promise\n\twhen.attempt     = attempt;              // alias for when.try\n\n\twhen.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\twhen.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\n\twhen.join        = join;                 // Join 2 or more promises\n\n\twhen.all         = all;                  // Resolve a list of promises\n\twhen.settle      = settle;               // Settle a list of promises\n\n\twhen.any         = lift(Promise.any);    // One-winner race\n\twhen.some        = lift(Promise.some);   // Multi-winner race\n\twhen.race        = lift(Promise.race);   // First-to-settle race\n\n\twhen.map         = map;                  // Array.map() for promises\n\twhen.filter      = filter;               // Array.filter() for promises\n\twhen.reduce      = lift(Promise.reduce);       // Array.reduce() for promises\n\twhen.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises\n\n\twhen.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable\n\n\twhen.Promise     = Promise;              // Promise constructor\n\twhen.defer       = defer;                // Create a {promise, resolve, reject} tuple\n\n\t// Error types\n\n\twhen.TimeoutError = TimeoutError;\n\n\t/**\n\t * Get a trusted promise for x, or by transforming x with onFulfilled\n\t *\n\t * @param {*} x\n\t * @param {function?} onFulfilled callback to be called when x is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} onRejected callback to be called when x is\n\t *   rejected.\n\t * @param {function?} onProgress callback to be called when progress updates\n\t *   are issued for x. @deprecated\n\t * @returns {Promise} a new promise that will fulfill with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(x, onFulfilled, onRejected, onProgress) {\n\t\tvar p = Promise.resolve(x);\n\t\tif (arguments.length < 2) {\n\t\t\treturn p;\n\t\t}\n\n\t\treturn p.then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn new Promise(resolver);\n\t}\n\n\t/**\n\t * Lift the supplied function, creating a version of f that returns\n\t * promises, and accepts promises as arguments.\n\t * @param {function} f\n\t * @returns {Function} version of f that returns promises\n\t */\n\tfunction lift(f) {\n\t\treturn function() {\n\t\t\tfor(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {\n\t\t\t\ta[i] = arguments[i];\n\t\t\t}\n\t\t\treturn apply(f, this, a);\n\t\t};\n\t}\n\n\t/**\n\t * Call f in a future turn, with the supplied args, and return a promise\n\t * for the result.\n\t * @param {function} f\n\t * @returns {Promise}\n\t */\n\tfunction attempt(f /*, args... */) {\n\t\t/*jshint validthis:true */\n\t\tfor(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {\n\t\t\ta[i] = arguments[i+1];\n\t\t}\n\t\treturn apply(f, this, a);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * @return {{promise: Promise, resolve: function, reject: function, notify: function}}\n\t */\n\tfunction defer() {\n\t\treturn new Deferred();\n\t}\n\n\tfunction Deferred() {\n\t\tvar p = Promise._defer();\n\n\t\tfunction resolve(x) { p._handler.resolve(x); }\n\t\tfunction reject(x) { p._handler.reject(x); }\n\t\tfunction notify(x) { p._handler.notify(x); }\n\n\t\tthis.promise = p;\n\t\tthis.resolve = resolve;\n\t\tthis.reject = reject;\n\t\tthis.notify = notify;\n\t\tthis.resolver = { resolve: resolve, reject: reject, notify: notify };\n\t}\n\n\t/**\n\t * Determines if x is promise-like, i.e. a thenable object\n\t * NOTE: Will return true for *any thenable object*, and isn't truly\n\t * safe, since it may attempt to access the `then` property of x (i.e.\n\t *  clever/malicious getters may do weird things)\n\t * @param {*} x anything\n\t * @returns {boolean} true if x is promise-like\n\t */\n\tfunction isPromiseLike(x) {\n\t\treturn x && typeof x.then === 'function';\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied arguments\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the arguments.\n\t * @param {...*} arguments may be a mix of promises and values\n\t * @returns {Promise}\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn Promise.all(arguments);\n\t}\n\n\t/**\n\t * Return a promise that will fulfill once all input promises have\n\t * fulfilled, or reject when any one input promise rejects.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise}\n\t */\n\tfunction all(promises) {\n\t\treturn when(promises, Promise.all);\n\t}\n\n\t/**\n\t * Return a promise that will always fulfill with an array containing\n\t * the outcome states of all input promises.  The returned promise\n\t * will only reject if `promises` itself is a rejected promise.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise} promise for array of settled state descriptors\n\t */\n\tfunction settle(promises) {\n\t\treturn when(promises, Promise.settle);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} promises array of anything, may contain promises and values\n\t * @param {function(x:*, index:Number):*} mapFunc map function which may\n\t *  return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(promises, mapFunc) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.map(promises, mapFunc);\n\t\t});\n\t}\n\n\t/**\n\t * Filter the provided array of promises using the provided predicate.  Input may\n\t * contain promises and values\n\t * @param {Array|Promise} promises array of promises and values\n\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t *  Must return truthy (or promise for truthy) for items to retain.\n\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t *  for which predicate returned truthy.\n\t */\n\tfunction filter(promises, predicate) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.filter(promises, predicate);\n\t\t});\n\t}\n\n\treturn when;\n}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n})(__webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\"));\n\n\n//# sourceURL=webpack://Mapillary/./node_modules/when/when.js?");

/***/ }),

/***/ "./src/API.ts":
/*!********************!*\
  !*** ./src/API.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar APIv3_1 = __webpack_require__(/*! ./api/APIv3 */ \"./src/api/APIv3.ts\");\n\nexports.APIv3 = APIv3_1.APIv3;\n\nvar ModelCreator_1 = __webpack_require__(/*! ./api/ModelCreator */ \"./src/api/ModelCreator.ts\");\n\nexports.ModelCreator = ModelCreator_1.ModelCreator;\n\n//# sourceURL=webpack://Mapillary/./src/API.ts?");

/***/ }),

/***/ "./src/Component.ts":
/*!**************************!*\
  !*** ./src/Component.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Component_1 = __webpack_require__(/*! ./component/Component */ \"./src/component/Component.ts\");\n\nexports.Component = Component_1.Component;\n\nvar ComponentService_1 = __webpack_require__(/*! ./component/ComponentService */ \"./src/component/ComponentService.ts\");\n\nexports.ComponentService = ComponentService_1.ComponentService;\n\nvar HandlerBase_1 = __webpack_require__(/*! ./component/utils/HandlerBase */ \"./src/component/utils/HandlerBase.ts\");\n\nexports.HandlerBase = HandlerBase_1.HandlerBase;\n\nvar MeshFactory_1 = __webpack_require__(/*! ./component/utils/MeshFactory */ \"./src/component/utils/MeshFactory.ts\");\n\nexports.MeshFactory = MeshFactory_1.MeshFactory;\n\nvar MeshScene_1 = __webpack_require__(/*! ./component/utils/MeshScene */ \"./src/component/utils/MeshScene.ts\");\n\nexports.MeshScene = MeshScene_1.MeshScene;\n\nvar MouseOperator_1 = __webpack_require__(/*! ./component/utils/MouseOperator */ \"./src/component/utils/MouseOperator.ts\");\n\nexports.MouseOperator = MouseOperator_1.MouseOperator;\n\nvar ComponentSize_1 = __webpack_require__(/*! ./component/utils/ComponentSize */ \"./src/component/utils/ComponentSize.ts\");\n\nexports.ComponentSize = ComponentSize_1.ComponentSize;\n\nvar AttributionComponent_1 = __webpack_require__(/*! ./component/AttributionComponent */ \"./src/component/AttributionComponent.ts\");\n\nexports.AttributionComponent = AttributionComponent_1.AttributionComponent;\n\nvar BackgroundComponent_1 = __webpack_require__(/*! ./component/BackgroundComponent */ \"./src/component/BackgroundComponent.ts\");\n\nexports.BackgroundComponent = BackgroundComponent_1.BackgroundComponent;\n\nvar BearingComponent_1 = __webpack_require__(/*! ./component/BearingComponent */ \"./src/component/BearingComponent.ts\");\n\nexports.BearingComponent = BearingComponent_1.BearingComponent;\n\nvar CacheComponent_1 = __webpack_require__(/*! ./component/CacheComponent */ \"./src/component/CacheComponent.ts\");\n\nexports.CacheComponent = CacheComponent_1.CacheComponent;\n\nvar CoverComponent_1 = __webpack_require__(/*! ./component/CoverComponent */ \"./src/component/CoverComponent.ts\");\n\nexports.CoverComponent = CoverComponent_1.CoverComponent;\n\nvar DebugComponent_1 = __webpack_require__(/*! ./component/DebugComponent */ \"./src/component/DebugComponent.ts\");\n\nexports.DebugComponent = DebugComponent_1.DebugComponent;\n\nvar DirectionComponent_1 = __webpack_require__(/*! ./component/direction/DirectionComponent */ \"./src/component/direction/DirectionComponent.ts\");\n\nexports.DirectionComponent = DirectionComponent_1.DirectionComponent;\n\nvar DirectionDOMCalculator_1 = __webpack_require__(/*! ./component/direction/DirectionDOMCalculator */ \"./src/component/direction/DirectionDOMCalculator.ts\");\n\nexports.DirectionDOMCalculator = DirectionDOMCalculator_1.DirectionDOMCalculator;\n\nvar DirectionDOMRenderer_1 = __webpack_require__(/*! ./component/direction/DirectionDOMRenderer */ \"./src/component/direction/DirectionDOMRenderer.ts\");\n\nexports.DirectionDOMRenderer = DirectionDOMRenderer_1.DirectionDOMRenderer;\n\nvar ImageComponent_1 = __webpack_require__(/*! ./component/ImageComponent */ \"./src/component/ImageComponent.ts\");\n\nexports.ImageComponent = ImageComponent_1.ImageComponent;\n\nvar KeyboardComponent_1 = __webpack_require__(/*! ./component/keyboard/KeyboardComponent */ \"./src/component/keyboard/KeyboardComponent.ts\");\n\nexports.KeyboardComponent = KeyboardComponent_1.KeyboardComponent;\n\nvar KeyPlayHandler_1 = __webpack_require__(/*! ./component/keyboard/KeyPlayHandler */ \"./src/component/keyboard/KeyPlayHandler.ts\");\n\nexports.KeyPlayHandler = KeyPlayHandler_1.KeyPlayHandler;\n\nvar KeyZoomHandler_1 = __webpack_require__(/*! ./component/keyboard/KeyZoomHandler */ \"./src/component/keyboard/KeyZoomHandler.ts\");\n\nexports.KeyZoomHandler = KeyZoomHandler_1.KeyZoomHandler;\n\nvar KeySequenceNavigationHandler_1 = __webpack_require__(/*! ./component/keyboard/KeySequenceNavigationHandler */ \"./src/component/keyboard/KeySequenceNavigationHandler.ts\");\n\nexports.KeySequenceNavigationHandler = KeySequenceNavigationHandler_1.KeySequenceNavigationHandler;\n\nvar KeySpatialNavigationHandler_1 = __webpack_require__(/*! ./component/keyboard/KeySpatialNavigationHandler */ \"./src/component/keyboard/KeySpatialNavigationHandler.ts\");\n\nexports.KeySpatialNavigationHandler = KeySpatialNavigationHandler_1.KeySpatialNavigationHandler;\n\nvar LoadingComponent_1 = __webpack_require__(/*! ./component/LoadingComponent */ \"./src/component/LoadingComponent.ts\");\n\nexports.LoadingComponent = LoadingComponent_1.LoadingComponent;\n\nvar Marker_1 = __webpack_require__(/*! ./component/marker/marker/Marker */ \"./src/component/marker/marker/Marker.ts\");\n\nexports.Marker = Marker_1.Marker;\n\nvar MarkerComponent_1 = __webpack_require__(/*! ./component/marker/MarkerComponent */ \"./src/component/marker/MarkerComponent.ts\");\n\nexports.MarkerComponent = MarkerComponent_1.MarkerComponent;\n\nvar MarkerScene_1 = __webpack_require__(/*! ./component/marker/MarkerScene */ \"./src/component/marker/MarkerScene.ts\");\n\nexports.MarkerScene = MarkerScene_1.MarkerScene;\n\nvar MarkerSet_1 = __webpack_require__(/*! ./component/marker/MarkerSet */ \"./src/component/marker/MarkerSet.ts\");\n\nexports.MarkerSet = MarkerSet_1.MarkerSet;\n\nvar MouseComponent_1 = __webpack_require__(/*! ./component/mouse/MouseComponent */ \"./src/component/mouse/MouseComponent.ts\");\n\nexports.MouseComponent = MouseComponent_1.MouseComponent;\n\nvar BounceHandler_1 = __webpack_require__(/*! ./component/mouse/BounceHandler */ \"./src/component/mouse/BounceHandler.ts\");\n\nexports.BounceHandler = BounceHandler_1.BounceHandler;\n\nvar DragPanHandler_1 = __webpack_require__(/*! ./component/mouse/DragPanHandler */ \"./src/component/mouse/DragPanHandler.ts\");\n\nexports.DragPanHandler = DragPanHandler_1.DragPanHandler;\n\nvar DoubleClickZoomHandler_1 = __webpack_require__(/*! ./component/mouse/DoubleClickZoomHandler */ \"./src/component/mouse/DoubleClickZoomHandler.ts\");\n\nexports.DoubleClickZoomHandler = DoubleClickZoomHandler_1.DoubleClickZoomHandler;\n\nvar EarthControlHandler_1 = __webpack_require__(/*! ./component/mouse/EarthControlHandler */ \"./src/component/mouse/EarthControlHandler.ts\");\n\nexports.EarthControlHandler = EarthControlHandler_1.EarthControlHandler;\n\nvar ScrollZoomHandler_1 = __webpack_require__(/*! ./component/mouse/ScrollZoomHandler */ \"./src/component/mouse/ScrollZoomHandler.ts\");\n\nexports.ScrollZoomHandler = ScrollZoomHandler_1.ScrollZoomHandler;\n\nvar TouchZoomHandler_1 = __webpack_require__(/*! ./component/mouse/TouchZoomHandler */ \"./src/component/mouse/TouchZoomHandler.ts\");\n\nexports.TouchZoomHandler = TouchZoomHandler_1.TouchZoomHandler;\n\nvar ImageBoundary = __webpack_require__(/*! ./component/mouse/ImageBoundary */ \"./src/component/mouse/ImageBoundary.ts\");\n\nexports.ImageBoundary = ImageBoundary;\n\nvar Popup_1 = __webpack_require__(/*! ./component/popup/popup/Popup */ \"./src/component/popup/popup/Popup.ts\");\n\nexports.Popup = Popup_1.Popup;\n\nvar PopupComponent_1 = __webpack_require__(/*! ./component/popup/PopupComponent */ \"./src/component/popup/PopupComponent.ts\");\n\nexports.PopupComponent = PopupComponent_1.PopupComponent;\n\nvar NavigationComponent_1 = __webpack_require__(/*! ./component/NavigationComponent */ \"./src/component/NavigationComponent.ts\");\n\nexports.NavigationComponent = NavigationComponent_1.NavigationComponent;\n\nvar RouteComponent_1 = __webpack_require__(/*! ./component/RouteComponent */ \"./src/component/RouteComponent.ts\");\n\nexports.RouteComponent = RouteComponent_1.RouteComponent;\n\nvar SequenceComponent_1 = __webpack_require__(/*! ./component/sequence/SequenceComponent */ \"./src/component/sequence/SequenceComponent.ts\");\n\nexports.SequenceComponent = SequenceComponent_1.SequenceComponent;\n\nvar SequenceDOMRenderer_1 = __webpack_require__(/*! ./component/sequence/SequenceDOMRenderer */ \"./src/component/sequence/SequenceDOMRenderer.ts\");\n\nexports.SequenceDOMRenderer = SequenceDOMRenderer_1.SequenceDOMRenderer;\n\nvar SequenceMode_1 = __webpack_require__(/*! ./component/sequence/SequenceMode */ \"./src/component/sequence/SequenceMode.ts\");\n\nexports.SequenceMode = SequenceMode_1.SequenceMode;\n\nvar SpatialDataCache_1 = __webpack_require__(/*! ./component/spatialdata/SpatialDataCache */ \"./src/component/spatialdata/SpatialDataCache.ts\");\n\nexports.SpatialDataCache = SpatialDataCache_1.SpatialDataCache;\n\nvar SpatialDataComponent_1 = __webpack_require__(/*! ./component/spatialdata/SpatialDataComponent */ \"./src/component/spatialdata/SpatialDataComponent.ts\");\n\nexports.SpatialDataComponent = SpatialDataComponent_1.SpatialDataComponent;\n\nvar SpatialDataScene_1 = __webpack_require__(/*! ./component/spatialdata/SpatialDataScene */ \"./src/component/spatialdata/SpatialDataScene.ts\");\n\nexports.SpatialDataScene = SpatialDataScene_1.SpatialDataScene;\n\nvar ImagePlaneComponent_1 = __webpack_require__(/*! ./component/imageplane/ImagePlaneComponent */ \"./src/component/imageplane/ImagePlaneComponent.ts\");\n\nexports.ImagePlaneComponent = ImagePlaneComponent_1.ImagePlaneComponent;\n\nvar ImagePlaneGLRenderer_1 = __webpack_require__(/*! ./component/imageplane/ImagePlaneGLRenderer */ \"./src/component/imageplane/ImagePlaneGLRenderer.ts\");\n\nexports.ImagePlaneGLRenderer = ImagePlaneGLRenderer_1.ImagePlaneGLRenderer;\n\nvar Shaders_1 = __webpack_require__(/*! ./component/shaders/Shaders */ \"./src/component/shaders/Shaders.ts\");\n\nexports.Shaders = Shaders_1.Shaders;\n\nvar SimpleMarker_1 = __webpack_require__(/*! ./component/marker/marker/SimpleMarker */ \"./src/component/marker/marker/SimpleMarker.ts\");\n\nexports.SimpleMarker = SimpleMarker_1.SimpleMarker;\n\nvar CircleMarker_1 = __webpack_require__(/*! ./component/marker/marker/CircleMarker */ \"./src/component/marker/marker/CircleMarker.ts\");\n\nexports.CircleMarker = CircleMarker_1.CircleMarker;\n\nvar SliderComponent_1 = __webpack_require__(/*! ./component/slider/SliderComponent */ \"./src/component/slider/SliderComponent.ts\");\n\nexports.SliderComponent = SliderComponent_1.SliderComponent;\n\nvar SliderDOMRenderer_1 = __webpack_require__(/*! ./component/slider/SliderDOMRenderer */ \"./src/component/slider/SliderDOMRenderer.ts\");\n\nexports.SliderDOMRenderer = SliderDOMRenderer_1.SliderDOMRenderer;\n\nvar SliderGLRenderer_1 = __webpack_require__(/*! ./component/slider/SliderGLRenderer */ \"./src/component/slider/SliderGLRenderer.ts\");\n\nexports.SliderGLRenderer = SliderGLRenderer_1.SliderGLRenderer;\n\nvar StatsComponent_1 = __webpack_require__(/*! ./component/StatsComponent */ \"./src/component/StatsComponent.ts\");\n\nexports.StatsComponent = StatsComponent_1.StatsComponent;\n\nvar TagHandlerBase_1 = __webpack_require__(/*! ./component/tag/handlers/TagHandlerBase */ \"./src/component/tag/handlers/TagHandlerBase.ts\");\n\nexports.TagHandlerBase = TagHandlerBase_1.TagHandlerBase;\n\nvar CreateHandlerBase_1 = __webpack_require__(/*! ./component/tag/handlers/CreateHandlerBase */ \"./src/component/tag/handlers/CreateHandlerBase.ts\");\n\nexports.CreateHandlerBase = CreateHandlerBase_1.CreateHandlerBase;\n\nvar CreatePointHandler_1 = __webpack_require__(/*! ./component/tag/handlers/CreatePointHandler */ \"./src/component/tag/handlers/CreatePointHandler.ts\");\n\nexports.CreatePointHandler = CreatePointHandler_1.CreatePointHandler;\n\nvar CreateVertexHandler_1 = __webpack_require__(/*! ./component/tag/handlers/CreateVertexHandler */ \"./src/component/tag/handlers/CreateVertexHandler.ts\");\n\nexports.CreateVertexHandler = CreateVertexHandler_1.CreateVertexHandler;\n\nvar CreatePolygonHandler_1 = __webpack_require__(/*! ./component/tag/handlers/CreatePolygonHandler */ \"./src/component/tag/handlers/CreatePolygonHandler.ts\");\n\nexports.CreatePolygonHandler = CreatePolygonHandler_1.CreatePolygonHandler;\n\nvar CreateRectHandler_1 = __webpack_require__(/*! ./component/tag/handlers/CreateRectHandler */ \"./src/component/tag/handlers/CreateRectHandler.ts\");\n\nexports.CreateRectHandler = CreateRectHandler_1.CreateRectHandler;\n\nvar CreateRectDragHandler_1 = __webpack_require__(/*! ./component/tag/handlers/CreateRectDragHandler */ \"./src/component/tag/handlers/CreateRectDragHandler.ts\");\n\nexports.CreateRectDragHandler = CreateRectDragHandler_1.CreateRectDragHandler;\n\nvar EditVertexHandler_1 = __webpack_require__(/*! ./component/tag/handlers/EditVertexHandler */ \"./src/component/tag/handlers/EditVertexHandler.ts\");\n\nexports.EditVertexHandler = EditVertexHandler_1.EditVertexHandler;\n\nvar Tag_1 = __webpack_require__(/*! ./component/tag/tag/Tag */ \"./src/component/tag/tag/Tag.ts\");\n\nexports.Tag = Tag_1.Tag;\n\nvar OutlineTag_1 = __webpack_require__(/*! ./component/tag/tag/OutlineTag */ \"./src/component/tag/tag/OutlineTag.ts\");\n\nexports.OutlineTag = OutlineTag_1.OutlineTag;\n\nvar RenderTag_1 = __webpack_require__(/*! ./component/tag/tag/RenderTag */ \"./src/component/tag/tag/RenderTag.ts\");\n\nexports.RenderTag = RenderTag_1.RenderTag;\n\nvar OutlineRenderTag_1 = __webpack_require__(/*! ./component/tag/tag/OutlineRenderTag */ \"./src/component/tag/tag/OutlineRenderTag.ts\");\n\nexports.OutlineRenderTag = OutlineRenderTag_1.OutlineRenderTag;\n\nvar OutlineCreateTag_1 = __webpack_require__(/*! ./component/tag/tag/OutlineCreateTag */ \"./src/component/tag/tag/OutlineCreateTag.ts\");\n\nexports.OutlineCreateTag = OutlineCreateTag_1.OutlineCreateTag;\n\nvar SpotTag_1 = __webpack_require__(/*! ./component/tag/tag/SpotTag */ \"./src/component/tag/tag/SpotTag.ts\");\n\nexports.SpotTag = SpotTag_1.SpotTag;\n\nvar SpotRenderTag_1 = __webpack_require__(/*! ./component/tag/tag/SpotRenderTag */ \"./src/component/tag/tag/SpotRenderTag.ts\");\n\nexports.SpotRenderTag = SpotRenderTag_1.SpotRenderTag;\n\nvar TagDomain_1 = __webpack_require__(/*! ./component/tag/tag/TagDomain */ \"./src/component/tag/tag/TagDomain.ts\");\n\nexports.TagDomain = TagDomain_1.TagDomain;\n\nvar TagComponent_1 = __webpack_require__(/*! ./component/tag/TagComponent */ \"./src/component/tag/TagComponent.ts\");\n\nexports.TagComponent = TagComponent_1.TagComponent;\n\nvar TagCreator_1 = __webpack_require__(/*! ./component/tag/TagCreator */ \"./src/component/tag/TagCreator.ts\");\n\nexports.TagCreator = TagCreator_1.TagCreator;\n\nvar TagDOMRenderer_1 = __webpack_require__(/*! ./component/tag/TagDOMRenderer */ \"./src/component/tag/TagDOMRenderer.ts\");\n\nexports.TagDOMRenderer = TagDOMRenderer_1.TagDOMRenderer;\n\nvar TagMode_1 = __webpack_require__(/*! ./component/tag/TagMode */ \"./src/component/tag/TagMode.ts\");\n\nexports.TagMode = TagMode_1.TagMode;\n\nvar TagOperation_1 = __webpack_require__(/*! ./component/tag/TagOperation */ \"./src/component/tag/TagOperation.ts\");\n\nexports.TagOperation = TagOperation_1.TagOperation;\n\nvar TagScene_1 = __webpack_require__(/*! ./component/tag/TagScene */ \"./src/component/tag/TagScene.ts\");\n\nexports.TagScene = TagScene_1.TagScene;\n\nvar TagSet_1 = __webpack_require__(/*! ./component/tag/TagSet */ \"./src/component/tag/TagSet.ts\");\n\nexports.TagSet = TagSet_1.TagSet;\n\nvar Geometry_1 = __webpack_require__(/*! ./component/tag/geometry/Geometry */ \"./src/component/tag/geometry/Geometry.ts\");\n\nexports.Geometry = Geometry_1.Geometry;\n\nvar VertexGeometry_1 = __webpack_require__(/*! ./component/tag/geometry/VertexGeometry */ \"./src/component/tag/geometry/VertexGeometry.ts\");\n\nexports.VertexGeometry = VertexGeometry_1.VertexGeometry;\n\nvar RectGeometry_1 = __webpack_require__(/*! ./component/tag/geometry/RectGeometry */ \"./src/component/tag/geometry/RectGeometry.ts\");\n\nexports.RectGeometry = RectGeometry_1.RectGeometry;\n\nvar PointGeometry_1 = __webpack_require__(/*! ./component/tag/geometry/PointGeometry */ \"./src/component/tag/geometry/PointGeometry.ts\");\n\nexports.PointGeometry = PointGeometry_1.PointGeometry;\n\nvar PolygonGeometry_1 = __webpack_require__(/*! ./component/tag/geometry/PolygonGeometry */ \"./src/component/tag/geometry/PolygonGeometry.ts\");\n\nexports.PolygonGeometry = PolygonGeometry_1.PolygonGeometry;\n\nvar GeometryTagError_1 = __webpack_require__(/*! ./component/tag/error/GeometryTagError */ \"./src/component/tag/error/GeometryTagError.ts\");\n\nexports.GeometryTagError = GeometryTagError_1.GeometryTagError;\n\nvar ZoomComponent_1 = __webpack_require__(/*! ./component/zoom/ZoomComponent */ \"./src/component/zoom/ZoomComponent.ts\");\n\nexports.ZoomComponent = ZoomComponent_1.ZoomComponent;\n\n__export(__webpack_require__(/*! ./component/interfaces/interfaces */ \"./src/component/interfaces/interfaces.ts\"));\n\n//# sourceURL=webpack://Mapillary/./src/Component.ts?");

/***/ }),

/***/ "./src/Edge.ts":
/*!*********************!*\
  !*** ./src/Edge.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar EdgeDirection_1 = __webpack_require__(/*! ./graph/edge/EdgeDirection */ \"./src/graph/edge/EdgeDirection.ts\");\n\nexports.EdgeDirection = EdgeDirection_1.EdgeDirection;\n\nvar EdgeCalculatorSettings_1 = __webpack_require__(/*! ./graph/edge/EdgeCalculatorSettings */ \"./src/graph/edge/EdgeCalculatorSettings.ts\");\n\nexports.EdgeCalculatorSettings = EdgeCalculatorSettings_1.EdgeCalculatorSettings;\n\nvar EdgeCalculatorDirections_1 = __webpack_require__(/*! ./graph/edge/EdgeCalculatorDirections */ \"./src/graph/edge/EdgeCalculatorDirections.ts\");\n\nexports.EdgeCalculatorDirections = EdgeCalculatorDirections_1.EdgeCalculatorDirections;\n\nvar EdgeCalculatorCoefficients_1 = __webpack_require__(/*! ./graph/edge/EdgeCalculatorCoefficients */ \"./src/graph/edge/EdgeCalculatorCoefficients.ts\");\n\nexports.EdgeCalculatorCoefficients = EdgeCalculatorCoefficients_1.EdgeCalculatorCoefficients;\n\nvar EdgeCalculator_1 = __webpack_require__(/*! ./graph/edge/EdgeCalculator */ \"./src/graph/edge/EdgeCalculator.ts\");\n\nexports.EdgeCalculator = EdgeCalculator_1.EdgeCalculator;\n\n//# sourceURL=webpack://Mapillary/./src/Edge.ts?");

/***/ }),

/***/ "./src/Error.ts":
/*!**********************!*\
  !*** ./src/Error.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar AbortMapillaryError_1 = __webpack_require__(/*! ./error/AbortMapillaryError */ \"./src/error/AbortMapillaryError.ts\");\n\nexports.AbortMapillaryError = AbortMapillaryError_1.AbortMapillaryError;\n\nvar ArgumentMapillaryError_1 = __webpack_require__(/*! ./error/ArgumentMapillaryError */ \"./src/error/ArgumentMapillaryError.ts\");\n\nexports.ArgumentMapillaryError = ArgumentMapillaryError_1.ArgumentMapillaryError;\n\nvar GraphMapillaryError_1 = __webpack_require__(/*! ./error/GraphMapillaryError */ \"./src/error/GraphMapillaryError.ts\");\n\nexports.GraphMapillaryError = GraphMapillaryError_1.GraphMapillaryError;\n\nvar MapillaryError_1 = __webpack_require__(/*! ./error/MapillaryError */ \"./src/error/MapillaryError.ts\");\n\nexports.MapillaryError = MapillaryError_1.MapillaryError;\n\n//# sourceURL=webpack://Mapillary/./src/Error.ts?");

/***/ }),

/***/ "./src/Geo.ts":
/*!********************!*\
  !*** ./src/Geo.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Camera_1 = __webpack_require__(/*! ./geo/Camera */ \"./src/geo/Camera.ts\");\n\nexports.Camera = Camera_1.Camera;\n\nvar GeoCoords_1 = __webpack_require__(/*! ./geo/GeoCoords */ \"./src/geo/GeoCoords.ts\");\n\nexports.GeoCoords = GeoCoords_1.GeoCoords;\n\nvar ViewportCoords_1 = __webpack_require__(/*! ./geo/ViewportCoords */ \"./src/geo/ViewportCoords.ts\");\n\nexports.ViewportCoords = ViewportCoords_1.ViewportCoords;\n\nvar Spatial_1 = __webpack_require__(/*! ./geo/Spatial */ \"./src/geo/Spatial.ts\");\n\nexports.Spatial = Spatial_1.Spatial;\n\nvar Transform_1 = __webpack_require__(/*! ./geo/Transform */ \"./src/geo/Transform.ts\");\n\nexports.Transform = Transform_1.Transform;\n\nvar Geo = __webpack_require__(/*! ./geo/Geo */ \"./src/geo/Geo.ts\");\n\nexports.Geo = Geo;\n\nvar Lines = __webpack_require__(/*! ./geo/Lines */ \"./src/geo/Lines.ts\");\n\nexports.Lines = Lines;\n\n//# sourceURL=webpack://Mapillary/./src/Geo.ts?");

/***/ }),

/***/ "./src/Graph.ts":
/*!**********************!*\
  !*** ./src/Graph.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar FilterCreator_1 = __webpack_require__(/*! ./graph/FilterCreator */ \"./src/graph/FilterCreator.ts\");\n\nexports.FilterCreator = FilterCreator_1.FilterCreator;\n\nvar Graph_1 = __webpack_require__(/*! ./graph/Graph */ \"./src/graph/Graph.ts\");\n\nexports.Graph = Graph_1.Graph;\n\nvar GraphCalculator_1 = __webpack_require__(/*! ./graph/GraphCalculator */ \"./src/graph/GraphCalculator.ts\");\n\nexports.GraphCalculator = GraphCalculator_1.GraphCalculator;\n\nvar GraphMode_1 = __webpack_require__(/*! ./graph/GraphMode */ \"./src/graph/GraphMode.ts\");\n\nexports.GraphMode = GraphMode_1.GraphMode;\n\nvar GraphService_1 = __webpack_require__(/*! ./graph/GraphService */ \"./src/graph/GraphService.ts\");\n\nexports.GraphService = GraphService_1.GraphService;\n\nvar ImageLoadingService_1 = __webpack_require__(/*! ./graph/ImageLoadingService */ \"./src/graph/ImageLoadingService.ts\");\n\nexports.ImageLoadingService = ImageLoadingService_1.ImageLoadingService;\n\nvar MeshReader_1 = __webpack_require__(/*! ./graph/MeshReader */ \"./src/graph/MeshReader.ts\");\n\nexports.MeshReader = MeshReader_1.MeshReader;\n\nvar Node_1 = __webpack_require__(/*! ./graph/Node */ \"./src/graph/Node.ts\");\n\nexports.Node = Node_1.Node;\n\nvar NodeCache_1 = __webpack_require__(/*! ./graph/NodeCache */ \"./src/graph/NodeCache.ts\");\n\nexports.NodeCache = NodeCache_1.NodeCache;\n\nvar Sequence_1 = __webpack_require__(/*! ./graph/Sequence */ \"./src/graph/Sequence.ts\");\n\nexports.Sequence = Sequence_1.Sequence;\n\n//# sourceURL=webpack://Mapillary/./src/Graph.ts?");

/***/ }),

/***/ "./src/Mapillary.ts":
/*!**************************!*\
  !*** ./src/Mapillary.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * MapillaryJS is a WebGL JavaScript library for exploring street level imagery\n * @name Mapillary\n */\n\nfunction __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__export(__webpack_require__(/*! ./Support */ \"./src/Support.ts\"));\n\nvar Edge_1 = __webpack_require__(/*! ./Edge */ \"./src/Edge.ts\");\n\nexports.EdgeDirection = Edge_1.EdgeDirection;\n\nvar Error_1 = __webpack_require__(/*! ./Error */ \"./src/Error.ts\");\n\nexports.AbortMapillaryError = Error_1.AbortMapillaryError;\n\nvar Render_1 = __webpack_require__(/*! ./Render */ \"./src/Render.ts\");\n\nexports.RenderMode = Render_1.RenderMode;\n\nvar State_1 = __webpack_require__(/*! ./State */ \"./src/State.ts\");\n\nexports.TransitionMode = State_1.TransitionMode;\n\nvar Viewer_1 = __webpack_require__(/*! ./Viewer */ \"./src/Viewer.ts\");\n\nexports.Alignment = Viewer_1.Alignment;\nexports.ImageSize = Viewer_1.ImageSize;\nexports.Viewer = Viewer_1.Viewer;\n\nvar Component_1 = __webpack_require__(/*! ./Component */ \"./src/Component.ts\");\n\nexports.SliderMode = Component_1.SliderMode;\nexports.ComponentSize = Component_1.ComponentSize;\n\nvar TagComponent = __webpack_require__(/*! ./component/tag/Tag */ \"./src/component/tag/Tag.ts\");\n\nexports.TagComponent = TagComponent;\n\nvar MarkerComponent = __webpack_require__(/*! ./component/marker/Marker */ \"./src/component/marker/Marker.ts\");\n\nexports.MarkerComponent = MarkerComponent;\n\nvar PopupComponent = __webpack_require__(/*! ./component/popup/Popup */ \"./src/component/popup/Popup.ts\");\n\nexports.PopupComponent = PopupComponent;\n\n//# sourceURL=webpack://Mapillary/./src/Mapillary.ts?");

/***/ }),

/***/ "./src/Render.ts":
/*!***********************!*\
  !*** ./src/Render.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DOMRenderer_1 = __webpack_require__(/*! ./render/DOMRenderer */ \"./src/render/DOMRenderer.ts\");\n\nexports.DOMRenderer = DOMRenderer_1.DOMRenderer;\n\nvar GLRenderer_1 = __webpack_require__(/*! ./render/GLRenderer */ \"./src/render/GLRenderer.ts\");\n\nexports.GLRenderer = GLRenderer_1.GLRenderer;\n\nvar GLRenderStage_1 = __webpack_require__(/*! ./render/GLRenderStage */ \"./src/render/GLRenderStage.ts\");\n\nexports.GLRenderStage = GLRenderStage_1.GLRenderStage;\n\nvar RenderCamera_1 = __webpack_require__(/*! ./render/RenderCamera */ \"./src/render/RenderCamera.ts\");\n\nexports.RenderCamera = RenderCamera_1.RenderCamera;\n\nvar RenderMode_1 = __webpack_require__(/*! ./render/RenderMode */ \"./src/render/RenderMode.ts\");\n\nexports.RenderMode = RenderMode_1.RenderMode;\n\nvar RenderService_1 = __webpack_require__(/*! ./render/RenderService */ \"./src/render/RenderService.ts\");\n\nexports.RenderService = RenderService_1.RenderService;\n\n//# sourceURL=webpack://Mapillary/./src/Render.ts?");

/***/ }),

/***/ "./src/State.ts":
/*!**********************!*\
  !*** ./src/State.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar FrameGenerator_1 = __webpack_require__(/*! ./state/FrameGenerator */ \"./src/state/FrameGenerator.ts\");\n\nexports.FrameGenerator = FrameGenerator_1.FrameGenerator;\n\nvar RotationDelta_1 = __webpack_require__(/*! ./state/RotationDelta */ \"./src/state/RotationDelta.ts\");\n\nexports.RotationDelta = RotationDelta_1.RotationDelta;\n\nvar State_1 = __webpack_require__(/*! ./state/State */ \"./src/state/State.ts\");\n\nexports.State = State_1.State;\n\nvar StateBase_1 = __webpack_require__(/*! ./state/states/StateBase */ \"./src/state/states/StateBase.ts\");\n\nexports.StateBase = StateBase_1.StateBase;\n\nvar StateContext_1 = __webpack_require__(/*! ./state/StateContext */ \"./src/state/StateContext.ts\");\n\nexports.StateContext = StateContext_1.StateContext;\n\nvar StateService_1 = __webpack_require__(/*! ./state/StateService */ \"./src/state/StateService.ts\");\n\nexports.StateService = StateService_1.StateService;\n\nvar TransitionMode_1 = __webpack_require__(/*! ./state/TransitionMode */ \"./src/state/TransitionMode.ts\");\n\nexports.TransitionMode = TransitionMode_1.TransitionMode;\n\nvar EarthState_1 = __webpack_require__(/*! ./state/states/EarthState */ \"./src/state/states/EarthState.ts\");\n\nexports.EarthState = EarthState_1.EarthState;\n\nvar InteractiveStateBase_1 = __webpack_require__(/*! ./state/states/InteractiveStateBase */ \"./src/state/states/InteractiveStateBase.ts\");\n\nexports.InteractiveStateBase = InteractiveStateBase_1.InteractiveStateBase;\n\nvar InteractiveWaitingState_1 = __webpack_require__(/*! ./state/states/InteractiveWaitingState */ \"./src/state/states/InteractiveWaitingState.ts\");\n\nexports.InteractiveWaitingState = InteractiveWaitingState_1.InteractiveWaitingState;\n\nvar TraversingState_1 = __webpack_require__(/*! ./state/states/TraversingState */ \"./src/state/states/TraversingState.ts\");\n\nexports.TraversingState = TraversingState_1.TraversingState;\n\nvar WaitingState_1 = __webpack_require__(/*! ./state/states/WaitingState */ \"./src/state/states/WaitingState.ts\");\n\nexports.WaitingState = WaitingState_1.WaitingState;\n\n//# sourceURL=webpack://Mapillary/./src/State.ts?");

/***/ }),

/***/ "./src/Support.ts":
/*!************************!*\
  !*** ./src/Support.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar support = __webpack_require__(/*! ./utils/Support */ \"./src/utils/Support.ts\");\n/**\n * Test whether the current browser supports the full\n * functionality of MapillaryJS.\n *\n * @description The full functionality includes WebGL rendering.\n *\n * @return {boolean}\n *\n * @example `var supported = Mapillary.isSupported();`\n */\n\n\nfunction isSupported() {\n  return isFallbackSupported() && support.isWebGLSupportedCached();\n}\n\nexports.isSupported = isSupported;\n/**\n * Test whether the current browser supports the fallback\n * functionality of MapillaryJS.\n *\n * @description The fallback functionality does not include WebGL\n * rendering, only 2D canvas rendering.\n *\n * @return {boolean}\n *\n * @example `var fallbackSupported = Mapillary.isFallbackSupported();`\n */\n\nfunction isFallbackSupported() {\n  return support.isBrowser() && support.isBlobSupported() && support.isArraySupported() && support.isFunctionSupported() && support.isJSONSupported() && support.isObjectSupported();\n}\n\nexports.isFallbackSupported = isFallbackSupported;\n\n//# sourceURL=webpack://Mapillary/./src/Support.ts?");

/***/ }),

/***/ "./src/Tiles.ts":
/*!**********************!*\
  !*** ./src/Tiles.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ImageTileLoader_1 = __webpack_require__(/*! ./tiles/ImageTileLoader */ \"./src/tiles/ImageTileLoader.ts\");\n\nexports.ImageTileLoader = ImageTileLoader_1.ImageTileLoader;\n\nvar ImageTileStore_1 = __webpack_require__(/*! ./tiles/ImageTileStore */ \"./src/tiles/ImageTileStore.ts\");\n\nexports.ImageTileStore = ImageTileStore_1.ImageTileStore;\n\nvar TextureProvider_1 = __webpack_require__(/*! ./tiles/TextureProvider */ \"./src/tiles/TextureProvider.ts\");\n\nexports.TextureProvider = TextureProvider_1.TextureProvider;\n\nvar RegionOfInterestCalculator_1 = __webpack_require__(/*! ./tiles/RegionOfInterestCalculator */ \"./src/tiles/RegionOfInterestCalculator.ts\");\n\nexports.RegionOfInterestCalculator = RegionOfInterestCalculator_1.RegionOfInterestCalculator;\n\n//# sourceURL=webpack://Mapillary/./src/Tiles.ts?");

/***/ }),

/***/ "./src/Utils.ts":
/*!**********************!*\
  !*** ./src/Utils.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DOM_1 = __webpack_require__(/*! ./utils/DOM */ \"./src/utils/DOM.ts\");\n\nexports.DOM = DOM_1.DOM;\n\nvar EventEmitter_1 = __webpack_require__(/*! ./utils/EventEmitter */ \"./src/utils/EventEmitter.ts\");\n\nexports.EventEmitter = EventEmitter_1.EventEmitter;\n\nvar Settings_1 = __webpack_require__(/*! ./utils/Settings */ \"./src/utils/Settings.ts\");\n\nexports.Settings = Settings_1.Settings;\n\n__export(__webpack_require__(/*! ./utils/Support */ \"./src/utils/Support.ts\"));\n\nvar Urls_1 = __webpack_require__(/*! ./utils/Urls */ \"./src/utils/Urls.ts\");\n\nexports.Urls = Urls_1.Urls;\n\n//# sourceURL=webpack://Mapillary/./src/Utils.ts?");

/***/ }),

/***/ "./src/Viewer.ts":
/*!***********************!*\
  !*** ./src/Viewer.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Alignment_1 = __webpack_require__(/*! ./viewer/Alignment */ \"./src/viewer/Alignment.ts\");\n\nexports.Alignment = Alignment_1.Alignment;\n\nvar CacheService_1 = __webpack_require__(/*! ./viewer/CacheService */ \"./src/viewer/CacheService.ts\");\n\nexports.CacheService = CacheService_1.CacheService;\n\nvar ComponentController_1 = __webpack_require__(/*! ./viewer/ComponentController */ \"./src/viewer/ComponentController.ts\");\n\nexports.ComponentController = ComponentController_1.ComponentController;\n\nvar Container_1 = __webpack_require__(/*! ./viewer/Container */ \"./src/viewer/Container.ts\");\n\nexports.Container = Container_1.Container;\n\nvar Observer_1 = __webpack_require__(/*! ./viewer/Observer */ \"./src/viewer/Observer.ts\");\n\nexports.Observer = Observer_1.Observer;\n\nvar ImageSize_1 = __webpack_require__(/*! ./viewer/ImageSize */ \"./src/viewer/ImageSize.ts\");\n\nexports.ImageSize = ImageSize_1.ImageSize;\n\nvar KeyboardService_1 = __webpack_require__(/*! ./viewer/KeyboardService */ \"./src/viewer/KeyboardService.ts\");\n\nexports.KeyboardService = KeyboardService_1.KeyboardService;\n\nvar LoadingService_1 = __webpack_require__(/*! ./viewer/LoadingService */ \"./src/viewer/LoadingService.ts\");\n\nexports.LoadingService = LoadingService_1.LoadingService;\n\nvar MouseService_1 = __webpack_require__(/*! ./viewer/MouseService */ \"./src/viewer/MouseService.ts\");\n\nexports.MouseService = MouseService_1.MouseService;\n\nvar Navigator_1 = __webpack_require__(/*! ./viewer/Navigator */ \"./src/viewer/Navigator.ts\");\n\nexports.Navigator = Navigator_1.Navigator;\n\nvar PlayService_1 = __webpack_require__(/*! ./viewer/PlayService */ \"./src/viewer/PlayService.ts\");\n\nexports.PlayService = PlayService_1.PlayService;\n\nvar Projection_1 = __webpack_require__(/*! ./viewer/Projection */ \"./src/viewer/Projection.ts\");\n\nexports.Projection = Projection_1.Projection;\n\nvar SpriteService_1 = __webpack_require__(/*! ./viewer/SpriteService */ \"./src/viewer/SpriteService.ts\");\n\nexports.SpriteService = SpriteService_1.SpriteService;\n\nvar TouchService_1 = __webpack_require__(/*! ./viewer/TouchService */ \"./src/viewer/TouchService.ts\");\n\nexports.TouchService = TouchService_1.TouchService;\n\nvar Viewer_1 = __webpack_require__(/*! ./viewer/Viewer */ \"./src/viewer/Viewer.ts\");\n\nexports.Viewer = Viewer_1.Viewer;\n\n//# sourceURL=webpack://Mapillary/./src/Viewer.ts?");

/***/ }),

/***/ "./src/api/APIv3.ts":
/*!**************************!*\
  !*** ./src/api/APIv3.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar API_1 = __webpack_require__(/*! ../API */ \"./src/API.ts\");\n/**\n * @class APIv3\n *\n * @classdesc Provides methods for access of API v3.\n */\n\n\nvar APIv3 =\n/** @class */\nfunction () {\n  /**\n   * Create a new api v3 instance.\n   *\n   * @param {number} clientId - Client id for API requests.\n   * @param {number} [token] - Optional bearer token for API requests of\n   * protected resources.\n   * @param {ModelCreator} [creator] - Optional model creator instance.\n   */\n  function APIv3(clientId, token, creator) {\n    this._clientId = clientId;\n    this._modelCreator = creator != null ? creator : new API_1.ModelCreator();\n    this._model = this._modelCreator.createModel(clientId, token);\n    this._pageCount = 999;\n    this._pathImageByKey = \"imageByKey\";\n    this._pathImageCloseTo = \"imageCloseTo\";\n    this._pathImagesByH = \"imagesByH\";\n    this._pathImageViewAdd = \"imageViewAdd\";\n    this._pathSequenceByKey = \"sequenceByKey\";\n    this._pathSequenceViewAdd = \"sequenceViewAdd\";\n    this._propertiesCore = [\"cl\", \"l\", \"sequence_key\"];\n    this._propertiesFill = [\"captured_at\", \"captured_with_camera_uuid\", \"user\", \"organization_key\", \"private\", \"project\"];\n    this._propertiesKey = [\"key\"];\n    this._propertiesSequence = [\"keys\"];\n    this._propertiesSpatial = [\"atomic_scale\", \"c_rotation\", \"ca\", \"calt\", \"camera_projection_type\", \"cca\", \"cfocal\", \"ck1\", \"ck2\", \"gpano\", \"height\", \"merge_cc\", \"merge_version\", \"orientation\", \"width\"];\n    this._propertiesUser = [\"username\"];\n  }\n\n  APIv3.prototype.imageByKeyFill$ = function (keys) {\n    return this._catchInvalidateGet$(this._wrapModelResponse$(this._model.get([this._pathImageByKey, keys, this._propertiesKey.concat(this._propertiesFill).concat(this._propertiesSpatial), this._propertiesKey.concat(this._propertiesUser)])).pipe(operators_1.map(function (value) {\n      if (!value) {\n        throw new Error(\"Images (\" + keys.join(\", \") + \") could not be found.\");\n      }\n\n      return value.json.imageByKey;\n    })), this._pathImageByKey, keys);\n  };\n\n  APIv3.prototype.imageByKeyFull$ = function (keys) {\n    return this._catchInvalidateGet$(this._wrapModelResponse$(this._model.get([this._pathImageByKey, keys, this._propertiesKey.concat(this._propertiesCore).concat(this._propertiesFill).concat(this._propertiesSpatial), this._propertiesKey.concat(this._propertiesUser)])).pipe(operators_1.map(function (value) {\n      if (!value) {\n        throw new Error(\"Images (\" + keys.join(\", \") + \") could not be found.\");\n      }\n\n      return value.json.imageByKey;\n    })), this._pathImageByKey, keys);\n  };\n\n  APIv3.prototype.imageCloseTo$ = function (lat, lon) {\n    var lonLat = lon + \":\" + lat;\n    return this._catchInvalidateGet$(this._wrapModelResponse$(this._model.get([this._pathImageCloseTo, [lonLat], this._propertiesKey.concat(this._propertiesCore).concat(this._propertiesFill).concat(this._propertiesSpatial), this._propertiesKey.concat(this._propertiesUser)])).pipe(operators_1.map(function (value) {\n      return value != null ? value.json.imageCloseTo[lonLat] : null;\n    })), this._pathImageCloseTo, [lonLat]);\n  };\n\n  APIv3.prototype.imagesByH$ = function (hs) {\n    var _this = this;\n\n    return this._catchInvalidateGet$(this._wrapModelResponse$(this._model.get([this._pathImagesByH, hs, {\n      from: 0,\n      to: this._pageCount\n    }, this._propertiesKey.concat(this._propertiesCore)])).pipe(operators_1.map(function (value) {\n      if (!value) {\n        value = {\n          json: {\n            imagesByH: {}\n          }\n        };\n\n        for (var _i = 0, hs_1 = hs; _i < hs_1.length; _i++) {\n          var h = hs_1[_i];\n          value.json.imagesByH[h] = {};\n\n          for (var i = 0; i <= _this._pageCount; i++) {\n            value.json.imagesByH[h][i] = null;\n          }\n        }\n      }\n\n      return value.json.imagesByH;\n    })), this._pathImagesByH, hs);\n  };\n\n  APIv3.prototype.imageViewAdd$ = function (keys) {\n    return this._catchInvalidateCall$(this._wrapCallModelResponse$(this._model.call([this._pathImageViewAdd], [keys])), this._pathImageViewAdd, keys);\n  };\n\n  APIv3.prototype.invalidateImageByKey = function (keys) {\n    this._invalidateGet(this._pathImageByKey, keys);\n  };\n\n  APIv3.prototype.invalidateImagesByH = function (hs) {\n    this._invalidateGet(this._pathImagesByH, hs);\n  };\n\n  APIv3.prototype.invalidateSequenceByKey = function (sKeys) {\n    this._invalidateGet(this._pathSequenceByKey, sKeys);\n  };\n\n  APIv3.prototype.setToken = function (token) {\n    this._model.invalidate([]);\n\n    this._model = null;\n    this._model = this._modelCreator.createModel(this._clientId, token);\n  };\n\n  APIv3.prototype.sequenceByKey$ = function (sequenceKeys) {\n    return this._catchInvalidateGet$(this._wrapModelResponse$(this._model.get([this._pathSequenceByKey, sequenceKeys, this._propertiesKey.concat(this._propertiesSequence)])).pipe(operators_1.map(function (value) {\n      if (!value) {\n        value = {\n          json: {\n            sequenceByKey: {}\n          }\n        };\n      }\n\n      for (var _i = 0, sequenceKeys_1 = sequenceKeys; _i < sequenceKeys_1.length; _i++) {\n        var sequenceKey = sequenceKeys_1[_i];\n\n        if (!(sequenceKey in value.json.sequenceByKey)) {\n          console.warn(\"Sequence data missing (\" + sequenceKey + \")\");\n          value.json.sequenceByKey[sequenceKey] = {\n            key: sequenceKey,\n            keys: []\n          };\n        }\n      }\n\n      return value.json.sequenceByKey;\n    })), this._pathSequenceByKey, sequenceKeys);\n  };\n\n  APIv3.prototype.sequenceViewAdd$ = function (sequenceKeys) {\n    return this._catchInvalidateCall$(this._wrapCallModelResponse$(this._model.call([this._pathSequenceViewAdd], [sequenceKeys])), this._pathSequenceViewAdd, sequenceKeys);\n  };\n\n  Object.defineProperty(APIv3.prototype, \"clientId\", {\n    get: function get() {\n      return this._clientId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  APIv3.prototype._catchInvalidateGet$ = function (observable, path, paths) {\n    var _this = this;\n\n    return observable.pipe(operators_1.catchError(function (error) {\n      _this._invalidateGet(path, paths);\n\n      throw error;\n    }));\n  };\n\n  APIv3.prototype._catchInvalidateCall$ = function (observable, path, paths) {\n    var _this = this;\n\n    return observable.pipe(operators_1.catchError(function (error) {\n      _this._invalidateCall(path, paths);\n\n      throw error;\n    }));\n  };\n\n  APIv3.prototype._invalidateGet = function (path, paths) {\n    this._model.invalidate([path, paths]);\n  };\n\n  APIv3.prototype._invalidateCall = function (path, paths) {\n    this._model.invalidate([path], [paths]);\n  };\n\n  APIv3.prototype._wrapModelResponse$ = function (modelResponse) {\n    return rxjs_1.Observable.create(function (subscriber) {\n      modelResponse.then(function (value) {\n        subscriber.next(value);\n        subscriber.complete();\n      }, function (error) {\n        subscriber.error(error);\n      });\n    });\n  };\n\n  APIv3.prototype._wrapCallModelResponse$ = function (modelResponse) {\n    return this._wrapModelResponse$(modelResponse).pipe(operators_1.map(function (value) {\n      return;\n    }));\n  };\n\n  return APIv3;\n}();\n\nexports.APIv3 = APIv3;\nexports.default = APIv3;\n\n//# sourceURL=webpack://Mapillary/./src/api/APIv3.ts?");

/***/ }),

/***/ "./src/api/ModelCreator.ts":
/*!*********************************!*\
  !*** ./src/api/ModelCreator.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar falcor = __webpack_require__(/*! falcor */ \"./node_modules/falcor/dist/falcor.browser.min.js\");\n\nvar falcor_http_datasource_1 = __webpack_require__(/*! falcor-http-datasource */ \"./node_modules/falcor-http-datasource/src/XMLHttpSource.js\");\n\nvar Utils_1 = __webpack_require__(/*! ../Utils */ \"./src/Utils.ts\");\n/**\n * @class ModelCreator\n *\n * @classdesc Creates API models.\n */\n\n\nvar ModelCreator =\n/** @class */\nfunction () {\n  function ModelCreator() {}\n  /**\n   * Creates a Falcor model.\n   *\n   * @description Max cache size will be set to 16 MB. Authorization\n   * header will be added if bearer token is supplied.\n   *\n   * @param {number} clientId - Client id for API requests.\n   * @param {number} [token] - Optional bearer token for API requests of\n   * protected resources.\n   * @returns {falcor.Model} Falcor model for HTTP requests.\n   */\n\n\n  ModelCreator.prototype.createModel = function (clientId, token) {\n    var configuration = {\n      crossDomain: true,\n      withCredentials: false\n    };\n\n    if (token != null) {\n      configuration.headers = {\n        \"Authorization\": \"Bearer \" + token\n      };\n    }\n\n    return new falcor.Model({\n      maxSize: 16 * 1024 * 1024,\n      source: new falcor_http_datasource_1.default(Utils_1.Urls.falcorModel(clientId), configuration)\n    });\n  };\n\n  return ModelCreator;\n}();\n\nexports.ModelCreator = ModelCreator;\nexports.default = ModelCreator;\n\n//# sourceURL=webpack://Mapillary/./src/api/ModelCreator.ts?");

/***/ }),

/***/ "./src/component/AttributionComponent.ts":
/*!***********************************************!*\
  !*** ./src/component/AttributionComponent.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../Utils */ \"./src/Utils.ts\");\n\nvar AttributionComponent =\n/** @class */\nfunction (_super) {\n  __extends(AttributionComponent, _super);\n\n  function AttributionComponent(name, container, navigator) {\n    return _super.call(this, name, container, navigator) || this;\n  }\n\n  AttributionComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._disposable = rxjs_1.combineLatest(this._navigator.stateService.currentNode$, this._container.renderService.size$).pipe(operators_1.map(function (_a) {\n      var node = _a[0],\n          size = _a[1];\n      return {\n        name: _this._name,\n        vnode: _this._getAttributionNode(node.username, node.key, node.capturedAt, size.width)\n      };\n    })).subscribe(this._container.domRenderer.render$);\n  };\n\n  AttributionComponent.prototype._deactivate = function () {\n    this._disposable.unsubscribe();\n  };\n\n  AttributionComponent.prototype._getDefaultConfiguration = function () {\n    return {};\n  };\n\n  AttributionComponent.prototype._getAttributionNode = function (username, key, capturedAt, width) {\n    var compact = width <= 640;\n    var mapillaryIcon = vd.h(\"div.AttributionMapillaryLogo\", []);\n    var mapillaryLink = vd.h(\"a.AttributionIconContainer\", {\n      href: Utils_1.Urls.explore,\n      target: \"_blank\"\n    }, [mapillaryIcon]);\n    var imageBy = compact ? \"\" + username : \"image by \" + username;\n    var imageByContent = vd.h(\"div.AttributionUsername\", {\n      textContent: imageBy\n    }, []);\n    var date = new Date(capturedAt).toDateString().split(\" \");\n    var formatted = (date.length > 3 ? compact ? [date[3]] : [date[1], date[2] + \",\", date[3]] : date).join(\" \");\n    var dateContent = vd.h(\"div.AttributionDate\", {\n      textContent: formatted\n    }, []);\n    var imageLink = vd.h(\"a.AttributionImageContainer\", {\n      href: Utils_1.Urls.exporeImage(key),\n      target: \"_blank\"\n    }, [imageByContent, dateContent]);\n    var compactClass = compact ? \".AttributionCompact\" : \"\";\n    return vd.h(\"div.AttributionContainer\" + compactClass, {}, [mapillaryLink, imageLink]);\n  };\n\n  AttributionComponent.componentName = \"attribution\";\n  return AttributionComponent;\n}(Component_1.Component);\n\nexports.AttributionComponent = AttributionComponent;\nComponent_1.ComponentService.register(AttributionComponent);\nexports.default = AttributionComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/AttributionComponent.ts?");

/***/ }),

/***/ "./src/component/BackgroundComponent.ts":
/*!**********************************************!*\
  !*** ./src/component/BackgroundComponent.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n\nvar BackgroundComponent =\n/** @class */\nfunction (_super) {\n  __extends(BackgroundComponent, _super);\n\n  function BackgroundComponent(name, container, navigator) {\n    return _super.call(this, name, container, navigator) || this;\n  }\n\n  BackgroundComponent.prototype._activate = function () {\n    this._container.domRenderer.render$.next({\n      name: this._name,\n      vnode: this._getBackgroundNode(\"The viewer can't display the given image.\")\n    });\n  };\n\n  BackgroundComponent.prototype._deactivate = function () {\n    return;\n  };\n\n  BackgroundComponent.prototype._getDefaultConfiguration = function () {\n    return {};\n  };\n\n  BackgroundComponent.prototype._getBackgroundNode = function (notice) {\n    // todo: add condition for when to display the DOM node\n    return vd.h(\"div.BackgroundWrapper\", {}, [vd.h(\"p\", {\n      textContent: notice\n    }, [])]);\n  };\n\n  BackgroundComponent.componentName = \"background\";\n  return BackgroundComponent;\n}(Component_1.Component);\n\nexports.BackgroundComponent = BackgroundComponent;\nComponent_1.ComponentService.register(BackgroundComponent);\nexports.default = BackgroundComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/BackgroundComponent.ts?");

/***/ }),

/***/ "./src/component/BearingComponent.ts":
/*!*******************************************!*\
  !*** ./src/component/BearingComponent.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar UnitBezier = __webpack_require__(/*! @mapbox/unitbezier */ \"./node_modules/@mapbox/unitbezier/index.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../Geo */ \"./src/Geo.ts\");\n\nvar ViewportCoords_1 = __webpack_require__(/*! ../geo/ViewportCoords */ \"./src/geo/ViewportCoords.ts\");\n\nvar ComponentSize_1 = __webpack_require__(/*! ./utils/ComponentSize */ \"./src/component/utils/ComponentSize.ts\");\n/**\n * @class BearingComponent\n *\n * @classdesc Component for indicating bearing and field of view.\n *\n * @example\n * ```\n * var viewer = new Mapillary.Viewer(\n *     \"<element-id>\",\n *     \"<client-id>\",\n *     \"<my key>\");\n *\n * var bearingComponent = viewer.getComponent(\"bearing\");\n * bearingComponent.configure({ size: Mapillary.ComponentSize.Small });\n * ```\n */\n\n\nvar BearingComponent =\n/** @class */\nfunction (_super) {\n  __extends(BearingComponent, _super);\n\n  function BearingComponent(name, container, navigator) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._spatial = new Geo_1.Spatial();\n    _this._viewportCoords = new ViewportCoords_1.default();\n    _this._svgNamespace = \"http://www.w3.org/2000/svg\";\n    _this._distinctThreshold = Math.PI / 360;\n    _this._animationSpeed = 0.075;\n    _this._unitBezier = new UnitBezier(0.74, 0.67, 0.38, 0.96);\n    return _this;\n  }\n\n  BearingComponent.prototype._activate = function () {\n    var _this = this;\n\n    var cameraBearingFov$ = this._container.renderService.renderCamera$.pipe(operators_1.map(function (rc) {\n      var vFov = _this._spatial.degToRad(rc.perspective.fov);\n\n      var hFov = rc.perspective.aspect === Number.POSITIVE_INFINITY ? Math.PI : Math.atan(rc.perspective.aspect * Math.tan(0.5 * vFov)) * 2;\n      return [_this._spatial.azimuthalToBearing(rc.rotation.phi), hFov];\n    }), operators_1.distinctUntilChanged(function (a1, a2) {\n      return Math.abs(a2[0] - a1[0]) < _this._distinctThreshold && Math.abs(a2[1] - a1[1]) < _this._distinctThreshold;\n    }));\n\n    var nodeFov$ = rxjs_1.combineLatest(this._navigator.stateService.currentState$.pipe(operators_1.distinctUntilChanged(undefined, function (frame) {\n      return frame.state.currentNode.key;\n    })), this._navigator.panService.panNodes$).pipe(operators_1.map(function (_a) {\n      var frame = _a[0],\n          panNodes = _a[1];\n      var node = frame.state.currentNode;\n      var transform = frame.state.currentTransform;\n\n      if (node.pano) {\n        var panoHFov = 2 * Math.PI * node.gpano.CroppedAreaImageWidthPixels / node.gpano.FullPanoWidthPixels;\n        return [panoHFov / 2, panoHFov / 2];\n      }\n\n      var currentProjectedPoints = _this._computeProjectedPoints(transform);\n\n      var hFov = _this._spatial.degToRad(_this._computeHorizontalFov(currentProjectedPoints));\n\n      var hFovLeft = hFov / 2;\n      var hFovRight = hFov / 2;\n\n      for (var _i = 0, panNodes_1 = panNodes; _i < panNodes_1.length; _i++) {\n        var _b = panNodes_1[_i],\n            n = _b[0],\n            f = _b[2];\n\n        var diff = _this._spatial.wrap(n.ca - node.ca, -180, 180);\n\n        if (diff < 0) {\n          hFovLeft = _this._spatial.degToRad(Math.abs(diff)) + f / 2;\n        } else {\n          hFovRight = _this._spatial.degToRad(Math.abs(diff)) + f / 2;\n        }\n      }\n\n      return [hFovLeft, hFovRight];\n    }), operators_1.distinctUntilChanged(function (_a, _b) {\n      var hFovLeft1 = _a[0],\n          hFovRight1 = _a[1];\n      var hFovLeft2 = _b[0],\n          hFovRight2 = _b[1];\n      return Math.abs(hFovLeft2 - hFovLeft1) < _this._distinctThreshold && Math.abs(hFovRight2 - hFovRight1) < _this._distinctThreshold;\n    }));\n    var offset$ = rxjs_1.combineLatest(this._navigator.stateService.currentState$.pipe(operators_1.distinctUntilChanged(undefined, function (frame) {\n      return frame.state.currentNode.key;\n    })), this._container.renderService.bearing$).pipe(operators_1.map(function (_a) {\n      var frame = _a[0],\n          bearing = _a[1];\n\n      var offset = _this._spatial.degToRad(frame.state.currentNode.ca - bearing);\n\n      return offset;\n    }));\n    var nodeFovOperation$ = new rxjs_1.Subject();\n    var smoothNodeFov$ = nodeFovOperation$.pipe(operators_1.scan(function (state, operation) {\n      return operation(state);\n    }, {\n      alpha: 0,\n      curr: [0, 0, 0],\n      prev: [0, 0, 0]\n    }), operators_1.map(function (state) {\n      var alpha = _this._unitBezier.solve(state.alpha);\n\n      var curr = state.curr;\n      var prev = state.prev;\n      return [_this._interpolate(prev[0], curr[0], alpha), _this._interpolate(prev[1], curr[1], alpha)];\n    }));\n    this._fovSubscription = nodeFov$.pipe(operators_1.map(function (nbf) {\n      return function (state) {\n        var a = _this._unitBezier.solve(state.alpha);\n\n        var c = state.curr;\n        var p = state.prev;\n        var prev = [_this._interpolate(p[0], c[0], a), _this._interpolate(p[1], c[1], a)];\n        var curr = nbf.slice();\n        return {\n          alpha: 0,\n          curr: curr,\n          prev: prev\n        };\n      };\n    })).subscribe(nodeFovOperation$);\n    this._fovAnimationSubscription = nodeFov$.pipe(operators_1.switchMap(function () {\n      return _this._container.renderService.renderCameraFrame$.pipe(operators_1.skip(1), operators_1.scan(function (alpha) {\n        return alpha + _this._animationSpeed;\n      }, 0), operators_1.takeWhile(function (alpha) {\n        return alpha <= 1 + _this._animationSpeed;\n      }), operators_1.map(function (alpha) {\n        return Math.min(alpha, 1);\n      }));\n    }), operators_1.map(function (alpha) {\n      return function (nbfState) {\n        return {\n          alpha: alpha,\n          curr: nbfState.curr.slice(),\n          prev: nbfState.prev.slice()\n        };\n      };\n    })).subscribe(nodeFovOperation$);\n    var nodeBearingFov$ = rxjs_1.combineLatest(offset$, smoothNodeFov$).pipe(operators_1.map(function (_a) {\n      var offset = _a[0],\n          fov = _a[1];\n      return [offset, fov[0], fov[1]];\n    }));\n    this._renderSubscription = rxjs_1.combineLatest(cameraBearingFov$, nodeBearingFov$, this._configuration$, this._container.renderService.size$).pipe(operators_1.map(function (_a) {\n      var _b = _a[0],\n          cb = _b[0],\n          cf = _b[1],\n          _c = _a[1],\n          no = _c[0],\n          nfl = _c[1],\n          nfr = _c[2],\n          configuration = _a[2],\n          size = _a[3];\n\n      var background = _this._createBackground(cb);\n\n      var fovIndicator = _this._createFovIndicator(nfl, nfr, no);\n\n      var north = _this._createNorth(cb);\n\n      var cameraSector = _this._createCircleSectorCompass(_this._createCircleSector(Math.max(Math.PI / 20, cf), \"#FFF\"));\n\n      var compact = configuration.size === ComponentSize_1.default.Small || configuration.size === ComponentSize_1.default.Automatic && size.width < 640 ? \".BearingCompact\" : \"\";\n      return {\n        name: _this._name,\n        vnode: vd.h(\"div.BearingIndicatorContainer\" + compact, {\n          oncontextmenu: function oncontextmenu(event) {\n            event.preventDefault();\n          }\n        }, [background, fovIndicator, north, cameraSector])\n      };\n    })).subscribe(this._container.domRenderer.render$);\n  };\n\n  BearingComponent.prototype._deactivate = function () {\n    this._renderSubscription.unsubscribe();\n\n    this._fovSubscription.unsubscribe();\n\n    this._fovAnimationSubscription.unsubscribe();\n  };\n\n  BearingComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      size: ComponentSize_1.default.Automatic\n    };\n  };\n\n  BearingComponent.prototype._createFovIndicator = function (fovLeft, fovRigth, offset) {\n    var arc = this._createFovArc(fovLeft, fovRigth);\n\n    var group = vd.h(\"g\", {\n      attributes: {\n        transform: \"translate(18,18)\"\n      },\n      namespace: this._svgNamespace\n    }, [arc]);\n    var svg = vd.h(\"svg\", {\n      attributes: {\n        viewBox: \"0 0 36 36\"\n      },\n      namespace: this._svgNamespace,\n      style: {\n        height: \"36px\",\n        left: \"2px\",\n        position: \"absolute\",\n        top: \"2px\",\n        transform: \"rotateZ(\" + this._spatial.radToDeg(offset) + \"deg)\",\n        width: \"36px\"\n      }\n    }, [group]);\n    return svg;\n  };\n\n  BearingComponent.prototype._createFovArc = function (fovLeft, fovRigth) {\n    var radius = 16.75;\n    var strokeWidth = 2.5;\n    var fov = fovLeft + fovRigth;\n\n    if (fov > 2 * Math.PI - Math.PI / 90) {\n      return vd.h(\"circle\", {\n        attributes: {\n          cx: \"0\",\n          cy: \"0\",\n          \"fill-opacity\": \"0\",\n          r: \"\" + radius,\n          stroke: \"#FFF\",\n          \"stroke-width\": \"\" + strokeWidth\n        },\n        namespace: this._svgNamespace\n      }, []);\n    }\n\n    var arcStart = -Math.PI / 2 - fovLeft;\n    var arcEnd = arcStart + fov;\n    var startX = radius * Math.cos(arcStart);\n    var startY = radius * Math.sin(arcStart);\n    var endX = radius * Math.cos(arcEnd);\n    var endY = radius * Math.sin(arcEnd);\n    var largeArc = fov >= Math.PI ? 1 : 0;\n    var description = \"M \" + startX + \" \" + startY + \" A \" + radius + \" \" + radius + \" 0 \" + largeArc + \" 1 \" + endX + \" \" + endY;\n    return vd.h(\"path\", {\n      attributes: {\n        d: description,\n        \"fill-opacity\": \"0\",\n        stroke: \"#FFF\",\n        \"stroke-width\": \"\" + strokeWidth\n      },\n      namespace: this._svgNamespace\n    }, []);\n  };\n\n  BearingComponent.prototype._createCircleSectorCompass = function (cameraSector) {\n    var group = vd.h(\"g\", {\n      attributes: {\n        transform: \"translate(1,1)\"\n      },\n      namespace: this._svgNamespace\n    }, [cameraSector]);\n    var svg = vd.h(\"svg\", {\n      attributes: {\n        viewBox: \"0 0 2 2\"\n      },\n      namespace: this._svgNamespace,\n      style: {\n        height: \"26px\",\n        left: \"7px\",\n        position: \"absolute\",\n        top: \"7px\",\n        width: \"26px\"\n      }\n    }, [group]);\n    return svg;\n  };\n\n  BearingComponent.prototype._createCircleSector = function (fov, fill) {\n    if (fov > 2 * Math.PI - Math.PI / 90) {\n      return vd.h(\"circle\", {\n        attributes: {\n          cx: \"0\",\n          cy: \"0\",\n          fill: fill,\n          r: \"1\"\n        },\n        namespace: this._svgNamespace\n      }, []);\n    }\n\n    var arcStart = -Math.PI / 2 - fov / 2;\n    var arcEnd = arcStart + fov;\n    var startX = Math.cos(arcStart);\n    var startY = Math.sin(arcStart);\n    var endX = Math.cos(arcEnd);\n    var endY = Math.sin(arcEnd);\n    var largeArc = fov >= Math.PI ? 1 : 0;\n    var description = \"M 0 0 \" + startX + \" \" + startY + \" A 1 1 0 \" + largeArc + \" 1 \" + endX + \" \" + endY;\n    return vd.h(\"path\", {\n      attributes: {\n        d: description,\n        fill: fill\n      },\n      namespace: this._svgNamespace\n    }, []);\n  };\n\n  BearingComponent.prototype._createNorth = function (bearing) {\n    var north = vd.h(\"div.BearingNorth\", []);\n    var container = vd.h(\"div.BearingNorthContainer\", {\n      style: {\n        transform: \"rotateZ(\" + this._spatial.radToDeg(-bearing) + \"deg)\"\n      }\n    }, [north]);\n    return container;\n  };\n\n  BearingComponent.prototype._createBackground = function (bearing) {\n    return vd.h(\"div.BearingIndicatorBackground\", {\n      style: {\n        transform: \"rotateZ(\" + this._spatial.radToDeg(-bearing) + \"deg)\"\n      }\n    }, [vd.h(\"div.BearingIndicatorBackgroundCircle\", []), vd.h(\"div.BearingIndicatorBackgroundArrowContainer\", [vd.h(\"div.BearingIndicatorBackgroundArrow\", [])])]);\n  };\n\n  BearingComponent.prototype._computeProjectedPoints = function (transform) {\n    var vertices = [[1, 0]];\n    var directions = [[0, 0.5]];\n    var pointsPerLine = 12;\n    return Geo_1.Geo.computeProjectedPoints(transform, vertices, directions, pointsPerLine, this._viewportCoords);\n  };\n\n  BearingComponent.prototype._computeHorizontalFov = function (projectedPoints) {\n    var _this = this;\n\n    var fovs = projectedPoints.map(function (projectedPoint) {\n      return _this._coordToFov(projectedPoint[0]);\n    });\n    var fov = Math.min.apply(Math, fovs);\n    return fov;\n  };\n\n  BearingComponent.prototype._coordToFov = function (x) {\n    return this._spatial.radToDeg(2 * Math.atan(x));\n  };\n\n  BearingComponent.prototype._interpolate = function (x1, x2, alpha) {\n    return (1 - alpha) * x1 + alpha * x2;\n  };\n\n  BearingComponent.componentName = \"bearing\";\n  return BearingComponent;\n}(Component_1.Component);\n\nexports.BearingComponent = BearingComponent;\nComponent_1.ComponentService.register(BearingComponent);\nexports.default = BearingComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/BearingComponent.ts?");

/***/ }),

/***/ "./src/component/CacheComponent.ts":
/*!*****************************************!*\
  !*** ./src/component/CacheComponent.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Edge_1 = __webpack_require__(/*! ../Edge */ \"./src/Edge.ts\");\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n\nvar CacheComponent =\n/** @class */\nfunction (_super) {\n  __extends(CacheComponent, _super);\n\n  function CacheComponent(name, container, navigator) {\n    return _super.call(this, name, container, navigator) || this;\n  }\n  /**\n   * Set the cache depth.\n   *\n   * Configures the cache depth. The cache depth can be different for\n   * different edge direction types.\n   *\n   * @param {ICacheDepth} depth - Cache depth structure.\n   */\n\n\n  CacheComponent.prototype.setDepth = function (depth) {\n    this.configure({\n      depth: depth\n    });\n  };\n\n  CacheComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._sequenceSubscription = rxjs_1.combineLatest(this._navigator.stateService.currentNode$.pipe(operators_1.switchMap(function (node) {\n      return node.sequenceEdges$;\n    }), operators_1.filter(function (status) {\n      return status.cached;\n    })), this._configuration$).pipe(operators_1.switchMap(function (nc) {\n      var status = nc[0];\n      var configuration = nc[1];\n      var sequenceDepth = Math.max(0, Math.min(4, configuration.depth.sequence));\n\n      var next$ = _this._cache$(status.edges, Edge_1.EdgeDirection.Next, sequenceDepth);\n\n      var prev$ = _this._cache$(status.edges, Edge_1.EdgeDirection.Prev, sequenceDepth);\n\n      return rxjs_1.merge(next$, prev$).pipe(operators_1.catchError(function (error, caught) {\n        console.error(\"Failed to cache sequence edges.\", error);\n        return rxjs_1.empty();\n      }));\n    })).subscribe(function () {});\n    this._spatialSubscription = rxjs_1.combineLatest(this._navigator.stateService.currentNode$.pipe(operators_1.switchMap(function (node) {\n      return rxjs_1.combineLatest(rxjs_1.of(node), node.spatialEdges$.pipe(operators_1.filter(function (status) {\n        return status.cached;\n      })));\n    })), this._configuration$).pipe(operators_1.switchMap(function (_a) {\n      var _b = _a[0],\n          node = _b[0],\n          edgeStatus = _b[1],\n          configuration = _a[1];\n      var edges = edgeStatus.edges;\n      var depth = configuration.depth;\n      var panoDepth = Math.max(0, Math.min(2, depth.pano));\n      var stepDepth = node.pano ? 0 : Math.max(0, Math.min(3, depth.step));\n      var turnDepth = node.pano ? 0 : Math.max(0, Math.min(1, depth.turn));\n\n      var pano$ = _this._cache$(edges, Edge_1.EdgeDirection.Pano, panoDepth);\n\n      var forward$ = _this._cache$(edges, Edge_1.EdgeDirection.StepForward, stepDepth);\n\n      var backward$ = _this._cache$(edges, Edge_1.EdgeDirection.StepBackward, stepDepth);\n\n      var left$ = _this._cache$(edges, Edge_1.EdgeDirection.StepLeft, stepDepth);\n\n      var right$ = _this._cache$(edges, Edge_1.EdgeDirection.StepRight, stepDepth);\n\n      var turnLeft$ = _this._cache$(edges, Edge_1.EdgeDirection.TurnLeft, turnDepth);\n\n      var turnRight$ = _this._cache$(edges, Edge_1.EdgeDirection.TurnRight, turnDepth);\n\n      var turnU$ = _this._cache$(edges, Edge_1.EdgeDirection.TurnU, turnDepth);\n\n      return rxjs_1.merge(forward$, backward$, left$, right$, pano$, turnLeft$, turnRight$, turnU$).pipe(operators_1.catchError(function (error, caught) {\n        console.error(\"Failed to cache spatial edges.\", error);\n        return rxjs_1.empty();\n      }));\n    })).subscribe(function () {});\n  };\n\n  CacheComponent.prototype._deactivate = function () {\n    this._sequenceSubscription.unsubscribe();\n\n    this._spatialSubscription.unsubscribe();\n  };\n\n  CacheComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      depth: {\n        pano: 1,\n        sequence: 2,\n        step: 1,\n        turn: 0\n      }\n    };\n  };\n\n  CacheComponent.prototype._cache$ = function (edges, direction, depth) {\n    var _this = this;\n\n    return rxjs_1.zip(rxjs_1.of(edges), rxjs_1.of(depth)).pipe(operators_1.expand(function (ed) {\n      var es = ed[0];\n      var d = ed[1];\n      var edgesDepths$ = [];\n\n      if (d > 0) {\n        for (var _i = 0, es_1 = es; _i < es_1.length; _i++) {\n          var edge = es_1[_i];\n\n          if (edge.data.direction === direction) {\n            edgesDepths$.push(rxjs_1.zip(_this._navigator.graphService.cacheNode$(edge.to).pipe(operators_1.mergeMap(function (n) {\n              return _this._nodeToEdges$(n, direction);\n            })), rxjs_1.of(d - 1)));\n          }\n        }\n      }\n\n      return rxjs_1.from(edgesDepths$).pipe(operators_1.mergeAll());\n    }), operators_1.skip(1));\n  };\n\n  CacheComponent.prototype._nodeToEdges$ = function (node, direction) {\n    return ([Edge_1.EdgeDirection.Next, Edge_1.EdgeDirection.Prev].indexOf(direction) > -1 ? node.sequenceEdges$ : node.spatialEdges$).pipe(operators_1.first(function (status) {\n      return status.cached;\n    }), operators_1.map(function (status) {\n      return status.edges;\n    }));\n  };\n\n  CacheComponent.componentName = \"cache\";\n  return CacheComponent;\n}(Component_1.Component);\n\nexports.CacheComponent = CacheComponent;\nComponent_1.ComponentService.register(CacheComponent);\nexports.default = CacheComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/CacheComponent.ts?");

/***/ }),

/***/ "./src/component/Component.ts":
/*!************************************!*\
  !*** ./src/component/Component.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Utils_1 = __webpack_require__(/*! ../Utils */ \"./src/Utils.ts\");\n\nvar Component =\n/** @class */\nfunction (_super) {\n  __extends(Component, _super);\n\n  function Component(name, container, navigator) {\n    var _this = _super.call(this) || this;\n\n    _this._activated$ = new rxjs_1.BehaviorSubject(false);\n    _this._configurationSubject$ = new rxjs_1.Subject();\n    _this._activated = false;\n    _this._container = container;\n    _this._name = name;\n    _this._navigator = navigator;\n    _this._configuration$ = _this._configurationSubject$.pipe(operators_1.startWith(_this.defaultConfiguration), operators_1.scan(function (conf, newConf) {\n      for (var key in newConf) {\n        if (newConf.hasOwnProperty(key)) {\n          conf[key] = newConf[key];\n        }\n      }\n\n      return conf;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    _this._configuration$.subscribe(function () {});\n\n    return _this;\n  }\n\n  Object.defineProperty(Component.prototype, \"activated\", {\n    get: function get() {\n      return this._activated;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"activated$\", {\n    /** @ignore */\n    get: function get() {\n      return this._activated$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"defaultConfiguration\", {\n    /**\n     * Get default configuration.\n     *\n     * @returns {TConfiguration} Default configuration for component.\n     */\n    get: function get() {\n      return this._getDefaultConfiguration();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"configuration$\", {\n    /** @ignore */\n    get: function get() {\n      return this._configuration$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"name\", {\n    /**\n     * Get name.\n     *\n     * @description The name of the component. Used when interacting with the\n     * component through the Viewer's API.\n     */\n    get: function get() {\n      return this._name;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Component.prototype.activate = function (conf) {\n    if (this._activated) {\n      return;\n    }\n\n    if (conf !== undefined) {\n      this._configurationSubject$.next(conf);\n    }\n\n    this._activated = true;\n\n    this._activate();\n\n    this._activated$.next(true);\n  };\n\n  Component.prototype.configure = function (conf) {\n    this._configurationSubject$.next(conf);\n  };\n\n  Component.prototype.deactivate = function () {\n    if (!this._activated) {\n      return;\n    }\n\n    this._activated = false;\n\n    this._deactivate();\n\n    this._container.domRenderer.clear(this._name);\n\n    this._container.glRenderer.clear(this._name);\n\n    this._activated$.next(false);\n  };\n  /**\n   * Detect the viewer's new width and height and resize the component's\n   * rendered elements accordingly if applicable.\n   *\n   * @ignore\n   */\n\n\n  Component.prototype.resize = function () {\n    return;\n  };\n\n  Component.componentName = \"not_worthy\";\n  return Component;\n}(Utils_1.EventEmitter);\n\nexports.Component = Component;\nexports.default = Component;\n\n//# sourceURL=webpack://Mapillary/./src/component/Component.ts?");

/***/ }),

/***/ "./src/component/ComponentService.ts":
/*!*******************************************!*\
  !*** ./src/component/ComponentService.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Error_1 = __webpack_require__(/*! ../Error */ \"./src/Error.ts\");\n\nvar ComponentService =\n/** @class */\nfunction () {\n  function ComponentService(container, navigator) {\n    this._components = {};\n\n    for (var componentName in ComponentService.registeredComponents) {\n      if (!ComponentService.registeredComponents.hasOwnProperty(componentName)) {\n        continue;\n      }\n\n      var component = ComponentService.registeredComponents[componentName];\n      this._components[componentName] = {\n        active: false,\n        component: new component(componentName, container, navigator)\n      };\n    }\n\n    this._coverComponent = new ComponentService.registeredCoverComponent(\"cover\", container, navigator);\n\n    this._coverComponent.activate();\n\n    this._coverActivated = true;\n  }\n\n  ComponentService.register = function (component) {\n    if (ComponentService.registeredComponents[component.componentName] === undefined) {\n      ComponentService.registeredComponents[component.componentName] = component;\n    }\n  };\n\n  ComponentService.registerCover = function (coverComponent) {\n    ComponentService.registeredCoverComponent = coverComponent;\n  };\n\n  Object.defineProperty(ComponentService.prototype, \"coverActivated\", {\n    get: function get() {\n      return this._coverActivated;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ComponentService.prototype.activateCover = function () {\n    if (this._coverActivated) {\n      return;\n    }\n\n    this._coverActivated = true;\n\n    for (var componentName in this._components) {\n      if (!this._components.hasOwnProperty(componentName)) {\n        continue;\n      }\n\n      var component = this._components[componentName];\n\n      if (component.active) {\n        component.component.deactivate();\n      }\n    }\n  };\n\n  ComponentService.prototype.deactivateCover = function () {\n    if (!this._coverActivated) {\n      return;\n    }\n\n    this._coverActivated = false;\n\n    for (var componentName in this._components) {\n      if (!this._components.hasOwnProperty(componentName)) {\n        continue;\n      }\n\n      var component = this._components[componentName];\n\n      if (component.active) {\n        component.component.activate();\n      }\n    }\n  };\n\n  ComponentService.prototype.activate = function (name) {\n    this._checkName(name);\n\n    this._components[name].active = true;\n\n    if (!this._coverActivated) {\n      this.get(name).activate();\n    }\n  };\n\n  ComponentService.prototype.configure = function (name, conf) {\n    this._checkName(name);\n\n    this.get(name).configure(conf);\n  };\n\n  ComponentService.prototype.deactivate = function (name) {\n    this._checkName(name);\n\n    this._components[name].active = false;\n\n    if (!this._coverActivated) {\n      this.get(name).deactivate();\n    }\n  };\n\n  ComponentService.prototype.get = function (name) {\n    return this._components[name].component;\n  };\n\n  ComponentService.prototype.getCover = function () {\n    return this._coverComponent;\n  };\n\n  ComponentService.prototype._checkName = function (name) {\n    if (!(name in this._components)) {\n      throw new Error_1.ArgumentMapillaryError(\"Component does not exist: \" + name);\n    }\n  };\n\n  ComponentService.registeredComponents = {};\n  return ComponentService;\n}();\n\nexports.ComponentService = ComponentService;\nexports.default = ComponentService;\n\n//# sourceURL=webpack://Mapillary/./src/component/ComponentService.ts?");

/***/ }),

/***/ "./src/component/CoverComponent.ts":
/*!*****************************************!*\
  !*** ./src/component/CoverComponent.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../Utils */ \"./src/Utils.ts\");\n\nvar Viewer_1 = __webpack_require__(/*! ../Viewer */ \"./src/Viewer.ts\");\n\nvar CoverComponent =\n/** @class */\nfunction (_super) {\n  __extends(CoverComponent, _super);\n\n  function CoverComponent(name, container, navigator) {\n    return _super.call(this, name, container, navigator) || this;\n  }\n\n  CoverComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._configuration$.pipe(operators_1.distinctUntilChanged(undefined, function (configuration) {\n      return configuration.state;\n    }), operators_1.switchMap(function (configuration) {\n      return rxjs_1.combineLatest(rxjs_1.of(configuration.state), _this._navigator.stateService.currentNode$);\n    }), operators_1.switchMap(function (_a) {\n      var state = _a[0],\n          node = _a[1];\n      var keySrc$ = rxjs_1.combineLatest(rxjs_1.of(node.key), node.image$.pipe(operators_1.filter(function (image) {\n        return !!image;\n      }), operators_1.map(function (image) {\n        return image.src;\n      })));\n      return state === Component_1.CoverState.Visible ? keySrc$.pipe(operators_1.first()) : keySrc$;\n    }), operators_1.distinctUntilChanged(function (_a, _b) {\n      var k1 = _a[0],\n          s1 = _a[1];\n      var k2 = _b[0],\n          s2 = _b[1];\n      return k1 === k2 && s1 === s2;\n    }), operators_1.map(function (_a) {\n      var key = _a[0],\n          src = _a[1];\n      return {\n        key: key,\n        src: src\n      };\n    })).subscribe(this._configurationSubject$);\n\n    this._renderSubscription = rxjs_1.combineLatest(this._configuration$, this._container.renderService.size$).pipe(operators_1.map(function (_a) {\n      var configuration = _a[0],\n          size = _a[1];\n\n      if (!configuration.key) {\n        return {\n          name: _this._name,\n          vnode: vd.h(\"div\", [])\n        };\n      }\n\n      var compactClass = size.width <= 640 || size.height <= 480 ? \".CoverCompact\" : \"\";\n\n      if (configuration.state === Component_1.CoverState.Hidden) {\n        var doneContainer = vd.h(\"div.CoverContainer.CoverDone\" + compactClass, [_this._getCoverBackgroundVNode(configuration)]);\n        return {\n          name: _this._name,\n          vnode: doneContainer\n        };\n      }\n\n      var container = vd.h(\"div.CoverContainer\" + compactClass, [_this._getCoverButtonVNode(configuration)]);\n      return {\n        name: _this._name,\n        vnode: container\n      };\n    })).subscribe(this._container.domRenderer.render$);\n  };\n\n  CoverComponent.prototype._deactivate = function () {\n    this._renderSubscription.unsubscribe();\n\n    this._keySubscription.unsubscribe();\n  };\n\n  CoverComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      state: Component_1.CoverState.Visible\n    };\n  };\n\n  CoverComponent.prototype._getCoverButtonVNode = function (configuration) {\n    var _this = this;\n\n    var cover = configuration.state === Component_1.CoverState.Loading ? \"div.Cover.CoverLoading\" : \"div.Cover\";\n    var coverButton = vd.h(\"div.CoverButton\", [vd.h(\"div.CoverButtonIcon\", [])]);\n    var coverLogo = vd.h(\"a.CoverLogo\", {\n      href: Utils_1.Urls.explore,\n      target: \"_blank\"\n    }, []);\n    var coverIndicator = vd.h(\"div.CoverIndicator\", {\n      onclick: function onclick() {\n        _this.configure({\n          state: Component_1.CoverState.Loading\n        });\n      }\n    }, []);\n    return vd.h(cover, [this._getCoverBackgroundVNode(configuration), coverIndicator, coverButton, coverLogo]);\n  };\n\n  CoverComponent.prototype._getCoverBackgroundVNode = function (conf) {\n    var url = conf.src != null ? conf.src : Utils_1.Urls.thumbnail(conf.key, Viewer_1.ImageSize.Size640);\n    var properties = {\n      style: {\n        backgroundImage: \"url(\" + url + \")\"\n      }\n    };\n    var children = [];\n\n    if (conf.state === Component_1.CoverState.Loading) {\n      children.push(vd.h(\"div.Spinner\", {}, []));\n    }\n\n    return vd.h(\"div.CoverBackground\", properties, children);\n  };\n\n  CoverComponent.componentName = \"cover\";\n  return CoverComponent;\n}(Component_1.Component);\n\nexports.CoverComponent = CoverComponent;\nComponent_1.ComponentService.registerCover(CoverComponent);\nexports.default = CoverComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/CoverComponent.ts?");

/***/ }),

/***/ "./src/component/DebugComponent.ts":
/*!*****************************************!*\
  !*** ./src/component/DebugComponent.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n\nvar DebugComponent =\n/** @class */\nfunction (_super) {\n  __extends(DebugComponent, _super);\n\n  function DebugComponent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._open$ = new rxjs_1.BehaviorSubject(false);\n    return _this;\n  }\n\n  DebugComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._disposable = rxjs_1.combineLatest(this._navigator.stateService.currentState$, this._open$, this._navigator.imageLoadingService.loadstatus$).pipe(operators_1.map(function (_a) {\n      var frame = _a[0],\n          open = _a[1],\n          loadStatus = _a[2];\n      return {\n        name: _this._name,\n        vnode: _this._getDebugVNode(open, _this._getDebugInfo(frame, loadStatus))\n      };\n    })).subscribe(this._container.domRenderer.render$);\n  };\n\n  DebugComponent.prototype._deactivate = function () {\n    this._disposable.unsubscribe();\n  };\n\n  DebugComponent.prototype._getDefaultConfiguration = function () {\n    return {};\n  };\n\n  DebugComponent.prototype._getDebugInfo = function (frame, loadStatus) {\n    var ret = [];\n    ret.push(vd.h(\"h2\", \"Node\"));\n\n    if (frame.state.currentNode) {\n      ret.push(vd.h(\"p\", \"currentNode: \" + frame.state.currentNode.key));\n    }\n\n    if (frame.state.previousNode) {\n      ret.push(vd.h(\"p\", \"previousNode: \" + frame.state.previousNode.key));\n    }\n\n    ret.push(vd.h(\"h2\", \"Loading\"));\n    var total = 0;\n    var loaded = 0;\n    var loading = 0;\n\n    for (var key in loadStatus) {\n      if (!loadStatus.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var status_1 = loadStatus[key];\n      total += status_1.loaded;\n\n      if (status_1.loaded !== status_1.total) {\n        loading++;\n      } else {\n        loaded++;\n      }\n    }\n\n    ret.push(vd.h(\"p\", \"Loaded Images: \" + loaded));\n    ret.push(vd.h(\"p\", \"Loading Images: \" + loading));\n    ret.push(vd.h(\"p\", \"Total bytes loaded: \" + total));\n    ret.push(vd.h(\"h2\", \"Camera\"));\n    ret.push(vd.h(\"p\", \"camera.position.x: \" + frame.state.camera.position.x));\n    ret.push(vd.h(\"p\", \"camera.position.y: \" + frame.state.camera.position.y));\n    ret.push(vd.h(\"p\", \"camera.position.z: \" + frame.state.camera.position.z));\n    ret.push(vd.h(\"p\", \"camera.lookat.x: \" + frame.state.camera.lookat.x));\n    ret.push(vd.h(\"p\", \"camera.lookat.y: \" + frame.state.camera.lookat.y));\n    ret.push(vd.h(\"p\", \"camera.lookat.z: \" + frame.state.camera.lookat.z));\n    ret.push(vd.h(\"p\", \"camera.up.x: \" + frame.state.camera.up.x));\n    ret.push(vd.h(\"p\", \"camera.up.y: \" + frame.state.camera.up.y));\n    ret.push(vd.h(\"p\", \"camera.up.z: \" + frame.state.camera.up.z));\n    return ret;\n  };\n\n  DebugComponent.prototype._getDebugVNode = function (open, info) {\n    if (open) {\n      return vd.h(\"div.Debug\", {}, [vd.h(\"h2\", {}, [\"Debug\"]), this._getDebugVNodeButton(open), vd.h(\"pre\", {}, info)]);\n    } else {\n      return this._getDebugVNodeButton(open);\n    }\n  };\n\n  DebugComponent.prototype._getDebugVNodeButton = function (open) {\n    var buttonText = open ? \"Disable Debug\" : \"D\";\n    var buttonCssClass = open ? \"\" : \".DebugButtonFixed\";\n\n    if (open) {\n      return vd.h(\"button.DebugButton\" + buttonCssClass, {\n        onclick: this._closeDebugElement.bind(this)\n      }, [buttonText]);\n    } else {\n      return vd.h(\"button.DebugButton\" + buttonCssClass, {\n        onclick: this._openDebugElement.bind(this)\n      }, [buttonText]);\n    }\n  };\n\n  DebugComponent.prototype._closeDebugElement = function (open) {\n    this._open$.next(false);\n  };\n\n  DebugComponent.prototype._openDebugElement = function () {\n    this._open$.next(true);\n  };\n\n  DebugComponent.componentName = \"debug\";\n  return DebugComponent;\n}(Component_1.Component);\n\nexports.DebugComponent = DebugComponent;\nComponent_1.ComponentService.register(DebugComponent);\nexports.default = DebugComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/DebugComponent.ts?");

/***/ }),

/***/ "./src/component/ImageComponent.ts":
/*!*****************************************!*\
  !*** ./src/component/ImageComponent.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../Utils */ \"./src/Utils.ts\");\n\nvar ImageComponent =\n/** @class */\nfunction (_super) {\n  __extends(ImageComponent, _super);\n\n  function ImageComponent(name, container, navigator, dom) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._canvasId = container.id + \"-\" + _this._name;\n    _this._dom = !!dom ? dom : new Utils_1.DOM();\n    return _this;\n  }\n\n  ImageComponent.prototype._activate = function () {\n    var _this = this;\n\n    var canvasSize$ = this._container.domRenderer.element$.pipe(operators_1.map(function (element) {\n      return _this._dom.document.getElementById(_this._canvasId);\n    }), operators_1.filter(function (canvas) {\n      return !!canvas;\n    }), operators_1.map(function (canvas) {\n      var adaptableDomRenderer = canvas.parentElement;\n      var width = adaptableDomRenderer.offsetWidth;\n      var height = adaptableDomRenderer.offsetHeight;\n      return [canvas, {\n        height: height,\n        width: width\n      }];\n    }), operators_1.distinctUntilChanged(function (s1, s2) {\n      return s1.height === s2.height && s1.width === s2.width;\n    }, function (_a) {\n      var canvas = _a[0],\n          size = _a[1];\n      return size;\n    }));\n\n    this.drawSubscription = rxjs_1.combineLatest(canvasSize$, this._navigator.stateService.currentNode$).subscribe(function (_a) {\n      var _b = _a[0],\n          canvas = _b[0],\n          size = _b[1],\n          node = _a[1];\n      canvas.width = size.width;\n      canvas.height = size.height;\n      canvas.getContext(\"2d\").drawImage(node.image, 0, 0, size.width, size.height);\n    });\n\n    this._container.domRenderer.renderAdaptive$.next({\n      name: this._name,\n      vnode: vd.h(\"canvas#\" + this._canvasId, [])\n    });\n  };\n\n  ImageComponent.prototype._deactivate = function () {\n    this.drawSubscription.unsubscribe();\n  };\n\n  ImageComponent.prototype._getDefaultConfiguration = function () {\n    return {};\n  };\n\n  ImageComponent.componentName = \"image\";\n  return ImageComponent;\n}(Component_1.Component);\n\nexports.ImageComponent = ImageComponent;\nComponent_1.ComponentService.register(ImageComponent);\nexports.default = ImageComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/ImageComponent.ts?");

/***/ }),

/***/ "./src/component/LoadingComponent.ts":
/*!*******************************************!*\
  !*** ./src/component/LoadingComponent.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n\nvar LoadingComponent =\n/** @class */\nfunction (_super) {\n  __extends(LoadingComponent, _super);\n\n  function LoadingComponent(name, container, navigator) {\n    return _super.call(this, name, container, navigator) || this;\n  }\n\n  LoadingComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._loadingSubscription = this._navigator.loadingService.loading$.pipe(operators_1.switchMap(function (loading) {\n      return loading ? _this._navigator.imageLoadingService.loadstatus$ : rxjs_1.of({});\n    }), operators_1.map(function (loadStatus) {\n      var total = 0;\n      var loaded = 0;\n\n      for (var key in loadStatus) {\n        if (!loadStatus.hasOwnProperty(key)) {\n          continue;\n        }\n\n        var status_1 = loadStatus[key];\n\n        if (status_1.loaded !== status_1.total) {\n          loaded += status_1.loaded;\n          total += status_1.total;\n        }\n      }\n\n      var percentage = 100;\n\n      if (total !== 0) {\n        percentage = loaded / total * 100;\n      }\n\n      return {\n        name: _this._name,\n        vnode: _this._getBarVNode(percentage)\n      };\n    })).subscribe(this._container.domRenderer.render$);\n  };\n\n  LoadingComponent.prototype._deactivate = function () {\n    this._loadingSubscription.unsubscribe();\n  };\n\n  LoadingComponent.prototype._getDefaultConfiguration = function () {\n    return {};\n  };\n\n  LoadingComponent.prototype._getBarVNode = function (percentage) {\n    var loadingBarStyle = {};\n    var loadingContainerStyle = {};\n\n    if (percentage !== 100) {\n      loadingBarStyle.width = percentage.toFixed(0) + \"%\";\n      loadingBarStyle.opacity = \"1\";\n    } else {\n      loadingBarStyle.width = \"100%\";\n      loadingBarStyle.opacity = \"0\";\n    }\n\n    return vd.h(\"div.Loading\", {\n      style: loadingContainerStyle\n    }, [vd.h(\"div.LoadingBar\", {\n      style: loadingBarStyle\n    }, [])]);\n  };\n\n  LoadingComponent.componentName = \"loading\";\n  return LoadingComponent;\n}(Component_1.Component);\n\nexports.LoadingComponent = LoadingComponent;\nComponent_1.ComponentService.register(LoadingComponent);\nexports.default = LoadingComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/LoadingComponent.ts?");

/***/ }),

/***/ "./src/component/NavigationComponent.ts":
/*!**********************************************!*\
  !*** ./src/component/NavigationComponent.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Edge_1 = __webpack_require__(/*! ../Edge */ \"./src/Edge.ts\");\n\nvar Error_1 = __webpack_require__(/*! ../Error */ \"./src/Error.ts\");\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n/**\n * @class NavigationComponent\n *\n * @classdesc Fallback navigation component for environments without WebGL support.\n *\n * Replaces the functionality in the Direction and Sequence components.\n */\n\n\nvar NavigationComponent =\n/** @class */\nfunction (_super) {\n  __extends(NavigationComponent, _super);\n  /** @ignore */\n\n\n  function NavigationComponent(name, container, navigator) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._seqNames = {};\n    _this._seqNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.Prev]] = \"Prev\";\n    _this._seqNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.Next]] = \"Next\";\n    _this._spaTopNames = {};\n    _this._spaTopNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.TurnLeft]] = \"Turnleft\";\n    _this._spaTopNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.StepLeft]] = \"Left\";\n    _this._spaTopNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.StepForward]] = \"Forward\";\n    _this._spaTopNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.StepRight]] = \"Right\";\n    _this._spaTopNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.TurnRight]] = \"Turnright\";\n    _this._spaBottomNames = {};\n    _this._spaBottomNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.TurnU]] = \"Turnaround\";\n    _this._spaBottomNames[Edge_1.EdgeDirection[Edge_1.EdgeDirection.StepBackward]] = \"Backward\";\n    return _this;\n  }\n\n  NavigationComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._renderSubscription = rxjs_1.combineLatest(this._navigator.stateService.currentNode$, this._configuration$).pipe(operators_1.switchMap(function (_a) {\n      var node = _a[0],\n          configuration = _a[1];\n      var sequenceEdges$ = configuration.sequence ? node.sequenceEdges$.pipe(operators_1.map(function (status) {\n        return status.edges.map(function (edge) {\n          return edge.data.direction;\n        });\n      })) : rxjs_1.of([]);\n      var spatialEdges$ = !node.pano && configuration.spatial ? node.spatialEdges$.pipe(operators_1.map(function (status) {\n        return status.edges.map(function (edge) {\n          return edge.data.direction;\n        });\n      })) : rxjs_1.of([]);\n      return rxjs_1.combineLatest(sequenceEdges$, spatialEdges$).pipe(operators_1.map(function (_a) {\n        var seq = _a[0],\n            spa = _a[1];\n        return seq.concat(spa);\n      }));\n    }), operators_1.map(function (edgeDirections) {\n      var seqs = _this._createArrowRow(_this._seqNames, edgeDirections);\n\n      var spaTops = _this._createArrowRow(_this._spaTopNames, edgeDirections);\n\n      var spaBottoms = _this._createArrowRow(_this._spaBottomNames, edgeDirections);\n\n      var seqContainer = vd.h(\"div.NavigationSequence\", seqs);\n      var spaTopContainer = vd.h(\"div.NavigationSpatialTop\", spaTops);\n      var spaBottomContainer = vd.h(\"div.NavigationSpatialBottom\", spaBottoms);\n      var spaContainer = vd.h(\"div.NavigationSpatial\", [spaTopContainer, spaBottomContainer]);\n      return {\n        name: _this._name,\n        vnode: vd.h(\"div.NavigationContainer\", [seqContainer, spaContainer])\n      };\n    })).subscribe(this._container.domRenderer.render$);\n  };\n\n  NavigationComponent.prototype._deactivate = function () {\n    this._renderSubscription.unsubscribe();\n  };\n\n  NavigationComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      sequence: true,\n      spatial: true\n    };\n  };\n\n  NavigationComponent.prototype._createArrowRow = function (arrowNames, edgeDirections) {\n    var arrows = [];\n\n    for (var arrowName in arrowNames) {\n      if (!arrowNames.hasOwnProperty(arrowName)) {\n        continue;\n      }\n\n      var direction = Edge_1.EdgeDirection[arrowName];\n\n      if (edgeDirections.indexOf(direction) !== -1) {\n        arrows.push(this._createVNode(direction, arrowNames[arrowName], \"visible\"));\n      } else {\n        arrows.push(this._createVNode(direction, arrowNames[arrowName], \"hidden\"));\n      }\n    }\n\n    return arrows;\n  };\n\n  NavigationComponent.prototype._createVNode = function (direction, name, visibility) {\n    var _this = this;\n\n    return vd.h(\"span.Direction.Direction\" + name, {\n      onclick: function onclick(ev) {\n        _this._navigator.moveDir$(direction).subscribe(undefined, function (error) {\n          if (!(error instanceof Error_1.AbortMapillaryError)) {\n            console.error(error);\n          }\n        });\n      },\n      style: {\n        visibility: visibility\n      }\n    }, []);\n  };\n\n  NavigationComponent.componentName = \"navigation\";\n  return NavigationComponent;\n}(Component_1.Component);\n\nexports.NavigationComponent = NavigationComponent;\nComponent_1.ComponentService.register(NavigationComponent);\nexports.default = NavigationComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/NavigationComponent.ts?");

/***/ }),

/***/ "./src/component/RouteComponent.ts":
/*!*****************************************!*\
  !*** ./src/component/RouteComponent.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n\nvar DescriptionState =\n/** @class */\nfunction () {\n  function DescriptionState() {}\n\n  return DescriptionState;\n}();\n\nvar RouteState =\n/** @class */\nfunction () {\n  function RouteState() {}\n\n  return RouteState;\n}();\n\nvar RouteTrack =\n/** @class */\nfunction () {\n  function RouteTrack() {\n    this.nodeInstructions = [];\n    this.nodeInstructionsOrdered = [];\n  }\n\n  return RouteTrack;\n}();\n\nvar RouteComponent =\n/** @class */\nfunction (_super) {\n  __extends(RouteComponent, _super);\n\n  function RouteComponent(name, container, navigator) {\n    return _super.call(this, name, container, navigator) || this;\n  }\n\n  RouteComponent.prototype._activate = function () {\n    var _this = this;\n\n    var slowedStream$ = this._navigator.stateService.currentState$.pipe(operators_1.filter(function (frame) {\n      return frame.id % 2 === 0;\n    }), operators_1.filter(function (frame) {\n      return frame.state.nodesAhead < 15;\n    }), operators_1.distinctUntilChanged(undefined, function (frame) {\n      return frame.state.lastNode.key;\n    }));\n\n    var routeTrack$ = rxjs_1.combineLatest(this.configuration$.pipe(operators_1.mergeMap(function (conf) {\n      return rxjs_1.from(conf.paths);\n    }), operators_1.distinct(function (p) {\n      return p.sequenceKey;\n    }), operators_1.mergeMap(function (path) {\n      return _this._navigator.apiV3.sequenceByKey$([path.sequenceKey]).pipe(operators_1.map(function (sequenceByKey) {\n        return sequenceByKey[path.sequenceKey];\n      }));\n    })), this.configuration$).pipe(operators_1.map(function (_a) {\n      var sequence = _a[0],\n          conf = _a[1];\n      var i = 0;\n      var instructionPlaces = [];\n\n      for (var _i = 0, _b = conf.paths; _i < _b.length; _i++) {\n        var path = _b[_i];\n\n        if (path.sequenceKey === sequence.key) {\n          var nodeInstructions = [];\n          var saveKey = false;\n\n          for (var _c = 0, _d = sequence.keys; _c < _d.length; _c++) {\n            var key = _d[_c];\n\n            if (path.startKey === key) {\n              saveKey = true;\n            }\n\n            if (saveKey) {\n              var description = null;\n\n              for (var _e = 0, _f = path.infoKeys; _e < _f.length; _e++) {\n                var infoKey = _f[_e];\n\n                if (infoKey.key === key) {\n                  description = infoKey.description;\n                }\n              }\n\n              nodeInstructions.push({\n                description: description,\n                key: key\n              });\n            }\n\n            if (path.stopKey === key) {\n              saveKey = false;\n            }\n          }\n\n          instructionPlaces.push({\n            nodeInstructions: nodeInstructions,\n            place: i\n          });\n        }\n\n        i++;\n      }\n\n      return instructionPlaces;\n    }), operators_1.scan(function (routeTrack, instructionPlaces) {\n      for (var _i = 0, instructionPlaces_1 = instructionPlaces; _i < instructionPlaces_1.length; _i++) {\n        var instructionPlace = instructionPlaces_1[_i];\n        routeTrack.nodeInstructionsOrdered[instructionPlace.place] = instructionPlace.nodeInstructions;\n      }\n\n      for (var place in routeTrack.nodeInstructionsOrdered) {\n        if (!routeTrack.nodeInstructionsOrdered.hasOwnProperty(place)) {\n          continue;\n        }\n\n        var instructionGroup = routeTrack.nodeInstructionsOrdered[place];\n\n        for (var _a = 0, instructionGroup_1 = instructionGroup; _a < instructionGroup_1.length; _a++) {\n          var instruction = instructionGroup_1[_a];\n          routeTrack.nodeInstructions.push(instruction);\n        }\n      }\n\n      return routeTrack;\n    }, new RouteTrack()));\n    var cacheNode$ = rxjs_1.combineLatest(slowedStream$, routeTrack$, this.configuration$).pipe(operators_1.map(function (_a) {\n      var frame = _a[0],\n          routeTrack = _a[1],\n          conf = _a[2];\n      return {\n        conf: conf,\n        frame: frame,\n        routeTrack: routeTrack\n      };\n    }), operators_1.scan(function (routeState, rtAndFrame) {\n      if (rtAndFrame.conf.playing === undefined || rtAndFrame.conf.playing) {\n        routeState.routeTrack = rtAndFrame.routeTrack;\n        routeState.currentNode = rtAndFrame.frame.state.currentNode;\n        routeState.lastNode = rtAndFrame.frame.state.lastNode;\n        routeState.playing = true;\n      } else {\n        _this._navigator.stateService.cutNodes();\n\n        routeState.playing = false;\n      }\n\n      return routeState;\n    }, new RouteState()), operators_1.filter(function (routeState) {\n      return routeState.playing;\n    }), operators_1.filter(function (routeState) {\n      for (var _i = 0, _a = routeState.routeTrack.nodeInstructions; _i < _a.length; _i++) {\n        var nodeInstruction = _a[_i];\n\n        if (!nodeInstruction) {\n          continue;\n        }\n\n        if (nodeInstruction.key === routeState.lastNode.key) {\n          return true;\n        }\n      }\n\n      return false;\n    }), operators_1.distinctUntilChanged(undefined, function (routeState) {\n      return routeState.lastNode.key;\n    }), operators_1.mergeMap(function (routeState) {\n      var i = 0;\n\n      for (var _i = 0, _a = routeState.routeTrack.nodeInstructions; _i < _a.length; _i++) {\n        var nodeInstruction = _a[_i];\n\n        if (nodeInstruction.key === routeState.lastNode.key) {\n          break;\n        }\n\n        i++;\n      }\n\n      var nextInstruction = routeState.routeTrack.nodeInstructions[i + 1];\n\n      if (!nextInstruction) {\n        return rxjs_1.of(null);\n      }\n\n      return _this._navigator.graphService.cacheNode$(nextInstruction.key);\n    }));\n    this._disposable = rxjs_1.combineLatest(cacheNode$, this.configuration$).pipe(operators_1.map(function (_a) {\n      var node = _a[0],\n          conf = _a[1];\n      return {\n        conf: conf,\n        node: node\n      };\n    }), operators_1.filter(function (cAN) {\n      return cAN.node !== null && cAN.conf.playing;\n    }), operators_1.pluck(\"node\")).subscribe(this._navigator.stateService.appendNode$);\n    this._disposableDescription = rxjs_1.combineLatest(this._navigator.stateService.currentNode$, routeTrack$, this.configuration$).pipe(operators_1.map(function (_a) {\n      var node = _a[0],\n          routeTrack = _a[1],\n          conf = _a[2];\n\n      if (conf.playing !== undefined && !conf.playing) {\n        return \"quit\";\n      }\n\n      var description = null;\n\n      for (var _i = 0, _b = routeTrack.nodeInstructions; _i < _b.length; _i++) {\n        var nodeInstruction = _b[_i];\n\n        if (nodeInstruction.key === node.key) {\n          description = nodeInstruction.description;\n          break;\n        }\n      }\n\n      return description;\n    }), operators_1.scan(function (descriptionState, description) {\n      if (description !== descriptionState.description && description !== null) {\n        descriptionState.description = description;\n        descriptionState.showsLeft = 6;\n      } else {\n        descriptionState.showsLeft--;\n      }\n\n      if (description === \"quit\") {\n        descriptionState.description = null;\n      }\n\n      return descriptionState;\n    }, new DescriptionState()), operators_1.map(function (descriptionState) {\n      if (descriptionState.showsLeft > 0 && descriptionState.description) {\n        return {\n          name: _this._name,\n          vnode: _this._getRouteAnnotationNode(descriptionState.description)\n        };\n      } else {\n        return {\n          name: _this._name,\n          vnode: vd.h(\"div\", [])\n        };\n      }\n    })).subscribe(this._container.domRenderer.render$);\n  };\n\n  RouteComponent.prototype._deactivate = function () {\n    this._disposable.unsubscribe();\n\n    this._disposableDescription.unsubscribe();\n  };\n\n  RouteComponent.prototype._getDefaultConfiguration = function () {\n    return {};\n  };\n\n  RouteComponent.prototype.play = function () {\n    this.configure({\n      playing: true\n    });\n  };\n\n  RouteComponent.prototype.stop = function () {\n    this.configure({\n      playing: false\n    });\n  };\n\n  RouteComponent.prototype._getRouteAnnotationNode = function (description) {\n    return vd.h(\"div.RouteFrame\", {}, [vd.h(\"p\", {\n      textContent: description\n    }, [])]);\n  };\n\n  RouteComponent.componentName = \"route\";\n  return RouteComponent;\n}(Component_1.Component);\n\nexports.RouteComponent = RouteComponent;\nComponent_1.ComponentService.register(RouteComponent);\nexports.default = RouteComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/RouteComponent.ts?");

/***/ }),

/***/ "./src/component/StatsComponent.ts":
/*!*****************************************!*\
  !*** ./src/component/StatsComponent.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n\nvar StatsComponent =\n/** @class */\nfunction (_super) {\n  __extends(StatsComponent, _super);\n\n  function StatsComponent(name, container, navigator, scheduler) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._scheduler = scheduler;\n    return _this;\n  }\n\n  StatsComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._sequenceSubscription = this._navigator.stateService.currentNode$.pipe(operators_1.scan(function (keys, node) {\n      var sKey = node.sequenceKey;\n      keys.report = [];\n\n      if (!(sKey in keys.reported)) {\n        keys.report = [sKey];\n        keys.reported[sKey] = true;\n      }\n\n      return keys;\n    }, {\n      report: [],\n      reported: {}\n    }), operators_1.filter(function (keys) {\n      return keys.report.length > 0;\n    }), operators_1.mergeMap(function (keys) {\n      return _this._navigator.apiV3.sequenceViewAdd$(keys.report).pipe(operators_1.catchError(function (error, caught) {\n        console.error(\"Failed to report sequence stats (\" + keys.report + \")\", error);\n        return rxjs_1.empty();\n      }));\n    })).subscribe(function () {});\n    this._imageSubscription = this._navigator.stateService.currentNode$.pipe(operators_1.map(function (node) {\n      return node.key;\n    })).pipe(operators_1.buffer(this._navigator.stateService.currentNode$.pipe(operators_1.debounceTime(5000, this._scheduler))), operators_1.scan(function (keys, newKeys) {\n      keys.report = [];\n\n      for (var _i = 0, newKeys_1 = newKeys; _i < newKeys_1.length; _i++) {\n        var key = newKeys_1[_i];\n\n        if (!(key in keys.reported)) {\n          keys.report.push(key);\n          keys.reported[key] = true;\n        }\n      }\n\n      return keys;\n    }, {\n      report: [],\n      reported: {}\n    }), operators_1.filter(function (keys) {\n      return keys.report.length > 0;\n    }), operators_1.mergeMap(function (keys) {\n      return _this._navigator.apiV3.imageViewAdd$(keys.report).pipe(operators_1.catchError(function (error, caught) {\n        console.error(\"Failed to report image stats (\" + keys.report + \")\", error);\n        return rxjs_1.empty();\n      }));\n    })).subscribe(function () {});\n  };\n\n  StatsComponent.prototype._deactivate = function () {\n    this._sequenceSubscription.unsubscribe();\n\n    this._imageSubscription.unsubscribe();\n  };\n\n  StatsComponent.prototype._getDefaultConfiguration = function () {\n    return {};\n  };\n\n  StatsComponent.componentName = \"stats\";\n  return StatsComponent;\n}(Component_1.Component);\n\nexports.StatsComponent = StatsComponent;\nComponent_1.ComponentService.register(StatsComponent);\nexports.default = StatsComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/StatsComponent.ts?");

/***/ }),

/***/ "./src/component/direction/DirectionComponent.ts":
/*!*******************************************************!*\
  !*** ./src/component/direction/DirectionComponent.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n/**\n * @class DirectionComponent\n * @classdesc Component showing navigation arrows for steps and turns.\n */\n\n\nvar DirectionComponent =\n/** @class */\nfunction (_super) {\n  __extends(DirectionComponent, _super);\n\n  function DirectionComponent(name, container, navigator, directionDOMRenderer) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._renderer = !!directionDOMRenderer ? directionDOMRenderer : new Component_1.DirectionDOMRenderer(_this.defaultConfiguration, {\n      height: container.element.offsetHeight,\n      width: container.element.offsetWidth\n    });\n    _this._hoveredKeySubject$ = new rxjs_1.Subject();\n    _this._hoveredKey$ = _this._hoveredKeySubject$.pipe(operators_1.share());\n    return _this;\n  }\n\n  Object.defineProperty(DirectionComponent.prototype, \"hoveredKey$\", {\n    /**\n     * Get hovered key observable.\n     *\n     * @description An observable emitting the key of the node for the direction\n     * arrow that is being hovered. When the mouse leaves a direction arrow null\n     * is emitted.\n     *\n     * @returns {Observable<string>}\n     */\n    get: function get() {\n      return this._hoveredKey$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Set highlight key.\n   *\n   * @description The arrow pointing towards the node corresponding to the\n   * highlight key will be highlighted.\n   *\n   * @param {string} highlightKey Key of node to be highlighted if existing\n   * among arrows.\n   */\n\n  DirectionComponent.prototype.setHighlightKey = function (highlightKey) {\n    this.configure({\n      highlightKey: highlightKey\n    });\n  };\n  /**\n   * Set min width of container element.\n   *\n   * @description  Set min width of the non transformed container element holding\n   * the navigation arrows. If the min width is larger than the max width the\n   * min width value will be used.\n   *\n   * The container element is automatically resized when the resize\n   * method on the Viewer class is called.\n   *\n   * @param {number} minWidth\n   */\n\n\n  DirectionComponent.prototype.setMinWidth = function (minWidth) {\n    this.configure({\n      minWidth: minWidth\n    });\n  };\n  /**\n   * Set max width of container element.\n   *\n   * @description Set max width of the non transformed container element holding\n   * the navigation arrows. If the min width is larger than the max width the\n   * min width value will be used.\n   *\n   * The container element is automatically resized when the resize\n   * method on the Viewer class is called.\n   *\n   * @param {number} minWidth\n   */\n\n\n  DirectionComponent.prototype.setMaxWidth = function (maxWidth) {\n    this.configure({\n      maxWidth: maxWidth\n    });\n  };\n\n  DirectionComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._configurationSubscription = this._configuration$.subscribe(function (configuration) {\n      _this._renderer.setConfiguration(configuration);\n    });\n    this._resizeSubscription = this._container.renderService.size$.subscribe(function (size) {\n      _this._renderer.resize(size);\n    });\n    this._nodeSubscription = this._navigator.stateService.currentNode$.pipe(operators_1.tap(function (node) {\n      _this._container.domRenderer.render$.next({\n        name: _this._name,\n        vnode: vd.h(\"div\", {}, [])\n      });\n\n      _this._renderer.setNode(node);\n    }), operators_1.withLatestFrom(this._configuration$), operators_1.switchMap(function (_a) {\n      var node = _a[0],\n          configuration = _a[1];\n      return rxjs_1.combineLatest(node.spatialEdges$, configuration.distinguishSequence ? _this._navigator.graphService.cacheSequence$(node.sequenceKey).pipe(operators_1.catchError(function (error, caught) {\n        console.error(\"Failed to cache sequence (\" + node.sequenceKey + \")\", error);\n        return rxjs_1.of(null);\n      })) : rxjs_1.of(null));\n    })).subscribe(function (_a) {\n      var edgeStatus = _a[0],\n          sequence = _a[1];\n\n      _this._renderer.setEdges(edgeStatus, sequence);\n    });\n    this._renderCameraSubscription = this._container.renderService.renderCameraFrame$.pipe(operators_1.tap(function (renderCamera) {\n      _this._renderer.setRenderCamera(renderCamera);\n    }), operators_1.map(function () {\n      return _this._renderer;\n    }), operators_1.filter(function (renderer) {\n      return renderer.needsRender;\n    }), operators_1.map(function (renderer) {\n      return {\n        name: _this._name,\n        vnode: renderer.render(_this._navigator)\n      };\n    })).subscribe(this._container.domRenderer.render$);\n    this._hoveredKeySubscription = rxjs_1.combineLatest(this._container.domRenderer.element$, this._container.renderService.renderCamera$, this._container.mouseService.mouseMove$.pipe(operators_1.startWith(null)), this._container.mouseService.mouseUp$.pipe(operators_1.startWith(null))).pipe(operators_1.map(function (_a) {\n      var element = _a[0];\n      var elements = element.getElementsByClassName(\"DirectionsPerspective\");\n\n      for (var i = 0; i < elements.length; i++) {\n        var hovered = elements.item(i).querySelector(\":hover\");\n\n        if (hovered != null && hovered.hasAttribute(\"data-key\")) {\n          return hovered.getAttribute(\"data-key\");\n        }\n      }\n\n      return null;\n    }), operators_1.distinctUntilChanged()).subscribe(this._hoveredKeySubject$);\n    this._emitHoveredKeySubscription = this._hoveredKey$.subscribe(function (key) {\n      _this.fire(DirectionComponent.hoveredkeychanged, key);\n    });\n  };\n\n  DirectionComponent.prototype._deactivate = function () {\n    this._configurationSubscription.unsubscribe();\n\n    this._emitHoveredKeySubscription.unsubscribe();\n\n    this._hoveredKeySubscription.unsubscribe();\n\n    this._nodeSubscription.unsubscribe();\n\n    this._renderCameraSubscription.unsubscribe();\n  };\n\n  DirectionComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      distinguishSequence: false,\n      maxWidth: 460,\n      minWidth: 260\n    };\n  };\n  /** @inheritdoc */\n\n\n  DirectionComponent.componentName = \"direction\";\n  /**\n   * Event fired when the hovered key changes.\n   *\n   * @description Emits the key of the node for the direction\n   * arrow that is being hovered. When the mouse leaves a\n   * direction arrow null is emitted.\n   *\n   * @event DirectionComponent#hoveredkeychanged\n   * @type {string} The hovered key, null if no key is hovered.\n   */\n\n  DirectionComponent.hoveredkeychanged = \"hoveredkeychanged\";\n  return DirectionComponent;\n}(Component_1.Component);\n\nexports.DirectionComponent = DirectionComponent;\nComponent_1.ComponentService.register(DirectionComponent);\nexports.default = DirectionComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/direction/DirectionComponent.ts?");

/***/ }),

/***/ "./src/component/direction/DirectionDOMCalculator.ts":
/*!***********************************************************!*\
  !*** ./src/component/direction/DirectionDOMCalculator.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n/**\n * @class DirectionDOMCalculator\n * @classdesc Helper class for calculating DOM CSS properties.\n */\n\n\nvar DirectionDOMCalculator =\n/** @class */\nfunction () {\n  function DirectionDOMCalculator(configuration, size) {\n    this._spatial = new Geo_1.Spatial();\n    this._minThresholdWidth = 320;\n    this._maxThresholdWidth = 1480;\n    this._minThresholdHeight = 240;\n    this._maxThresholdHeight = 820;\n\n    this._configure(configuration);\n\n    this._resize(size);\n\n    this._reset();\n  }\n\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"minWidth\", {\n    get: function get() {\n      return this._minWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"maxWidth\", {\n    get: function get() {\n      return this._maxWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"containerWidth\", {\n    get: function get() {\n      return this._containerWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"containerWidthCss\", {\n    get: function get() {\n      return this._containerWidthCss;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"containerMarginCss\", {\n    get: function get() {\n      return this._containerMarginCss;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"containerLeftCss\", {\n    get: function get() {\n      return this._containerLeftCss;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"containerHeight\", {\n    get: function get() {\n      return this._containerHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"containerHeightCss\", {\n    get: function get() {\n      return this._containerHeightCss;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"containerBottomCss\", {\n    get: function get() {\n      return this._containerBottomCss;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"stepCircleSize\", {\n    get: function get() {\n      return this._stepCircleSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"stepCircleSizeCss\", {\n    get: function get() {\n      return this._stepCircleSizeCss;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"stepCircleMarginCss\", {\n    get: function get() {\n      return this._stepCircleMarginCss;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"turnCircleSize\", {\n    get: function get() {\n      return this._turnCircleSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"turnCircleSizeCss\", {\n    get: function get() {\n      return this._turnCircleSizeCss;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"outerRadius\", {\n    get: function get() {\n      return this._outerRadius;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"innerRadius\", {\n    get: function get() {\n      return this._innerRadius;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DirectionDOMCalculator.prototype, \"shadowOffset\", {\n    get: function get() {\n      return this._shadowOffset;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Configures the min and max width values.\n   *\n   * @param {IDirectionConfiguration} configuration Configuration\n   * with min and max width values.\n   */\n\n  DirectionDOMCalculator.prototype.configure = function (configuration) {\n    this._configure(configuration);\n\n    this._reset();\n  };\n  /**\n   * Resizes all properties according to the width and height\n   * of the size object.\n   *\n   * @param {ISize} size The size of the container element.\n   */\n\n\n  DirectionDOMCalculator.prototype.resize = function (size) {\n    this._resize(size);\n\n    this._reset();\n  };\n  /**\n   * Calculates the coordinates on the unit circle for an angle.\n   *\n   * @param {number} angle Angle in radians.\n   * @returns {Array<number>} The x and y coordinates on the unit circle.\n   */\n\n\n  DirectionDOMCalculator.prototype.angleToCoordinates = function (angle) {\n    return [Math.cos(angle), Math.sin(angle)];\n  };\n  /**\n   * Calculates the coordinates on the unit circle for the\n   * relative angle between the first and second angle.\n   *\n   * @param {number} first Angle in radians.\n   * @param {number} second Angle in radians.\n   * @returns {Array<number>} The x and y coordinates on the unit circle\n   * for the relative angle between the first and second angle.\n   */\n\n\n  DirectionDOMCalculator.prototype.relativeAngleToCoordiantes = function (first, second) {\n    var relativeAngle = this._spatial.wrapAngle(first - second);\n\n    return this.angleToCoordinates(relativeAngle);\n  };\n\n  DirectionDOMCalculator.prototype._configure = function (configuration) {\n    this._minWidth = configuration.minWidth;\n    this._maxWidth = this._getMaxWidth(configuration.minWidth, configuration.maxWidth);\n  };\n\n  DirectionDOMCalculator.prototype._resize = function (size) {\n    this._elementWidth = size.width;\n    this._elementHeight = size.height;\n  };\n\n  DirectionDOMCalculator.prototype._reset = function () {\n    this._containerWidth = this._getContainerWidth(this._elementWidth, this._elementHeight);\n    this._containerHeight = this._getContainerHeight(this.containerWidth);\n    this._stepCircleSize = this._getStepCircleDiameter(this._containerHeight);\n    this._turnCircleSize = this._getTurnCircleDiameter(this.containerHeight);\n    this._outerRadius = this._getOuterRadius(this._containerHeight);\n    this._innerRadius = this._getInnerRadius(this._containerHeight);\n    this._shadowOffset = 3;\n    this._containerWidthCss = this._numberToCssPixels(this._containerWidth);\n    this._containerMarginCss = this._numberToCssPixels(-0.5 * this._containerWidth);\n    this._containerLeftCss = this._numberToCssPixels(Math.floor(0.5 * this._elementWidth));\n    this._containerHeightCss = this._numberToCssPixels(this._containerHeight);\n    this._containerBottomCss = this._numberToCssPixels(Math.floor(-0.08 * this._containerHeight));\n    this._stepCircleSizeCss = this._numberToCssPixels(this._stepCircleSize);\n    this._stepCircleMarginCss = this._numberToCssPixels(-0.5 * this._stepCircleSize);\n    this._turnCircleSizeCss = this._numberToCssPixels(this._turnCircleSize);\n  };\n\n  DirectionDOMCalculator.prototype._getContainerWidth = function (elementWidth, elementHeight) {\n    var relativeWidth = (elementWidth - this._minThresholdWidth) / (this._maxThresholdWidth - this._minThresholdWidth);\n    var relativeHeight = (elementHeight - this._minThresholdHeight) / (this._maxThresholdHeight - this._minThresholdHeight);\n    var coeff = Math.max(0, Math.min(1, Math.min(relativeWidth, relativeHeight)));\n    coeff = 0.04 * Math.round(25 * coeff);\n    return this._minWidth + coeff * (this._maxWidth - this._minWidth);\n  };\n\n  DirectionDOMCalculator.prototype._getContainerHeight = function (containerWidth) {\n    return 0.77 * containerWidth;\n  };\n\n  DirectionDOMCalculator.prototype._getStepCircleDiameter = function (containerHeight) {\n    return 0.34 * containerHeight;\n  };\n\n  DirectionDOMCalculator.prototype._getTurnCircleDiameter = function (containerHeight) {\n    return 0.3 * containerHeight;\n  };\n\n  DirectionDOMCalculator.prototype._getOuterRadius = function (containerHeight) {\n    return 0.31 * containerHeight;\n  };\n\n  DirectionDOMCalculator.prototype._getInnerRadius = function (containerHeight) {\n    return 0.125 * containerHeight;\n  };\n\n  DirectionDOMCalculator.prototype._numberToCssPixels = function (value) {\n    return value + \"px\";\n  };\n\n  DirectionDOMCalculator.prototype._getMaxWidth = function (value, minWidth) {\n    return value > minWidth ? value : minWidth;\n  };\n\n  return DirectionDOMCalculator;\n}();\n\nexports.DirectionDOMCalculator = DirectionDOMCalculator;\nexports.default = DirectionDOMCalculator;\n\n//# sourceURL=webpack://Mapillary/./src/component/direction/DirectionDOMCalculator.ts?");

/***/ }),

/***/ "./src/component/direction/DirectionDOMRenderer.ts":
/*!*********************************************************!*\
  !*** ./src/component/direction/DirectionDOMRenderer.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Edge_1 = __webpack_require__(/*! ../../Edge */ \"./src/Edge.ts\");\n\nvar Error_1 = __webpack_require__(/*! ../../Error */ \"./src/Error.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n/**\n * @class DirectionDOMRenderer\n * @classdesc DOM renderer for direction arrows.\n */\n\n\nvar DirectionDOMRenderer =\n/** @class */\nfunction () {\n  function DirectionDOMRenderer(configuration, size) {\n    this._isEdge = false;\n    this._spatial = new Geo_1.Spatial();\n    this._calculator = new Component_1.DirectionDOMCalculator(configuration, size);\n    this._node = null;\n    this._rotation = {\n      phi: 0,\n      theta: 0\n    };\n    this._epsilon = 0.5 * Math.PI / 180;\n    this._highlightKey = null;\n    this._distinguishSequence = false;\n    this._needsRender = false;\n    this._stepEdges = [];\n    this._turnEdges = [];\n    this._panoEdges = [];\n    this._sequenceEdgeKeys = [];\n    this._stepDirections = [Edge_1.EdgeDirection.StepForward, Edge_1.EdgeDirection.StepBackward, Edge_1.EdgeDirection.StepLeft, Edge_1.EdgeDirection.StepRight];\n    this._turnDirections = [Edge_1.EdgeDirection.TurnLeft, Edge_1.EdgeDirection.TurnRight, Edge_1.EdgeDirection.TurnU];\n    this._turnNames = {};\n    this._turnNames[Edge_1.EdgeDirection.TurnLeft] = \"TurnLeft\";\n    this._turnNames[Edge_1.EdgeDirection.TurnRight] = \"TurnRight\";\n    this._turnNames[Edge_1.EdgeDirection.TurnU] = \"TurnAround\"; // detects IE 8-11, then Edge 20+.\n\n    var isIE = !!document.documentMode;\n    this._isEdge = !isIE && !!window.StyleMedia;\n  }\n\n  Object.defineProperty(DirectionDOMRenderer.prototype, \"needsRender\", {\n    /**\n     * Get needs render.\n     *\n     * @returns {boolean} Value indicating whether render should be called.\n     */\n    get: function get() {\n      return this._needsRender;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Renders virtual DOM elements.\n   *\n   * @description Calling render resets the needs render property.\n   */\n\n  DirectionDOMRenderer.prototype.render = function (navigator) {\n    this._needsRender = false;\n    var rotation = this._rotation;\n    var steps = [];\n    var turns = [];\n\n    if (this._node.pano) {\n      steps = steps.concat(this._createPanoArrows(navigator, rotation));\n    } else {\n      steps = steps.concat(this._createPerspectiveToPanoArrows(navigator, rotation));\n      steps = steps.concat(this._createStepArrows(navigator, rotation));\n      turns = turns.concat(this._createTurnArrows(navigator));\n    }\n\n    return this._getContainer(steps, turns, rotation);\n  };\n\n  DirectionDOMRenderer.prototype.setEdges = function (edgeStatus, sequence) {\n    this._setEdges(edgeStatus, sequence);\n\n    this._setNeedsRender();\n  };\n  /**\n   * Set node for which to show edges.\n   *\n   * @param {Node} node\n   */\n\n\n  DirectionDOMRenderer.prototype.setNode = function (node) {\n    this._node = node;\n\n    this._clearEdges();\n\n    this._setNeedsRender();\n  };\n  /**\n   * Set the render camera to use for calculating rotations.\n   *\n   * @param {RenderCamera} renderCamera\n   */\n\n\n  DirectionDOMRenderer.prototype.setRenderCamera = function (renderCamera) {\n    var rotation = renderCamera.rotation;\n\n    if (Math.abs(rotation.phi - this._rotation.phi) < this._epsilon) {\n      return;\n    }\n\n    this._rotation = rotation;\n\n    this._setNeedsRender();\n  };\n  /**\n   * Set configuration values.\n   *\n   * @param {IDirectionConfiguration} configuration\n   */\n\n\n  DirectionDOMRenderer.prototype.setConfiguration = function (configuration) {\n    var needsRender = false;\n\n    if (this._highlightKey !== configuration.highlightKey || this._distinguishSequence !== configuration.distinguishSequence) {\n      this._highlightKey = configuration.highlightKey;\n      this._distinguishSequence = configuration.distinguishSequence;\n      needsRender = true;\n    }\n\n    if (this._calculator.minWidth !== configuration.minWidth || this._calculator.maxWidth !== configuration.maxWidth) {\n      this._calculator.configure(configuration);\n\n      needsRender = true;\n    }\n\n    if (needsRender) {\n      this._setNeedsRender();\n    }\n  };\n  /**\n   * Detect the element's width and height and resize\n   * elements accordingly.\n   *\n   * @param {ISize} size Size of vßiewer container element.\n   */\n\n\n  DirectionDOMRenderer.prototype.resize = function (size) {\n    this._calculator.resize(size);\n\n    this._setNeedsRender();\n  };\n\n  DirectionDOMRenderer.prototype._setNeedsRender = function () {\n    if (this._node != null) {\n      this._needsRender = true;\n    }\n  };\n\n  DirectionDOMRenderer.prototype._clearEdges = function () {\n    this._stepEdges = [];\n    this._turnEdges = [];\n    this._panoEdges = [];\n    this._sequenceEdgeKeys = [];\n  };\n\n  DirectionDOMRenderer.prototype._setEdges = function (edgeStatus, sequence) {\n    this._stepEdges = [];\n    this._turnEdges = [];\n    this._panoEdges = [];\n    this._sequenceEdgeKeys = [];\n\n    for (var _i = 0, _a = edgeStatus.edges; _i < _a.length; _i++) {\n      var edge = _a[_i];\n      var direction = edge.data.direction;\n\n      if (this._stepDirections.indexOf(direction) > -1) {\n        this._stepEdges.push(edge);\n\n        continue;\n      }\n\n      if (this._turnDirections.indexOf(direction) > -1) {\n        this._turnEdges.push(edge);\n\n        continue;\n      }\n\n      if (edge.data.direction === Edge_1.EdgeDirection.Pano) {\n        this._panoEdges.push(edge);\n      }\n    }\n\n    if (this._distinguishSequence && sequence != null) {\n      var edges = this._panoEdges.concat(this._stepEdges).concat(this._turnEdges);\n\n      for (var _b = 0, edges_1 = edges; _b < edges_1.length; _b++) {\n        var edge = edges_1[_b];\n        var edgeKey = edge.to;\n\n        for (var _c = 0, _d = sequence.keys; _c < _d.length; _c++) {\n          var sequenceKey = _d[_c];\n\n          if (sequenceKey === edgeKey) {\n            this._sequenceEdgeKeys.push(edgeKey);\n\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  DirectionDOMRenderer.prototype._createPanoArrows = function (navigator, rotation) {\n    var arrows = [];\n\n    for (var _i = 0, _a = this._panoEdges; _i < _a.length; _i++) {\n      var panoEdge = _a[_i];\n      arrows.push(this._createVNodeByKey(navigator, panoEdge.to, panoEdge.data.worldMotionAzimuth, rotation, this._calculator.outerRadius, \"DirectionsArrowPano\"));\n    }\n\n    for (var _b = 0, _c = this._stepEdges; _b < _c.length; _b++) {\n      var stepEdge = _c[_b];\n      arrows.push(this._createPanoToPerspectiveArrow(navigator, stepEdge.to, stepEdge.data.worldMotionAzimuth, rotation, stepEdge.data.direction));\n    }\n\n    return arrows;\n  };\n\n  DirectionDOMRenderer.prototype._createPanoToPerspectiveArrow = function (navigator, key, azimuth, rotation, direction) {\n    var threshold = Math.PI / 8;\n    var relativePhi = rotation.phi;\n\n    switch (direction) {\n      case Edge_1.EdgeDirection.StepBackward:\n        relativePhi = rotation.phi - Math.PI;\n        break;\n\n      case Edge_1.EdgeDirection.StepLeft:\n        relativePhi = rotation.phi + Math.PI / 2;\n        break;\n\n      case Edge_1.EdgeDirection.StepRight:\n        relativePhi = rotation.phi - Math.PI / 2;\n        break;\n\n      default:\n        break;\n    }\n\n    if (Math.abs(this._spatial.wrapAngle(azimuth - relativePhi)) < threshold) {\n      return this._createVNodeByKey(navigator, key, azimuth, rotation, this._calculator.outerRadius, \"DirectionsArrowStep\");\n    }\n\n    return this._createVNodeDisabled(key, azimuth, rotation);\n  };\n\n  DirectionDOMRenderer.prototype._createPerspectiveToPanoArrows = function (navigator, rotation) {\n    var arrows = [];\n\n    for (var _i = 0, _a = this._panoEdges; _i < _a.length; _i++) {\n      var panoEdge = _a[_i];\n      arrows.push(this._createVNodeByKey(navigator, panoEdge.to, panoEdge.data.worldMotionAzimuth, rotation, this._calculator.innerRadius, \"DirectionsArrowPano\", true));\n    }\n\n    return arrows;\n  };\n\n  DirectionDOMRenderer.prototype._createStepArrows = function (navigator, rotation) {\n    var arrows = [];\n\n    for (var _i = 0, _a = this._stepEdges; _i < _a.length; _i++) {\n      var stepEdge = _a[_i];\n      arrows.push(this._createVNodeByDirection(navigator, stepEdge.to, stepEdge.data.worldMotionAzimuth, rotation, stepEdge.data.direction));\n    }\n\n    return arrows;\n  };\n\n  DirectionDOMRenderer.prototype._createTurnArrows = function (navigator) {\n    var turns = [];\n\n    for (var _i = 0, _a = this._turnEdges; _i < _a.length; _i++) {\n      var turnEdge = _a[_i];\n      var direction = turnEdge.data.direction;\n      var name_1 = this._turnNames[direction];\n      turns.push(this._createVNodeByTurn(navigator, turnEdge.to, name_1, direction));\n    }\n\n    return turns;\n  };\n\n  DirectionDOMRenderer.prototype._createVNodeByKey = function (navigator, key, azimuth, rotation, offset, className, shiftVertically) {\n    var onClick = function onClick(e) {\n      navigator.moveToKey$(key).subscribe(undefined, function (error) {\n        if (!(error instanceof Error_1.AbortMapillaryError)) {\n          console.error(error);\n        }\n      });\n    };\n\n    return this._createVNode(key, azimuth, rotation, offset, className, \"DirectionsCircle\", onClick, shiftVertically);\n  };\n\n  DirectionDOMRenderer.prototype._createVNodeByDirection = function (navigator, key, azimuth, rotation, direction) {\n    var onClick = function onClick(e) {\n      navigator.moveDir$(direction).subscribe(undefined, function (error) {\n        if (!(error instanceof Error_1.AbortMapillaryError)) {\n          console.error(error);\n        }\n      });\n    };\n\n    return this._createVNode(key, azimuth, rotation, this._calculator.outerRadius, \"DirectionsArrowStep\", \"DirectionsCircle\", onClick);\n  };\n\n  DirectionDOMRenderer.prototype._createVNodeByTurn = function (navigator, key, className, direction) {\n    var onClick = function onClick(e) {\n      navigator.moveDir$(direction).subscribe(undefined, function (error) {\n        if (!(error instanceof Error_1.AbortMapillaryError)) {\n          console.error(error);\n        }\n      });\n    };\n\n    var style = {\n      height: this._calculator.turnCircleSizeCss,\n      transform: \"rotate(0)\",\n      width: this._calculator.turnCircleSizeCss\n    };\n\n    switch (direction) {\n      case Edge_1.EdgeDirection.TurnLeft:\n        style.left = \"5px\";\n        style.top = \"5px\";\n        break;\n\n      case Edge_1.EdgeDirection.TurnRight:\n        style.right = \"5px\";\n        style.top = \"5px\";\n        break;\n\n      case Edge_1.EdgeDirection.TurnU:\n        style.left = \"5px\";\n        style.bottom = \"5px\";\n        break;\n\n      default:\n        break;\n    }\n\n    var circleProperties = {\n      attributes: {\n        \"data-key\": key\n      },\n      onclick: onClick,\n      style: style\n    };\n    var circleClassName = \"TurnCircle\";\n\n    if (this._sequenceEdgeKeys.indexOf(key) > -1) {\n      circleClassName += \"Sequence\";\n    }\n\n    if (this._highlightKey === key) {\n      circleClassName += \"Highlight\";\n    }\n\n    var turn = vd.h(\"div.\" + className, {}, []);\n    return vd.h(\"div.\" + circleClassName, circleProperties, [turn]);\n  };\n\n  DirectionDOMRenderer.prototype._createVNodeDisabled = function (key, azimuth, rotation) {\n    return this._createVNode(key, azimuth, rotation, this._calculator.outerRadius, \"DirectionsArrowDisabled\", \"DirectionsCircleDisabled\");\n  };\n\n  DirectionDOMRenderer.prototype._createVNode = function (key, azimuth, rotation, radius, className, circleClassName, onClick, shiftVertically) {\n    var translation = this._calculator.angleToCoordinates(azimuth - rotation.phi); // rotate 90 degrees clockwise and flip over X-axis\n\n\n    var translationX = Math.round(-radius * translation[1] + 0.5 * this._calculator.containerWidth);\n    var translationY = Math.round(-radius * translation[0] + 0.5 * this._calculator.containerHeight);\n\n    var shadowTranslation = this._calculator.relativeAngleToCoordiantes(azimuth, rotation.phi);\n\n    var shadowOffset = this._calculator.shadowOffset;\n    var shadowTranslationX = -shadowOffset * shadowTranslation[1];\n    var shadowTranslationY = shadowOffset * shadowTranslation[0];\n    var filter = \"drop-shadow(\" + shadowTranslationX + \"px \" + shadowTranslationY + \"px 1px rgba(0,0,0,0.8))\";\n    var properties = {\n      style: {\n        \"-webkit-filter\": filter,\n        filter: filter\n      }\n    };\n    var chevron = vd.h(\"div.\" + className, properties, []);\n    var azimuthDeg = -this._spatial.radToDeg(azimuth - rotation.phi);\n    var circleTransform = shiftVertically ? \"translate(\" + translationX + \"px, \" + translationY + \"px) rotate(\" + azimuthDeg + \"deg) translateZ(-0.01px)\" : \"translate(\" + translationX + \"px, \" + translationY + \"px) rotate(\" + azimuthDeg + \"deg)\";\n    var circleProperties = {\n      attributes: {\n        \"data-key\": key\n      },\n      onclick: onClick,\n      style: {\n        height: this._calculator.stepCircleSizeCss,\n        marginLeft: this._calculator.stepCircleMarginCss,\n        marginTop: this._calculator.stepCircleMarginCss,\n        transform: circleTransform,\n        width: this._calculator.stepCircleSizeCss\n      }\n    };\n\n    if (this._sequenceEdgeKeys.indexOf(key) > -1) {\n      circleClassName += \"Sequence\";\n    }\n\n    if (this._highlightKey === key) {\n      circleClassName += \"Highlight\";\n    }\n\n    return vd.h(\"div.\" + circleClassName, circleProperties, [chevron]);\n  };\n\n  DirectionDOMRenderer.prototype._getContainer = function (steps, turns, rotation) {\n    // edge does not handle hover on perspective transforms.\n    var transform = this._isEdge ? \"rotateX(60deg)\" : \"perspective(\" + this._calculator.containerWidthCss + \") rotateX(60deg)\";\n    var properties = {\n      oncontextmenu: function oncontextmenu(event) {\n        event.preventDefault();\n      },\n      style: {\n        bottom: this._calculator.containerBottomCss,\n        height: this._calculator.containerHeightCss,\n        left: this._calculator.containerLeftCss,\n        marginLeft: this._calculator.containerMarginCss,\n        transform: transform,\n        width: this._calculator.containerWidthCss\n      }\n    };\n    return vd.h(\"div.DirectionsPerspective\", properties, turns.concat(steps));\n  };\n\n  return DirectionDOMRenderer;\n}();\n\nexports.DirectionDOMRenderer = DirectionDOMRenderer;\nexports.default = DirectionDOMRenderer;\n\n//# sourceURL=webpack://Mapillary/./src/component/direction/DirectionDOMRenderer.ts?");

/***/ }),

/***/ "./src/component/imageplane/ImagePlaneComponent.ts":
/*!*********************************************************!*\
  !*** ./src/component/imageplane/ImagePlaneComponent.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Viewer_1 = __webpack_require__(/*! ../../Viewer */ \"./src/Viewer.ts\");\n\nvar Render_1 = __webpack_require__(/*! ../../Render */ \"./src/Render.ts\");\n\nvar Tiles_1 = __webpack_require__(/*! ../../Tiles */ \"./src/Tiles.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../../Utils */ \"./src/Utils.ts\");\n\nvar ViewportCoords_1 = __webpack_require__(/*! ../../geo/ViewportCoords */ \"./src/geo/ViewportCoords.ts\");\n\nvar Spatial_1 = __webpack_require__(/*! ../../geo/Spatial */ \"./src/geo/Spatial.ts\");\n\nvar ImagePlaneComponent =\n/** @class */\nfunction (_super) {\n  __extends(ImagePlaneComponent, _super);\n\n  function ImagePlaneComponent(name, container, navigator) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._imageTileLoader = new Tiles_1.ImageTileLoader(Utils_1.Urls.tileScheme, Utils_1.Urls.tileDomain, Utils_1.Urls.origin);\n    _this._roiCalculator = new Tiles_1.RegionOfInterestCalculator();\n    _this._rendererOperation$ = new rxjs_1.Subject();\n    _this._rendererCreator$ = new rxjs_1.Subject();\n    _this._rendererDisposer$ = new rxjs_1.Subject();\n    _this._renderer$ = _this._rendererOperation$.pipe(operators_1.scan(function (renderer, operation) {\n      return operation(renderer);\n    }, null), operators_1.filter(function (renderer) {\n      return renderer != null;\n    }), operators_1.distinctUntilChanged(undefined, function (renderer) {\n      return renderer.frameId;\n    }));\n\n    _this._rendererCreator$.pipe(operators_1.map(function () {\n      return function (renderer) {\n        if (renderer != null) {\n          throw new Error(\"Multiple image plane states can not be created at the same time\");\n        }\n\n        return new Component_1.ImagePlaneGLRenderer();\n      };\n    })).subscribe(_this._rendererOperation$);\n\n    _this._rendererDisposer$.pipe(operators_1.map(function () {\n      return function (renderer) {\n        renderer.dispose();\n        return null;\n      };\n    })).subscribe(_this._rendererOperation$);\n\n    return _this;\n  }\n\n  ImagePlaneComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._rendererSubscription = this._renderer$.pipe(operators_1.map(function (renderer) {\n      var renderHash = {\n        name: _this._name,\n        render: {\n          frameId: renderer.frameId,\n          needsRender: renderer.needsRender,\n          render: renderer.render.bind(renderer),\n          stage: Render_1.GLRenderStage.Background\n        }\n      };\n      renderer.clearNeedsRender();\n      return renderHash;\n    })).subscribe(this._container.glRenderer.render$);\n\n    this._rendererCreator$.next(null);\n\n    this._stateSubscription = this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      return function (renderer) {\n        renderer.updateFrame(frame);\n        return renderer;\n      };\n    })).subscribe(this._rendererOperation$);\n\n    var textureProvider$ = this._navigator.stateService.currentState$.pipe(operators_1.distinctUntilChanged(undefined, function (frame) {\n      return frame.state.currentNode.key;\n    }), operators_1.withLatestFrom(this._container.glRenderer.webGLRenderer$, this._container.renderService.size$), operators_1.map(function (_a) {\n      var frame = _a[0],\n          renderer = _a[1],\n          size = _a[2];\n      var state = frame.state;\n      var viewportSize = Math.max(size.width, size.height);\n      var currentNode = state.currentNode;\n      var currentTransform = state.currentTransform;\n      var tileSize = viewportSize > 2048 ? 2048 : viewportSize > 1024 ? 1024 : 512;\n      return new Tiles_1.TextureProvider(currentNode.key, currentTransform.basicWidth, currentTransform.basicHeight, tileSize, currentNode.image, _this._imageTileLoader, new Tiles_1.ImageTileStore(), renderer);\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._textureProviderSubscription = textureProvider$.subscribe(function () {});\n    this._setTextureProviderSubscription = textureProvider$.pipe(operators_1.map(function (provider) {\n      return function (renderer) {\n        renderer.setTextureProvider(provider.key, provider);\n        return renderer;\n      };\n    })).subscribe(this._rendererOperation$);\n    this._setTileSizeSubscription = this._container.renderService.size$.pipe(operators_1.switchMap(function (size) {\n      return rxjs_1.combineLatest(textureProvider$, rxjs_1.of(size)).pipe(operators_1.first());\n    })).subscribe(function (_a) {\n      var provider = _a[0],\n          size = _a[1];\n      var viewportSize = Math.max(size.width, size.height);\n      var tileSize = viewportSize > 2048 ? 2048 : viewportSize > 1024 ? 1024 : 512;\n      provider.setTileSize(tileSize);\n    });\n    this._abortTextureProviderSubscription = textureProvider$.pipe(operators_1.pairwise()).subscribe(function (pair) {\n      var previous = pair[0];\n      previous.abort();\n    });\n    var roiTrigger$ = rxjs_1.combineLatest(this._container.renderService.renderCameraFrame$, this._container.renderService.size$.pipe(operators_1.debounceTime(250))).pipe(operators_1.map(function (_a) {\n      var camera = _a[0],\n          size = _a[1];\n      return [camera.camera.position.clone(), camera.camera.lookat.clone(), camera.zoom.valueOf(), size.height.valueOf(), size.width.valueOf()];\n    }), operators_1.pairwise(), operators_1.skipWhile(function (pls) {\n      return pls[1][2] - pls[0][2] < 0 || pls[1][2] === 0;\n    }), operators_1.map(function (pls) {\n      var samePosition = pls[0][0].equals(pls[1][0]);\n      var sameLookat = pls[0][1].equals(pls[1][1]);\n      var sameZoom = pls[0][2] === pls[1][2];\n      var sameHeight = pls[0][3] === pls[1][3];\n      var sameWidth = pls[0][4] === pls[1][4];\n      return samePosition && sameLookat && sameZoom && sameHeight && sameWidth;\n    }), operators_1.distinctUntilChanged(), operators_1.filter(function (stalled) {\n      return stalled;\n    }), operators_1.switchMap(function (stalled) {\n      return _this._container.renderService.renderCameraFrame$.pipe(operators_1.first());\n    }), operators_1.withLatestFrom(this._container.renderService.size$, this._navigator.stateService.currentTransform$));\n    this._setRegionOfInterestSubscription = textureProvider$.pipe(operators_1.switchMap(function (provider) {\n      return roiTrigger$.pipe(operators_1.map(function (_a) {\n        var camera = _a[0],\n            size = _a[1],\n            transform = _a[2];\n        var basic = new ViewportCoords_1.default().viewportToBasic(0, 0, transform, camera.perspective);\n\n        if (basic[0] < 0 || basic[1] < 0 || basic[0] > 1 || basic[1] > 1) {\n          return undefined;\n        }\n\n        return [_this._roiCalculator.computeRegionOfInterest(camera, size, transform), provider];\n      }), operators_1.filter(function (args) {\n        return !!args;\n      }));\n    }), operators_1.filter(function (args) {\n      return !args[1].disposed;\n    })).subscribe(function (args) {\n      var roi = args[0];\n      var provider = args[1];\n      provider.setRegionOfInterest(roi);\n    });\n    var hasTexture$ = textureProvider$.pipe(operators_1.switchMap(function (provider) {\n      return provider.hasTexture$;\n    }), operators_1.startWith(false), operators_1.publishReplay(1), operators_1.refCount());\n    this._hasTextureSubscription = hasTexture$.subscribe(function () {});\n\n    var nodeImage$ = this._navigator.stateService.currentState$.pipe(operators_1.filter(function (frame) {\n      return frame.state.nodesAhead === 0;\n    }), operators_1.map(function (frame) {\n      return frame.state.currentNode;\n    }), operators_1.distinctUntilChanged(undefined, function (node) {\n      return node.key;\n    }), operators_1.debounceTime(1000), operators_1.withLatestFrom(hasTexture$), operators_1.filter(function (args) {\n      return !args[1];\n    }), operators_1.map(function (args) {\n      return args[0];\n    }), operators_1.filter(function (node) {\n      return node.pano ? Utils_1.Settings.maxImageSize > Utils_1.Settings.basePanoramaSize : Utils_1.Settings.maxImageSize > Utils_1.Settings.baseImageSize;\n    }), operators_1.switchMap(function (node) {\n      var baseImageSize = node.pano ? Utils_1.Settings.basePanoramaSize : Utils_1.Settings.baseImageSize;\n\n      if (Math.max(node.image.width, node.image.height) > baseImageSize) {\n        return rxjs_1.empty();\n      }\n\n      var image$ = node.cacheImage$(Utils_1.Settings.maxImageSize).pipe(operators_1.map(function (n) {\n        return [n.image, n];\n      }));\n      return image$.pipe(operators_1.takeUntil(hasTexture$.pipe(operators_1.filter(function (hasTexture) {\n        return hasTexture;\n      }))), operators_1.catchError(function (error, caught) {\n        console.error(\"Failed to fetch high res image (\" + node.key + \")\", error);\n        return rxjs_1.empty();\n      }));\n    })).pipe(operators_1.publish(), operators_1.refCount());\n\n    this._updateBackgroundSubscription = nodeImage$.pipe(operators_1.withLatestFrom(textureProvider$)).subscribe(function (args) {\n      if (args[0][1].key !== args[1].key || args[1].disposed) {\n        return;\n      }\n\n      args[1].updateBackground(args[0][0]);\n    });\n    this._updateTextureImageSubscription = nodeImage$.pipe(operators_1.map(function (imn) {\n      return function (renderer) {\n        renderer.updateTextureImage(imn[0], imn[1]);\n        return renderer;\n      };\n    })).subscribe(this._rendererOperation$);\n    this._clearPeripheryPlaneSubscription = this._navigator.panService.panNodes$.pipe(operators_1.filter(function (panNodes) {\n      return panNodes.length === 0;\n    }), operators_1.map(function () {\n      return function (renderer) {\n        renderer.clearPeripheryPlanes();\n        return renderer;\n      };\n    })).subscribe(this._rendererOperation$);\n\n    var cachedPanNodes$ = this._navigator.panService.panNodes$.pipe(operators_1.switchMap(function (nts) {\n      return rxjs_1.from(nts).pipe(operators_1.mergeMap(function (_a) {\n        var n = _a[0],\n            t = _a[1];\n        return rxjs_1.combineLatest(_this._navigator.graphService.cacheNode$(n.key).pipe(operators_1.catchError(function (error) {\n          console.error(\"Failed to cache periphery node (\" + n.key + \")\", error);\n          return rxjs_1.empty();\n        })), rxjs_1.of(t));\n      }));\n    }), operators_1.share());\n\n    this._addPeripheryPlaneSubscription = cachedPanNodes$.pipe(operators_1.map(function (_a) {\n      var n = _a[0],\n          t = _a[1];\n      return function (renderer) {\n        renderer.addPeripheryPlane(n, t);\n        return renderer;\n      };\n    })).subscribe(this._rendererOperation$);\n    this._updatePeripheryPlaneTextureSubscription = cachedPanNodes$.pipe(operators_1.mergeMap(function (_a) {\n      var n = _a[0];\n      return Viewer_1.ImageSize.Size2048 > Math.max(n.image.width, n.image.height) ? n.cacheImage$(Viewer_1.ImageSize.Size2048).pipe(operators_1.catchError(function () {\n        return rxjs_1.empty();\n      })) : rxjs_1.empty();\n    }), operators_1.map(function (n) {\n      return function (renderer) {\n        renderer.updateTextureImage(n.image, n);\n        return renderer;\n      };\n    })).subscribe(this._rendererOperation$);\n\n    var inTransition$ = this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      return frame.state.alpha < 1;\n    }), operators_1.distinctUntilChanged());\n\n    var panTrigger$ = rxjs_1.combineLatest(this._container.mouseService.active$, this._container.touchService.active$, this._navigator.stateService.inMotion$, inTransition$).pipe(operators_1.map(function (_a) {\n      var mouseActive = _a[0],\n          touchActive = _a[1],\n          inMotion = _a[2],\n          inTransition = _a[3];\n      return !(mouseActive || touchActive || inMotion || inTransition);\n    }), operators_1.filter(function (trigger) {\n      return trigger;\n    }));\n    this._moveToPeripheryNodeSubscription = this._navigator.panService.panNodes$.pipe(operators_1.switchMap(function (nts) {\n      return panTrigger$.pipe(operators_1.withLatestFrom(_this._container.renderService.renderCamera$, _this._navigator.stateService.currentNode$, _this._navigator.stateService.currentTransform$), operators_1.mergeMap(function (_a) {\n        var renderCamera = _a[1],\n            currentNode = _a[2],\n            currentTransform = _a[3];\n        return rxjs_1.of([renderCamera, currentNode, currentTransform, nts]);\n      }));\n    }), operators_1.switchMap(function (_a) {\n      var camera = _a[0],\n          cn = _a[1],\n          ct = _a[2],\n          nts = _a[3];\n      var direction = camera.camera.lookat.clone().sub(camera.camera.position);\n      var cd = new Spatial_1.default().viewingDirection(cn.rotation);\n      var ca = cd.angleTo(direction);\n      var closest = [ca, undefined];\n      var basic = new ViewportCoords_1.default().viewportToBasic(0, 0, ct, camera.perspective);\n\n      if (basic[0] >= 0 && basic[0] <= 1 && basic[1] >= 0 && basic[1] <= 1) {\n        closest[0] = Number.NEGATIVE_INFINITY;\n      }\n\n      for (var _i = 0, nts_1 = nts; _i < nts_1.length; _i++) {\n        var n = nts_1[_i][0];\n        var d = new Spatial_1.default().viewingDirection(n.rotation);\n        var a = d.angleTo(direction);\n\n        if (a < closest[0]) {\n          closest[0] = a;\n          closest[1] = n.key;\n        }\n      }\n\n      if (!closest[1]) {\n        return rxjs_1.empty();\n      }\n\n      return _this._navigator.moveToKey$(closest[1]).pipe(operators_1.catchError(function () {\n        return rxjs_1.empty();\n      }));\n    })).subscribe();\n  };\n\n  ImagePlaneComponent.prototype._deactivate = function () {\n    this._rendererDisposer$.next(null);\n\n    this._abortTextureProviderSubscription.unsubscribe();\n\n    this._hasTextureSubscription.unsubscribe();\n\n    this._rendererSubscription.unsubscribe();\n\n    this._setRegionOfInterestSubscription.unsubscribe();\n\n    this._setTextureProviderSubscription.unsubscribe();\n\n    this._setTileSizeSubscription.unsubscribe();\n\n    this._stateSubscription.unsubscribe();\n\n    this._textureProviderSubscription.unsubscribe();\n\n    this._updateBackgroundSubscription.unsubscribe();\n\n    this._updateTextureImageSubscription.unsubscribe();\n\n    this._clearPeripheryPlaneSubscription.unsubscribe();\n\n    this._addPeripheryPlaneSubscription.unsubscribe();\n\n    this._updatePeripheryPlaneTextureSubscription.unsubscribe();\n\n    this._moveToPeripheryNodeSubscription.unsubscribe();\n  };\n\n  ImagePlaneComponent.prototype._getDefaultConfiguration = function () {\n    return {};\n  };\n\n  ImagePlaneComponent.componentName = \"imagePlane\";\n  return ImagePlaneComponent;\n}(Component_1.Component);\n\nexports.ImagePlaneComponent = ImagePlaneComponent;\nComponent_1.ComponentService.register(ImagePlaneComponent);\nexports.default = ImagePlaneComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/imageplane/ImagePlaneComponent.ts?");

/***/ }),

/***/ "./src/component/imageplane/ImagePlaneGLRenderer.ts":
/*!**********************************************************!*\
  !*** ./src/component/imageplane/ImagePlaneGLRenderer.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar ImagePlaneGLRenderer =\n/** @class */\nfunction () {\n  function ImagePlaneGLRenderer() {\n    this._factory = new Component_1.MeshFactory();\n    this._scene = new Component_1.MeshScene();\n    this._alpha = 0;\n    this._alphaOld = 0;\n    this._fadeOutSpeed = 0.05;\n    this._currentKey = null;\n    this._previousKey = null;\n    this._providerDisposers = {};\n    this._frameId = 0;\n    this._needsRender = false;\n  }\n\n  Object.defineProperty(ImagePlaneGLRenderer.prototype, \"frameId\", {\n    get: function get() {\n      return this._frameId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ImagePlaneGLRenderer.prototype, \"needsRender\", {\n    get: function get() {\n      return this._needsRender;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ImagePlaneGLRenderer.prototype.indicateNeedsRender = function () {\n    this._needsRender = true;\n  };\n\n  ImagePlaneGLRenderer.prototype.addPeripheryPlane = function (node, transform) {\n    var mesh = this._factory.createMesh(node, transform);\n\n    var planes = {};\n    planes[node.key] = mesh;\n\n    this._scene.addPeripheryPlanes(planes);\n\n    this._needsRender = true;\n  };\n\n  ImagePlaneGLRenderer.prototype.clearPeripheryPlanes = function () {\n    this._scene.setPeripheryPlanes({});\n\n    this._needsRender = true;\n  };\n\n  ImagePlaneGLRenderer.prototype.updateFrame = function (frame) {\n    this._updateFrameId(frame.id);\n\n    this._needsRender = this._updateAlpha(frame.state.alpha) || this._needsRender;\n    this._needsRender = this._updateAlphaOld(frame.state.alpha) || this._needsRender;\n    this._needsRender = this._updateImagePlanes(frame.state) || this._needsRender;\n  };\n\n  ImagePlaneGLRenderer.prototype.setTextureProvider = function (key, provider) {\n    var _this = this;\n\n    if (key !== this._currentKey) {\n      return;\n    }\n\n    var createdSubscription = provider.textureCreated$.subscribe(function (texture) {\n      _this._updateTexture(texture);\n    });\n    var updatedSubscription = provider.textureUpdated$.subscribe(function (updated) {\n      _this._needsRender = true;\n    });\n\n    var dispose = function dispose() {\n      createdSubscription.unsubscribe();\n      updatedSubscription.unsubscribe();\n      provider.dispose();\n    };\n\n    if (key in this._providerDisposers) {\n      var disposeProvider = this._providerDisposers[key];\n      disposeProvider();\n      delete this._providerDisposers[key];\n    }\n\n    this._providerDisposers[key] = dispose;\n  };\n\n  ImagePlaneGLRenderer.prototype.updateTextureImage = function (image, node) {\n    this._needsRender = true;\n\n    var planes = this._extend({}, this._scene.planes, this._scene.planesOld, this._scene.planesPeriphery);\n\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      if (key !== node.key) {\n        continue;\n      }\n\n      var plane = planes[key];\n      var material = plane.material;\n      var texture = material.uniforms.projectorTex.value;\n      texture.image = image;\n      texture.needsUpdate = true;\n    }\n  };\n\n  ImagePlaneGLRenderer.prototype.render = function (perspectiveCamera, renderer) {\n    var planes = this._scene.planes;\n    var planesOld = this._scene.planesOld;\n    var planesPeriphery = this._scene.planesPeriphery;\n    var planeAlpha = Object.keys(planesOld).length ? 1 : this._alpha;\n    var peripheryAlpha = Object.keys(planesOld).length ? 1 : Math.floor(this._alpha);\n\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n      plane.material.uniforms.opacity.value = planeAlpha;\n    }\n\n    for (var key in planesOld) {\n      if (!planesOld.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planesOld[key];\n      plane.material.uniforms.opacity.value = this._alphaOld;\n    }\n\n    for (var key in planesPeriphery) {\n      if (!planesPeriphery.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planesPeriphery[key];\n      plane.material.uniforms.opacity.value = peripheryAlpha;\n    }\n\n    renderer.render(this._scene.scenePeriphery, perspectiveCamera);\n    renderer.render(this._scene.scene, perspectiveCamera);\n    renderer.render(this._scene.sceneOld, perspectiveCamera);\n\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n      plane.material.uniforms.opacity.value = this._alpha;\n    }\n\n    renderer.render(this._scene.scene, perspectiveCamera);\n  };\n\n  ImagePlaneGLRenderer.prototype.clearNeedsRender = function () {\n    this._needsRender = false;\n  };\n\n  ImagePlaneGLRenderer.prototype.dispose = function () {\n    this._scene.clear();\n  };\n\n  ImagePlaneGLRenderer.prototype._updateFrameId = function (frameId) {\n    this._frameId = frameId;\n  };\n\n  ImagePlaneGLRenderer.prototype._updateAlpha = function (alpha) {\n    if (alpha === this._alpha) {\n      return false;\n    }\n\n    this._alpha = alpha;\n    return true;\n  };\n\n  ImagePlaneGLRenderer.prototype._updateAlphaOld = function (alpha) {\n    if (alpha < 1 || this._alphaOld === 0) {\n      return false;\n    }\n\n    this._alphaOld = Math.max(0, this._alphaOld - this._fadeOutSpeed);\n    return true;\n  };\n\n  ImagePlaneGLRenderer.prototype._updateImagePlanes = function (state) {\n    if (state.currentNode == null || state.currentNode.key === this._currentKey) {\n      return false;\n    }\n\n    var previousKey = state.previousNode != null ? state.previousNode.key : null;\n    var currentKey = state.currentNode.key;\n\n    if (this._previousKey !== previousKey && this._previousKey !== currentKey && this._previousKey in this._providerDisposers) {\n      var disposeProvider = this._providerDisposers[this._previousKey];\n      disposeProvider();\n      delete this._providerDisposers[this._previousKey];\n    }\n\n    if (previousKey != null) {\n      if (previousKey !== this._currentKey && previousKey !== this._previousKey) {\n        var previousMesh = this._factory.createMesh(state.previousNode, state.previousTransform);\n\n        var previousPlanes = {};\n        previousPlanes[previousKey] = previousMesh;\n\n        this._scene.updateImagePlanes(previousPlanes);\n      }\n\n      this._previousKey = previousKey;\n    }\n\n    this._currentKey = currentKey;\n\n    var currentMesh = this._factory.createMesh(state.currentNode, state.currentTransform);\n\n    var planes = {};\n    planes[currentKey] = currentMesh;\n\n    this._scene.updateImagePlanes(planes);\n\n    this._alphaOld = 1;\n    return true;\n  };\n\n  ImagePlaneGLRenderer.prototype._updateTexture = function (texture) {\n    this._needsRender = true;\n    var planes = this._scene.planes;\n\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n      var material = plane.material;\n      var oldTexture = material.uniforms.projectorTex.value;\n      material.uniforms.projectorTex.value = null;\n      oldTexture.dispose();\n      material.uniforms.projectorTex.value = texture;\n    }\n  };\n\n  ImagePlaneGLRenderer.prototype._extend = function (dest) {\n    var sources = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      sources[_i - 1] = arguments[_i];\n    }\n\n    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\n      var src = sources_1[_a];\n\n      for (var k in src) {\n        if (!src.hasOwnProperty(k)) {\n          continue;\n        }\n\n        dest[k] = src[k];\n      }\n    }\n\n    return dest;\n  };\n\n  return ImagePlaneGLRenderer;\n}();\n\nexports.ImagePlaneGLRenderer = ImagePlaneGLRenderer;\nexports.default = ImagePlaneGLRenderer;\n\n//# sourceURL=webpack://Mapillary/./src/component/imageplane/ImagePlaneGLRenderer.ts?");

/***/ }),

/***/ "./src/component/interfaces/ICoverConfiguration.ts":
/*!*********************************************************!*\
  !*** ./src/component/interfaces/ICoverConfiguration.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar CoverState;\n\n(function (CoverState) {\n  CoverState[CoverState[\"Hidden\"] = 0] = \"Hidden\";\n  CoverState[CoverState[\"Loading\"] = 1] = \"Loading\";\n  CoverState[CoverState[\"Visible\"] = 2] = \"Visible\";\n})(CoverState = exports.CoverState || (exports.CoverState = {}));\n\n//# sourceURL=webpack://Mapillary/./src/component/interfaces/ICoverConfiguration.ts?");

/***/ }),

/***/ "./src/component/interfaces/ISliderConfiguration.ts":
/*!**********************************************************!*\
  !*** ./src/component/interfaces/ISliderConfiguration.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enumeration for slider mode.\n *\n * @enum {number}\n * @readonly\n *\n * @description Modes for specifying how transitions\n * between nodes are performed in slider mode. Only\n * applicable when the slider component determines\n * that transitions with motion is possilble. When it\n * is not, the stationary mode will be applied.\n */\n\nvar SliderMode;\n\n(function (SliderMode) {\n  /**\n   * Transitions with motion.\n   *\n   * @description The slider component moves the\n   * camera between the node origins.\n   *\n   * In this mode it is not possible to zoom or pan.\n   *\n   * The slider component falls back to stationary\n   * mode when it determines that the pair of nodes\n   * does not have a strong enough relation.\n   */\n  SliderMode[SliderMode[\"Motion\"] = 0] = \"Motion\";\n  /**\n   * Stationary transitions.\n   *\n   * @description The camera is stationary.\n   *\n   * In this mode it is possible to zoom and pan.\n   */\n\n  SliderMode[SliderMode[\"Stationary\"] = 1] = \"Stationary\";\n})(SliderMode = exports.SliderMode || (exports.SliderMode = {}));\n\n//# sourceURL=webpack://Mapillary/./src/component/interfaces/ISliderConfiguration.ts?");

/***/ }),

/***/ "./src/component/interfaces/interfaces.ts":
/*!************************************************!*\
  !*** ./src/component/interfaces/interfaces.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ICoverConfiguration_1 = __webpack_require__(/*! ./ICoverConfiguration */ \"./src/component/interfaces/ICoverConfiguration.ts\");\n\nexports.CoverState = ICoverConfiguration_1.CoverState;\n\nvar ISliderConfiguration_1 = __webpack_require__(/*! ./ISliderConfiguration */ \"./src/component/interfaces/ISliderConfiguration.ts\");\n\nexports.SliderMode = ISliderConfiguration_1.SliderMode;\n\n//# sourceURL=webpack://Mapillary/./src/component/interfaces/interfaces.ts?");

/***/ }),

/***/ "./src/component/keyboard/KeyPlayHandler.ts":
/*!**************************************************!*\
  !*** ./src/component/keyboard/KeyPlayHandler.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Edge_1 = __webpack_require__(/*! ../../Edge */ \"./src/Edge.ts\");\n/**\n * The `KeyPlayHandler` allows the user to control the play behavior\n * using the following key commands:\n *\n * `Spacebar`: Start or stop playing.\n * `SHIFT` + `D`: Switch direction.\n * `<`: Decrease speed.\n * `>`: Increase speed.\n *\n * @example\n * ```\n * var keyboardComponent = viewer.getComponent(\"keyboard\");\n *\n * keyboardComponent.keyPlay.disable();\n * keyboardComponent.keyPlay.enable();\n *\n * var isEnabled = keyboardComponent.keyPlay.isEnabled;\n * ```\n */\n\n\nvar KeyPlayHandler =\n/** @class */\nfunction (_super) {\n  __extends(KeyPlayHandler, _super);\n\n  function KeyPlayHandler() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  KeyPlayHandler.prototype._enable = function () {\n    var _this = this;\n\n    this._keyDownSubscription = this._container.keyboardService.keyDown$.pipe(operators_1.withLatestFrom(this._navigator.playService.playing$, this._navigator.playService.direction$, this._navigator.playService.speed$, this._navigator.stateService.currentNode$.pipe(operators_1.switchMap(function (node) {\n      return node.sequenceEdges$;\n    })))).subscribe(function (_a) {\n      var event = _a[0],\n          playing = _a[1],\n          direction = _a[2],\n          speed = _a[3],\n          status = _a[4];\n\n      if (event.altKey || event.ctrlKey || event.metaKey) {\n        return;\n      }\n\n      switch (event.key) {\n        case \"D\":\n          if (!event.shiftKey) {\n            return;\n          }\n\n          var newDirection = playing ? null : direction === Edge_1.EdgeDirection.Next ? Edge_1.EdgeDirection.Prev : direction === Edge_1.EdgeDirection.Prev ? Edge_1.EdgeDirection.Next : null;\n\n          if (newDirection != null) {\n            _this._navigator.playService.setDirection(newDirection);\n          }\n\n          break;\n\n        case \" \":\n          if (event.shiftKey) {\n            return;\n          }\n\n          if (playing) {\n            _this._navigator.playService.stop();\n          } else {\n            for (var _i = 0, _b = status.edges; _i < _b.length; _i++) {\n              var edge = _b[_i];\n\n              if (edge.data.direction === direction) {\n                _this._navigator.playService.play();\n              }\n            }\n          }\n\n          break;\n\n        case \"<\":\n          _this._navigator.playService.setSpeed(speed - 0.05);\n\n          break;\n\n        case \">\":\n          _this._navigator.playService.setSpeed(speed + 0.05);\n\n          break;\n\n        default:\n          return;\n      }\n\n      event.preventDefault();\n    });\n  };\n\n  KeyPlayHandler.prototype._disable = function () {\n    this._keyDownSubscription.unsubscribe();\n  };\n\n  KeyPlayHandler.prototype._getConfiguration = function (enable) {\n    return {\n      keyZoom: enable\n    };\n  };\n\n  return KeyPlayHandler;\n}(Component_1.HandlerBase);\n\nexports.KeyPlayHandler = KeyPlayHandler;\nexports.default = KeyPlayHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/keyboard/KeyPlayHandler.ts?");

/***/ }),

/***/ "./src/component/keyboard/KeySequenceNavigationHandler.ts":
/*!****************************************************************!*\
  !*** ./src/component/keyboard/KeySequenceNavigationHandler.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Edge_1 = __webpack_require__(/*! ../../Edge */ \"./src/Edge.ts\");\n\nvar Error_1 = __webpack_require__(/*! ../../Error */ \"./src/Error.ts\");\n/**\n * The `KeySequenceNavigationHandler` allows the user to navigate through a sequence using the\n * following key commands:\n *\n * `ALT` + `Up Arrow`: Navigate to next image in the sequence.\n * `ALT` + `Down Arrow`: Navigate to previous image in sequence.\n *\n * @example\n * ```\n * var keyboardComponent = viewer.getComponent(\"keyboard\");\n *\n * keyboardComponent.keySequenceNavigation.disable();\n * keyboardComponent.keySequenceNavigation.enable();\n *\n * var isEnabled = keyboardComponent.keySequenceNavigation.isEnabled;\n * ```\n */\n\n\nvar KeySequenceNavigationHandler =\n/** @class */\nfunction (_super) {\n  __extends(KeySequenceNavigationHandler, _super);\n\n  function KeySequenceNavigationHandler() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  KeySequenceNavigationHandler.prototype._enable = function () {\n    var _this = this;\n\n    var sequenceEdges$ = this._navigator.stateService.currentNode$.pipe(operators_1.switchMap(function (node) {\n      return node.sequenceEdges$;\n    }));\n\n    this._keyDownSubscription = this._container.keyboardService.keyDown$.pipe(operators_1.withLatestFrom(sequenceEdges$)).subscribe(function (_a) {\n      var event = _a[0],\n          edgeStatus = _a[1];\n      var direction = null;\n\n      switch (event.keyCode) {\n        case 38:\n          // up\n          direction = Edge_1.EdgeDirection.Next;\n          break;\n\n        case 40:\n          // down\n          direction = Edge_1.EdgeDirection.Prev;\n          break;\n\n        default:\n          return;\n      }\n\n      event.preventDefault();\n\n      if (!event.altKey || event.shiftKey || !edgeStatus.cached) {\n        return;\n      }\n\n      for (var _i = 0, _b = edgeStatus.edges; _i < _b.length; _i++) {\n        var edge = _b[_i];\n\n        if (edge.data.direction === direction) {\n          _this._navigator.moveToKey$(edge.to).subscribe(undefined, function (error) {\n            if (!(error instanceof Error_1.AbortMapillaryError)) {\n              console.error(error);\n            }\n          });\n\n          return;\n        }\n      }\n    });\n  };\n\n  KeySequenceNavigationHandler.prototype._disable = function () {\n    this._keyDownSubscription.unsubscribe();\n  };\n\n  KeySequenceNavigationHandler.prototype._getConfiguration = function (enable) {\n    return {\n      keySequenceNavigation: enable\n    };\n  };\n\n  return KeySequenceNavigationHandler;\n}(Component_1.HandlerBase);\n\nexports.KeySequenceNavigationHandler = KeySequenceNavigationHandler;\nexports.default = KeySequenceNavigationHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/keyboard/KeySequenceNavigationHandler.ts?");

/***/ }),

/***/ "./src/component/keyboard/KeySpatialNavigationHandler.ts":
/*!***************************************************************!*\
  !*** ./src/component/keyboard/KeySpatialNavigationHandler.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Edge_1 = __webpack_require__(/*! ../../Edge */ \"./src/Edge.ts\");\n\nvar Error_1 = __webpack_require__(/*! ../../Error */ \"./src/Error.ts\");\n/**\n * The `KeySpatialNavigationHandler` allows the user to navigate through a sequence using the\n * following key commands:\n *\n * `Up Arrow`: Step forward.\n * `Down Arrow`: Step backward.\n * `Left Arrow`: Step to the left.\n * `Rigth Arrow`: Step to the right.\n * `SHIFT` + `Down Arrow`: Turn around.\n * `SHIFT` + `Left Arrow`: Turn to the left.\n * `SHIFT` + `Rigth Arrow`: Turn to the right.\n *\n * @example\n * ```\n * var keyboardComponent = viewer.getComponent(\"keyboard\");\n *\n * keyboardComponent.keySpatialNavigation.disable();\n * keyboardComponent.keySpatialNavigation.enable();\n *\n * var isEnabled = keyboardComponent.keySpatialNavigation.isEnabled;\n * ```\n */\n\n\nvar KeySpatialNavigationHandler =\n/** @class */\nfunction (_super) {\n  __extends(KeySpatialNavigationHandler, _super);\n  /** @ignore */\n\n\n  function KeySpatialNavigationHandler(component, container, navigator, spatial) {\n    var _this = _super.call(this, component, container, navigator) || this;\n\n    _this._spatial = spatial;\n    return _this;\n  }\n\n  KeySpatialNavigationHandler.prototype._enable = function () {\n    var _this = this;\n\n    var spatialEdges$ = this._navigator.stateService.currentNode$.pipe(operators_1.switchMap(function (node) {\n      return node.spatialEdges$;\n    }));\n\n    this._keyDownSubscription = this._container.keyboardService.keyDown$.pipe(operators_1.withLatestFrom(spatialEdges$, this._navigator.stateService.currentState$)).subscribe(function (_a) {\n      var event = _a[0],\n          edgeStatus = _a[1],\n          frame = _a[2];\n      var pano = frame.state.currentNode.pano;\n      var direction = null;\n\n      switch (event.keyCode) {\n        case 37:\n          // left\n          direction = event.shiftKey && !pano ? Edge_1.EdgeDirection.TurnLeft : Edge_1.EdgeDirection.StepLeft;\n          break;\n\n        case 38:\n          // up\n          direction = event.shiftKey && !pano ? Edge_1.EdgeDirection.Pano : Edge_1.EdgeDirection.StepForward;\n          break;\n\n        case 39:\n          // right\n          direction = event.shiftKey && !pano ? Edge_1.EdgeDirection.TurnRight : Edge_1.EdgeDirection.StepRight;\n          break;\n\n        case 40:\n          // down\n          direction = event.shiftKey && !pano ? Edge_1.EdgeDirection.TurnU : Edge_1.EdgeDirection.StepBackward;\n          break;\n\n        default:\n          return;\n      }\n\n      event.preventDefault();\n\n      if (event.altKey || !edgeStatus.cached || event.shiftKey && pano) {\n        return;\n      }\n\n      if (!pano) {\n        _this._moveDir(direction, edgeStatus);\n      } else {\n        var shifts = {};\n        shifts[Edge_1.EdgeDirection.StepBackward] = Math.PI;\n        shifts[Edge_1.EdgeDirection.StepForward] = 0;\n        shifts[Edge_1.EdgeDirection.StepLeft] = Math.PI / 2;\n        shifts[Edge_1.EdgeDirection.StepRight] = -Math.PI / 2;\n\n        var phi = _this._rotationFromCamera(frame.state.camera).phi;\n\n        var navigationAngle = _this._spatial.wrapAngle(phi + shifts[direction]);\n\n        var threshold = Math.PI / 4;\n        var edges = edgeStatus.edges.filter(function (e) {\n          return e.data.direction === Edge_1.EdgeDirection.Pano || e.data.direction === direction;\n        });\n        var smallestAngle = Number.MAX_VALUE;\n        var toKey = null;\n\n        for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {\n          var edge = edges_1[_i];\n          var angle = Math.abs(_this._spatial.wrapAngle(edge.data.worldMotionAzimuth - navigationAngle));\n\n          if (angle < Math.min(smallestAngle, threshold)) {\n            smallestAngle = angle;\n            toKey = edge.to;\n          }\n        }\n\n        if (toKey == null) {\n          return;\n        }\n\n        _this._moveToKey(toKey);\n      }\n    });\n  };\n\n  KeySpatialNavigationHandler.prototype._disable = function () {\n    this._keyDownSubscription.unsubscribe();\n  };\n\n  KeySpatialNavigationHandler.prototype._getConfiguration = function (enable) {\n    return {\n      keySpatialNavigation: enable\n    };\n  };\n\n  KeySpatialNavigationHandler.prototype._moveDir = function (direction, edgeStatus) {\n    for (var _i = 0, _a = edgeStatus.edges; _i < _a.length; _i++) {\n      var edge = _a[_i];\n\n      if (edge.data.direction === direction) {\n        this._moveToKey(edge.to);\n\n        return;\n      }\n    }\n  };\n\n  KeySpatialNavigationHandler.prototype._moveToKey = function (key) {\n    this._navigator.moveToKey$(key).subscribe(undefined, function (error) {\n      if (!(error instanceof Error_1.AbortMapillaryError)) {\n        console.error(error);\n      }\n    });\n  };\n\n  KeySpatialNavigationHandler.prototype._rotationFromCamera = function (camera) {\n    var direction = camera.lookat.clone().sub(camera.position);\n    var upProjection = direction.clone().dot(camera.up);\n    var planeProjection = direction.clone().sub(camera.up.clone().multiplyScalar(upProjection));\n    var phi = Math.atan2(planeProjection.y, planeProjection.x);\n\n    var theta = Math.PI / 2 - this._spatial.angleToPlane(direction.toArray(), [0, 0, 1]);\n\n    return {\n      phi: phi,\n      theta: theta\n    };\n  };\n\n  return KeySpatialNavigationHandler;\n}(Component_1.HandlerBase);\n\nexports.KeySpatialNavigationHandler = KeySpatialNavigationHandler;\nexports.default = KeySpatialNavigationHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/keyboard/KeySpatialNavigationHandler.ts?");

/***/ }),

/***/ "./src/component/keyboard/KeyZoomHandler.ts":
/*!**************************************************!*\
  !*** ./src/component/keyboard/KeyZoomHandler.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n/**\n * The `KeyZoomHandler` allows the user to zoom in and out using the\n * following key commands:\n *\n * `+`: Zoom in.\n * `-`: Zoom out.\n *\n * @example\n * ```\n * var keyboardComponent = viewer.getComponent(\"keyboard\");\n *\n * keyboardComponent.keyZoom.disable();\n * keyboardComponent.keyZoom.enable();\n *\n * var isEnabled = keyboardComponent.keyZoom.isEnabled;\n * ```\n */\n\n\nvar KeyZoomHandler =\n/** @class */\nfunction (_super) {\n  __extends(KeyZoomHandler, _super);\n  /** @ignore */\n\n\n  function KeyZoomHandler(component, container, navigator, viewportCoords) {\n    var _this = _super.call(this, component, container, navigator) || this;\n\n    _this._viewportCoords = viewportCoords;\n    return _this;\n  }\n\n  KeyZoomHandler.prototype._enable = function () {\n    var _this = this;\n\n    this._keyDownSubscription = this._container.keyboardService.keyDown$.pipe(operators_1.withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$)).subscribe(function (_a) {\n      var event = _a[0],\n          render = _a[1],\n          transform = _a[2];\n\n      if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n        return;\n      }\n\n      var delta = 0;\n\n      switch (event.key) {\n        case \"+\":\n          delta = 1;\n          break;\n\n        case \"-\":\n          delta = -1;\n          break;\n\n        default:\n          return;\n      }\n\n      event.preventDefault();\n\n      var unprojected = _this._viewportCoords.unprojectFromViewport(0, 0, render.perspective);\n\n      var reference = transform.projectBasic(unprojected.toArray());\n\n      _this._navigator.stateService.zoomIn(delta, reference);\n    });\n  };\n\n  KeyZoomHandler.prototype._disable = function () {\n    this._keyDownSubscription.unsubscribe();\n  };\n\n  KeyZoomHandler.prototype._getConfiguration = function (enable) {\n    return {\n      keyZoom: enable\n    };\n  };\n\n  return KeyZoomHandler;\n}(Component_1.HandlerBase);\n\nexports.KeyZoomHandler = KeyZoomHandler;\nexports.default = KeyZoomHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/keyboard/KeyZoomHandler.ts?");

/***/ }),

/***/ "./src/component/keyboard/KeyboardComponent.ts":
/*!*****************************************************!*\
  !*** ./src/component/keyboard/KeyboardComponent.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n/**\n * @class KeyboardComponent\n *\n * @classdesc Component for keyboard event handling.\n *\n * To retrive and use the keyboard component\n *\n * @example\n * ```\n * var viewer = new Mapillary.Viewer(\n *     \"<element-id>\",\n *     \"<client-id>\",\n *     \"<my key>\");\n *\n * var keyboardComponent = viewer.getComponent(\"keyboard\");\n * ```\n */\n\n\nvar KeyboardComponent =\n/** @class */\nfunction (_super) {\n  __extends(KeyboardComponent, _super);\n  /** @ignore */\n\n\n  function KeyboardComponent(name, container, navigator) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._keyPlayHandler = new Component_1.KeyPlayHandler(_this, container, navigator);\n    _this._keySequenceNavigationHandler = new Component_1.KeySequenceNavigationHandler(_this, container, navigator);\n    _this._keySpatialNavigationHandler = new Component_1.KeySpatialNavigationHandler(_this, container, navigator, new Geo_1.Spatial());\n    _this._keyZoomHandler = new Component_1.KeyZoomHandler(_this, container, navigator, new Geo_1.ViewportCoords());\n    return _this;\n  }\n\n  Object.defineProperty(KeyboardComponent.prototype, \"keyPlay\", {\n    /**\n     * Get key play.\n     *\n     * @returns {KeyPlayHandler} The key play handler.\n     */\n    get: function get() {\n      return this._keyPlayHandler;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(KeyboardComponent.prototype, \"keySequenceNavigation\", {\n    /**\n     * Get key sequence navigation.\n     *\n     * @returns {KeySequenceNavigationHandler} The key sequence navigation handler.\n     */\n    get: function get() {\n      return this._keySequenceNavigationHandler;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(KeyboardComponent.prototype, \"keySpatialNavigation\", {\n    /**\n     * Get spatial.\n     *\n     * @returns {KeySpatialNavigationHandler} The spatial handler.\n     */\n    get: function get() {\n      return this._keySpatialNavigationHandler;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(KeyboardComponent.prototype, \"keyZoom\", {\n    /**\n     * Get key zoom.\n     *\n     * @returns {KeyZoomHandler} The key zoom handler.\n     */\n    get: function get() {\n      return this._keyZoomHandler;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  KeyboardComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._configurationSubscription = this._configuration$.subscribe(function (configuration) {\n      if (configuration.keyPlay) {\n        _this._keyPlayHandler.enable();\n      } else {\n        _this._keyPlayHandler.disable();\n      }\n\n      if (configuration.keySequenceNavigation) {\n        _this._keySequenceNavigationHandler.enable();\n      } else {\n        _this._keySequenceNavigationHandler.disable();\n      }\n\n      if (configuration.keySpatialNavigation) {\n        _this._keySpatialNavigationHandler.enable();\n      } else {\n        _this._keySpatialNavigationHandler.disable();\n      }\n\n      if (configuration.keyZoom) {\n        _this._keyZoomHandler.enable();\n      } else {\n        _this._keyZoomHandler.disable();\n      }\n    });\n  };\n\n  KeyboardComponent.prototype._deactivate = function () {\n    this._configurationSubscription.unsubscribe();\n\n    this._keyPlayHandler.disable();\n\n    this._keySequenceNavigationHandler.disable();\n\n    this._keySpatialNavigationHandler.disable();\n\n    this._keyZoomHandler.disable();\n  };\n\n  KeyboardComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      keyPlay: true,\n      keySequenceNavigation: true,\n      keySpatialNavigation: true,\n      keyZoom: true\n    };\n  };\n\n  KeyboardComponent.componentName = \"keyboard\";\n  return KeyboardComponent;\n}(Component_1.Component);\n\nexports.KeyboardComponent = KeyboardComponent;\nComponent_1.ComponentService.register(KeyboardComponent);\nexports.default = KeyboardComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/keyboard/KeyboardComponent.ts?");

/***/ }),

/***/ "./src/component/marker/Marker.ts":
/*!****************************************!*\
  !*** ./src/component/marker/Marker.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar MarkerComponent_1 = __webpack_require__(/*! ./MarkerComponent */ \"./src/component/marker/MarkerComponent.ts\");\n\nexports.MarkerComponent = MarkerComponent_1.MarkerComponent;\n\nvar SimpleMarker_1 = __webpack_require__(/*! ./marker/SimpleMarker */ \"./src/component/marker/marker/SimpleMarker.ts\");\n\nexports.SimpleMarker = SimpleMarker_1.SimpleMarker;\n\nvar CircleMarker_1 = __webpack_require__(/*! ./marker/CircleMarker */ \"./src/component/marker/marker/CircleMarker.ts\");\n\nexports.CircleMarker = CircleMarker_1.CircleMarker;\n\n//# sourceURL=webpack://Mapillary/./src/component/marker/Marker.ts?");

/***/ }),

/***/ "./src/component/marker/MarkerComponent.ts":
/*!*************************************************!*\
  !*** ./src/component/marker/MarkerComponent.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar when = __webpack_require__(/*! when */ \"./node_modules/when/when.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Render_1 = __webpack_require__(/*! ../../Render */ \"./src/Render.ts\");\n\nvar Graph_1 = __webpack_require__(/*! ../../Graph */ \"./src/Graph.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n/**\n * @class MarkerComponent\n *\n * @classdesc Component for showing and editing 3D marker objects.\n *\n * The `add` method is used for adding new markers or replacing\n * markers already in the set.\n *\n * If a marker already in the set has the same\n * id as one of the markers added, the old marker will be removed and\n * the added marker will take its place.\n *\n * It is not possible to update markers in the set by updating any properties\n * directly on the marker object. Markers need to be replaced by\n * re-adding them for updates to geographic position or configuration\n * to be reflected.\n *\n * Markers added to the marker component can be either interactive\n * or non-interactive. Different marker types define their behavior.\n * Markers with interaction support can be configured with options\n * to respond to dragging inside the viewer and be detected when\n * retrieving markers from pixel points with the `getMarkerIdAt` method.\n *\n * To retrive and use the marker component\n *\n * @example\n * ```\n * var viewer = new Mapillary.Viewer(\n *     \"<element-id>\",\n *     \"<client-id>\",\n *     \"<my key>\",\n *     { component: { marker: true } });\n *\n * var markerComponent = viewer.getComponent(\"marker\");\n * ```\n */\n\n\nvar MarkerComponent =\n/** @class */\nfunction (_super) {\n  __extends(MarkerComponent, _super);\n  /** @ignore */\n\n\n  function MarkerComponent(name, container, navigator) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._relativeGroundAltitude = -2;\n    _this._geoCoords = new Geo_1.GeoCoords();\n    _this._graphCalculator = new Graph_1.GraphCalculator();\n    _this._markerScene = new Component_1.MarkerScene();\n    _this._markerSet = new Component_1.MarkerSet();\n    _this._viewportCoords = new Geo_1.ViewportCoords();\n    return _this;\n  }\n  /**\n   * Add markers to the marker set or replace markers in the marker set.\n   *\n   * @description If a marker already in the set has the same\n   * id as one of the markers added, the old marker will be removed\n   * the added marker will take its place.\n   *\n   * Any marker inside the visible bounding bbox\n   * will be initialized and placed in the viewer.\n   *\n   * @param {Array<Marker>} markers - Markers to add.\n   *\n   * @example ```markerComponent.add([marker1, marker2]);```\n   */\n\n\n  MarkerComponent.prototype.add = function (markers) {\n    this._markerSet.add(markers);\n  };\n  /**\n   * Returns the marker in the marker set with the specified id, or\n   * undefined if the id matches no marker.\n   *\n   * @param {string} markerId - Id of the marker.\n   *\n   * @example ```var marker = markerComponent.get(\"markerId\");```\n   *\n   */\n\n\n  MarkerComponent.prototype.get = function (markerId) {\n    return this._markerSet.get(markerId);\n  };\n  /**\n   * Returns an array of all markers.\n   *\n   * @example ```var markers = markerComponent.getAll();```\n   */\n\n\n  MarkerComponent.prototype.getAll = function () {\n    return this._markerSet.getAll();\n  };\n  /**\n   * Returns the id of the interactive marker closest to the current camera\n   * position at the specified point.\n   *\n   * @description Notice that the pixelPoint argument requires x, y\n   * coordinates from pixel space.\n   *\n   * With this function, you can use the coordinates provided by mouse\n   * events to get information out of the marker component.\n   *\n   * If no interactive geometry of an interactive marker exist at the pixel\n   * point, `null` will be returned.\n   *\n   * @param {Array<number>} pixelPoint - Pixel coordinates on the viewer element.\n   * @returns {string} Id of the interactive marker closest to the camera. If no\n   * interactive marker exist at the pixel point, `null` will be returned.\n   *\n   * @example\n   * ```\n   * markerComponent.getMarkerIdAt([100, 100])\n   *     .then((markerId) => { console.log(markerId); });\n   * ```\n   */\n\n\n  MarkerComponent.prototype.getMarkerIdAt = function (pixelPoint) {\n    var _this = this;\n\n    return when.promise(function (resolve, reject) {\n      _this._container.renderService.renderCamera$.pipe(operators_1.first(), operators_1.map(function (render) {\n        var viewport = _this._viewportCoords.canvasToViewport(pixelPoint[0], pixelPoint[1], _this._container.element);\n\n        var id = _this._markerScene.intersectObjects(viewport, render.perspective);\n\n        return id;\n      })).subscribe(function (id) {\n        resolve(id);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Check if a marker exist in the marker set.\n   *\n   * @param {string} markerId - Id of the marker.\n   *\n   * @example ```var markerExists = markerComponent.has(\"markerId\");```\n   */\n\n\n  MarkerComponent.prototype.has = function (markerId) {\n    return this._markerSet.has(markerId);\n  };\n  /**\n   * Remove markers with the specified ids from the marker set.\n   *\n   * @param {Array<string>} markerIds - Ids for markers to remove.\n   *\n   * @example ```markerComponent.remove([\"id-1\", \"id-2\"]);```\n   */\n\n\n  MarkerComponent.prototype.remove = function (markerIds) {\n    this._markerSet.remove(markerIds);\n  };\n  /**\n   * Remove all markers from the marker set.\n   *\n   * @example ```markerComponent.removeAll();```\n   */\n\n\n  MarkerComponent.prototype.removeAll = function () {\n    this._markerSet.removeAll();\n  };\n\n  MarkerComponent.prototype._activate = function () {\n    var _this = this;\n\n    var groundAltitude$ = this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      return frame.state.camera.position.z + _this._relativeGroundAltitude;\n    }), operators_1.distinctUntilChanged(function (a1, a2) {\n      return Math.abs(a1 - a2) < 0.01;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    var geoInitiated$ = rxjs_1.combineLatest(groundAltitude$, this._navigator.stateService.reference$).pipe(operators_1.first(), operators_1.map(function () {}), operators_1.publishReplay(1), operators_1.refCount());\n\n    var clampedConfiguration$ = this._configuration$.pipe(operators_1.map(function (configuration) {\n      return {\n        visibleBBoxSize: Math.max(1, Math.min(200, configuration.visibleBBoxSize))\n      };\n    }));\n\n    var currentlatLon$ = this._navigator.stateService.currentNode$.pipe(operators_1.map(function (node) {\n      return node.latLon;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    var visibleBBox$ = rxjs_1.combineLatest(clampedConfiguration$, currentlatLon$).pipe(operators_1.map(function (_a) {\n      var configuration = _a[0],\n          latLon = _a[1];\n      return _this._graphCalculator.boundingBoxCorners(latLon, configuration.visibleBBoxSize / 2);\n    }), operators_1.publishReplay(1), operators_1.refCount());\n    var visibleMarkers$ = rxjs_1.combineLatest(rxjs_1.concat(rxjs_1.of(this._markerSet), this._markerSet.changed$), visibleBBox$).pipe(operators_1.map(function (_a) {\n      var set = _a[0],\n          bbox = _a[1];\n      return set.search(bbox);\n    }));\n    this._setChangedSubscription = geoInitiated$.pipe(operators_1.switchMap(function () {\n      return visibleMarkers$.pipe(operators_1.withLatestFrom(_this._navigator.stateService.reference$, groundAltitude$));\n    })).subscribe(function (_a) {\n      var markers = _a[0],\n          reference = _a[1],\n          alt = _a[2];\n      var geoCoords = _this._geoCoords;\n      var markerScene = _this._markerScene;\n      var sceneMarkers = markerScene.markers;\n      var markersToRemove = Object.assign({}, sceneMarkers);\n\n      for (var _i = 0, markers_1 = markers; _i < markers_1.length; _i++) {\n        var marker = markers_1[_i];\n\n        if (marker.id in sceneMarkers) {\n          delete markersToRemove[marker.id];\n        } else {\n          var point3d = geoCoords.geodeticToEnu(marker.latLon.lat, marker.latLon.lon, reference.alt + alt, reference.lat, reference.lon, reference.alt);\n          markerScene.add(marker, point3d);\n        }\n      }\n\n      for (var id in markersToRemove) {\n        if (!markersToRemove.hasOwnProperty(id)) {\n          continue;\n        }\n\n        markerScene.remove(id);\n      }\n    });\n    this._markersUpdatedSubscription = geoInitiated$.pipe(operators_1.switchMap(function () {\n      return _this._markerSet.updated$.pipe(operators_1.withLatestFrom(visibleBBox$, _this._navigator.stateService.reference$, groundAltitude$));\n    })).subscribe(function (_a) {\n      var markers = _a[0],\n          _b = _a[1],\n          sw = _b[0],\n          ne = _b[1],\n          reference = _a[2],\n          alt = _a[3];\n      var geoCoords = _this._geoCoords;\n      var markerScene = _this._markerScene;\n\n      for (var _i = 0, markers_2 = markers; _i < markers_2.length; _i++) {\n        var marker = markers_2[_i];\n        var exists = markerScene.has(marker.id);\n        var visible = marker.latLon.lat > sw.lat && marker.latLon.lat < ne.lat && marker.latLon.lon > sw.lon && marker.latLon.lon < ne.lon;\n\n        if (visible) {\n          var point3d = geoCoords.geodeticToEnu(marker.latLon.lat, marker.latLon.lon, reference.alt + alt, reference.lat, reference.lon, reference.alt);\n          markerScene.add(marker, point3d);\n        } else if (!visible && exists) {\n          markerScene.remove(marker.id);\n        }\n      }\n    });\n    this._referenceSubscription = this._navigator.stateService.reference$.pipe(operators_1.skip(1), operators_1.withLatestFrom(groundAltitude$)).subscribe(function (_a) {\n      var reference = _a[0],\n          alt = _a[1];\n      var geoCoords = _this._geoCoords;\n      var markerScene = _this._markerScene;\n\n      for (var _i = 0, _b = markerScene.getAll(); _i < _b.length; _i++) {\n        var marker = _b[_i];\n        var point3d = geoCoords.geodeticToEnu(marker.latLon.lat, marker.latLon.lon, reference.alt + alt, reference.lat, reference.lon, reference.alt);\n        markerScene.update(marker.id, point3d);\n      }\n    });\n    this._adjustHeightSubscription = groundAltitude$.pipe(operators_1.skip(1), operators_1.withLatestFrom(this._navigator.stateService.reference$, currentlatLon$)).subscribe(function (_a) {\n      var alt = _a[0],\n          reference = _a[1],\n          latLon = _a[2];\n      var geoCoords = _this._geoCoords;\n      var markerScene = _this._markerScene;\n      var position = geoCoords.geodeticToEnu(latLon.lat, latLon.lon, reference.alt + alt, reference.lat, reference.lon, reference.alt);\n\n      for (var _i = 0, _b = markerScene.getAll(); _i < _b.length; _i++) {\n        var marker = _b[_i];\n        var point3d = geoCoords.geodeticToEnu(marker.latLon.lat, marker.latLon.lon, reference.alt + alt, reference.lat, reference.lon, reference.alt);\n        var distanceX = point3d[0] - position[0];\n        var distanceY = point3d[1] - position[1];\n        var groundDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n        if (groundDistance > 50) {\n          continue;\n        }\n\n        markerScene.lerpAltitude(marker.id, alt, Math.min(1, Math.max(0, 1.2 - 1.2 * groundDistance / 50)));\n      }\n    });\n    this._renderSubscription = this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      var scene = _this._markerScene;\n      return {\n        name: _this._name,\n        render: {\n          frameId: frame.id,\n          needsRender: scene.needsRender,\n          render: scene.render.bind(scene),\n          stage: Render_1.GLRenderStage.Foreground\n        }\n      };\n    })).subscribe(this._container.glRenderer.render$);\n    var hoveredMarkerId$ = rxjs_1.combineLatest(this._container.renderService.renderCamera$, this._container.mouseService.mouseMove$).pipe(operators_1.map(function (_a) {\n      var render = _a[0],\n          event = _a[1];\n      var element = _this._container.element;\n\n      var _b = _this._viewportCoords.canvasPosition(event, element),\n          canvasX = _b[0],\n          canvasY = _b[1];\n\n      var viewport = _this._viewportCoords.canvasToViewport(canvasX, canvasY, element);\n\n      var markerId = _this._markerScene.intersectObjects(viewport, render.perspective);\n\n      return markerId;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    var draggingStarted$ = this._container.mouseService.filtered$(this._name, this._container.mouseService.mouseDragStart$).pipe(operators_1.map(function (event) {\n      return true;\n    }));\n\n    var draggingStopped$ = this._container.mouseService.filtered$(this._name, this._container.mouseService.mouseDragEnd$).pipe(operators_1.map(function (event) {\n      return false;\n    }));\n\n    var filteredDragging$ = rxjs_1.merge(draggingStarted$, draggingStopped$).pipe(operators_1.startWith(false));\n    this._dragEventSubscription = rxjs_1.merge(draggingStarted$.pipe(operators_1.withLatestFrom(hoveredMarkerId$)), rxjs_1.combineLatest(draggingStopped$, rxjs_1.of(null))).pipe(operators_1.startWith([false, null]), operators_1.pairwise()).subscribe(function (_a) {\n      var previous = _a[0],\n          current = _a[1];\n      var dragging = current[0];\n      var eventType = dragging ? MarkerComponent.dragstart : MarkerComponent.dragend;\n      var id = dragging ? current[1] : previous[1];\n\n      var marker = _this._markerScene.get(id);\n\n      var markerEvent = {\n        marker: marker,\n        target: _this,\n        type: eventType\n      };\n\n      _this.fire(eventType, markerEvent);\n    });\n    var mouseDown$ = rxjs_1.merge(this._container.mouseService.mouseDown$.pipe(operators_1.map(function (event) {\n      return true;\n    })), this._container.mouseService.documentMouseUp$.pipe(operators_1.map(function (event) {\n      return false;\n    }))).pipe(operators_1.startWith(false));\n    this._mouseClaimSubscription = rxjs_1.combineLatest(this._container.mouseService.active$, hoveredMarkerId$.pipe(operators_1.distinctUntilChanged()), mouseDown$, filteredDragging$).pipe(operators_1.map(function (_a) {\n      var active = _a[0],\n          markerId = _a[1],\n          mouseDown = _a[2],\n          filteredDragging = _a[3];\n      return !active && markerId != null && mouseDown || filteredDragging;\n    }), operators_1.distinctUntilChanged()).subscribe(function (claim) {\n      if (claim) {\n        _this._container.mouseService.claimMouse(_this._name, 1);\n\n        _this._container.mouseService.claimWheel(_this._name, 1);\n      } else {\n        _this._container.mouseService.unclaimMouse(_this._name);\n\n        _this._container.mouseService.unclaimWheel(_this._name);\n      }\n    });\n\n    var offset$ = this._container.mouseService.filtered$(this._name, this._container.mouseService.mouseDragStart$).pipe(operators_1.withLatestFrom(hoveredMarkerId$, this._container.renderService.renderCamera$), operators_1.map(function (_a) {\n      var e = _a[0],\n          id = _a[1],\n          r = _a[2];\n\n      var marker = _this._markerScene.get(id);\n\n      var element = _this._container.element;\n\n      var _b = _this._viewportCoords.projectToCanvas(marker.geometry.position.toArray(), element, r.perspective),\n          groundCanvasX = _b[0],\n          groundCanvasY = _b[1];\n\n      var _c = _this._viewportCoords.canvasPosition(e, element),\n          canvasX = _c[0],\n          canvasY = _c[1];\n\n      var offset = [canvasX - groundCanvasX, canvasY - groundCanvasY];\n      return [marker, offset, r];\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._updateMarkerSubscription = this._container.mouseService.filtered$(this._name, this._container.mouseService.mouseDrag$).pipe(operators_1.withLatestFrom(offset$, this._navigator.stateService.reference$, clampedConfiguration$)).subscribe(function (_a) {\n      var event = _a[0],\n          _b = _a[1],\n          marker = _b[0],\n          offset = _b[1],\n          render = _b[2],\n          reference = _a[2],\n          configuration = _a[3];\n\n      if (!_this._markerScene.has(marker.id)) {\n        return;\n      }\n\n      var element = _this._container.element;\n\n      var _c = _this._viewportCoords.canvasPosition(event, element),\n          canvasX = _c[0],\n          canvasY = _c[1];\n\n      var groundX = canvasX - offset[0];\n      var groundY = canvasY - offset[1];\n\n      var _d = _this._viewportCoords.canvasToViewport(groundX, groundY, element),\n          viewportX = _d[0],\n          viewportY = _d[1];\n\n      var direction = new THREE.Vector3(viewportX, viewportY, 1).unproject(render.perspective).sub(render.perspective.position).normalize();\n      var distance = Math.min(_this._relativeGroundAltitude / direction.z, configuration.visibleBBoxSize / 2 - 0.1);\n\n      if (distance < 0) {\n        return;\n      }\n\n      var intersection = direction.clone().multiplyScalar(distance).add(render.perspective.position);\n      intersection.z = render.perspective.position.z + _this._relativeGroundAltitude;\n\n      var _e = _this._geoCoords.enuToGeodetic(intersection.x, intersection.y, intersection.z, reference.lat, reference.lon, reference.alt),\n          lat = _e[0],\n          lon = _e[1];\n\n      _this._markerScene.update(marker.id, intersection.toArray(), {\n        lat: lat,\n        lon: lon\n      });\n\n      _this._markerSet.update(marker);\n\n      var markerEvent = {\n        marker: marker,\n        target: _this,\n        type: MarkerComponent.changed\n      };\n\n      _this.fire(MarkerComponent.changed, markerEvent);\n    });\n  };\n\n  MarkerComponent.prototype._deactivate = function () {\n    this._adjustHeightSubscription.unsubscribe();\n\n    this._dragEventSubscription.unsubscribe();\n\n    this._markersUpdatedSubscription.unsubscribe();\n\n    this._mouseClaimSubscription.unsubscribe();\n\n    this._referenceSubscription.unsubscribe();\n\n    this._renderSubscription.unsubscribe();\n\n    this._setChangedSubscription.unsubscribe();\n\n    this._updateMarkerSubscription.unsubscribe();\n\n    this._markerScene.clear();\n  };\n\n  MarkerComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      visibleBBoxSize: 100\n    };\n  };\n\n  MarkerComponent.componentName = \"marker\";\n  /**\n   * Fired when the position of a marker is changed.\n   * @event\n   * @type {IMarkerEvent} markerEvent - Marker event data.\n   * @example\n   * ```\n   * markerComponent.on(\"changed\", function(e) {\n   *     console.log(e.marker.id, e.marker.latLon);\n   * });\n   * ```\n   */\n\n  MarkerComponent.changed = \"changed\";\n  /**\n   * Fired when a marker drag interaction starts.\n   * @event\n   * @type {IMarkerEvent} markerEvent - Marker event data.\n   * @example\n   * ```\n   * markerComponent.on(\"dragstart\", function(e) {\n   *     console.log(e.marker.id, e.marker.latLon);\n   * });\n   * ```\n   */\n\n  MarkerComponent.dragstart = \"dragstart\";\n  /**\n   * Fired when a marker drag interaction ends.\n   * @event\n   * @type {IMarkerEvent} markerEvent - Marker event data.\n   * @example\n   * ```\n   * markerComponent.on(\"dragend\", function(e) {\n   *     console.log(e.marker.id, e.marker.latLon);\n   * });\n   * ```\n   */\n\n  MarkerComponent.dragend = \"dragend\";\n  return MarkerComponent;\n}(Component_1.Component);\n\nexports.MarkerComponent = MarkerComponent;\nComponent_1.ComponentService.register(MarkerComponent);\nexports.default = MarkerComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/marker/MarkerComponent.ts?");

/***/ }),

/***/ "./src/component/marker/MarkerScene.ts":
/*!*********************************************!*\
  !*** ./src/component/marker/MarkerScene.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar MarkerScene =\n/** @class */\nfunction () {\n  function MarkerScene(scene, raycaster) {\n    this._needsRender = false;\n    this._interactiveObjects = [];\n    this._markers = {};\n    this._objectMarkers = {};\n    this._raycaster = !!raycaster ? raycaster : new THREE.Raycaster();\n    this._scene = !!scene ? scene : new THREE.Scene();\n  }\n\n  Object.defineProperty(MarkerScene.prototype, \"markers\", {\n    get: function get() {\n      return this._markers;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MarkerScene.prototype, \"needsRender\", {\n    get: function get() {\n      return this._needsRender;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MarkerScene.prototype.add = function (marker, position) {\n    if (marker.id in this._markers) {\n      this._dispose(marker.id);\n    }\n\n    marker.createGeometry(position);\n\n    this._scene.add(marker.geometry);\n\n    this._markers[marker.id] = marker;\n\n    for (var _i = 0, _a = marker.getInteractiveObjects(); _i < _a.length; _i++) {\n      var interactiveObject = _a[_i];\n\n      this._interactiveObjects.push(interactiveObject);\n\n      this._objectMarkers[interactiveObject.uuid] = marker.id;\n    }\n\n    this._needsRender = true;\n  };\n\n  MarkerScene.prototype.clear = function () {\n    for (var id in this._markers) {\n      if (!this._markers.hasOwnProperty) {\n        continue;\n      }\n\n      this._dispose(id);\n    }\n\n    this._needsRender = true;\n  };\n\n  MarkerScene.prototype.get = function (id) {\n    return this._markers[id];\n  };\n\n  MarkerScene.prototype.getAll = function () {\n    var _this = this;\n\n    return Object.keys(this._markers).map(function (id) {\n      return _this._markers[id];\n    });\n  };\n\n  MarkerScene.prototype.has = function (id) {\n    return id in this._markers;\n  };\n\n  MarkerScene.prototype.intersectObjects = function (_a, camera) {\n    var viewportX = _a[0],\n        viewportY = _a[1];\n\n    this._raycaster.setFromCamera(new THREE.Vector2(viewportX, viewportY), camera);\n\n    var intersects = this._raycaster.intersectObjects(this._interactiveObjects);\n\n    for (var _i = 0, intersects_1 = intersects; _i < intersects_1.length; _i++) {\n      var intersect = intersects_1[_i];\n\n      if (intersect.object.uuid in this._objectMarkers) {\n        return this._objectMarkers[intersect.object.uuid];\n      }\n    }\n\n    return null;\n  };\n\n  MarkerScene.prototype.lerpAltitude = function (id, alt, alpha) {\n    if (!(id in this._markers)) {\n      return;\n    }\n\n    this._markers[id].lerpAltitude(alt, alpha);\n\n    this._needsRender = true;\n  };\n\n  MarkerScene.prototype.remove = function (id) {\n    if (!(id in this._markers)) {\n      return;\n    }\n\n    this._dispose(id);\n\n    this._needsRender = true;\n  };\n\n  MarkerScene.prototype.render = function (perspectiveCamera, renderer) {\n    renderer.render(this._scene, perspectiveCamera);\n    this._needsRender = false;\n  };\n\n  MarkerScene.prototype.update = function (id, position, latLon) {\n    if (!(id in this._markers)) {\n      return;\n    }\n\n    var marker = this._markers[id];\n    marker.updatePosition(position, latLon);\n    this._needsRender = true;\n  };\n\n  MarkerScene.prototype._dispose = function (id) {\n    var marker = this._markers[id];\n\n    this._scene.remove(marker.geometry);\n\n    for (var _i = 0, _a = marker.getInteractiveObjects(); _i < _a.length; _i++) {\n      var interactiveObject = _a[_i];\n\n      var index = this._interactiveObjects.indexOf(interactiveObject);\n\n      if (index !== -1) {\n        this._interactiveObjects.splice(index, 1);\n      } else {\n        console.warn(\"Object does not exist (\" + interactiveObject.id + \") for \" + id);\n      }\n\n      delete this._objectMarkers[interactiveObject.uuid];\n    }\n\n    marker.disposeGeometry();\n    delete this._markers[id];\n  };\n\n  return MarkerScene;\n}();\n\nexports.MarkerScene = MarkerScene;\nexports.default = MarkerScene;\n\n//# sourceURL=webpack://Mapillary/./src/component/marker/MarkerScene.ts?");

/***/ }),

/***/ "./src/component/marker/MarkerSet.ts":
/*!*******************************************!*\
  !*** ./src/component/marker/MarkerSet.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rbush = __webpack_require__(/*! rbush */ \"./node_modules/rbush/index.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar MarkerSet =\n/** @class */\nfunction () {\n  function MarkerSet() {\n    this._hash = {};\n    this._index = rbush(16, [\".lon\", \".lat\", \".lon\", \".lat\"]);\n    this._indexChanged$ = new rxjs_1.Subject();\n    this._updated$ = new rxjs_1.Subject();\n  }\n\n  Object.defineProperty(MarkerSet.prototype, \"changed$\", {\n    get: function get() {\n      return this._indexChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MarkerSet.prototype, \"updated$\", {\n    get: function get() {\n      return this._updated$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MarkerSet.prototype.add = function (markers) {\n    var updated = [];\n    var hash = this._hash;\n    var index = this._index;\n\n    for (var _i = 0, markers_1 = markers; _i < markers_1.length; _i++) {\n      var marker = markers_1[_i];\n      var id = marker.id;\n\n      if (id in hash) {\n        index.remove(hash[id]);\n        updated.push(marker);\n      }\n\n      var item = {\n        lat: marker.latLon.lat,\n        lon: marker.latLon.lon,\n        marker: marker\n      };\n      hash[id] = item;\n      index.insert(item);\n    }\n\n    if (updated.length > 0) {\n      this._updated$.next(updated);\n    }\n\n    if (markers.length > updated.length) {\n      this._indexChanged$.next(this);\n    }\n  };\n\n  MarkerSet.prototype.has = function (id) {\n    return id in this._hash;\n  };\n\n  MarkerSet.prototype.get = function (id) {\n    return this.has(id) ? this._hash[id].marker : undefined;\n  };\n\n  MarkerSet.prototype.getAll = function () {\n    return this._index.all().map(function (indexItem) {\n      return indexItem.marker;\n    });\n  };\n\n  MarkerSet.prototype.remove = function (ids) {\n    var hash = this._hash;\n    var index = this._index;\n    var changed = false;\n\n    for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {\n      var id = ids_1[_i];\n\n      if (!(id in hash)) {\n        continue;\n      }\n\n      var item = hash[id];\n      index.remove(item);\n      delete hash[id];\n      changed = true;\n    }\n\n    if (changed) {\n      this._indexChanged$.next(this);\n    }\n  };\n\n  MarkerSet.prototype.removeAll = function () {\n    this._hash = {};\n\n    this._index.clear();\n\n    this._indexChanged$.next(this);\n  };\n\n  MarkerSet.prototype.search = function (_a) {\n    var sw = _a[0],\n        ne = _a[1];\n    return this._index.search({\n      maxX: ne.lon,\n      maxY: ne.lat,\n      minX: sw.lon,\n      minY: sw.lat\n    }).map(function (indexItem) {\n      return indexItem.marker;\n    });\n  };\n\n  MarkerSet.prototype.update = function (marker) {\n    var hash = this._hash;\n    var index = this._index;\n    var id = marker.id;\n\n    if (!(id in hash)) {\n      return;\n    }\n\n    index.remove(hash[id]);\n    var item = {\n      lat: marker.latLon.lat,\n      lon: marker.latLon.lon,\n      marker: marker\n    };\n    hash[id] = item;\n    index.insert(item);\n  };\n\n  return MarkerSet;\n}();\n\nexports.MarkerSet = MarkerSet;\nexports.default = MarkerSet;\n\n//# sourceURL=webpack://Mapillary/./src/component/marker/MarkerSet.ts?");

/***/ }),

/***/ "./src/component/marker/marker/CircleMarker.ts":
/*!*****************************************************!*\
  !*** ./src/component/marker/marker/CircleMarker.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n/**\n * @class CircleMarker\n *\n * @classdesc Non-interactive marker with a flat circle shape. The circle\n * marker can not be configured to be interactive.\n *\n * Circle marker properties can not be updated after creation.\n *\n * To create and add one `CircleMarker` with default configuration\n * and one with configuration use\n *\n * @example\n * ```\n * var defaultMarker = new Mapillary.MarkerComponent.CircleMarker(\n *     \"id-1\",\n *     { lat: 0, lon: 0, });\n *\n * var configuredMarker = new Mapillary.MarkerComponent.CircleMarker(\n *     \"id-2\",\n *     { lat: 0, lon: 0, },\n *     {\n *         color: \"#0Ff\",\n *         opacity: 0.3,\n *         radius: 0.7,\n *     });\n *\n * markerComponent.add([defaultMarker, configuredMarker]);\n * ```\n */\n\n\nvar CircleMarker =\n/** @class */\nfunction (_super) {\n  __extends(CircleMarker, _super);\n\n  function CircleMarker(id, latLon, options) {\n    var _this = _super.call(this, id, latLon) || this;\n\n    options = !!options ? options : {};\n    _this._color = options.color != null ? options.color : 0xffffff;\n    _this._opacity = options.opacity != null ? options.opacity : 0.4;\n    _this._radius = options.radius != null ? options.radius : 1;\n    return _this;\n  }\n\n  CircleMarker.prototype._createGeometry = function (position) {\n    var circle = new THREE.Mesh(new THREE.CircleGeometry(this._radius, 16), new THREE.MeshBasicMaterial({\n      color: this._color,\n      opacity: this._opacity,\n      transparent: true\n    }));\n    circle.up.fromArray([0, 0, 1]);\n    circle.renderOrder = -1;\n    var group = new THREE.Object3D();\n    group.add(circle);\n    group.position.fromArray(position);\n    this._geometry = group;\n  };\n\n  CircleMarker.prototype._disposeGeometry = function () {\n    for (var _i = 0, _a = this._geometry.children; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n      mesh.geometry.dispose();\n      mesh.material.dispose();\n    }\n  };\n\n  CircleMarker.prototype._getInteractiveObjects = function () {\n    return [];\n  };\n\n  return CircleMarker;\n}(Component_1.Marker);\n\nexports.CircleMarker = CircleMarker;\nexports.default = CircleMarker;\n\n//# sourceURL=webpack://Mapillary/./src/component/marker/marker/CircleMarker.ts?");

/***/ }),

/***/ "./src/component/marker/marker/Marker.ts":
/*!***********************************************!*\
  !*** ./src/component/marker/marker/Marker.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @class Marker\n *\n * @classdesc Represents an abstract marker class that should be extended\n * by marker implementations used in the marker component.\n */\n\nvar Marker =\n/** @class */\nfunction () {\n  function Marker(id, latLon) {\n    this._id = id;\n    this._latLon = latLon;\n  }\n\n  Object.defineProperty(Marker.prototype, \"id\", {\n    /**\n     * Get id.\n     * @returns {string} The id of the marker.\n     */\n    get: function get() {\n      return this._id;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Marker.prototype, \"geometry\", {\n    /**\n     * Get geometry.\n     *\n     * @ignore\n     */\n    get: function get() {\n      return this._geometry;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Marker.prototype, \"latLon\", {\n    /**\n     * Get lat lon.\n     * @returns {ILatLon} The geographic coordinates of the marker.\n     */\n    get: function get() {\n      return this._latLon;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @ignore */\n\n  Marker.prototype.createGeometry = function (position) {\n    if (!!this._geometry) {\n      return;\n    }\n\n    this._createGeometry(position); // update matrix world if raycasting occurs before first render\n\n\n    this._geometry.updateMatrixWorld(true);\n  };\n  /** @ignore */\n\n\n  Marker.prototype.disposeGeometry = function () {\n    if (!this._geometry) {\n      return;\n    }\n\n    this._disposeGeometry();\n\n    this._geometry = undefined;\n  };\n  /** @ignore */\n\n\n  Marker.prototype.getInteractiveObjects = function () {\n    if (!this._geometry) {\n      return [];\n    }\n\n    return this._getInteractiveObjects();\n  };\n  /** @ignore */\n\n\n  Marker.prototype.lerpAltitude = function (alt, alpha) {\n    if (!this._geometry) {\n      return;\n    }\n\n    this._geometry.position.z = (1 - alpha) * this._geometry.position.z + alpha * alt;\n  };\n  /** @ignore */\n\n\n  Marker.prototype.updatePosition = function (position, latLon) {\n    if (!!latLon) {\n      this._latLon.lat = latLon.lat;\n      this._latLon.lon = latLon.lon;\n    }\n\n    if (!this._geometry) {\n      return;\n    }\n\n    this._geometry.position.fromArray(position);\n\n    this._geometry.updateMatrixWorld(true);\n  };\n\n  return Marker;\n}();\n\nexports.Marker = Marker;\nexports.default = Marker;\n\n//# sourceURL=webpack://Mapillary/./src/component/marker/marker/Marker.ts?");

/***/ }),

/***/ "./src/component/marker/marker/SimpleMarker.ts":
/*!*****************************************************!*\
  !*** ./src/component/marker/marker/SimpleMarker.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n/**\n * @class SimpleMarker\n *\n * @classdesc Interactive marker with ice cream shape. The sphere\n * inside the ice cream can be configured to be interactive.\n *\n * Simple marker properties can not be updated after creation.\n *\n * To create and add one `SimpleMarker` with default configuration\n * (non-interactive) and one interactive with configuration use\n *\n * @example\n * ```\n * var defaultMarker = new Mapillary.MarkerComponent.SimpleMarker(\n *     \"id-1\",\n *     { lat: 0, lon: 0, });\n *\n * var interactiveMarker = new Mapillary.MarkerComponent.SimpleMarker(\n *     \"id-2\",\n *     { lat: 0, lon: 0, },\n *     {\n *         ballColor: \"#00f\",\n *         ballOpacity: 0.5,\n *         color: \"#00f\",\n *         interactive: true,\n *         opacity: 0.3,\n *         radius: 0.7,\n *     });\n *\n * markerComponent.add([defaultMarker, interactiveMarker]);\n * ```\n */\n\n\nvar SimpleMarker =\n/** @class */\nfunction (_super) {\n  __extends(SimpleMarker, _super);\n\n  function SimpleMarker(id, latLon, options) {\n    var _this = _super.call(this, id, latLon) || this;\n\n    options = !!options ? options : {};\n    _this._ballColor = options.ballColor != null ? options.ballColor : 0xff0000;\n    _this._ballOpacity = options.ballOpacity != null ? options.ballOpacity : 0.8;\n    _this._circleToRayAngle = 2;\n    _this._color = options.color != null ? options.color : 0xff0000;\n    _this._interactive = !!options.interactive;\n    _this._opacity = options.opacity != null ? options.opacity : 0.4;\n    _this._radius = options.radius != null ? options.radius : 1;\n    return _this;\n  }\n\n  SimpleMarker.prototype._createGeometry = function (position) {\n    var radius = this._radius;\n    var cone = new THREE.Mesh(this._markerGeometry(radius, 8, 8), new THREE.MeshBasicMaterial({\n      color: this._color,\n      opacity: this._opacity,\n      transparent: true\n    }));\n    cone.renderOrder = 1;\n    var ball = new THREE.Mesh(new THREE.SphereGeometry(radius / 2, 8, 8), new THREE.MeshBasicMaterial({\n      color: this._ballColor,\n      opacity: this._ballOpacity,\n      transparent: true\n    }));\n    ball.position.z = this._markerHeight(radius);\n    var group = new THREE.Object3D();\n    group.add(ball);\n    group.add(cone);\n    group.position.fromArray(position);\n    this._geometry = group;\n  };\n\n  SimpleMarker.prototype._disposeGeometry = function () {\n    for (var _i = 0, _a = this._geometry.children; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n      mesh.geometry.dispose();\n      mesh.material.dispose();\n    }\n  };\n\n  SimpleMarker.prototype._getInteractiveObjects = function () {\n    return this._interactive ? [this._geometry.children[0]] : [];\n  };\n\n  SimpleMarker.prototype._markerHeight = function (radius) {\n    var t = Math.tan(Math.PI - this._circleToRayAngle);\n    return radius * Math.sqrt(1 + t * t);\n  };\n\n  SimpleMarker.prototype._markerGeometry = function (radius, widthSegments, heightSegments) {\n    var geometry = new THREE.Geometry();\n    widthSegments = Math.max(3, Math.floor(widthSegments) || 8);\n    heightSegments = Math.max(2, Math.floor(heightSegments) || 6);\n\n    var height = this._markerHeight(radius);\n\n    var vertices = [];\n\n    for (var y = 0; y <= heightSegments; ++y) {\n      var verticesRow = [];\n\n      for (var x = 0; x <= widthSegments; ++x) {\n        var u = x / widthSegments * Math.PI * 2;\n        var v = y / heightSegments * Math.PI;\n        var r = void 0;\n\n        if (v < this._circleToRayAngle) {\n          r = radius;\n        } else {\n          var t = Math.tan(v - this._circleToRayAngle);\n          r = radius * Math.sqrt(1 + t * t);\n        }\n\n        var vertex = new THREE.Vector3();\n        vertex.x = r * Math.cos(u) * Math.sin(v);\n        vertex.y = r * Math.sin(u) * Math.sin(v);\n        vertex.z = r * Math.cos(v) + height;\n        geometry.vertices.push(vertex);\n        verticesRow.push(geometry.vertices.length - 1);\n      }\n\n      vertices.push(verticesRow);\n    }\n\n    for (var y = 0; y < heightSegments; ++y) {\n      for (var x = 0; x < widthSegments; ++x) {\n        var v1 = vertices[y][x + 1];\n        var v2 = vertices[y][x];\n        var v3 = vertices[y + 1][x];\n        var v4 = vertices[y + 1][x + 1];\n        var n1 = geometry.vertices[v1].clone().normalize();\n        var n2 = geometry.vertices[v2].clone().normalize();\n        var n3 = geometry.vertices[v3].clone().normalize();\n        var n4 = geometry.vertices[v4].clone().normalize();\n        geometry.faces.push(new THREE.Face3(v1, v2, v4, [n1, n2, n4]));\n        geometry.faces.push(new THREE.Face3(v2, v3, v4, [n2.clone(), n3, n4.clone()]));\n      }\n    }\n\n    geometry.computeFaceNormals();\n    geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius + height);\n    return geometry;\n  };\n\n  return SimpleMarker;\n}(Component_1.Marker);\n\nexports.SimpleMarker = SimpleMarker;\nexports.default = SimpleMarker;\n\n//# sourceURL=webpack://Mapillary/./src/component/marker/marker/SimpleMarker.ts?");

/***/ }),

/***/ "./src/component/mouse/BounceHandler.ts":
/*!**********************************************!*\
  !*** ./src/component/mouse/BounceHandler.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n/**\n * The `BounceHandler` ensures that the viewer bounces back to the image\n * when drag panning outside of the image edge.\n */\n\n\nvar BounceHandler =\n/** @class */\nfunction (_super) {\n  __extends(BounceHandler, _super);\n\n  function BounceHandler(component, container, navigator, viewportCoords, spatial) {\n    var _this = _super.call(this, component, container, navigator) || this;\n\n    _this._spatial = spatial;\n    _this._viewportCoords = viewportCoords;\n    return _this;\n  }\n\n  BounceHandler.prototype._enable = function () {\n    var _this = this;\n\n    var inTransition$ = this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      return frame.state.alpha < 1;\n    }), operators_1.distinctUntilChanged());\n\n    this._bounceSubscription = rxjs_1.combineLatest(inTransition$, this._navigator.stateService.inTranslation$, this._container.mouseService.active$, this._container.touchService.active$).pipe(operators_1.map(function (noForce) {\n      return noForce[0] || noForce[1] || noForce[2] || noForce[3];\n    }), operators_1.distinctUntilChanged(), operators_1.switchMap(function (noForce) {\n      return noForce ? rxjs_1.empty() : rxjs_1.combineLatest(_this._container.renderService.renderCamera$, _this._navigator.stateService.currentTransform$.pipe(operators_1.first()));\n    }), operators_1.withLatestFrom(this._navigator.panService.panNodes$)).subscribe(function (_a) {\n      var _b = _a[0],\n          render = _b[0],\n          transform = _b[1],\n          nts = _a[1];\n\n      if (!transform.hasValidScale && render.camera.focal < 0.1) {\n        return;\n      }\n\n      if (render.perspective.aspect === 0 || render.perspective.aspect === Number.POSITIVE_INFINITY) {\n        return;\n      }\n\n      var distances = Component_1.ImageBoundary.viewportDistances(transform, render.perspective, _this._viewportCoords);\n\n      var basic = _this._viewportCoords.viewportToBasic(0, 0, transform, render.perspective);\n\n      if ((basic[0] < 0 || basic[0] > 1) && nts.length > 0) {\n        distances[0] = distances[2] = 0;\n      }\n\n      for (var _i = 0, nts_1 = nts; _i < nts_1.length; _i++) {\n        var _c = nts_1[_i],\n            t = _c[1];\n        var d = Component_1.ImageBoundary.viewportDistances(t, render.perspective, _this._viewportCoords);\n\n        for (var i = 1; i < distances.length; i += 2) {\n          if (d[i] < distances[i]) {\n            distances[i] = d[i];\n          }\n        }\n      }\n\n      if (Math.max.apply(Math, distances) < 0.01) {\n        return;\n      }\n\n      var horizontalDistance = distances[1] - distances[3];\n      var verticalDistance = distances[0] - distances[2];\n\n      var currentDirection = _this._viewportCoords.unprojectFromViewport(0, 0, render.perspective).sub(render.perspective.position);\n\n      var directionPhi = _this._viewportCoords.unprojectFromViewport(horizontalDistance, 0, render.perspective).sub(render.perspective.position);\n\n      var directionTheta = _this._viewportCoords.unprojectFromViewport(0, verticalDistance, render.perspective).sub(render.perspective.position);\n\n      var phi = (horizontalDistance > 0 ? 1 : -1) * directionPhi.angleTo(currentDirection);\n      var theta = (verticalDistance > 0 ? 1 : -1) * directionTheta.angleTo(currentDirection);\n      var threshold = Math.PI / 60;\n      var coeff = 1e-1;\n      phi = _this._spatial.clamp(coeff * phi, -threshold, threshold);\n      theta = _this._spatial.clamp(coeff * theta, -threshold, threshold);\n\n      _this._navigator.stateService.rotateUnbounded({\n        phi: phi,\n        theta: theta\n      });\n    });\n  };\n\n  BounceHandler.prototype._disable = function () {\n    this._bounceSubscription.unsubscribe();\n  };\n\n  BounceHandler.prototype._getConfiguration = function () {\n    return {};\n  };\n\n  return BounceHandler;\n}(Component_1.HandlerBase);\n\nexports.BounceHandler = BounceHandler;\nexports.default = BounceHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/mouse/BounceHandler.ts?");

/***/ }),

/***/ "./src/component/mouse/DoubleClickZoomHandler.ts":
/*!*******************************************************!*\
  !*** ./src/component/mouse/DoubleClickZoomHandler.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n/**\n * The `DoubleClickZoomHandler` allows the user to zoom the viewer image at a point by double clicking.\n *\n * @example\n * ```\n * var mouseComponent = viewer.getComponent(\"mouse\");\n *\n * mouseComponent.doubleClickZoom.disable();\n * mouseComponent.doubleClickZoom.enable();\n *\n * var isEnabled = mouseComponent.doubleClickZoom.isEnabled;\n * ```\n */\n\n\nvar DoubleClickZoomHandler =\n/** @class */\nfunction (_super) {\n  __extends(DoubleClickZoomHandler, _super);\n  /** @ignore */\n\n\n  function DoubleClickZoomHandler(component, container, navigator, viewportCoords) {\n    var _this = _super.call(this, component, container, navigator) || this;\n\n    _this._viewportCoords = viewportCoords;\n    return _this;\n  }\n\n  DoubleClickZoomHandler.prototype._enable = function () {\n    var _this = this;\n\n    this._zoomSubscription = rxjs_1.merge(this._container.mouseService.filtered$(this._component.name, this._container.mouseService.dblClick$), this._container.touchService.doubleTap$.pipe(operators_1.map(function (e) {\n      var touch = e.touches[0];\n      return {\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n        shiftKey: e.shiftKey\n      };\n    }))).pipe(operators_1.withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$)).subscribe(function (_a) {\n      var event = _a[0],\n          render = _a[1],\n          transform = _a[2];\n      var element = _this._container.element;\n\n      var _b = _this._viewportCoords.canvasPosition(event, element),\n          canvasX = _b[0],\n          canvasY = _b[1];\n\n      var unprojected = _this._viewportCoords.unprojectFromCanvas(canvasX, canvasY, element, render.perspective);\n\n      var reference = transform.projectBasic(unprojected.toArray());\n      var delta = !!event.shiftKey ? -1 : 1;\n\n      _this._navigator.stateService.zoomIn(delta, reference);\n    });\n  };\n\n  DoubleClickZoomHandler.prototype._disable = function () {\n    this._zoomSubscription.unsubscribe();\n  };\n\n  DoubleClickZoomHandler.prototype._getConfiguration = function (enable) {\n    return {\n      doubleClickZoom: enable\n    };\n  };\n\n  return DoubleClickZoomHandler;\n}(Component_1.HandlerBase);\n\nexports.DoubleClickZoomHandler = DoubleClickZoomHandler;\nexports.default = DoubleClickZoomHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/mouse/DoubleClickZoomHandler.ts?");

/***/ }),

/***/ "./src/component/mouse/DragPanHandler.ts":
/*!***********************************************!*\
  !*** ./src/component/mouse/DragPanHandler.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n/**\n * The `DragPanHandler` allows the user to pan the viewer image by clicking and dragging the cursor.\n *\n * @example\n * ```\n * var mouseComponent = viewer.getComponent(\"mouse\");\n *\n * mouseComponent.dragPan.disable();\n * mouseComponent.dragPan.enable();\n *\n * var isEnabled = mouseComponent.dragPan.isEnabled;\n * ```\n */\n\n\nvar DragPanHandler =\n/** @class */\nfunction (_super) {\n  __extends(DragPanHandler, _super);\n  /** @ignore */\n\n\n  function DragPanHandler(component, container, navigator, viewportCoords, spatial) {\n    var _this = _super.call(this, component, container, navigator) || this;\n\n    _this._spatial = spatial;\n    _this._viewportCoords = viewportCoords;\n    return _this;\n  }\n\n  DragPanHandler.prototype._enable = function () {\n    var _this = this;\n\n    var draggingStarted$ = this._container.mouseService.filtered$(this._component.name, this._container.mouseService.mouseDragStart$).pipe(operators_1.map(function () {\n      return true;\n    }), operators_1.share());\n\n    var draggingStopped$ = this._container.mouseService.filtered$(this._component.name, this._container.mouseService.mouseDragEnd$).pipe(operators_1.map(function () {\n      return false;\n    }), operators_1.share());\n\n    this._activeMouseSubscription = rxjs_1.merge(draggingStarted$, draggingStopped$).subscribe(this._container.mouseService.activate$);\n    var documentMouseMove$ = rxjs_1.merge(draggingStarted$, draggingStopped$).pipe(operators_1.switchMap(function (dragging) {\n      return dragging ? _this._container.mouseService.documentMouseMove$ : rxjs_1.empty();\n    }));\n    this._preventDefaultSubscription = rxjs_1.merge(documentMouseMove$, this._container.touchService.touchMove$).subscribe(function (event) {\n      event.preventDefault(); // prevent selection of content outside the viewer\n    });\n\n    var touchMovingStarted$ = this._container.touchService.singleTouchDragStart$.pipe(operators_1.map(function () {\n      return true;\n    }));\n\n    var touchMovingStopped$ = this._container.touchService.singleTouchDragEnd$.pipe(operators_1.map(function () {\n      return false;\n    }));\n\n    this._activeTouchSubscription = rxjs_1.merge(touchMovingStarted$, touchMovingStopped$).subscribe(this._container.touchService.activate$);\n\n    var rotation$ = this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      return frame.state.currentNode.fullPano || frame.state.nodesAhead < 1;\n    }), operators_1.distinctUntilChanged(), operators_1.switchMap(function (enable) {\n      if (!enable) {\n        return rxjs_1.empty();\n      }\n\n      var mouseDrag$ = Component_1.MouseOperator.filteredPairwiseMouseDrag$(_this._component.name, _this._container.mouseService);\n      var singleTouchDrag$ = rxjs_1.merge(_this._container.touchService.singleTouchDragStart$, _this._container.touchService.singleTouchDrag$, _this._container.touchService.singleTouchDragEnd$.pipe(operators_1.map(function () {\n        return null;\n      }))).pipe(operators_1.map(function (event) {\n        return event != null && event.touches.length > 0 ? event.touches[0] : null;\n      }), operators_1.pairwise(), operators_1.filter(function (pair) {\n        return pair[0] != null && pair[1] != null;\n      }));\n      return rxjs_1.merge(mouseDrag$, singleTouchDrag$);\n    }), operators_1.withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$, this._navigator.panService.panNodes$), operators_1.map(function (_a) {\n      var events = _a[0],\n          render = _a[1],\n          transform = _a[2],\n          nts = _a[3];\n      var previousEvent = events[0];\n      var event = events[1];\n      var movementX = event.clientX - previousEvent.clientX;\n      var movementY = event.clientY - previousEvent.clientY;\n      var element = _this._container.element;\n\n      var _b = _this._viewportCoords.canvasPosition(event, element),\n          canvasX = _b[0],\n          canvasY = _b[1];\n\n      var currentDirection = _this._viewportCoords.unprojectFromCanvas(canvasX, canvasY, element, render.perspective).sub(render.perspective.position);\n\n      var directionX = _this._viewportCoords.unprojectFromCanvas(canvasX - movementX, canvasY, element, render.perspective).sub(render.perspective.position);\n\n      var directionY = _this._viewportCoords.unprojectFromCanvas(canvasX, canvasY - movementY, element, render.perspective).sub(render.perspective.position);\n\n      var phi = (movementX > 0 ? 1 : -1) * directionX.angleTo(currentDirection);\n      var theta = (movementY > 0 ? -1 : 1) * directionY.angleTo(currentDirection);\n      var distances = Component_1.ImageBoundary.viewportDistances(transform, render.perspective, _this._viewportCoords);\n\n      for (var _i = 0, nts_1 = nts; _i < nts_1.length; _i++) {\n        var _c = nts_1[_i],\n            t = _c[1];\n        var d = Component_1.ImageBoundary.viewportDistances(t, render.perspective, _this._viewportCoords);\n\n        for (var i = 0; i < distances.length; i++) {\n          if (d[i] < distances[i]) {\n            distances[i] = d[i];\n          }\n        }\n      }\n\n      if (distances[0] > 0 && theta < 0) {\n        theta /= Math.max(1, 2e2 * distances[0]);\n      }\n\n      if (distances[2] > 0 && theta > 0) {\n        theta /= Math.max(1, 2e2 * distances[2]);\n      }\n\n      if (distances[1] > 0 && phi < 0) {\n        phi /= Math.max(1, 2e2 * distances[1]);\n      }\n\n      if (distances[3] > 0 && phi > 0) {\n        phi /= Math.max(1, 2e2 * distances[3]);\n      }\n\n      return {\n        phi: phi,\n        theta: theta\n      };\n    }), operators_1.share());\n\n    this._rotateWithoutInertiaSubscription = rotation$.subscribe(function (rotation) {\n      _this._navigator.stateService.rotateWithoutInertia(rotation);\n    });\n    this._rotateSubscription = rotation$.pipe(operators_1.scan(function (rotationBuffer, rotation) {\n      _this._drainBuffer(rotationBuffer);\n\n      rotationBuffer.push([Date.now(), rotation]);\n      return rotationBuffer;\n    }, []), operators_1.sample(rxjs_1.merge(this._container.mouseService.filtered$(this._component.name, this._container.mouseService.mouseDragEnd$), this._container.touchService.singleTouchDragEnd$)), operators_1.map(function (rotationBuffer) {\n      var drainedBuffer = _this._drainBuffer(rotationBuffer.slice());\n\n      var rotation = {\n        phi: 0,\n        theta: 0\n      };\n\n      for (var _i = 0, drainedBuffer_1 = drainedBuffer; _i < drainedBuffer_1.length; _i++) {\n        var bufferedRotation = drainedBuffer_1[_i];\n        rotation.phi += bufferedRotation[1].phi;\n        rotation.theta += bufferedRotation[1].theta;\n      }\n\n      var count = drainedBuffer.length;\n\n      if (count > 0) {\n        rotation.phi /= count;\n        rotation.theta /= count;\n      }\n\n      var threshold = Math.PI / 18;\n      rotation.phi = _this._spatial.clamp(rotation.phi, -threshold, threshold);\n      rotation.theta = _this._spatial.clamp(rotation.theta, -threshold, threshold);\n      return rotation;\n    })).subscribe(function (rotation) {\n      _this._navigator.stateService.rotate(rotation);\n    });\n  };\n\n  DragPanHandler.prototype._disable = function () {\n    this._activeMouseSubscription.unsubscribe();\n\n    this._activeTouchSubscription.unsubscribe();\n\n    this._preventDefaultSubscription.unsubscribe();\n\n    this._rotateSubscription.unsubscribe();\n\n    this._rotateWithoutInertiaSubscription.unsubscribe();\n\n    this._activeMouseSubscription = null;\n    this._activeTouchSubscription = null;\n    this._preventDefaultSubscription = null;\n    this._rotateSubscription = null;\n  };\n\n  DragPanHandler.prototype._getConfiguration = function (enable) {\n    return {\n      dragPan: enable\n    };\n  };\n\n  DragPanHandler.prototype._drainBuffer = function (buffer) {\n    var cutoff = 50;\n    var now = Date.now();\n\n    while (buffer.length > 0 && now - buffer[0][0] > cutoff) {\n      buffer.shift();\n    }\n\n    return buffer;\n  };\n\n  return DragPanHandler;\n}(Component_1.HandlerBase);\n\nexports.DragPanHandler = DragPanHandler;\nexports.default = DragPanHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/mouse/DragPanHandler.ts?");

/***/ }),

/***/ "./src/component/mouse/EarthControlHandler.ts":
/*!****************************************************!*\
  !*** ./src/component/mouse/EarthControlHandler.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar State_1 = __webpack_require__(/*! ../../State */ \"./src/State.ts\");\n\nvar EarthControlHandler =\n/** @class */\nfunction (_super) {\n  __extends(EarthControlHandler, _super);\n\n  function EarthControlHandler(component, container, navigator, viewportCoords, spatial) {\n    var _this = _super.call(this, component, container, navigator) || this;\n\n    _this._spatial = spatial;\n    _this._viewportCoords = viewportCoords;\n    return _this;\n  }\n\n  EarthControlHandler.prototype._enable = function () {\n    var _this = this;\n\n    var earth$ = this._navigator.stateService.state$.pipe(operators_1.map(function (state) {\n      return state === State_1.State.Earth;\n    }), operators_1.share());\n\n    this._preventDefaultSubscription = earth$.pipe(operators_1.switchMap(function (earth) {\n      return earth ? _this._container.mouseService.mouseWheel$ : rxjs_1.empty();\n    })).subscribe(function (event) {\n      event.preventDefault();\n    });\n    this._truckSubscription = earth$.pipe(operators_1.switchMap(function (earth) {\n      if (!earth) {\n        return rxjs_1.empty();\n      }\n\n      return Component_1.MouseOperator.filteredPairwiseMouseDrag$(_this._component.name, _this._container.mouseService).pipe(operators_1.filter(function (_a) {\n        var e1 = _a[0],\n            e2 = _a[1];\n        return !(e1.ctrlKey && e2.ctrlKey);\n      }));\n    }), operators_1.withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$), operators_1.map(function (_a) {\n      var _b = _a[0],\n          previous = _b[0],\n          current = _b[1],\n          render = _a[1],\n          transform = _a[2];\n      var planeNormal = [0, 0, 1];\n      var planePoint = transform.unprojectBasic([0.5, 0.5], 0);\n      planePoint[2] -= 2;\n\n      var currentIntersection = _this._planeIntersection(current, planeNormal, planePoint, render.perspective, _this._container.element);\n\n      var previousIntersection = _this._planeIntersection(previous, planeNormal, planePoint, render.perspective, _this._container.element);\n\n      if (!currentIntersection || !previousIntersection) {\n        return null;\n      }\n\n      var direction = new THREE.Vector3().subVectors(currentIntersection, previousIntersection).multiplyScalar(-1).toArray();\n      return direction;\n    }), operators_1.filter(function (direction) {\n      return !!direction;\n    })).subscribe(function (direction) {\n      _this._navigator.stateService.truck(direction);\n    });\n    this._orbitSubscription = earth$.pipe(operators_1.switchMap(function (earth) {\n      if (!earth) {\n        return rxjs_1.empty();\n      }\n\n      return Component_1.MouseOperator.filteredPairwiseMouseDrag$(_this._component.name, _this._container.mouseService).pipe(operators_1.filter(function (_a) {\n        var e1 = _a[0],\n            e2 = _a[1];\n        return e1.ctrlKey && e2.ctrlKey;\n      }));\n    }), operators_1.map(function (_a) {\n      var previous = _a[0],\n          current = _a[1];\n\n      var _b = _this._eventToViewport(current, _this._container.element),\n          currentX = _b[0],\n          currentY = _b[1];\n\n      var _c = _this._eventToViewport(previous, _this._container.element),\n          previousX = _c[0],\n          previousY = _c[1];\n\n      var phi = (previousX - currentX) * Math.PI;\n      var theta = (currentY - previousY) * Math.PI / 2;\n      return {\n        phi: phi,\n        theta: theta\n      };\n    })).subscribe(function (rotation) {\n      _this._navigator.stateService.orbit(rotation);\n    });\n    this._dollySubscription = earth$.pipe(operators_1.switchMap(function (earth) {\n      if (!earth) {\n        return rxjs_1.empty();\n      }\n\n      return _this._container.mouseService.filteredWheel$(_this._component.name, _this._container.mouseService.mouseWheel$);\n    }), operators_1.map(function (event) {\n      var delta = event.deltaY;\n\n      if (event.deltaMode === 1) {\n        delta = 40 * delta;\n      } else if (event.deltaMode === 2) {\n        delta = 800 * delta;\n      }\n\n      var canvasSize = _this._viewportCoords.containerToCanvas(_this._container.element);\n\n      return -delta / canvasSize[1];\n    })).subscribe(function (delta) {\n      _this._navigator.stateService.dolly(delta);\n    });\n  };\n\n  EarthControlHandler.prototype._disable = function () {\n    this._dollySubscription.unsubscribe();\n\n    this._orbitSubscription.unsubscribe();\n\n    this._preventDefaultSubscription.unsubscribe();\n\n    this._truckSubscription.unsubscribe();\n  };\n\n  EarthControlHandler.prototype._getConfiguration = function () {\n    return {};\n  };\n\n  EarthControlHandler.prototype._eventToViewport = function (event, element) {\n    var previousCanvas = this._viewportCoords.canvasPosition(event, element);\n\n    return this._viewportCoords.canvasToViewport(previousCanvas[0], previousCanvas[1], element);\n  };\n\n  EarthControlHandler.prototype._planeIntersection = function (event, planeNormal, planePoint, camera, element) {\n    var _a = this._viewportCoords.canvasPosition(event, element),\n        canvasX = _a[0],\n        canvasY = _a[1];\n\n    var direction = this._viewportCoords.unprojectFromCanvas(canvasX, canvasY, element, camera).sub(camera.position).normalize();\n\n    if (Math.abs(this._spatial.angleToPlane(direction.toArray(), planeNormal)) < Math.PI / 90) {\n      return null;\n    }\n\n    var l0 = camera.position.clone();\n    var n = new THREE.Vector3().fromArray(planeNormal);\n    var p0 = new THREE.Vector3().fromArray(planePoint);\n    var d = new THREE.Vector3().subVectors(p0, l0).dot(n) / direction.clone().dot(n);\n    var intersection = new THREE.Vector3().addVectors(l0, direction.multiplyScalar(d));\n\n    if (this._viewportCoords.worldToCamera(intersection.toArray(), camera)[2] > 0) {\n      return null;\n    }\n\n    return intersection;\n  };\n\n  return EarthControlHandler;\n}(Component_1.HandlerBase);\n\nexports.EarthControlHandler = EarthControlHandler;\nexports.default = EarthControlHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/mouse/EarthControlHandler.ts?");

/***/ }),

/***/ "./src/component/mouse/ImageBoundary.ts":
/*!**********************************************!*\
  !*** ./src/component/mouse/ImageBoundary.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Geo_1 = __webpack_require__(/*! ../../../src/Geo */ \"./src/Geo.ts\");\n\nfunction basicBoundaryPoints(pointsPerSide) {\n  var points = [];\n  var os = [[0, 0], [1, 0], [1, 1], [0, 1]];\n  var ds = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\n  for (var side = 0; side < 4; ++side) {\n    var o = os[side];\n    var d = ds[side];\n\n    for (var i = 0; i < pointsPerSide; ++i) {\n      points.push([o[0] + d[0] * i / pointsPerSide, o[1] + d[1] * i / pointsPerSide]);\n    }\n  }\n\n  return points;\n}\n\nfunction insideViewport(x, y) {\n  return x >= -1 && x <= 1 && y >= -1 && y <= 1;\n}\n\nfunction insideBasic(x, y) {\n  return x >= 0 && x <= 1 && y >= 0 && y <= 1;\n}\n\nfunction viewportDistances(transform, perspective, viewportCoords) {\n  var boundaryPointsBasic = basicBoundaryPoints(100);\n  var boundaryPointsViewport = boundaryPointsBasic.map(function (basic) {\n    return viewportCoords.basicToViewportSafe(basic[0], basic[1], transform, perspective);\n  });\n  var visibleBoundaryPoints = [];\n  var viewportSides = [{\n    x: -1,\n    y: 1\n  }, {\n    x: 1,\n    y: 1\n  }, {\n    x: 1,\n    y: -1\n  }, {\n    x: -1,\n    y: -1\n  }];\n  var intersections = [false, false, false, false];\n\n  for (var i = 0; i < boundaryPointsViewport.length; i++) {\n    var p1 = boundaryPointsViewport[i];\n    var p2 = boundaryPointsViewport[(i + 1) % boundaryPointsViewport.length];\n\n    if (p1 === null) {\n      continue;\n    }\n\n    if (p2 === null) {\n      if (insideViewport(p1[0], p1[1])) {\n        visibleBoundaryPoints.push(p1);\n      }\n\n      continue;\n    }\n\n    var x1 = p1[0],\n        y1 = p1[1];\n    var x2 = p2[0],\n        y2 = p2[1];\n\n    if (insideViewport(x1, y1)) {\n      if (insideViewport(x2, y2)) {\n        visibleBoundaryPoints.push(p1);\n      } else {\n        for (var side = 0; side < 4; side++) {\n          var s1 = {\n            p1: {\n              x: x1,\n              y: y1\n            },\n            p2: {\n              x: x2,\n              y: y2\n            }\n          };\n          var s2 = {\n            p1: viewportSides[side],\n            p2: viewportSides[(side + 1) % 4]\n          };\n          var intersecting = Geo_1.Lines.segmentsIntersect(s1, s2);\n\n          if (intersecting) {\n            var intersection = Geo_1.Lines.segmentIntersection(s1, s2);\n            visibleBoundaryPoints.push(p1, [intersection.x, intersection.y]);\n            intersections[side] = true;\n          }\n        }\n      }\n    }\n  }\n\n  var _a = viewportCoords.viewportToBasic(-1, 1, transform, perspective),\n      topLeftBasicX = _a[0],\n      topLeftBasicY = _a[1];\n\n  var _b = viewportCoords.viewportToBasic(1, 1, transform, perspective),\n      topRightBasicX = _b[0],\n      topRightBasicY = _b[1];\n\n  var _c = viewportCoords.viewportToBasic(1, -1, transform, perspective),\n      bottomRightBasicX = _c[0],\n      bottomRightBasicY = _c[1];\n\n  var _d = viewportCoords.viewportToBasic(-1, -1, transform, perspective),\n      bottomLeftBasicX = _d[0],\n      bottomLeftBasicY = _d[1];\n\n  if (insideBasic(topLeftBasicX, topLeftBasicY)) {\n    intersections[3] = intersections[0] = true;\n  }\n\n  if (insideBasic(topRightBasicX, topRightBasicY)) {\n    intersections[0] = intersections[1] = true;\n  }\n\n  if (insideBasic(bottomRightBasicX, bottomRightBasicY)) {\n    intersections[1] = intersections[2] = true;\n  }\n\n  if (insideBasic(bottomLeftBasicX, bottomLeftBasicY)) {\n    intersections[2] = intersections[3] = true;\n  }\n\n  var maximums = [-1, -1, 1, 1];\n\n  for (var _i = 0, visibleBoundaryPoints_1 = visibleBoundaryPoints; _i < visibleBoundaryPoints_1.length; _i++) {\n    var visibleBoundaryPoint = visibleBoundaryPoints_1[_i];\n    var x = visibleBoundaryPoint[0];\n    var y = visibleBoundaryPoint[1];\n\n    if (x > maximums[1]) {\n      maximums[1] = x;\n    }\n\n    if (x < maximums[3]) {\n      maximums[3] = x;\n    }\n\n    if (y > maximums[0]) {\n      maximums[0] = y;\n    }\n\n    if (y < maximums[2]) {\n      maximums[2] = y;\n    }\n  }\n\n  var boundary = [1, 1, -1, -1];\n  var distances = [];\n\n  for (var side = 0; side < 4; side++) {\n    if (intersections[side]) {\n      distances.push(0);\n      continue;\n    }\n\n    distances.push(Math.abs(boundary[side] - maximums[side]));\n  }\n\n  return distances;\n}\n\nexports.viewportDistances = viewportDistances;\n\n//# sourceURL=webpack://Mapillary/./src/component/mouse/ImageBoundary.ts?");

/***/ }),

/***/ "./src/component/mouse/MouseComponent.ts":
/*!***********************************************!*\
  !*** ./src/component/mouse/MouseComponent.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n/**\n * @class MouseComponent\n *\n * @classdesc Component handling mouse and touch events for camera movement.\n *\n * To retrive and use the mouse component\n *\n * @example\n * ```\n * var viewer = new Mapillary.Viewer(\n *     \"<element-id>\",\n *     \"<client-id>\",\n *     \"<my key>\");\n *\n * var mouseComponent = viewer.getComponent(\"mouse\");\n * ```\n */\n\n\nvar MouseComponent =\n/** @class */\nfunction (_super) {\n  __extends(MouseComponent, _super);\n  /** @ignore */\n\n\n  function MouseComponent(name, container, navigator) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    var spatial = new Geo_1.Spatial();\n    var viewportCoords = new Geo_1.ViewportCoords();\n    _this._bounceHandler = new Component_1.BounceHandler(_this, container, navigator, viewportCoords, spatial);\n    _this._doubleClickZoomHandler = new Component_1.DoubleClickZoomHandler(_this, container, navigator, viewportCoords);\n    _this._dragPanHandler = new Component_1.DragPanHandler(_this, container, navigator, viewportCoords, spatial);\n    _this._earthControlHandler = new Component_1.EarthControlHandler(_this, container, navigator, viewportCoords, spatial);\n    _this._scrollZoomHandler = new Component_1.ScrollZoomHandler(_this, container, navigator, viewportCoords);\n    _this._touchZoomHandler = new Component_1.TouchZoomHandler(_this, container, navigator, viewportCoords);\n    return _this;\n  }\n\n  Object.defineProperty(MouseComponent.prototype, \"doubleClickZoom\", {\n    /**\n     * Get double click zoom.\n     *\n     * @returns {DoubleClickZoomHandler} The double click zoom handler.\n     */\n    get: function get() {\n      return this._doubleClickZoomHandler;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseComponent.prototype, \"dragPan\", {\n    /**\n     * Get drag pan.\n     *\n     * @returns {DragPanHandler} The drag pan handler.\n     */\n    get: function get() {\n      return this._dragPanHandler;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseComponent.prototype, \"scrollZoom\", {\n    /**\n     * Get scroll zoom.\n     *\n     * @returns {ScrollZoomHandler} The scroll zoom handler.\n     */\n    get: function get() {\n      return this._scrollZoomHandler;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseComponent.prototype, \"touchZoom\", {\n    /**\n     * Get touch zoom.\n     *\n     * @returns {TouchZoomHandler} The touch zoom handler.\n     */\n    get: function get() {\n      return this._touchZoomHandler;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MouseComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._bounceHandler.enable();\n\n    this._earthControlHandler.enable();\n\n    this._configurationSubscription = this._configuration$.subscribe(function (configuration) {\n      if (configuration.doubleClickZoom) {\n        _this._doubleClickZoomHandler.enable();\n      } else {\n        _this._doubleClickZoomHandler.disable();\n      }\n\n      if (configuration.dragPan) {\n        _this._dragPanHandler.enable();\n      } else {\n        _this._dragPanHandler.disable();\n      }\n\n      if (configuration.scrollZoom) {\n        _this._scrollZoomHandler.enable();\n      } else {\n        _this._scrollZoomHandler.disable();\n      }\n\n      if (configuration.touchZoom) {\n        _this._touchZoomHandler.enable();\n      } else {\n        _this._touchZoomHandler.disable();\n      }\n    });\n\n    this._container.mouseService.claimMouse(this._name, 0);\n  };\n\n  MouseComponent.prototype._deactivate = function () {\n    this._container.mouseService.unclaimMouse(this._name);\n\n    this._configurationSubscription.unsubscribe();\n\n    this._bounceHandler.disable();\n\n    this._doubleClickZoomHandler.disable();\n\n    this._dragPanHandler.disable();\n\n    this._earthControlHandler.disable();\n\n    this._scrollZoomHandler.disable();\n\n    this._touchZoomHandler.disable();\n  };\n\n  MouseComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      doubleClickZoom: false,\n      dragPan: true,\n      scrollZoom: true,\n      touchZoom: true\n    };\n  };\n  /** @inheritdoc */\n\n\n  MouseComponent.componentName = \"mouse\";\n  return MouseComponent;\n}(Component_1.Component);\n\nexports.MouseComponent = MouseComponent;\nComponent_1.ComponentService.register(MouseComponent);\nexports.default = MouseComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/mouse/MouseComponent.ts?");

/***/ }),

/***/ "./src/component/mouse/ScrollZoomHandler.ts":
/*!**************************************************!*\
  !*** ./src/component/mouse/ScrollZoomHandler.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n/**\n * The `ScrollZoomHandler` allows the user to zoom the viewer image by scrolling.\n *\n * @example\n * ```\n * var mouseComponent = viewer.getComponent(\"mouse\");\n *\n * mouseComponent.scrollZoom.disable();\n * mouseComponent.scrollZoom.enable();\n *\n * var isEnabled = mouseComponent.scrollZoom.isEnabled;\n * ```\n */\n\n\nvar ScrollZoomHandler =\n/** @class */\nfunction (_super) {\n  __extends(ScrollZoomHandler, _super);\n  /** @ignore */\n\n\n  function ScrollZoomHandler(component, container, navigator, viewportCoords) {\n    var _this = _super.call(this, component, container, navigator) || this;\n\n    _this._viewportCoords = viewportCoords;\n    return _this;\n  }\n\n  ScrollZoomHandler.prototype._enable = function () {\n    var _this = this;\n\n    this._container.mouseService.claimWheel(this._component.name, 0);\n\n    this._preventDefaultSubscription = this._container.mouseService.mouseWheel$.subscribe(function (event) {\n      event.preventDefault();\n    });\n    this._zoomSubscription = this._container.mouseService.filteredWheel$(this._component.name, this._container.mouseService.mouseWheel$).pipe(operators_1.withLatestFrom(this._navigator.stateService.currentState$, function (w, f) {\n      return [w, f];\n    }), operators_1.filter(function (args) {\n      var state = args[1].state;\n      return state.currentNode.fullPano || state.nodesAhead < 1;\n    }), operators_1.map(function (args) {\n      return args[0];\n    }), operators_1.withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$, function (w, r, t) {\n      return [w, r, t];\n    })).subscribe(function (args) {\n      var event = args[0];\n      var render = args[1];\n      var transform = args[2];\n      var element = _this._container.element;\n\n      var _a = _this._viewportCoords.canvasPosition(event, element),\n          canvasX = _a[0],\n          canvasY = _a[1];\n\n      var unprojected = _this._viewportCoords.unprojectFromCanvas(canvasX, canvasY, element, render.perspective);\n\n      var reference = transform.projectBasic(unprojected.toArray());\n      var deltaY = event.deltaY;\n\n      if (event.deltaMode === 1) {\n        deltaY = 40 * deltaY;\n      } else if (event.deltaMode === 2) {\n        deltaY = 800 * deltaY;\n      }\n\n      var canvasSize = _this._viewportCoords.containerToCanvas(element);\n\n      var zoom = -3 * deltaY / canvasSize[1];\n\n      _this._navigator.stateService.zoomIn(zoom, reference);\n    });\n  };\n\n  ScrollZoomHandler.prototype._disable = function () {\n    this._container.mouseService.unclaimWheel(this._component.name);\n\n    this._preventDefaultSubscription.unsubscribe();\n\n    this._zoomSubscription.unsubscribe();\n\n    this._preventDefaultSubscription = null;\n    this._zoomSubscription = null;\n  };\n\n  ScrollZoomHandler.prototype._getConfiguration = function (enable) {\n    return {\n      scrollZoom: enable\n    };\n  };\n\n  return ScrollZoomHandler;\n}(Component_1.HandlerBase);\n\nexports.ScrollZoomHandler = ScrollZoomHandler;\nexports.default = ScrollZoomHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/mouse/ScrollZoomHandler.ts?");

/***/ }),

/***/ "./src/component/mouse/TouchZoomHandler.ts":
/*!*************************************************!*\
  !*** ./src/component/mouse/TouchZoomHandler.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n/**\n * The `TouchZoomHandler` allows the user to zoom the viewer image by pinching on a touchscreen.\n *\n * @example\n * ```\n * var mouseComponent = viewer.getComponent(\"mouse\");\n *\n * mouseComponent.touchZoom.disable();\n * mouseComponent.touchZoom.enable();\n *\n * var isEnabled = mouseComponent.touchZoom.isEnabled;\n * ```\n */\n\n\nvar TouchZoomHandler =\n/** @class */\nfunction (_super) {\n  __extends(TouchZoomHandler, _super);\n  /** @ignore */\n\n\n  function TouchZoomHandler(component, container, navigator, viewportCoords) {\n    var _this = _super.call(this, component, container, navigator) || this;\n\n    _this._viewportCoords = viewportCoords;\n    return _this;\n  }\n\n  TouchZoomHandler.prototype._enable = function () {\n    var _this = this;\n\n    this._preventDefaultSubscription = this._container.touchService.pinch$.subscribe(function (pinch) {\n      pinch.originalEvent.preventDefault();\n    });\n\n    var pinchStarted$ = this._container.touchService.pinchStart$.pipe(operators_1.map(function (event) {\n      return true;\n    }));\n\n    var pinchStopped$ = this._container.touchService.pinchEnd$.pipe(operators_1.map(function (event) {\n      return false;\n    }));\n\n    this._activeSubscription = rxjs_1.merge(pinchStarted$, pinchStopped$).subscribe(this._container.touchService.activate$);\n    this._zoomSubscription = this._container.touchService.pinch$.pipe(operators_1.withLatestFrom(this._navigator.stateService.currentState$), operators_1.filter(function (args) {\n      var state = args[1].state;\n      return state.currentNode.fullPano || state.nodesAhead < 1;\n    }), operators_1.map(function (args) {\n      return args[0];\n    }), operators_1.withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$)).subscribe(function (_a) {\n      var pinch = _a[0],\n          render = _a[1],\n          transform = _a[2];\n      var element = _this._container.element;\n\n      var _b = _this._viewportCoords.canvasPosition(pinch, element),\n          canvasX = _b[0],\n          canvasY = _b[1];\n\n      var unprojected = _this._viewportCoords.unprojectFromCanvas(canvasX, canvasY, element, render.perspective);\n\n      var reference = transform.projectBasic(unprojected.toArray());\n\n      var _c = _this._viewportCoords.containerToCanvas(element),\n          canvasWidth = _c[0],\n          canvasHeight = _c[1];\n\n      var zoom = 3 * pinch.distanceChange / Math.min(canvasWidth, canvasHeight);\n\n      _this._navigator.stateService.zoomIn(zoom, reference);\n    });\n  };\n\n  TouchZoomHandler.prototype._disable = function () {\n    this._activeSubscription.unsubscribe();\n\n    this._preventDefaultSubscription.unsubscribe();\n\n    this._zoomSubscription.unsubscribe();\n\n    this._preventDefaultSubscription = null;\n    this._zoomSubscription = null;\n  };\n\n  TouchZoomHandler.prototype._getConfiguration = function (enable) {\n    return {\n      touchZoom: enable\n    };\n  };\n\n  return TouchZoomHandler;\n}(Component_1.HandlerBase);\n\nexports.TouchZoomHandler = TouchZoomHandler;\nexports.default = TouchZoomHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/mouse/TouchZoomHandler.ts?");

/***/ }),

/***/ "./src/component/popup/Popup.ts":
/*!**************************************!*\
  !*** ./src/component/popup/Popup.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Popup_1 = __webpack_require__(/*! ./popup/Popup */ \"./src/component/popup/popup/Popup.ts\");\n\nexports.Popup = Popup_1.Popup;\n\nvar PopupComponent_1 = __webpack_require__(/*! ./PopupComponent */ \"./src/component/popup/PopupComponent.ts\");\n\nexports.PopupComponent = PopupComponent_1.PopupComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/popup/Popup.ts?");

/***/ }),

/***/ "./src/component/popup/PopupComponent.ts":
/*!***********************************************!*\
  !*** ./src/component/popup/PopupComponent.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../../Utils */ \"./src/Utils.ts\");\n/**\n * @class PopupComponent\n *\n * @classdesc Component for showing HTML popup objects.\n *\n * The `add` method is used for adding new popups. Popups are removed by reference.\n *\n * It is not possible to update popups in the set by updating any properties\n * directly on the popup object. Popups need to be replaced by\n * removing them and creating new ones with relevant changed properties and\n * adding those instead.\n *\n * Popups are only relevant to a single image because they are based on\n * 2D basic image coordinates. Popups related to a certain image should\n * be removed when the viewer is moved to another node.\n *\n * To retrive and use the popup component\n *\n * @example\n * ```\n * var viewer = new Mapillary.Viewer(\n *     \"<element-id>\",\n *     \"<client-id>\",\n *     \"<my key>\",\n *     { component: { popup: true } });\n *\n * var popupComponent = viewer.getComponent(\"popup\");\n * ```\n */\n\n\nvar PopupComponent =\n/** @class */\nfunction (_super) {\n  __extends(PopupComponent, _super);\n  /** @ignore */\n\n\n  function PopupComponent(name, container, navigator, dom) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._dom = !!dom ? dom : new Utils_1.DOM();\n    _this._popups = [];\n    _this._added$ = new rxjs_1.Subject();\n    _this._popups$ = new rxjs_1.Subject();\n    return _this;\n  }\n  /**\n   * Add popups to the popups set.\n   *\n   * @description Adding a new popup never replaces an old one\n   * because they are stored by reference. Adding an already\n   * existing popup has no effect.\n   *\n   * @param {Array<Popup>} popups - Popups to add.\n   *\n   * @example ```popupComponent.add([popup1, popup2]);```\n   */\n\n\n  PopupComponent.prototype.add = function (popups) {\n    for (var _i = 0, popups_1 = popups; _i < popups_1.length; _i++) {\n      var popup = popups_1[_i];\n\n      if (this._popups.indexOf(popup) !== -1) {\n        continue;\n      }\n\n      this._popups.push(popup);\n\n      if (this._activated) {\n        popup.setParentContainer(this._popupContainer);\n      }\n    }\n\n    this._added$.next(popups);\n\n    this._popups$.next(this._popups);\n  };\n  /**\n   * Returns an array of all popups.\n   *\n   * @example ```var popups = popupComponent.getAll();```\n   */\n\n\n  PopupComponent.prototype.getAll = function () {\n    return this._popups.slice();\n  };\n  /**\n   * Remove popups based on reference from the popup set.\n   *\n   * @param {Array<Popup>} popups - Popups to remove.\n   *\n   * @example ```popupComponent.remove([popup1, popup2]);```\n   */\n\n\n  PopupComponent.prototype.remove = function (popups) {\n    for (var _i = 0, popups_2 = popups; _i < popups_2.length; _i++) {\n      var popup = popups_2[_i];\n\n      this._remove(popup);\n    }\n\n    this._popups$.next(this._popups);\n  };\n  /**\n   * Remove all popups from the popup set.\n   *\n   * @example ```popupComponent.removeAll();```\n   */\n\n\n  PopupComponent.prototype.removeAll = function () {\n    for (var _i = 0, _a = this._popups.slice(); _i < _a.length; _i++) {\n      var popup = _a[_i];\n\n      this._remove(popup);\n    }\n\n    this._popups$.next(this._popups);\n  };\n\n  PopupComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._popupContainer = this._dom.createElement(\"div\", \"mapillary-js-popup-container\", this._container.element);\n\n    for (var _i = 0, _a = this._popups; _i < _a.length; _i++) {\n      var popup = _a[_i];\n      popup.setParentContainer(this._popupContainer);\n    }\n\n    this._updateAllSubscription = rxjs_1.combineLatest(this._container.renderService.renderCamera$, this._container.renderService.size$, this._navigator.stateService.currentTransform$).subscribe(function (_a) {\n      var renderCamera = _a[0],\n          size = _a[1],\n          transform = _a[2];\n\n      for (var _i = 0, _b = _this._popups; _i < _b.length; _i++) {\n        var popup = _b[_i];\n        popup.update(renderCamera, size, transform);\n      }\n    });\n\n    var changed$ = this._popups$.pipe(operators_1.startWith(this._popups), operators_1.switchMap(function (popups) {\n      return rxjs_1.from(popups).pipe(operators_1.mergeMap(function (popup) {\n        return popup.changed$;\n      }));\n    }), operators_1.map(function (popup) {\n      return [popup];\n    }));\n\n    this._updateAddedChangedSubscription = rxjs_1.merge(this._added$, changed$).pipe(operators_1.withLatestFrom(this._container.renderService.renderCamera$, this._container.renderService.size$, this._navigator.stateService.currentTransform$)).subscribe(function (_a) {\n      var popups = _a[0],\n          renderCamera = _a[1],\n          size = _a[2],\n          transform = _a[3];\n\n      for (var _i = 0, popups_3 = popups; _i < popups_3.length; _i++) {\n        var popup = popups_3[_i];\n        popup.update(renderCamera, size, transform);\n      }\n    });\n  };\n\n  PopupComponent.prototype._deactivate = function () {\n    this._updateAllSubscription.unsubscribe();\n\n    this._updateAddedChangedSubscription.unsubscribe();\n\n    for (var _i = 0, _a = this._popups; _i < _a.length; _i++) {\n      var popup = _a[_i];\n      popup.remove();\n    }\n\n    this._container.element.removeChild(this._popupContainer);\n\n    delete this._popupContainer;\n  };\n\n  PopupComponent.prototype._getDefaultConfiguration = function () {\n    return {};\n  };\n\n  PopupComponent.prototype._remove = function (popup) {\n    var index = this._popups.indexOf(popup);\n\n    if (index === -1) {\n      return;\n    }\n\n    var removed = this._popups.splice(index, 1)[0];\n\n    if (this._activated) {\n      removed.remove();\n    }\n  };\n\n  PopupComponent.componentName = \"popup\";\n  return PopupComponent;\n}(Component_1.Component);\n\nexports.PopupComponent = PopupComponent;\nComponent_1.ComponentService.register(PopupComponent);\nexports.default = PopupComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/popup/PopupComponent.ts?");

/***/ }),

/***/ "./src/component/popup/popup/Popup.ts":
/*!********************************************!*\
  !*** ./src/component/popup/popup/Popup.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Geo_1 = __webpack_require__(/*! ../../../Geo */ \"./src/Geo.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../../../Utils */ \"./src/Utils.ts\");\n\nvar Viewer_1 = __webpack_require__(/*! ../../../Viewer */ \"./src/Viewer.ts\");\n/**\n * @class Popup\n *\n * @classdesc Popup instance for rendering custom HTML content\n * on top of images. Popups are based on 2D basic image coordinates\n * (see the {@link Viewer} class documentation for more information about coordinate\n * systems) and a certain popup is therefore only relevant to a single image.\n * Popups related to a certain image should be removed when moving\n * to another image.\n *\n * A popup must have both its content and its point or rect set to be\n * rendered. Popup options can not be updated after creation but the\n * basic point or rect as well as its content can be changed by calling\n * the appropriate methods.\n *\n * To create and add one `Popup` with default configuration\n * (tooltip visuals and automatic float) and one with specific options\n * use\n *\n * @example\n * ```\n * var defaultSpan = document.createElement('span');\n * defaultSpan.innerHTML = 'hello default';\n *\n * var defaultPopup = new Mapillary.PopupComponent.Popup();\n * defaultPopup.setDOMContent(defaultSpan);\n * defaultPopup.setBasicPoint([0.3, 0.3]);\n *\n * var cleanSpan = document.createElement('span');\n * cleanSpan.innerHTML = 'hello clean';\n *\n * var cleanPopup = new Mapillary.PopupComponent.Popup({\n *     clean: true,\n *     float: Mapillary.Alignment.Top,\n *     offset: 10,\n *     opacity: 0.7,\n * });\n *\n * cleanPopup.setDOMContent(cleanSpan);\n * cleanPopup.setBasicPoint([0.6, 0.6]);\n *\n * popupComponent.add([defaultPopup, cleanPopup]);\n * ```\n *\n * @description Implementation of API methods and API documentation inspired\n * by/used from https://github.com/mapbox/mapbox-gl-js/blob/v0.38.0/src/ui/popup.js\n */\n\n\nvar Popup =\n/** @class */\nfunction () {\n  function Popup(options, viewportCoords, dom) {\n    this._options = {};\n    options = !!options ? options : {};\n    this._options.capturePointer = options.capturePointer === false ? options.capturePointer : true;\n    this._options.clean = options.clean;\n    this._options.float = options.float;\n    this._options.offset = options.offset;\n    this._options.opacity = options.opacity;\n    this._options.position = options.position;\n    this._dom = !!dom ? dom : new Utils_1.DOM();\n    this._viewportCoords = !!viewportCoords ? viewportCoords : new Geo_1.ViewportCoords();\n    this._notifyChanged$ = new rxjs_1.Subject();\n  }\n\n  Object.defineProperty(Popup.prototype, \"changed$\", {\n    /**\n     * @description Internal observable used by the component to\n     * render the popup when its position or content has changed.\n     * @ignore\n     */\n    get: function get() {\n      return this._notifyChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @description Internal method used by the component to\n   * remove all references to the popup.\n   * @ignore\n   */\n\n  Popup.prototype.remove = function () {\n    if (this._content && this._content.parentNode) {\n      this._content.parentNode.removeChild(this._content);\n    }\n\n    if (this._container) {\n      this._container.parentNode.removeChild(this._container);\n\n      delete this._container;\n    }\n\n    if (this._parentContainer) {\n      delete this._parentContainer;\n    }\n  };\n  /**\n   * Sets a 2D basic image coordinates point to the popup's anchor, and\n   * moves the popup to it.\n   *\n   * @description Overwrites any previously set point or rect.\n   *\n   * @param {Array<number>} basicPoint - Point in 2D basic image coordinates.\n   *\n   * @example\n   * ```\n   * var popup = new Mapillary.PopupComponent.Popup();\n   * popup.setText('hello image');\n   * popup.setBasicPoint([0.3, 0.3]);\n   *\n   * popupComponent.add([popup]);\n   * ```\n   */\n\n\n  Popup.prototype.setBasicPoint = function (basicPoint) {\n    this._point = basicPoint.slice();\n    this._rect = null;\n\n    this._notifyChanged$.next(this);\n  };\n  /**\n   * Sets a 2D basic image coordinates rect to the popup's anchor, and\n   * moves the popup to it.\n   *\n   * @description Overwrites any previously set point or rect.\n   *\n   * @param {Array<number>} basicRect - Rect in 2D basic image\n   * coordinates ([topLeftX, topLeftY, bottomRightX, bottomRightY]) .\n   *\n   * @example\n   * ```\n   * var popup = new Mapillary.PopupComponent.Popup();\n   * popup.setText('hello image');\n   * popup.setBasicRect([0.3, 0.3, 0.5, 0.6]);\n   *\n   * popupComponent.add([popup]);\n   * ```\n   */\n\n\n  Popup.prototype.setBasicRect = function (basicRect) {\n    this._rect = basicRect.slice();\n    this._point = null;\n\n    this._notifyChanged$.next(this);\n  };\n  /**\n   * Sets the popup's content to the element provided as a DOM node.\n   *\n   * @param {Node} htmlNode - A DOM node to be used as content for the popup.\n   *\n   * @example\n   * ```\n   * var div = document.createElement('div');\n   * div.innerHTML = 'hello image';\n   *\n   * var popup = new Mapillary.PopupComponent.Popup();\n   * popup.setDOMContent(div);\n   * popup.setBasicPoint([0.3, 0.3]);\n   *\n   * popupComponent.add([popup]);\n   * ```\n   */\n\n\n  Popup.prototype.setDOMContent = function (htmlNode) {\n    if (this._content && this._content.parentNode) {\n      this._content.parentNode.removeChild(this._content);\n    }\n\n    var className = \"mapillaryjs-popup-content\" + (this._options.clean === true ? \"-clean\" : \"\") + (this._options.capturePointer === true ? \" mapillaryjs-popup-capture-pointer\" : \"\");\n    this._content = this._dom.createElement(\"div\", className, this._container);\n\n    this._content.appendChild(htmlNode);\n\n    this._notifyChanged$.next(this);\n  };\n  /**\n   * Sets the popup's content to the HTML provided as a string.\n   *\n   * @description This method does not perform HTML filtering or sanitization,\n   * and must be used only with trusted content. Consider Popup#setText if the\n   * content is an untrusted text string.\n   *\n   * @param {string} html - A string representing HTML content for the popup.\n   *\n   * @example\n   * ```\n   * var popup = new Mapillary.PopupComponent.Popup();\n   * popup.setHTML('<div>hello image</div>');\n   * popup.setBasicPoint([0.3, 0.3]);\n   *\n   * popupComponent.add([popup]);\n   * ```\n   */\n\n\n  Popup.prototype.setHTML = function (html) {\n    var frag = this._dom.document.createDocumentFragment();\n\n    var temp = this._dom.createElement(\"body\");\n\n    var child;\n    temp.innerHTML = html;\n\n    while (true) {\n      child = temp.firstChild;\n\n      if (!child) {\n        break;\n      }\n\n      frag.appendChild(child);\n    }\n\n    this.setDOMContent(frag);\n  };\n  /**\n   * Sets the popup's content to a string of text.\n   *\n   * @description This function creates a Text node in the DOM, so it cannot insert raw HTML.\n   * Use this method for security against XSS if the popup content is user-provided.\n   *\n   * @param {string} text - Textual content for the popup.\n   *\n   * @example\n   * ```\n   * var popup = new Mapillary.PopupComponent.Popup();\n   * popup.setText('hello image');\n   * popup.setBasicPoint([0.3, 0.3]);\n   *\n   * popupComponent.add([popup]);\n   * ```\n   */\n\n\n  Popup.prototype.setText = function (text) {\n    this.setDOMContent(this._dom.document.createTextNode(text));\n  };\n  /**\n   * @description Internal method for attaching the popup to\n   * its parent container so that it is rendered in the DOM tree.\n   * @ignore\n   */\n\n\n  Popup.prototype.setParentContainer = function (parentContainer) {\n    this._parentContainer = parentContainer;\n  };\n  /**\n   * @description Internal method for updating the rendered\n   * position of the popup called by the popup component.\n   * @ignore\n   */\n\n\n  Popup.prototype.update = function (renderCamera, size, transform) {\n    var _a;\n\n    if (!this._parentContainer || !this._content) {\n      return;\n    }\n\n    if (!this._point && !this._rect) {\n      return;\n    }\n\n    if (!this._container) {\n      this._container = this._dom.createElement(\"div\", \"mapillaryjs-popup\", this._parentContainer);\n      var showTip = this._options.clean !== true && this._options.float !== Viewer_1.Alignment.Center;\n\n      if (showTip) {\n        var tipClassName = \"mapillaryjs-popup-tip\" + (this._options.capturePointer === true ? \" mapillaryjs-popup-capture-pointer\" : \"\");\n        this._tip = this._dom.createElement(\"div\", tipClassName, this._container);\n\n        this._dom.createElement(\"div\", \"mapillaryjs-popup-tip-inner\", this._tip);\n      }\n\n      this._container.appendChild(this._content);\n\n      this._parentContainer.appendChild(this._container);\n\n      if (this._options.opacity != null) {\n        this._container.style.opacity = this._options.opacity.toString();\n      }\n    }\n\n    var pointPixel = null;\n\n    var position = this._alignmentToPopupAligment(this._options.position);\n\n    var float = this._alignmentToPopupAligment(this._options.float);\n\n    var classList = this._container.classList;\n\n    if (this._point != null) {\n      pointPixel = this._viewportCoords.basicToCanvasSafe(this._point[0], this._point[1], {\n        offsetHeight: size.height,\n        offsetWidth: size.width\n      }, transform, renderCamera.perspective);\n    } else {\n      var alignments = [\"center\", \"top\", \"bottom\", \"left\", \"right\", \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"];\n      var appliedPosition = null;\n\n      for (var _i = 0, alignments_1 = alignments; _i < alignments_1.length; _i++) {\n        var alignment = alignments_1[_i];\n\n        if (classList.contains(\"mapillaryjs-popup-float-\" + alignment)) {\n          appliedPosition = alignment;\n          break;\n        }\n      }\n\n      _a = this._rectToPixel(this._rect, position, appliedPosition, renderCamera, size, transform), pointPixel = _a[0], position = _a[1];\n\n      if (!float) {\n        float = position;\n      }\n    }\n\n    if (pointPixel == null) {\n      this._container.style.display = \"none\";\n      return;\n    }\n\n    this._container.style.display = \"\";\n\n    if (!float) {\n      var width = this._container.offsetWidth;\n      var height = this._container.offsetHeight;\n\n      var floats = this._pixelToFloats(pointPixel, size, width, height);\n\n      float = floats.length === 0 ? \"top\" : floats.join(\"-\");\n    }\n\n    var offset = this._normalizeOffset(this._options.offset);\n\n    pointPixel = [pointPixel[0] + offset[float][0], pointPixel[1] + offset[float][1]];\n    pointPixel = [Math.round(pointPixel[0]), Math.round(pointPixel[1])];\n    var floatTranslate = {\n      \"bottom\": \"translate(-50%,0)\",\n      \"bottom-left\": \"translate(-100%,0)\",\n      \"bottom-right\": \"translate(0,0)\",\n      \"center\": \"translate(-50%,-50%)\",\n      \"left\": \"translate(-100%,-50%)\",\n      \"right\": \"translate(0,-50%)\",\n      \"top\": \"translate(-50%,-100%)\",\n      \"top-left\": \"translate(-100%,-100%)\",\n      \"top-right\": \"translate(0,-100%)\"\n    };\n\n    for (var key in floatTranslate) {\n      if (!floatTranslate.hasOwnProperty(key)) {\n        continue;\n      }\n\n      classList.remove(\"mapillaryjs-popup-float-\" + key);\n    }\n\n    classList.add(\"mapillaryjs-popup-float-\" + float);\n    this._container.style.transform = floatTranslate[float] + \" translate(\" + pointPixel[0] + \"px,\" + pointPixel[1] + \"px)\";\n  };\n\n  Popup.prototype._rectToPixel = function (rect, position, appliedPosition, renderCamera, size, transform) {\n    if (!position) {\n      var width = this._container.offsetWidth;\n      var height = this._container.offsetHeight;\n      var floatOffsets = {\n        \"bottom\": [0, height / 2],\n        \"bottom-left\": [-width / 2, height / 2],\n        \"bottom-right\": [width / 2, height / 2],\n        \"left\": [-width / 2, 0],\n        \"right\": [width / 2, 0],\n        \"top\": [0, -height / 2],\n        \"top-left\": [-width / 2, -height / 2],\n        \"top-right\": [width / 2, -height / 2]\n      };\n      var automaticPositions = [\"top\", \"bottom\", \"left\", \"right\"];\n      var largestVisibleArea = [0, null, null];\n\n      for (var _i = 0, automaticPositions_1 = automaticPositions; _i < automaticPositions_1.length; _i++) {\n        var automaticPosition = automaticPositions_1[_i];\n\n        var autoPointBasic = this._pointFromRectPosition(rect, automaticPosition);\n\n        var autoPointPixel = this._viewportCoords.basicToCanvasSafe(autoPointBasic[0], autoPointBasic[1], {\n          offsetHeight: size.height,\n          offsetWidth: size.width\n        }, transform, renderCamera.perspective);\n\n        if (autoPointPixel == null) {\n          continue;\n        }\n\n        var floatOffset = floatOffsets[automaticPosition];\n        var offsetedPosition = [autoPointPixel[0] + floatOffset[0], autoPointPixel[1] + floatOffset[1]];\n        var staticCoeff = appliedPosition != null && appliedPosition === automaticPosition ? 1 : 0.7;\n\n        var floats = this._pixelToFloats(offsetedPosition, size, width / staticCoeff, height / (2 * staticCoeff));\n\n        if (floats.length === 0 && autoPointPixel[0] > 0 && autoPointPixel[0] < size.width && autoPointPixel[1] > 0 && autoPointPixel[1] < size.height) {\n          return [autoPointPixel, automaticPosition];\n        }\n\n        var minX = Math.max(offsetedPosition[0] - width / 2, 0);\n        var maxX = Math.min(offsetedPosition[0] + width / 2, size.width);\n        var minY = Math.max(offsetedPosition[1] - height / 2, 0);\n        var maxY = Math.min(offsetedPosition[1] + height / 2, size.height);\n        var visibleX = Math.max(0, maxX - minX);\n        var visibleY = Math.max(0, maxY - minY);\n        var visibleArea = staticCoeff * visibleX * visibleY;\n\n        if (visibleArea > largestVisibleArea[0]) {\n          largestVisibleArea[0] = visibleArea;\n          largestVisibleArea[1] = autoPointPixel;\n          largestVisibleArea[2] = automaticPosition;\n        }\n      }\n\n      if (largestVisibleArea[0] > 0) {\n        return [largestVisibleArea[1], largestVisibleArea[2]];\n      }\n    }\n\n    var pointBasic = this._pointFromRectPosition(rect, position);\n\n    var pointPixel = this._viewportCoords.basicToCanvasSafe(pointBasic[0], pointBasic[1], {\n      offsetHeight: size.height,\n      offsetWidth: size.width\n    }, transform, renderCamera.perspective);\n\n    return [pointPixel, position != null ? position : \"top\"];\n  };\n\n  Popup.prototype._alignmentToPopupAligment = function (float) {\n    switch (float) {\n      case Viewer_1.Alignment.Bottom:\n        return \"bottom\";\n\n      case Viewer_1.Alignment.BottomLeft:\n        return \"bottom-left\";\n\n      case Viewer_1.Alignment.BottomRight:\n        return \"bottom-right\";\n\n      case Viewer_1.Alignment.Center:\n        return \"center\";\n\n      case Viewer_1.Alignment.Left:\n        return \"left\";\n\n      case Viewer_1.Alignment.Right:\n        return \"right\";\n\n      case Viewer_1.Alignment.Top:\n        return \"top\";\n\n      case Viewer_1.Alignment.TopLeft:\n        return \"top-left\";\n\n      case Viewer_1.Alignment.TopRight:\n        return \"top-right\";\n\n      default:\n        return null;\n    }\n  };\n\n  Popup.prototype._normalizeOffset = function (offset) {\n    if (offset == null) {\n      return this._normalizeOffset(0);\n    }\n\n    if (typeof offset === \"number\") {\n      // input specifies a radius\n      var sideOffset = offset;\n      var sign = sideOffset >= 0 ? 1 : -1;\n      var cornerOffset = sign * Math.round(Math.sqrt(0.5 * Math.pow(sideOffset, 2)));\n      return {\n        \"bottom\": [0, sideOffset],\n        \"bottom-left\": [-cornerOffset, cornerOffset],\n        \"bottom-right\": [cornerOffset, cornerOffset],\n        \"center\": [0, 0],\n        \"left\": [-sideOffset, 0],\n        \"right\": [sideOffset, 0],\n        \"top\": [0, -sideOffset],\n        \"top-left\": [-cornerOffset, -cornerOffset],\n        \"top-right\": [cornerOffset, -cornerOffset]\n      };\n    } else {\n      // input specifes a value for each position\n      return {\n        \"bottom\": offset.bottom || [0, 0],\n        \"bottom-left\": offset.bottomLeft || [0, 0],\n        \"bottom-right\": offset.bottomRight || [0, 0],\n        \"center\": offset.center || [0, 0],\n        \"left\": offset.left || [0, 0],\n        \"right\": offset.right || [0, 0],\n        \"top\": offset.top || [0, 0],\n        \"top-left\": offset.topLeft || [0, 0],\n        \"top-right\": offset.topRight || [0, 0]\n      };\n    }\n  };\n\n  Popup.prototype._pixelToFloats = function (pointPixel, size, width, height) {\n    var floats = [];\n\n    if (pointPixel[1] < height) {\n      floats.push(\"bottom\");\n    } else if (pointPixel[1] > size.height - height) {\n      floats.push(\"top\");\n    }\n\n    if (pointPixel[0] < width / 2) {\n      floats.push(\"right\");\n    } else if (pointPixel[0] > size.width - width / 2) {\n      floats.push(\"left\");\n    }\n\n    return floats;\n  };\n\n  Popup.prototype._pointFromRectPosition = function (rect, position) {\n    var x0 = rect[0];\n    var x1 = rect[0] < rect[2] ? rect[2] : rect[2] + 1;\n    var y0 = rect[1];\n    var y1 = rect[3];\n\n    switch (position) {\n      case \"bottom\":\n        return [(x0 + x1) / 2, y1];\n\n      case \"bottom-left\":\n        return [x0, y1];\n\n      case \"bottom-right\":\n        return [x1, y1];\n\n      case \"center\":\n        return [(x0 + x1) / 2, (y0 + y1) / 2];\n\n      case \"left\":\n        return [x0, (y0 + y1) / 2];\n\n      case \"right\":\n        return [x1, (y0 + y1) / 2];\n\n      case \"top\":\n        return [(x0 + x1) / 2, y0];\n\n      case \"top-left\":\n        return [x0, y0];\n\n      case \"top-right\":\n        return [x1, y0];\n\n      default:\n        return [(x0 + x1) / 2, y1];\n    }\n  };\n\n  return Popup;\n}();\n\nexports.Popup = Popup;\nexports.default = Popup;\n\n//# sourceURL=webpack://Mapillary/./src/component/popup/popup/Popup.ts?");

/***/ }),

/***/ "./src/component/sequence/SequenceComponent.ts":
/*!*****************************************************!*\
  !*** ./src/component/sequence/SequenceComponent.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Edge_1 = __webpack_require__(/*! ../../Edge */ \"./src/Edge.ts\");\n\nvar Graph_1 = __webpack_require__(/*! ../../Graph */ \"./src/Graph.ts\");\n/**\n * @class SequenceComponent\n * @classdesc Component showing navigation arrows for sequence directions\n * as well as playing button. Exposes an API to start and stop play.\n */\n\n\nvar SequenceComponent =\n/** @class */\nfunction (_super) {\n  __extends(SequenceComponent, _super);\n\n  function SequenceComponent(name, container, navigator, renderer, scheduler) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._sequenceDOMRenderer = !!renderer ? renderer : new Component_1.SequenceDOMRenderer(container);\n    _this._scheduler = scheduler;\n    _this._containerWidth$ = new rxjs_1.Subject();\n    _this._hoveredKeySubject$ = new rxjs_1.Subject();\n    _this._hoveredKey$ = _this._hoveredKeySubject$.pipe(operators_1.share());\n\n    _this._navigator.playService.playing$.pipe(operators_1.skip(1), operators_1.withLatestFrom(_this._configuration$)).subscribe(function (_a) {\n      var playing = _a[0],\n          configuration = _a[1];\n\n      _this.fire(SequenceComponent.playingchanged, playing);\n\n      if (playing === configuration.playing) {\n        return;\n      }\n\n      if (playing) {\n        _this.play();\n      } else {\n        _this.stop();\n      }\n    });\n\n    _this._navigator.playService.direction$.pipe(operators_1.skip(1), operators_1.withLatestFrom(_this._configuration$)).subscribe(function (_a) {\n      var direction = _a[0],\n          configuration = _a[1];\n\n      if (direction !== configuration.direction) {\n        _this.setDirection(direction);\n      }\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(SequenceComponent.prototype, \"hoveredKey$\", {\n    /**\n     * Get hovered key observable.\n     *\n     * @description An observable emitting the key of the node for the direction\n     * arrow that is being hovered. When the mouse leaves a direction arrow null\n     * is emitted.\n     *\n     * @returns {Observable<string>}\n     */\n    get: function get() {\n      return this._hoveredKey$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Start playing.\n   *\n   * @fires PlayerComponent#playingchanged\n   */\n\n  SequenceComponent.prototype.play = function () {\n    this.configure({\n      playing: true\n    });\n  };\n  /**\n   * Stop playing.\n   *\n   * @fires PlayerComponent#playingchanged\n   */\n\n\n  SequenceComponent.prototype.stop = function () {\n    this.configure({\n      playing: false\n    });\n  };\n  /**\n   * Set the direction to follow when playing.\n   *\n   * @param {EdgeDirection} direction - The direction that will be followed when playing.\n   */\n\n\n  SequenceComponent.prototype.setDirection = function (direction) {\n    this.configure({\n      direction: direction\n    });\n  };\n  /**\n   * Set highlight key.\n   *\n   * @description The arrow pointing towards the node corresponding to the\n   * highlight key will be highlighted.\n   *\n   * @param {string} highlightKey Key of node to be highlighted if existing.\n   */\n\n\n  SequenceComponent.prototype.setHighlightKey = function (highlightKey) {\n    this.configure({\n      highlightKey: highlightKey\n    });\n  };\n  /**\n   * Set max width of container element.\n   *\n   * @description Set max width of the container element holding\n   * the sequence navigation elements. If the min width is larger than the\n   * max width the min width value will be used.\n   *\n   * The container element is automatically resized when the resize\n   * method on the Viewer class is called.\n   *\n   * @param {number} minWidth\n   */\n\n\n  SequenceComponent.prototype.setMaxWidth = function (maxWidth) {\n    this.configure({\n      maxWidth: maxWidth\n    });\n  };\n  /**\n   * Set min width of container element.\n   *\n   * @description Set min width of the container element holding\n   * the sequence navigation elements. If the min width is larger than the\n   * max width the min width value will be used.\n   *\n   * The container element is automatically resized when the resize\n   * method on the Viewer class is called.\n   *\n   * @param {number} minWidth\n   */\n\n\n  SequenceComponent.prototype.setMinWidth = function (minWidth) {\n    this.configure({\n      minWidth: minWidth\n    });\n  };\n  /**\n   * Set the value indicating whether the sequence UI elements should be visible.\n   *\n   * @param {boolean} visible\n   */\n\n\n  SequenceComponent.prototype.setVisible = function (visible) {\n    this.configure({\n      visible: visible\n    });\n  };\n\n  SequenceComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._sequenceDOMRenderer.activate();\n\n    var edgeStatus$ = this._navigator.stateService.currentNode$.pipe(operators_1.switchMap(function (node) {\n      return node.sequenceEdges$;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    var sequence$ = this._navigator.stateService.currentNode$.pipe(operators_1.distinctUntilChanged(undefined, function (node) {\n      return node.sequenceKey;\n    }), operators_1.switchMap(function (node) {\n      return rxjs_1.concat(rxjs_1.of(null), _this._navigator.graphService.cacheSequence$(node.sequenceKey).pipe(operators_1.retry(3), operators_1.catchError(function (e) {\n        console.error(\"Failed to cache sequence\", e);\n        return rxjs_1.of(null);\n      })));\n    }), operators_1.startWith(null), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._sequenceSubscription = sequence$.subscribe();\n\n    var rendererKey$ = this._sequenceDOMRenderer.index$.pipe(operators_1.withLatestFrom(sequence$), operators_1.map(function (_a) {\n      var index = _a[0],\n          sequence = _a[1];\n      return sequence != null ? sequence.keys[index] : null;\n    }), operators_1.filter(function (key) {\n      return !!key;\n    }), operators_1.distinctUntilChanged(), operators_1.publish(), operators_1.refCount());\n\n    this._moveSubscription = rxjs_1.merge(rendererKey$.pipe(operators_1.debounceTime(100, this._scheduler)), rendererKey$.pipe(operators_1.auditTime(400, this._scheduler))).pipe(operators_1.distinctUntilChanged(), operators_1.switchMap(function (key) {\n      return _this._navigator.moveToKey$(key).pipe(operators_1.catchError(function (e) {\n        return rxjs_1.empty();\n      }));\n    })).subscribe();\n    this._setSequenceGraphModeSubscription = this._sequenceDOMRenderer.changingPositionChanged$.pipe(operators_1.filter(function (changing) {\n      return changing;\n    })).subscribe(function () {\n      _this._navigator.graphService.setGraphMode(Graph_1.GraphMode.Sequence);\n    });\n    this._setSpatialGraphModeSubscription = this._sequenceDOMRenderer.changingPositionChanged$.pipe(operators_1.filter(function (changing) {\n      return !changing;\n    })).subscribe(function () {\n      _this._navigator.graphService.setGraphMode(Graph_1.GraphMode.Spatial);\n    });\n\n    this._navigator.graphService.graphMode$.pipe(operators_1.switchMap(function (mode) {\n      return mode === Graph_1.GraphMode.Spatial ? _this._navigator.stateService.currentNode$.pipe(operators_1.take(2)) : rxjs_1.empty();\n    }), operators_1.filter(function (node) {\n      return !node.spatialEdges.cached;\n    }), operators_1.switchMap(function (node) {\n      return _this._navigator.graphService.cacheNode$(node.key).pipe(operators_1.catchError(function (e) {\n        return rxjs_1.empty();\n      }));\n    })).subscribe();\n\n    this._stopSubscription = this._sequenceDOMRenderer.changingPositionChanged$.pipe(operators_1.filter(function (changing) {\n      return changing;\n    })).subscribe(function () {\n      _this._navigator.playService.stop();\n    });\n    this._cacheSequenceNodesSubscription = rxjs_1.combineLatest(this._navigator.graphService.graphMode$, this._sequenceDOMRenderer.changingPositionChanged$.pipe(operators_1.startWith(false), operators_1.distinctUntilChanged())).pipe(operators_1.withLatestFrom(this._navigator.stateService.currentNode$), operators_1.switchMap(function (_a) {\n      var _b = _a[0],\n          mode = _b[0],\n          changing = _b[1],\n          node = _a[1];\n      return changing && mode === Graph_1.GraphMode.Sequence ? _this._navigator.graphService.cacheSequenceNodes$(node.sequenceKey, node.key).pipe(operators_1.retry(3), operators_1.catchError(function (error) {\n        console.error(\"Failed to cache sequence nodes.\", error);\n        return rxjs_1.empty();\n      })) : rxjs_1.empty();\n    })).subscribe();\n    var position$ = sequence$.pipe(operators_1.switchMap(function (sequence) {\n      if (!sequence) {\n        return rxjs_1.of({\n          index: null,\n          max: null\n        });\n      }\n\n      var firstCurrentKey = true;\n      return _this._sequenceDOMRenderer.changingPositionChanged$.pipe(operators_1.startWith(false), operators_1.distinctUntilChanged(), operators_1.switchMap(function (changingPosition) {\n        var skipCount = !changingPosition && firstCurrentKey ? 0 : 1;\n        firstCurrentKey = false;\n        return changingPosition ? rendererKey$ : _this._navigator.stateService.currentNode$.pipe(operators_1.map(function (node) {\n          return node.key;\n        }), operators_1.distinctUntilChanged(), operators_1.skip(skipCount));\n      }), operators_1.map(function (key) {\n        var index = sequence.keys.indexOf(key);\n\n        if (index === -1) {\n          return {\n            index: null,\n            max: null\n          };\n        }\n\n        return {\n          index: index,\n          max: sequence.keys.length - 1\n        };\n      }));\n    }));\n    this._renderSubscription = rxjs_1.combineLatest(edgeStatus$, this._configuration$, this._containerWidth$, this._sequenceDOMRenderer.changed$.pipe(operators_1.startWith(this._sequenceDOMRenderer)), this._navigator.playService.speed$, position$).pipe(operators_1.map(function (_a) {\n      var edgeStatus = _a[0],\n          configuration = _a[1],\n          containerWidth = _a[2],\n          renderer = _a[3],\n          speed = _a[4],\n          position = _a[5];\n\n      var vNode = _this._sequenceDOMRenderer.render(edgeStatus, configuration, containerWidth, speed, position.index, position.max, _this, _this._navigator);\n\n      return {\n        name: _this._name,\n        vnode: vNode\n      };\n    })).subscribe(this._container.domRenderer.render$);\n    this._setSpeedSubscription = this._sequenceDOMRenderer.speed$.subscribe(function (speed) {\n      _this._navigator.playService.setSpeed(speed);\n    });\n    this._setDirectionSubscription = this._configuration$.pipe(operators_1.map(function (configuration) {\n      return configuration.direction;\n    }), operators_1.distinctUntilChanged()).subscribe(function (direction) {\n      _this._navigator.playService.setDirection(direction);\n    });\n    this._containerWidthSubscription = rxjs_1.combineLatest(this._container.renderService.size$, this._configuration$.pipe(operators_1.distinctUntilChanged(function (value1, value2) {\n      return value1[0] === value2[0] && value1[1] === value2[1];\n    }, function (configuration) {\n      return [configuration.minWidth, configuration.maxWidth];\n    }))).pipe(operators_1.map(function (_a) {\n      var size = _a[0],\n          configuration = _a[1];\n      return _this._sequenceDOMRenderer.getContainerWidth(size, configuration);\n    })).subscribe(this._containerWidth$);\n    this._playingSubscription = this._configuration$.pipe(operators_1.map(function (configuration) {\n      return configuration.playing;\n    }), operators_1.distinctUntilChanged()).subscribe(function (playing) {\n      if (playing) {\n        _this._navigator.playService.play();\n      } else {\n        _this._navigator.playService.stop();\n      }\n    });\n    this._hoveredKeySubscription = this._sequenceDOMRenderer.mouseEnterDirection$.pipe(operators_1.switchMap(function (direction) {\n      var edgeTo$ = edgeStatus$.pipe(operators_1.map(function (edgeStatus) {\n        for (var _i = 0, _a = edgeStatus.edges; _i < _a.length; _i++) {\n          var edge = _a[_i];\n\n          if (edge.data.direction === direction) {\n            return edge.to;\n          }\n        }\n\n        return null;\n      }), operators_1.takeUntil(_this._sequenceDOMRenderer.mouseLeaveDirection$));\n      return rxjs_1.concat(edgeTo$, rxjs_1.of(null));\n    }), operators_1.distinctUntilChanged()).subscribe(this._hoveredKeySubject$);\n    this._emitHoveredKeySubscription = this._hoveredKey$.subscribe(function (key) {\n      _this.fire(SequenceComponent.hoveredkeychanged, key);\n    });\n  };\n\n  SequenceComponent.prototype._deactivate = function () {\n    this._emitHoveredKeySubscription.unsubscribe();\n\n    this._renderSubscription.unsubscribe();\n\n    this._playingSubscription.unsubscribe();\n\n    this._containerWidthSubscription.unsubscribe();\n\n    this._hoveredKeySubscription.unsubscribe();\n\n    this._setSpeedSubscription.unsubscribe();\n\n    this._setDirectionSubscription.unsubscribe();\n\n    this._setSequenceGraphModeSubscription.unsubscribe();\n\n    this._setSpatialGraphModeSubscription.unsubscribe();\n\n    this._sequenceSubscription.unsubscribe();\n\n    this._moveSubscription.unsubscribe();\n\n    this._cacheSequenceNodesSubscription.unsubscribe();\n\n    this._stopSubscription.unsubscribe();\n\n    this._sequenceDOMRenderer.deactivate();\n  };\n\n  SequenceComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      direction: Edge_1.EdgeDirection.Next,\n      maxWidth: 108,\n      minWidth: 70,\n      playing: false,\n      visible: true\n    };\n  };\n  /** @inheritdoc */\n\n\n  SequenceComponent.componentName = \"sequence\";\n  /**\n   * Event fired when playing starts or stops.\n   *\n   * @event SequenceComponent#playingchanged\n   * @type {boolean} Indicates whether the player is playing.\n   */\n\n  SequenceComponent.playingchanged = \"playingchanged\";\n  /**\n   * Event fired when the hovered key changes.\n   *\n   * @description Emits the key of the node for the direction\n   * arrow that is being hovered. When the mouse leaves a\n   * direction arrow null is emitted.\n   *\n   * @event SequenceComponent#hoveredkeychanged\n   * @type {string} The hovered key, null if no key is hovered.\n   */\n\n  SequenceComponent.hoveredkeychanged = \"hoveredkeychanged\";\n  return SequenceComponent;\n}(Component_1.Component);\n\nexports.SequenceComponent = SequenceComponent;\nComponent_1.ComponentService.register(SequenceComponent);\nexports.default = SequenceComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/sequence/SequenceComponent.ts?");

/***/ }),

/***/ "./src/component/sequence/SequenceDOMRenderer.ts":
/*!*******************************************************!*\
  !*** ./src/component/sequence/SequenceDOMRenderer.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Edge_1 = __webpack_require__(/*! ../../Edge */ \"./src/Edge.ts\");\n\nvar Error_1 = __webpack_require__(/*! ../../Error */ \"./src/Error.ts\");\n\nvar SequenceDOMRenderer =\n/** @class */\nfunction () {\n  function SequenceDOMRenderer(container) {\n    this._container = container;\n    this._minThresholdWidth = 320;\n    this._maxThresholdWidth = 1480;\n    this._minThresholdHeight = 240;\n    this._maxThresholdHeight = 820;\n    this._stepperDefaultWidth = 108;\n    this._controlsDefaultWidth = 88;\n    this._defaultHeight = 30;\n    this._expandControls = false;\n    this._mode = Component_1.SequenceMode.Default;\n    this._speed = 0.5;\n    this._changingSpeed = false;\n    this._index = null;\n    this._changingPosition = false;\n    this._mouseEnterDirection$ = new rxjs_1.Subject();\n    this._mouseLeaveDirection$ = new rxjs_1.Subject();\n    this._notifyChanged$ = new rxjs_1.Subject();\n    this._notifyChangingPositionChanged$ = new rxjs_1.Subject();\n    this._notifySpeedChanged$ = new rxjs_1.Subject();\n    this._notifyIndexChanged$ = new rxjs_1.Subject();\n  }\n\n  Object.defineProperty(SequenceDOMRenderer.prototype, \"changed$\", {\n    get: function get() {\n      return this._notifyChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SequenceDOMRenderer.prototype, \"changingPositionChanged$\", {\n    get: function get() {\n      return this._notifyChangingPositionChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SequenceDOMRenderer.prototype, \"speed$\", {\n    get: function get() {\n      return this._notifySpeedChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SequenceDOMRenderer.prototype, \"index$\", {\n    get: function get() {\n      return this._notifyIndexChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SequenceDOMRenderer.prototype, \"mouseEnterDirection$\", {\n    get: function get() {\n      return this._mouseEnterDirection$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SequenceDOMRenderer.prototype, \"mouseLeaveDirection$\", {\n    get: function get() {\n      return this._mouseLeaveDirection$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SequenceDOMRenderer.prototype.activate = function () {\n    var _this = this;\n\n    if (!!this._changingSubscription) {\n      return;\n    }\n\n    this._changingSubscription = rxjs_1.merge(this._container.mouseService.documentMouseUp$, this._container.touchService.touchEnd$.pipe(operators_1.filter(function (touchEvent) {\n      return touchEvent.touches.length === 0;\n    }))).subscribe(function (event) {\n      if (_this._changingSpeed) {\n        _this._changingSpeed = false;\n      }\n\n      if (_this._changingPosition) {\n        _this._setChangingPosition(false);\n      }\n    });\n  };\n\n  SequenceDOMRenderer.prototype.deactivate = function () {\n    if (!this._changingSubscription) {\n      return;\n    }\n\n    this._changingSpeed = false;\n    this._changingPosition = false;\n    this._expandControls = false;\n    this._mode = Component_1.SequenceMode.Default;\n\n    this._changingSubscription.unsubscribe();\n\n    this._changingSubscription = null;\n  };\n\n  SequenceDOMRenderer.prototype.render = function (edgeStatus, configuration, containerWidth, speed, index, max, component, navigator) {\n    if (configuration.visible === false) {\n      return vd.h(\"div.SequenceContainer\", {}, []);\n    }\n\n    var stepper = this._createStepper(edgeStatus, configuration, containerWidth, component, navigator);\n\n    var controls = this._createSequenceControls(containerWidth);\n\n    var playback = this._createPlaybackControls(containerWidth, speed, component, configuration);\n\n    var timeline = this._createTimelineControls(containerWidth, index, max);\n\n    return vd.h(\"div.SequenceContainer\", [stepper, controls, playback, timeline]);\n  };\n\n  SequenceDOMRenderer.prototype.getContainerWidth = function (size, configuration) {\n    var minWidth = configuration.minWidth;\n    var maxWidth = configuration.maxWidth;\n\n    if (maxWidth < minWidth) {\n      maxWidth = minWidth;\n    }\n\n    var relativeWidth = (size.width - this._minThresholdWidth) / (this._maxThresholdWidth - this._minThresholdWidth);\n    var relativeHeight = (size.height - this._minThresholdHeight) / (this._maxThresholdHeight - this._minThresholdHeight);\n    var coeff = Math.max(0, Math.min(1, Math.min(relativeWidth, relativeHeight)));\n    return minWidth + coeff * (maxWidth - minWidth);\n  };\n\n  SequenceDOMRenderer.prototype._createPositionInput = function (index, max) {\n    var _this = this;\n\n    this._index = index;\n\n    var onPosition = function onPosition(e) {\n      _this._index = Number(e.target.value);\n\n      _this._notifyIndexChanged$.next(_this._index);\n    };\n\n    var boundingRect = this._container.domContainer.getBoundingClientRect();\n\n    var width = Math.max(276, Math.min(410, 5 + 0.8 * boundingRect.width)) - 65;\n\n    var onStart = function onStart(e) {\n      e.stopPropagation();\n\n      _this._setChangingPosition(true);\n    };\n\n    var onMove = function onMove(e) {\n      if (_this._changingPosition === true) {\n        e.stopPropagation();\n      }\n    };\n\n    var onKeyDown = function onKeyDown(e) {\n      if (e.key === \"ArrowDown\" || e.key === \"ArrowLeft\" || e.key === \"ArrowRight\" || e.key === \"ArrowUp\") {\n        e.preventDefault();\n      }\n    };\n\n    var positionInputProperties = {\n      max: max != null ? max : 1,\n      min: 0,\n      onchange: onPosition,\n      oninput: onPosition,\n      onkeydown: onKeyDown,\n      onmousedown: onStart,\n      onmousemove: onMove,\n      ontouchmove: onMove,\n      ontouchstart: onStart,\n      style: {\n        width: width + \"px\"\n      },\n      type: \"range\",\n      value: index != null ? index : 0\n    };\n    var disabled = index == null || max == null || max <= 1;\n\n    if (disabled) {\n      positionInputProperties.disabled = \"true\";\n    }\n\n    var positionInput = vd.h(\"input.SequencePosition\", positionInputProperties, []);\n    var positionContainerClass = disabled ? \".SequencePositionContainerDisabled\" : \".SequencePositionContainer\";\n    return vd.h(\"div\" + positionContainerClass, [positionInput]);\n  };\n\n  SequenceDOMRenderer.prototype._createSpeedInput = function (speed) {\n    var _this = this;\n\n    this._speed = speed;\n\n    var onSpeed = function onSpeed(e) {\n      _this._speed = Number(e.target.value) / 1000;\n\n      _this._notifySpeedChanged$.next(_this._speed);\n    };\n\n    var boundingRect = this._container.domContainer.getBoundingClientRect();\n\n    var width = Math.max(276, Math.min(410, 5 + 0.8 * boundingRect.width)) - 160;\n\n    var onStart = function onStart(e) {\n      _this._changingSpeed = true;\n      e.stopPropagation();\n    };\n\n    var onMove = function onMove(e) {\n      if (_this._changingSpeed === true) {\n        e.stopPropagation();\n      }\n    };\n\n    var onKeyDown = function onKeyDown(e) {\n      if (e.key === \"ArrowDown\" || e.key === \"ArrowLeft\" || e.key === \"ArrowRight\" || e.key === \"ArrowUp\") {\n        e.preventDefault();\n      }\n    };\n\n    var speedInput = vd.h(\"input.SequenceSpeed\", {\n      max: 1000,\n      min: 0,\n      onchange: onSpeed,\n      oninput: onSpeed,\n      onkeydown: onKeyDown,\n      onmousedown: onStart,\n      onmousemove: onMove,\n      ontouchmove: onMove,\n      ontouchstart: onStart,\n      style: {\n        width: width + \"px\"\n      },\n      type: \"range\",\n      value: 1000 * speed\n    }, []);\n    return vd.h(\"div.SequenceSpeedContainer\", [speedInput]);\n  };\n\n  SequenceDOMRenderer.prototype._createPlaybackControls = function (containerWidth, speed, component, configuration) {\n    var _this = this;\n\n    if (this._mode !== Component_1.SequenceMode.Playback) {\n      return vd.h(\"div.SequencePlayback\", []);\n    }\n\n    var switchIcon = vd.h(\"div.SequenceSwitchIcon.SequenceIconVisible\", []);\n    var direction = configuration.direction === Edge_1.EdgeDirection.Next ? Edge_1.EdgeDirection.Prev : Edge_1.EdgeDirection.Next;\n    var playing = configuration.playing;\n    var switchButtonProperties = {\n      onclick: function onclick() {\n        if (!playing) {\n          component.setDirection(direction);\n        }\n      }\n    };\n    var switchButtonClassName = configuration.playing ? \".SequenceSwitchButtonDisabled\" : \".SequenceSwitchButton\";\n    var switchButton = vd.h(\"div\" + switchButtonClassName, switchButtonProperties, [switchIcon]);\n    var slowIcon = vd.h(\"div.SequenceSlowIcon.SequenceIconVisible\", []);\n    var slowContainer = vd.h(\"div.SequenceSlowContainer\", [slowIcon]);\n    var fastIcon = vd.h(\"div.SequenceFastIcon.SequenceIconVisible\", []);\n    var fastContainer = vd.h(\"div.SequenceFastContainer\", [fastIcon]);\n    var closeIcon = vd.h(\"div.SequenceCloseIcon.SequenceIconVisible\", []);\n    var closeButtonProperties = {\n      onclick: function onclick() {\n        _this._mode = Component_1.SequenceMode.Default;\n\n        _this._notifyChanged$.next(_this);\n      }\n    };\n    var closeButton = vd.h(\"div.SequenceCloseButton\", closeButtonProperties, [closeIcon]);\n\n    var speedInput = this._createSpeedInput(speed);\n\n    var playbackChildren = [switchButton, slowContainer, speedInput, fastContainer, closeButton];\n    var top = Math.round(containerWidth / this._stepperDefaultWidth * this._defaultHeight + 10);\n    var playbackProperties = {\n      style: {\n        top: top + \"px\"\n      }\n    };\n    return vd.h(\"div.SequencePlayback\", playbackProperties, playbackChildren);\n  };\n\n  SequenceDOMRenderer.prototype._createPlayingButton = function (nextKey, prevKey, configuration, component) {\n    var canPlay = configuration.direction === Edge_1.EdgeDirection.Next && nextKey != null || configuration.direction === Edge_1.EdgeDirection.Prev && prevKey != null;\n    var onclick = configuration.playing ? function (e) {\n      component.stop();\n    } : canPlay ? function (e) {\n      component.play();\n    } : null;\n    var buttonProperties = {\n      onclick: onclick\n    };\n    var iconClass = configuration.playing ? \"Stop\" : canPlay ? \"Play\" : \"PlayDisabled\";\n    var iconProperties = {\n      className: iconClass\n    };\n\n    if (configuration.direction === Edge_1.EdgeDirection.Prev) {\n      iconProperties.style = {\n        transform: \"rotate(180deg) translate(50%, 50%)\"\n      };\n    }\n\n    var icon = vd.h(\"div.SequenceComponentIcon\", iconProperties, []);\n    var buttonClass = canPlay ? \"SequencePlay\" : \"SequencePlayDisabled\";\n    return vd.h(\"div.\" + buttonClass, buttonProperties, [icon]);\n  };\n\n  SequenceDOMRenderer.prototype._createSequenceControls = function (containerWidth) {\n    var _this = this;\n\n    var borderRadius = Math.round(8 / this._stepperDefaultWidth * containerWidth);\n    var expanderProperties = {\n      onclick: function onclick() {\n        _this._expandControls = !_this._expandControls;\n        _this._mode = Component_1.SequenceMode.Default;\n\n        _this._notifyChanged$.next(_this);\n      },\n      style: {\n        \"border-bottom-right-radius\": borderRadius + \"px\",\n        \"border-top-right-radius\": borderRadius + \"px\"\n      }\n    };\n    var expanderBar = vd.h(\"div.SequenceExpanderBar\", []);\n    var expander = vd.h(\"div.SequenceExpanderButton\", expanderProperties, [expanderBar]);\n    var fastIconClassName = this._mode === Component_1.SequenceMode.Playback ? \".SequenceFastIconGrey.SequenceIconVisible\" : \".SequenceFastIcon\";\n    var fastIcon = vd.h(\"div\" + fastIconClassName, []);\n    var playbackProperties = {\n      onclick: function onclick() {\n        _this._mode = _this._mode === Component_1.SequenceMode.Playback ? Component_1.SequenceMode.Default : Component_1.SequenceMode.Playback;\n\n        _this._notifyChanged$.next(_this);\n      }\n    };\n    var playback = vd.h(\"div.SequencePlaybackButton\", playbackProperties, [fastIcon]);\n    var timelineIconClassName = this._mode === Component_1.SequenceMode.Timeline ? \".SequenceTimelineIconGrey.SequenceIconVisible\" : \".SequenceTimelineIcon\";\n    var timelineIcon = vd.h(\"div\" + timelineIconClassName, []);\n    var timelineProperties = {\n      onclick: function onclick() {\n        _this._mode = _this._mode === Component_1.SequenceMode.Timeline ? Component_1.SequenceMode.Default : Component_1.SequenceMode.Timeline;\n\n        _this._notifyChanged$.next(_this);\n      }\n    };\n    var timeline = vd.h(\"div.SequenceTimelineButton\", timelineProperties, [timelineIcon]);\n    var properties = {\n      style: {\n        height: this._defaultHeight / this._stepperDefaultWidth * containerWidth + \"px\",\n        transform: \"translate(\" + (containerWidth / 2 + 2) + \"px, 0)\",\n        width: this._controlsDefaultWidth / this._stepperDefaultWidth * containerWidth + \"px\"\n      }\n    };\n    var className = \".SequenceControls\" + (this._expandControls ? \".SequenceControlsExpanded\" : \"\");\n    return vd.h(\"div\" + className, properties, [playback, timeline, expander]);\n  };\n\n  SequenceDOMRenderer.prototype._createSequenceArrows = function (nextKey, prevKey, containerWidth, configuration, navigator) {\n    var _this = this;\n\n    var nextProperties = {\n      onclick: nextKey != null ? function (e) {\n        navigator.moveDir$(Edge_1.EdgeDirection.Next).subscribe(undefined, function (error) {\n          if (!(error instanceof Error_1.AbortMapillaryError)) {\n            console.error(error);\n          }\n        });\n      } : null,\n      onmouseenter: function onmouseenter(e) {\n        _this._mouseEnterDirection$.next(Edge_1.EdgeDirection.Next);\n      },\n      onmouseleave: function onmouseleave(e) {\n        _this._mouseLeaveDirection$.next(Edge_1.EdgeDirection.Next);\n      }\n    };\n    var borderRadius = Math.round(8 / this._stepperDefaultWidth * containerWidth);\n    var prevProperties = {\n      onclick: prevKey != null ? function (e) {\n        navigator.moveDir$(Edge_1.EdgeDirection.Prev).subscribe(undefined, function (error) {\n          if (!(error instanceof Error_1.AbortMapillaryError)) {\n            console.error(error);\n          }\n        });\n      } : null,\n      onmouseenter: function onmouseenter(e) {\n        _this._mouseEnterDirection$.next(Edge_1.EdgeDirection.Prev);\n      },\n      onmouseleave: function onmouseleave(e) {\n        _this._mouseLeaveDirection$.next(Edge_1.EdgeDirection.Prev);\n      },\n      style: {\n        \"border-bottom-left-radius\": borderRadius + \"px\",\n        \"border-top-left-radius\": borderRadius + \"px\"\n      }\n    };\n\n    var nextClass = this._getStepClassName(Edge_1.EdgeDirection.Next, nextKey, configuration.highlightKey);\n\n    var prevClass = this._getStepClassName(Edge_1.EdgeDirection.Prev, prevKey, configuration.highlightKey);\n\n    var nextIcon = vd.h(\"div.SequenceComponentIcon\", []);\n    var prevIcon = vd.h(\"div.SequenceComponentIcon\", []);\n    return [vd.h(\"div.\" + prevClass, prevProperties, [prevIcon]), vd.h(\"div.\" + nextClass, nextProperties, [nextIcon])];\n  };\n\n  SequenceDOMRenderer.prototype._createStepper = function (edgeStatus, configuration, containerWidth, component, navigator) {\n    var nextKey = null;\n    var prevKey = null;\n\n    for (var _i = 0, _a = edgeStatus.edges; _i < _a.length; _i++) {\n      var edge = _a[_i];\n\n      if (edge.data.direction === Edge_1.EdgeDirection.Next) {\n        nextKey = edge.to;\n      }\n\n      if (edge.data.direction === Edge_1.EdgeDirection.Prev) {\n        prevKey = edge.to;\n      }\n    }\n\n    var playingButton = this._createPlayingButton(nextKey, prevKey, configuration, component);\n\n    var buttons = this._createSequenceArrows(nextKey, prevKey, containerWidth, configuration, navigator);\n\n    buttons.splice(1, 0, playingButton);\n    var containerProperties = {\n      oncontextmenu: function oncontextmenu(event) {\n        event.preventDefault();\n      },\n      style: {\n        height: this._defaultHeight / this._stepperDefaultWidth * containerWidth + \"px\",\n        width: containerWidth + \"px\"\n      }\n    };\n    return vd.h(\"div.SequenceStepper\", containerProperties, buttons);\n  };\n\n  SequenceDOMRenderer.prototype._createTimelineControls = function (containerWidth, index, max) {\n    var _this = this;\n\n    if (this._mode !== Component_1.SequenceMode.Timeline) {\n      return vd.h(\"div.SequenceTimeline\", []);\n    }\n\n    var positionInput = this._createPositionInput(index, max);\n\n    var closeIcon = vd.h(\"div.SequenceCloseIcon.SequenceIconVisible\", []);\n    var closeButtonProperties = {\n      onclick: function onclick() {\n        _this._mode = Component_1.SequenceMode.Default;\n\n        _this._notifyChanged$.next(_this);\n      }\n    };\n    var closeButton = vd.h(\"div.SequenceCloseButton\", closeButtonProperties, [closeIcon]);\n    var top = Math.round(containerWidth / this._stepperDefaultWidth * this._defaultHeight + 10);\n    var playbackProperties = {\n      style: {\n        top: top + \"px\"\n      }\n    };\n    return vd.h(\"div.SequenceTimeline\", playbackProperties, [positionInput, closeButton]);\n  };\n\n  SequenceDOMRenderer.prototype._getStepClassName = function (direction, key, highlightKey) {\n    var className = direction === Edge_1.EdgeDirection.Next ? \"SequenceStepNext\" : \"SequenceStepPrev\";\n\n    if (key == null) {\n      className += \"Disabled\";\n    } else {\n      if (highlightKey === key) {\n        className += \"Highlight\";\n      }\n    }\n\n    return className;\n  };\n\n  SequenceDOMRenderer.prototype._setChangingPosition = function (value) {\n    this._changingPosition = value;\n\n    this._notifyChangingPositionChanged$.next(value);\n  };\n\n  return SequenceDOMRenderer;\n}();\n\nexports.SequenceDOMRenderer = SequenceDOMRenderer;\nexports.default = SequenceDOMRenderer;\n\n//# sourceURL=webpack://Mapillary/./src/component/sequence/SequenceDOMRenderer.ts?");

/***/ }),

/***/ "./src/component/sequence/SequenceMode.ts":
/*!************************************************!*\
  !*** ./src/component/sequence/SequenceMode.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar SequenceMode;\n\n(function (SequenceMode) {\n  SequenceMode[SequenceMode[\"Default\"] = 0] = \"Default\";\n  SequenceMode[SequenceMode[\"Playback\"] = 1] = \"Playback\";\n  SequenceMode[SequenceMode[\"Timeline\"] = 2] = \"Timeline\";\n})(SequenceMode = exports.SequenceMode || (exports.SequenceMode = {}));\n\nexports.default = SequenceMode;\n\n//# sourceURL=webpack://Mapillary/./src/component/sequence/SequenceMode.ts?");

/***/ }),

/***/ "./src/component/shaders/Shaders.ts":
/*!******************************************!*\
  !*** ./src/component/shaders/Shaders.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar path = __webpack_require__(/*! path */ \"./node_modules/node-libs-browser/node_modules/path-browserify/index.js\");\n\nvar Shaders =\n/** @class */\nfunction () {\n  function Shaders() {}\n\n  Shaders.equirectangular = {\n    fragment: fs.readFileSync(path.join(__dirname, \"./equirectangular.fragment.glsl\"), \"utf8\"),\n    vertex: fs.readFileSync(path.join(__dirname, \"./equirectangular.vertex.glsl\"), \"utf8\")\n  };\n  Shaders.equirectangularCurtain = {\n    fragment: fs.readFileSync(path.join(__dirname, \"./equirectangular_curtain.fragment.glsl\"), \"utf8\"),\n    vertex: fs.readFileSync(path.join(__dirname, \"./equirectangular_curtain.vertex.glsl\"), \"utf8\")\n  };\n  Shaders.perspective = {\n    fragment: fs.readFileSync(path.join(__dirname, \"./perspective.fragment.glsl\"), \"utf8\"),\n    vertex: fs.readFileSync(path.join(__dirname, \"./perspective.vertex.glsl\"), \"utf8\")\n  };\n  Shaders.perspectiveCurtain = {\n    fragment: fs.readFileSync(path.join(__dirname, \"./perspective_curtain.fragment.glsl\"), \"utf8\"),\n    vertex: fs.readFileSync(path.join(__dirname, \"./perspective_curtain.vertex.glsl\"), \"utf8\")\n  };\n  Shaders.fisheye = {\n    fragment: fs.readFileSync(path.join(__dirname, \"./fisheye.fragment.glsl\"), \"utf8\"),\n    vertex: fs.readFileSync(path.join(__dirname, \"./fisheye.vertex.glsl\"), \"utf8\")\n  };\n  Shaders.fisheyeCurtain = {\n    fragment: fs.readFileSync(path.join(__dirname, \"./fisheye_curtain.fragment.glsl\"), \"utf8\"),\n    vertex: fs.readFileSync(path.join(__dirname, \"./fisheye_curtain.vertex.glsl\"), \"utf8\")\n  };\n  Shaders.perspectiveDistorted = {\n    fragment: fs.readFileSync(path.join(__dirname, \"./perspective_distorted.fragment.glsl\"), \"utf8\"),\n    vertex: fs.readFileSync(path.join(__dirname, \"./perspective_distorted.vertex.glsl\"), \"utf8\")\n  };\n  Shaders.perspectiveDistortedCurtain = {\n    fragment: fs.readFileSync(path.join(__dirname, \"./perspective_distorted_curtain.fragment.glsl\"), \"utf8\"),\n    vertex: fs.readFileSync(path.join(__dirname, \"./perspective_distorted_curtain.vertex.glsl\"), \"utf8\")\n  };\n  return Shaders;\n}();\n\nexports.Shaders = Shaders;\n\n//# sourceURL=webpack://Mapillary/./src/component/shaders/Shaders.ts?");

/***/ }),

/***/ "./src/component/slider/SliderComponent.ts":
/*!*************************************************!*\
  !*** ./src/component/slider/SliderComponent.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n\nvar State_1 = __webpack_require__(/*! ../../State */ \"./src/State.ts\");\n\nvar Render_1 = __webpack_require__(/*! ../../Render */ \"./src/Render.ts\");\n\nvar Tiles_1 = __webpack_require__(/*! ../../Tiles */ \"./src/Tiles.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../../Utils */ \"./src/Utils.ts\");\n/**\n * @class SliderComponent\n *\n * @classdesc Component for comparing pairs of images. Renders\n * a slider for adjusting the curtain of the first image.\n *\n * Deactivate the sequence, direction and image plane\n * components when activating the slider component to avoid\n * interfering UI elements.\n *\n * To retrive and use the slider component\n *\n * @example\n * ```\n * var viewer = new Mapillary.Viewer(\n *     \"<element-id>\",\n *     \"<client-id>\",\n *     \"<my key>\");\n *\n * viewer.deactivateComponent(\"imagePlane\");\n * viewer.deactivateComponent(\"direction\");\n * viewer.deactivateComponent(\"sequence\");\n *\n * viewer.activateComponent(\"slider\");\n *\n * var sliderComponent = viewer.getComponent(\"slider\");\n * ```\n */\n\n\nvar SliderComponent =\n/** @class */\nfunction (_super) {\n  __extends(SliderComponent, _super);\n  /** @ignore */\n\n\n  function SliderComponent(name, container, navigator, viewportCoords) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._viewportCoords = !!viewportCoords ? viewportCoords : new Geo_1.ViewportCoords();\n    _this._domRenderer = new Component_1.SliderDOMRenderer(container);\n    _this._imageTileLoader = new Tiles_1.ImageTileLoader(Utils_1.Urls.tileScheme, Utils_1.Urls.tileDomain, Utils_1.Urls.origin);\n    _this._roiCalculator = new Tiles_1.RegionOfInterestCalculator();\n    _this._spatial = new Geo_1.Spatial();\n    _this._glRendererOperation$ = new rxjs_1.Subject();\n    _this._glRendererCreator$ = new rxjs_1.Subject();\n    _this._glRendererDisposer$ = new rxjs_1.Subject();\n    _this._glRenderer$ = _this._glRendererOperation$.pipe(operators_1.scan(function (glRenderer, operation) {\n      return operation(glRenderer);\n    }, null), operators_1.filter(function (glRenderer) {\n      return glRenderer != null;\n    }), operators_1.distinctUntilChanged(undefined, function (glRenderer) {\n      return glRenderer.frameId;\n    }));\n\n    _this._glRendererCreator$.pipe(operators_1.map(function () {\n      return function (glRenderer) {\n        if (glRenderer != null) {\n          throw new Error(\"Multiple slider states can not be created at the same time\");\n        }\n\n        return new Component_1.SliderGLRenderer();\n      };\n    })).subscribe(_this._glRendererOperation$);\n\n    _this._glRendererDisposer$.pipe(operators_1.map(function () {\n      return function (glRenderer) {\n        glRenderer.dispose();\n        return null;\n      };\n    })).subscribe(_this._glRendererOperation$);\n\n    return _this;\n  }\n  /**\n   * Set the initial position.\n   *\n   * @description Configures the intial position of the slider.\n   * The inital position value will be used when the component\n   * is activated.\n   *\n   * @param {number} initialPosition - Initial slider position.\n   */\n\n\n  SliderComponent.prototype.setInitialPosition = function (initialPosition) {\n    this.configure({\n      initialPosition: initialPosition\n    });\n  };\n  /**\n   * Set the image keys.\n   *\n   * @description Configures the component to show the image\n   * planes for the supplied image keys.\n   *\n   * @param {ISliderKeys} keys - Slider keys object specifying\n   * the images to be shown in the foreground and the background.\n   */\n\n\n  SliderComponent.prototype.setKeys = function (keys) {\n    this.configure({\n      keys: keys\n    });\n  };\n  /**\n   * Set the slider mode.\n   *\n   * @description Configures the mode for transitions between\n   * image pairs.\n   *\n   * @param {SliderMode} mode - Slider mode to be set.\n   */\n\n\n  SliderComponent.prototype.setSliderMode = function (mode) {\n    this.configure({\n      mode: mode\n    });\n  };\n  /**\n   * Set the value controlling if the slider is visible.\n   *\n   * @param {boolean} sliderVisible - Value indicating if\n   * the slider should be visible or not.\n   */\n\n\n  SliderComponent.prototype.setSliderVisible = function (sliderVisible) {\n    this.configure({\n      sliderVisible: sliderVisible\n    });\n  };\n\n  SliderComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._modeSubcription = this._domRenderer.mode$.subscribe(function (mode) {\n      _this.setSliderMode(mode);\n    });\n    this._glRenderSubscription = this._glRenderer$.pipe(operators_1.map(function (glRenderer) {\n      var renderHash = {\n        name: _this._name,\n        render: {\n          frameId: glRenderer.frameId,\n          needsRender: glRenderer.needsRender,\n          render: glRenderer.render.bind(glRenderer),\n          stage: Render_1.GLRenderStage.Background\n        }\n      };\n      return renderHash;\n    })).subscribe(this._container.glRenderer.render$);\n    var position$ = rxjs_1.concat(this.configuration$.pipe(operators_1.map(function (configuration) {\n      return configuration.initialPosition != null ? configuration.initialPosition : 1;\n    }), operators_1.first()), this._domRenderer.position$);\n    var mode$ = this.configuration$.pipe(operators_1.map(function (configuration) {\n      return configuration.mode;\n    }), operators_1.distinctUntilChanged());\n\n    var motionless$ = this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      return frame.state.motionless;\n    }), operators_1.distinctUntilChanged());\n\n    var fullPano$ = this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      return frame.state.currentNode.fullPano;\n    }), operators_1.distinctUntilChanged());\n\n    var sliderVisible$ = rxjs_1.combineLatest(this._configuration$.pipe(operators_1.map(function (configuration) {\n      return configuration.sliderVisible;\n    })), this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      return !(frame.state.currentNode == null || frame.state.previousNode == null || frame.state.currentNode.pano && !frame.state.currentNode.fullPano || frame.state.previousNode.pano && !frame.state.previousNode.fullPano || frame.state.currentNode.fullPano && !frame.state.previousNode.fullPano);\n    }), operators_1.distinctUntilChanged())).pipe(operators_1.map(function (_a) {\n      var sliderVisible = _a[0],\n          enabledState = _a[1];\n      return sliderVisible && enabledState;\n    }), operators_1.distinctUntilChanged());\n    this._waitSubscription = rxjs_1.combineLatest(mode$, motionless$, fullPano$, sliderVisible$).pipe(operators_1.withLatestFrom(this._navigator.stateService.state$)).subscribe(function (_a) {\n      var _b = _a[0],\n          mode = _b[0],\n          motionless = _b[1],\n          fullPano = _b[2],\n          sliderVisible = _b[3],\n          state = _a[1];\n      var interactive = sliderVisible && (motionless || mode === Component_1.SliderMode.Stationary || fullPano);\n\n      if (interactive && state !== State_1.State.WaitingInteractively) {\n        _this._navigator.stateService.waitInteractively();\n      } else if (!interactive && state !== State_1.State.Waiting) {\n        _this._navigator.stateService.wait();\n      }\n    });\n    this._moveSubscription = rxjs_1.combineLatest(position$, mode$, motionless$, fullPano$, sliderVisible$).subscribe(function (_a) {\n      var position = _a[0],\n          mode = _a[1],\n          motionless = _a[2],\n          fullPano = _a[3],\n          sliderVisible = _a[4];\n\n      if (motionless || mode === Component_1.SliderMode.Stationary || fullPano) {\n        _this._navigator.stateService.moveTo(1);\n      } else {\n        _this._navigator.stateService.moveTo(position);\n      }\n    });\n    this._domRenderSubscription = rxjs_1.combineLatest(position$, mode$, motionless$, fullPano$, sliderVisible$, this._container.renderService.size$).pipe(operators_1.map(function (_a) {\n      var position = _a[0],\n          mode = _a[1],\n          motionless = _a[2],\n          fullPano = _a[3],\n          sliderVisible = _a[4],\n          size = _a[5];\n      return {\n        name: _this._name,\n        vnode: _this._domRenderer.render(position, mode, motionless, fullPano, sliderVisible)\n      };\n    })).subscribe(this._container.domRenderer.render$);\n\n    this._glRendererCreator$.next(null);\n\n    this._updateCurtainSubscription = rxjs_1.combineLatest(position$, fullPano$, sliderVisible$, this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$).pipe(operators_1.map(function (_a) {\n      var position = _a[0],\n          fullPano = _a[1],\n          visible = _a[2],\n          render = _a[3],\n          transform = _a[4];\n\n      if (!fullPano) {\n        return visible ? position : 1;\n      }\n\n      var basicMin = _this._viewportCoords.viewportToBasic(-1.15, 0, transform, render.perspective);\n\n      var basicMax = _this._viewportCoords.viewportToBasic(1.15, 0, transform, render.perspective);\n\n      var shiftedMax = basicMax[0] < basicMin[0] ? basicMax[0] + 1 : basicMax[0];\n      var basicPosition = basicMin[0] + position * (shiftedMax - basicMin[0]);\n      return basicPosition > 1 ? basicPosition - 1 : basicPosition;\n    }), operators_1.map(function (position) {\n      return function (glRenderer) {\n        glRenderer.updateCurtain(position);\n        return glRenderer;\n      };\n    })).subscribe(this._glRendererOperation$);\n    this._stateSubscription = rxjs_1.combineLatest(this._navigator.stateService.currentState$, mode$).pipe(operators_1.map(function (_a) {\n      var frame = _a[0],\n          mode = _a[1];\n      return function (glRenderer) {\n        glRenderer.update(frame, mode);\n        return glRenderer;\n      };\n    })).subscribe(this._glRendererOperation$);\n    this._setKeysSubscription = this._configuration$.pipe(operators_1.filter(function (configuration) {\n      return configuration.keys != null;\n    }), operators_1.switchMap(function (configuration) {\n      return rxjs_1.zip(rxjs_1.zip(_this._catchCacheNode$(configuration.keys.background), _this._catchCacheNode$(configuration.keys.foreground)).pipe(operators_1.map(function (nodes) {\n        return {\n          background: nodes[0],\n          foreground: nodes[1]\n        };\n      })), _this._navigator.stateService.currentState$.pipe(operators_1.first())).pipe(operators_1.map(function (nf) {\n        return {\n          nodes: nf[0],\n          state: nf[1].state\n        };\n      }));\n    })).subscribe(function (co) {\n      if (co.state.currentNode != null && co.state.previousNode != null && co.state.currentNode.key === co.nodes.foreground.key && co.state.previousNode.key === co.nodes.background.key) {\n        return;\n      }\n\n      if (co.state.currentNode.key === co.nodes.background.key) {\n        _this._navigator.stateService.setNodes([co.nodes.foreground]);\n\n        return;\n      }\n\n      if (co.state.currentNode.key === co.nodes.foreground.key && co.state.trajectory.length === 1) {\n        _this._navigator.stateService.prependNodes([co.nodes.background]);\n\n        return;\n      }\n\n      _this._navigator.stateService.setNodes([co.nodes.background]);\n\n      _this._navigator.stateService.setNodes([co.nodes.foreground]);\n    }, function (e) {\n      console.error(e);\n    });\n\n    var previousNode$ = this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      return frame.state.previousNode;\n    }), operators_1.filter(function (node) {\n      return node != null;\n    }), operators_1.distinctUntilChanged(undefined, function (node) {\n      return node.key;\n    }));\n\n    var textureProvider$ = this._navigator.stateService.currentState$.pipe(operators_1.distinctUntilChanged(undefined, function (frame) {\n      return frame.state.currentNode.key;\n    }), operators_1.withLatestFrom(this._container.glRenderer.webGLRenderer$, this._container.renderService.size$), operators_1.map(function (_a) {\n      var frame = _a[0],\n          renderer = _a[1],\n          size = _a[2];\n      var state = frame.state;\n      var viewportSize = Math.max(size.width, size.height);\n      var currentNode = state.currentNode;\n      var currentTransform = state.currentTransform;\n      var tileSize = viewportSize > 2048 ? 2048 : viewportSize > 1024 ? 1024 : 512;\n      return new Tiles_1.TextureProvider(currentNode.key, currentTransform.basicWidth, currentTransform.basicHeight, tileSize, currentNode.image, _this._imageTileLoader, new Tiles_1.ImageTileStore(), renderer);\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._textureProviderSubscription = textureProvider$.subscribe(function () {});\n    this._setTextureProviderSubscription = textureProvider$.pipe(operators_1.map(function (provider) {\n      return function (renderer) {\n        renderer.setTextureProvider(provider.key, provider);\n        return renderer;\n      };\n    })).subscribe(this._glRendererOperation$);\n    this._setTileSizeSubscription = this._container.renderService.size$.pipe(operators_1.switchMap(function (size) {\n      return rxjs_1.combineLatest(textureProvider$, rxjs_1.of(size)).pipe(operators_1.first());\n    })).subscribe(function (_a) {\n      var provider = _a[0],\n          size = _a[1];\n      var viewportSize = Math.max(size.width, size.height);\n      var tileSize = viewportSize > 2048 ? 2048 : viewportSize > 1024 ? 1024 : 512;\n      provider.setTileSize(tileSize);\n    });\n    this._abortTextureProviderSubscription = textureProvider$.pipe(operators_1.pairwise()).subscribe(function (pair) {\n      var previous = pair[0];\n      previous.abort();\n    });\n    var roiTrigger$ = rxjs_1.combineLatest(this._container.renderService.renderCameraFrame$, this._container.renderService.size$.pipe(operators_1.debounceTime(250))).pipe(operators_1.map(function (_a) {\n      var camera = _a[0],\n          size = _a[1];\n      return [camera.camera.position.clone(), camera.camera.lookat.clone(), camera.zoom.valueOf(), size.height.valueOf(), size.width.valueOf()];\n    }), operators_1.pairwise(), operators_1.skipWhile(function (pls) {\n      return pls[1][2] - pls[0][2] < 0 || pls[1][2] === 0;\n    }), operators_1.map(function (pls) {\n      var samePosition = pls[0][0].equals(pls[1][0]);\n      var sameLookat = pls[0][1].equals(pls[1][1]);\n      var sameZoom = pls[0][2] === pls[1][2];\n      var sameHeight = pls[0][3] === pls[1][3];\n      var sameWidth = pls[0][4] === pls[1][4];\n      return samePosition && sameLookat && sameZoom && sameHeight && sameWidth;\n    }), operators_1.distinctUntilChanged(), operators_1.filter(function (stalled) {\n      return stalled;\n    }), operators_1.switchMap(function (stalled) {\n      return _this._container.renderService.renderCameraFrame$.pipe(operators_1.first());\n    }), operators_1.withLatestFrom(this._container.renderService.size$, this._navigator.stateService.currentTransform$));\n    this._setRegionOfInterestSubscription = textureProvider$.pipe(operators_1.switchMap(function (provider) {\n      return roiTrigger$.pipe(operators_1.map(function (_a) {\n        var camera = _a[0],\n            size = _a[1],\n            transform = _a[2];\n        return [_this._roiCalculator.computeRegionOfInterest(camera, size, transform), provider];\n      }));\n    }), operators_1.filter(function (args) {\n      return !args[1].disposed;\n    })).subscribe(function (args) {\n      var roi = args[0];\n      var provider = args[1];\n      provider.setRegionOfInterest(roi);\n    });\n    var hasTexture$ = textureProvider$.pipe(operators_1.switchMap(function (provider) {\n      return provider.hasTexture$;\n    }), operators_1.startWith(false), operators_1.publishReplay(1), operators_1.refCount());\n    this._hasTextureSubscription = hasTexture$.subscribe(function () {});\n\n    var nodeImage$ = this._navigator.stateService.currentState$.pipe(operators_1.filter(function (frame) {\n      return frame.state.nodesAhead === 0;\n    }), operators_1.map(function (frame) {\n      return frame.state.currentNode;\n    }), operators_1.distinctUntilChanged(undefined, function (node) {\n      return node.key;\n    }), operators_1.debounceTime(1000), operators_1.withLatestFrom(hasTexture$), operators_1.filter(function (args) {\n      return !args[1];\n    }), operators_1.map(function (args) {\n      return args[0];\n    }), operators_1.filter(function (node) {\n      return node.pano ? Utils_1.Settings.maxImageSize > Utils_1.Settings.basePanoramaSize : Utils_1.Settings.maxImageSize > Utils_1.Settings.baseImageSize;\n    }), operators_1.switchMap(function (node) {\n      var baseImageSize = node.pano ? Utils_1.Settings.basePanoramaSize : Utils_1.Settings.baseImageSize;\n\n      if (Math.max(node.image.width, node.image.height) > baseImageSize) {\n        return rxjs_1.empty();\n      }\n\n      var image$ = node.cacheImage$(Utils_1.Settings.maxImageSize).pipe(operators_1.map(function (n) {\n        return [n.image, n];\n      }));\n      return image$.pipe(operators_1.takeUntil(hasTexture$.pipe(operators_1.filter(function (hasTexture) {\n        return hasTexture;\n      }))), operators_1.catchError(function (error, caught) {\n        console.error(\"Failed to fetch high res image (\" + node.key + \")\", error);\n        return rxjs_1.empty();\n      }));\n    })).pipe(operators_1.publish(), operators_1.refCount());\n\n    this._updateBackgroundSubscription = nodeImage$.pipe(operators_1.withLatestFrom(textureProvider$)).subscribe(function (args) {\n      if (args[0][1].key !== args[1].key || args[1].disposed) {\n        return;\n      }\n\n      args[1].updateBackground(args[0][0]);\n    });\n    this._updateTextureImageSubscription = nodeImage$.pipe(operators_1.map(function (imn) {\n      return function (renderer) {\n        renderer.updateTextureImage(imn[0], imn[1]);\n        return renderer;\n      };\n    })).subscribe(this._glRendererOperation$);\n\n    var textureProviderPrev$ = this._navigator.stateService.currentState$.pipe(operators_1.filter(function (frame) {\n      return !!frame.state.previousNode;\n    }), operators_1.distinctUntilChanged(undefined, function (frame) {\n      return frame.state.previousNode.key;\n    }), operators_1.withLatestFrom(this._container.glRenderer.webGLRenderer$, this._container.renderService.size$), operators_1.map(function (_a) {\n      var frame = _a[0],\n          renderer = _a[1],\n          size = _a[2];\n      var state = frame.state;\n      var viewportSize = Math.max(size.width, size.height);\n      var previousNode = state.previousNode;\n      var previousTransform = state.previousTransform;\n      var tileSize = viewportSize > 2048 ? 2048 : viewportSize > 1024 ? 1024 : 512;\n      return new Tiles_1.TextureProvider(previousNode.key, previousTransform.basicWidth, previousTransform.basicHeight, tileSize, previousNode.image, _this._imageTileLoader, new Tiles_1.ImageTileStore(), renderer);\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._textureProviderSubscriptionPrev = textureProviderPrev$.subscribe(function () {});\n    this._setTextureProviderSubscriptionPrev = textureProviderPrev$.pipe(operators_1.map(function (provider) {\n      return function (renderer) {\n        renderer.setTextureProviderPrev(provider.key, provider);\n        return renderer;\n      };\n    })).subscribe(this._glRendererOperation$);\n    this._setTileSizeSubscriptionPrev = this._container.renderService.size$.pipe(operators_1.switchMap(function (size) {\n      return rxjs_1.combineLatest(textureProviderPrev$, rxjs_1.of(size)).pipe(operators_1.first());\n    })).subscribe(function (_a) {\n      var provider = _a[0],\n          size = _a[1];\n      var viewportSize = Math.max(size.width, size.height);\n      var tileSize = viewportSize > 2048 ? 2048 : viewportSize > 1024 ? 1024 : 512;\n      provider.setTileSize(tileSize);\n    });\n    this._abortTextureProviderSubscriptionPrev = textureProviderPrev$.pipe(operators_1.pairwise()).subscribe(function (pair) {\n      var previous = pair[0];\n      previous.abort();\n    });\n    var roiTriggerPrev$ = rxjs_1.combineLatest(this._container.renderService.renderCameraFrame$, this._container.renderService.size$.pipe(operators_1.debounceTime(250))).pipe(operators_1.map(function (_a) {\n      var camera = _a[0],\n          size = _a[1];\n      return [camera.camera.position.clone(), camera.camera.lookat.clone(), camera.zoom.valueOf(), size.height.valueOf(), size.width.valueOf()];\n    }), operators_1.pairwise(), operators_1.skipWhile(function (pls) {\n      return pls[1][2] - pls[0][2] < 0 || pls[1][2] === 0;\n    }), operators_1.map(function (pls) {\n      var samePosition = pls[0][0].equals(pls[1][0]);\n      var sameLookat = pls[0][1].equals(pls[1][1]);\n      var sameZoom = pls[0][2] === pls[1][2];\n      var sameHeight = pls[0][3] === pls[1][3];\n      var sameWidth = pls[0][4] === pls[1][4];\n      return samePosition && sameLookat && sameZoom && sameHeight && sameWidth;\n    }), operators_1.distinctUntilChanged(), operators_1.filter(function (stalled) {\n      return stalled;\n    }), operators_1.switchMap(function (stalled) {\n      return _this._container.renderService.renderCameraFrame$.pipe(operators_1.first());\n    }), operators_1.withLatestFrom(this._container.renderService.size$, this._navigator.stateService.currentTransform$));\n    this._setRegionOfInterestSubscriptionPrev = textureProviderPrev$.pipe(operators_1.switchMap(function (provider) {\n      return roiTriggerPrev$.pipe(operators_1.map(function (_a) {\n        var camera = _a[0],\n            size = _a[1],\n            transform = _a[2];\n        return [_this._roiCalculator.computeRegionOfInterest(camera, size, transform), provider];\n      }));\n    }), operators_1.filter(function (args) {\n      return !args[1].disposed;\n    }), operators_1.withLatestFrom(this._navigator.stateService.currentState$)).subscribe(function (_a) {\n      var _b = _a[0],\n          roi = _b[0],\n          provider = _b[1],\n          frame = _a[1];\n      var shiftedRoi = null;\n\n      if (frame.state.previousNode.fullPano) {\n        if (frame.state.currentNode.fullPano) {\n          var currentViewingDirection = _this._spatial.viewingDirection(frame.state.currentNode.rotation);\n\n          var previousViewingDirection = _this._spatial.viewingDirection(frame.state.previousNode.rotation);\n\n          var directionDiff = _this._spatial.angleBetweenVector2(currentViewingDirection.x, currentViewingDirection.y, previousViewingDirection.x, previousViewingDirection.y);\n\n          var shift = directionDiff / (2 * Math.PI);\n          var bbox = {\n            maxX: _this._spatial.wrap(roi.bbox.maxX + shift, 0, 1),\n            maxY: roi.bbox.maxY,\n            minX: _this._spatial.wrap(roi.bbox.minX + shift, 0, 1),\n            minY: roi.bbox.minY\n          };\n          shiftedRoi = {\n            bbox: bbox,\n            pixelHeight: roi.pixelHeight,\n            pixelWidth: roi.pixelWidth\n          };\n        } else {\n          var currentViewingDirection = _this._spatial.viewingDirection(frame.state.currentNode.rotation);\n\n          var previousViewingDirection = _this._spatial.viewingDirection(frame.state.previousNode.rotation);\n\n          var directionDiff = _this._spatial.angleBetweenVector2(currentViewingDirection.x, currentViewingDirection.y, previousViewingDirection.x, previousViewingDirection.y);\n\n          var shiftX = directionDiff / (2 * Math.PI);\n\n          var a1 = _this._spatial.angleToPlane(currentViewingDirection.toArray(), [0, 0, 1]);\n\n          var a2 = _this._spatial.angleToPlane(previousViewingDirection.toArray(), [0, 0, 1]);\n\n          var shiftY = (a2 - a1) / (2 * Math.PI);\n          var currentTransform = frame.state.currentTransform;\n          var size = Math.max(currentTransform.basicWidth, currentTransform.basicHeight);\n          var hFov = size > 0 ? 2 * Math.atan(0.5 * currentTransform.basicWidth / (size * currentTransform.focal)) : Math.PI / 3;\n          var vFov = size > 0 ? 2 * Math.atan(0.5 * currentTransform.basicHeight / (size * currentTransform.focal)) : Math.PI / 3;\n          var spanningWidth = hFov / (2 * Math.PI);\n          var spanningHeight = vFov / Math.PI;\n          var basicWidth = (roi.bbox.maxX - roi.bbox.minX) * spanningWidth;\n          var basicHeight = (roi.bbox.maxY - roi.bbox.minY) * spanningHeight;\n          var pixelWidth = roi.pixelWidth * spanningWidth;\n          var pixelHeight = roi.pixelHeight * spanningHeight;\n          var zoomShiftX = (roi.bbox.minX + roi.bbox.maxX) / 2 - 0.5;\n          var zoomShiftY = (roi.bbox.minY + roi.bbox.maxY) / 2 - 0.5;\n          var minX = 0.5 + shiftX + spanningWidth * zoomShiftX - basicWidth / 2;\n          var maxX = 0.5 + shiftX + spanningWidth * zoomShiftX + basicWidth / 2;\n          var minY = 0.5 + shiftY + spanningHeight * zoomShiftY - basicHeight / 2;\n          var maxY = 0.5 + shiftY + spanningHeight * zoomShiftY + basicHeight / 2;\n          var bbox = {\n            maxX: _this._spatial.wrap(maxX, 0, 1),\n            maxY: maxY,\n            minX: _this._spatial.wrap(minX, 0, 1),\n            minY: minY\n          };\n          shiftedRoi = {\n            bbox: bbox,\n            pixelHeight: pixelHeight,\n            pixelWidth: pixelWidth\n          };\n        }\n      } else {\n        var currentBasicAspect = frame.state.currentTransform.basicAspect;\n        var previousBasicAspect = frame.state.previousTransform.basicAspect;\n\n        var _c = _this._getBasicCorners(currentBasicAspect, previousBasicAspect),\n            _d = _c[0],\n            cornerMinX = _d[0],\n            cornerMinY = _d[1],\n            _e = _c[1],\n            cornerMaxX = _e[0],\n            cornerMaxY = _e[1];\n\n        var basicWidth = cornerMaxX - cornerMinX;\n        var basicHeight = cornerMaxY - cornerMinY;\n        var pixelWidth = roi.pixelWidth / basicWidth;\n        var pixelHeight = roi.pixelHeight / basicHeight;\n        var minX = (basicWidth - 1) / (2 * basicWidth) + roi.bbox.minX / basicWidth;\n        var maxX = (basicWidth - 1) / (2 * basicWidth) + roi.bbox.maxX / basicWidth;\n        var minY = (basicHeight - 1) / (2 * basicHeight) + roi.bbox.minY / basicHeight;\n        var maxY = (basicHeight - 1) / (2 * basicHeight) + roi.bbox.maxY / basicHeight;\n        var bbox = {\n          maxX: maxX,\n          maxY: maxY,\n          minX: minX,\n          minY: minY\n        };\n\n        _this._clipBoundingBox(bbox);\n\n        shiftedRoi = {\n          bbox: bbox,\n          pixelHeight: pixelHeight,\n          pixelWidth: pixelWidth\n        };\n      }\n\n      provider.setRegionOfInterest(shiftedRoi);\n    });\n    var hasTexturePrev$ = textureProviderPrev$.pipe(operators_1.switchMap(function (provider) {\n      return provider.hasTexture$;\n    }), operators_1.startWith(false), operators_1.publishReplay(1), operators_1.refCount());\n    this._hasTextureSubscriptionPrev = hasTexturePrev$.subscribe(function () {});\n\n    var nodeImagePrev$ = this._navigator.stateService.currentState$.pipe(operators_1.filter(function (frame) {\n      return frame.state.nodesAhead === 0 && !!frame.state.previousNode;\n    }), operators_1.map(function (frame) {\n      return frame.state.previousNode;\n    }), operators_1.distinctUntilChanged(undefined, function (node) {\n      return node.key;\n    }), operators_1.debounceTime(1000), operators_1.withLatestFrom(hasTexturePrev$), operators_1.filter(function (args) {\n      return !args[1];\n    }), operators_1.map(function (args) {\n      return args[0];\n    }), operators_1.filter(function (node) {\n      return node.pano ? Utils_1.Settings.maxImageSize > Utils_1.Settings.basePanoramaSize : Utils_1.Settings.maxImageSize > Utils_1.Settings.baseImageSize;\n    }), operators_1.switchMap(function (node) {\n      var baseImageSize = node.pano ? Utils_1.Settings.basePanoramaSize : Utils_1.Settings.baseImageSize;\n\n      if (Math.max(node.image.width, node.image.height) > baseImageSize) {\n        return rxjs_1.empty();\n      }\n\n      var image$ = node.cacheImage$(Utils_1.Settings.maxImageSize).pipe(operators_1.map(function (n) {\n        return [n.image, n];\n      }));\n      return image$.pipe(operators_1.takeUntil(hasTexturePrev$.pipe(operators_1.filter(function (hasTexture) {\n        return hasTexture;\n      }))), operators_1.catchError(function (error, caught) {\n        console.error(\"Failed to fetch high res image (\" + node.key + \")\", error);\n        return rxjs_1.empty();\n      }));\n    })).pipe(operators_1.publish(), operators_1.refCount());\n\n    this._updateBackgroundSubscriptionPrev = nodeImagePrev$.pipe(operators_1.withLatestFrom(textureProviderPrev$)).subscribe(function (args) {\n      if (args[0][1].key !== args[1].key || args[1].disposed) {\n        return;\n      }\n\n      args[1].updateBackground(args[0][0]);\n    });\n    this._updateTextureImageSubscriptionPrev = nodeImagePrev$.pipe(operators_1.map(function (imn) {\n      return function (renderer) {\n        renderer.updateTextureImage(imn[0], imn[1]);\n        return renderer;\n      };\n    })).subscribe(this._glRendererOperation$);\n  };\n\n  SliderComponent.prototype._deactivate = function () {\n    var _this = this;\n\n    this._waitSubscription.unsubscribe();\n\n    this._navigator.stateService.state$.pipe(operators_1.first()).subscribe(function (state) {\n      if (state !== State_1.State.Traversing) {\n        _this._navigator.stateService.traverse();\n      }\n    });\n\n    this._glRendererDisposer$.next(null);\n\n    this._domRenderer.deactivate();\n\n    this._modeSubcription.unsubscribe();\n\n    this._setKeysSubscription.unsubscribe();\n\n    this._stateSubscription.unsubscribe();\n\n    this._glRenderSubscription.unsubscribe();\n\n    this._domRenderSubscription.unsubscribe();\n\n    this._moveSubscription.unsubscribe();\n\n    this._updateCurtainSubscription.unsubscribe();\n\n    this._textureProviderSubscription.unsubscribe();\n\n    this._setTextureProviderSubscription.unsubscribe();\n\n    this._setTileSizeSubscription.unsubscribe();\n\n    this._abortTextureProviderSubscription.unsubscribe();\n\n    this._setRegionOfInterestSubscription.unsubscribe();\n\n    this._hasTextureSubscription.unsubscribe();\n\n    this._updateBackgroundSubscription.unsubscribe();\n\n    this._updateTextureImageSubscription.unsubscribe();\n\n    this._textureProviderSubscriptionPrev.unsubscribe();\n\n    this._setTextureProviderSubscriptionPrev.unsubscribe();\n\n    this._setTileSizeSubscriptionPrev.unsubscribe();\n\n    this._abortTextureProviderSubscriptionPrev.unsubscribe();\n\n    this._setRegionOfInterestSubscriptionPrev.unsubscribe();\n\n    this._hasTextureSubscriptionPrev.unsubscribe();\n\n    this._updateBackgroundSubscriptionPrev.unsubscribe();\n\n    this._updateTextureImageSubscriptionPrev.unsubscribe();\n\n    this.configure({\n      keys: null\n    });\n  };\n\n  SliderComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      initialPosition: 1,\n      mode: Component_1.SliderMode.Motion,\n      sliderVisible: true\n    };\n  };\n\n  SliderComponent.prototype._catchCacheNode$ = function (key) {\n    return this._navigator.graphService.cacheNode$(key).pipe(operators_1.catchError(function (error, caught) {\n      console.error(\"Failed to cache slider node (\" + key + \")\", error);\n      return rxjs_1.empty();\n    }));\n  };\n\n  SliderComponent.prototype._getBasicCorners = function (currentAspect, previousAspect) {\n    var offsetX;\n    var offsetY;\n\n    if (currentAspect > previousAspect) {\n      offsetX = 0.5;\n      offsetY = 0.5 * currentAspect / previousAspect;\n    } else {\n      offsetX = 0.5 * previousAspect / currentAspect;\n      offsetY = 0.5;\n    }\n\n    return [[0.5 - offsetX, 0.5 - offsetY], [0.5 + offsetX, 0.5 + offsetY]];\n  };\n\n  SliderComponent.prototype._clipBoundingBox = function (bbox) {\n    bbox.minX = Math.max(0, Math.min(1, bbox.minX));\n    bbox.maxX = Math.max(0, Math.min(1, bbox.maxX));\n    bbox.minY = Math.max(0, Math.min(1, bbox.minY));\n    bbox.maxY = Math.max(0, Math.min(1, bbox.maxY));\n  };\n\n  SliderComponent.componentName = \"slider\";\n  return SliderComponent;\n}(Component_1.Component);\n\nexports.SliderComponent = SliderComponent;\nComponent_1.ComponentService.register(SliderComponent);\nexports.default = SliderComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/slider/SliderComponent.ts?");

/***/ }),

/***/ "./src/component/slider/SliderDOMRenderer.ts":
/*!***************************************************!*\
  !*** ./src/component/slider/SliderDOMRenderer.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar SliderDOMRenderer =\n/** @class */\nfunction () {\n  function SliderDOMRenderer(container) {\n    this._container = container;\n    this._interacting = false;\n    this._notifyModeChanged$ = new rxjs_1.Subject();\n    this._notifyPositionChanged$ = new rxjs_1.Subject();\n    this._stopInteractionSubscription = null;\n  }\n\n  Object.defineProperty(SliderDOMRenderer.prototype, \"mode$\", {\n    get: function get() {\n      return this._notifyModeChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SliderDOMRenderer.prototype, \"position$\", {\n    get: function get() {\n      return this._notifyPositionChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SliderDOMRenderer.prototype.activate = function () {\n    var _this = this;\n\n    if (!!this._stopInteractionSubscription) {\n      return;\n    }\n\n    this._stopInteractionSubscription = rxjs_1.merge(this._container.mouseService.documentMouseUp$, this._container.touchService.touchEnd$.pipe(operators_1.filter(function (touchEvent) {\n      return touchEvent.touches.length === 0;\n    }))).subscribe(function (event) {\n      if (_this._interacting) {\n        _this._interacting = false;\n      }\n    });\n  };\n\n  SliderDOMRenderer.prototype.deactivate = function () {\n    if (!this._stopInteractionSubscription) {\n      return;\n    }\n\n    this._interacting = false;\n\n    this._stopInteractionSubscription.unsubscribe();\n\n    this._stopInteractionSubscription = null;\n  };\n\n  SliderDOMRenderer.prototype.render = function (position, mode, motionless, pano, visible) {\n    var children = [];\n\n    if (visible) {\n      children.push(vd.h(\"div.SliderBorder\", []));\n      var modeVisible = !(motionless || pano);\n\n      if (modeVisible) {\n        children.push(this._createModeButton(mode));\n        children.push(this._createModeButton2d(mode));\n      }\n\n      children.push(this._createPositionInput(position, modeVisible));\n    }\n\n    var boundingRect = this._container.domContainer.getBoundingClientRect();\n\n    var width = Math.max(215, Math.min(400, boundingRect.width - 100));\n    return vd.h(\"div.SliderContainer\", {\n      style: {\n        width: width + \"px\"\n      }\n    }, children);\n  };\n\n  SliderDOMRenderer.prototype._createModeButton = function (mode) {\n    var _this = this;\n\n    var properties = {\n      onclick: function onclick() {\n        if (mode === Component_1.SliderMode.Motion) {\n          return;\n        }\n\n        _this._notifyModeChanged$.next(Component_1.SliderMode.Motion);\n      }\n    };\n    var className = mode === Component_1.SliderMode.Stationary ? \"SliderModeButtonDisabled\" : \"SliderModeButton\";\n    return vd.h(\"div.\" + className, properties, [vd.h(\"div.SliderModeIcon\", [])]);\n  };\n\n  SliderDOMRenderer.prototype._createModeButton2d = function (mode) {\n    var _this = this;\n\n    var properties = {\n      onclick: function onclick() {\n        if (mode === Component_1.SliderMode.Stationary) {\n          return;\n        }\n\n        _this._notifyModeChanged$.next(Component_1.SliderMode.Stationary);\n      }\n    };\n    var className = mode === Component_1.SliderMode.Motion ? \"SliderModeButton2dDisabled\" : \"SliderModeButton2d\";\n    return vd.h(\"div.\" + className, properties, [vd.h(\"div.SliderModeIcon2d\", [])]);\n  };\n\n  SliderDOMRenderer.prototype._createPositionInput = function (position, modeVisible) {\n    var _this = this;\n\n    var onChange = function onChange(e) {\n      _this._notifyPositionChanged$.next(Number(e.target.value) / 1000);\n    };\n\n    var onStart = function onStart(e) {\n      _this._interacting = true;\n      e.stopPropagation();\n    };\n\n    var onMove = function onMove(e) {\n      if (_this._interacting) {\n        e.stopPropagation();\n      }\n    };\n\n    var onKeyDown = function onKeyDown(e) {\n      if (e.key === \"ArrowDown\" || e.key === \"ArrowLeft\" || e.key === \"ArrowRight\" || e.key === \"ArrowUp\") {\n        e.preventDefault();\n      }\n    };\n\n    var boundingRect = this._container.domContainer.getBoundingClientRect();\n\n    var width = Math.max(215, Math.min(400, boundingRect.width - 105)) - 84 + (modeVisible ? 0 : 52);\n    var positionInput = vd.h(\"input.SliderPosition\", {\n      max: 1000,\n      min: 0,\n      onchange: onChange,\n      oninput: onChange,\n      onkeydown: onKeyDown,\n      onmousedown: onStart,\n      onmousemove: onMove,\n      ontouchmove: onMove,\n      ontouchstart: onStart,\n      style: {\n        width: width + \"px\"\n      },\n      type: \"range\",\n      value: 1000 * position\n    }, []);\n    return vd.h(\"div.SliderPositionContainer\", [positionInput]);\n  };\n\n  return SliderDOMRenderer;\n}();\n\nexports.SliderDOMRenderer = SliderDOMRenderer;\nexports.default = SliderDOMRenderer;\n\n//# sourceURL=webpack://Mapillary/./src/component/slider/SliderDOMRenderer.ts?");

/***/ }),

/***/ "./src/component/slider/SliderGLRenderer.ts":
/*!**************************************************!*\
  !*** ./src/component/slider/SliderGLRenderer.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n\nvar SliderGLRenderer =\n/** @class */\nfunction () {\n  function SliderGLRenderer() {\n    this._factory = new Component_1.MeshFactory();\n    this._scene = new Component_1.MeshScene();\n    this._spatial = new Geo_1.Spatial();\n    this._currentKey = null;\n    this._previousKey = null;\n    this._disabled = false;\n    this._curtain = 1;\n    this._frameId = 0;\n    this._needsRender = false;\n    this._mode = null;\n    this._currentProviderDisposers = {};\n    this._previousProviderDisposers = {};\n  }\n\n  Object.defineProperty(SliderGLRenderer.prototype, \"disabled\", {\n    get: function get() {\n      return this._disabled;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SliderGLRenderer.prototype, \"frameId\", {\n    get: function get() {\n      return this._frameId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SliderGLRenderer.prototype, \"needsRender\", {\n    get: function get() {\n      return this._needsRender;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SliderGLRenderer.prototype.setTextureProvider = function (key, provider) {\n    this._setTextureProvider(key, this._currentKey, provider, this._currentProviderDisposers, this._updateTexture.bind(this));\n  };\n\n  SliderGLRenderer.prototype.setTextureProviderPrev = function (key, provider) {\n    this._setTextureProvider(key, this._previousKey, provider, this._previousProviderDisposers, this._updateTexturePrev.bind(this));\n  };\n\n  SliderGLRenderer.prototype.update = function (frame, mode) {\n    this._updateFrameId(frame.id);\n\n    this._updateImagePlanes(frame.state, mode);\n  };\n\n  SliderGLRenderer.prototype.updateCurtain = function (curtain) {\n    if (this._curtain === curtain) {\n      return;\n    }\n\n    this._curtain = curtain;\n\n    this._updateCurtain();\n\n    this._needsRender = true;\n  };\n\n  SliderGLRenderer.prototype.updateTexture = function (image, node) {\n    var planes = node.key === this._currentKey ? this._scene.planes : node.key === this._previousKey ? this._scene.planesOld : {};\n\n    if (Object.keys(planes).length === 0) {\n      return;\n    }\n\n    this._needsRender = true;\n\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n      var material = plane.material;\n      var texture = material.uniforms.projectorTex.value;\n      texture.image = image;\n      texture.needsUpdate = true;\n    }\n  };\n\n  SliderGLRenderer.prototype.updateTextureImage = function (image, node) {\n    if (this._currentKey !== node.key) {\n      return;\n    }\n\n    this._needsRender = true;\n    var planes = this._scene.planes;\n\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n      var material = plane.material;\n      var texture = material.uniforms.projectorTex.value;\n      texture.image = image;\n      texture.needsUpdate = true;\n    }\n  };\n\n  SliderGLRenderer.prototype.render = function (perspectiveCamera, renderer) {\n    if (!this.disabled) {\n      renderer.render(this._scene.sceneOld, perspectiveCamera);\n    }\n\n    renderer.render(this._scene.scene, perspectiveCamera);\n    this._needsRender = false;\n  };\n\n  SliderGLRenderer.prototype.dispose = function () {\n    this._scene.clear();\n\n    for (var key in this._currentProviderDisposers) {\n      if (!this._currentProviderDisposers.hasOwnProperty(key)) {\n        continue;\n      }\n\n      this._currentProviderDisposers[key]();\n    }\n\n    for (var key in this._previousProviderDisposers) {\n      if (!this._previousProviderDisposers.hasOwnProperty(key)) {\n        continue;\n      }\n\n      this._previousProviderDisposers[key]();\n    }\n\n    this._currentProviderDisposers = {};\n    this._previousProviderDisposers = {};\n  };\n\n  SliderGLRenderer.prototype._getBasicCorners = function (currentAspect, previousAspect) {\n    var offsetX;\n    var offsetY;\n\n    if (currentAspect > previousAspect) {\n      offsetX = 0.5;\n      offsetY = 0.5 * currentAspect / previousAspect;\n    } else {\n      offsetX = 0.5 * previousAspect / currentAspect;\n      offsetY = 0.5;\n    }\n\n    return [[0.5 - offsetX, 0.5 - offsetY], [0.5 + offsetX, 0.5 + offsetY]];\n  };\n\n  SliderGLRenderer.prototype._setDisabled = function (state) {\n    this._disabled = state.currentNode == null || state.previousNode == null || state.currentNode.pano && !state.currentNode.fullPano || state.previousNode.pano && !state.previousNode.fullPano || state.currentNode.fullPano && !state.previousNode.fullPano;\n  };\n\n  SliderGLRenderer.prototype._setTextureProvider = function (key, originalKey, provider, providerDisposers, updateTexture) {\n    var _this = this;\n\n    if (key !== originalKey) {\n      return;\n    }\n\n    var createdSubscription = provider.textureCreated$.subscribe(updateTexture);\n    var updatedSubscription = provider.textureUpdated$.subscribe(function (updated) {\n      _this._needsRender = true;\n    });\n\n    var dispose = function dispose() {\n      createdSubscription.unsubscribe();\n      updatedSubscription.unsubscribe();\n      provider.dispose();\n    };\n\n    if (key in providerDisposers) {\n      var disposeProvider = providerDisposers[key];\n      disposeProvider();\n      delete providerDisposers[key];\n    }\n\n    providerDisposers[key] = dispose;\n  };\n\n  SliderGLRenderer.prototype._updateCurtain = function () {\n    var planes = this._scene.planes;\n\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n      var shaderMaterial = plane.material;\n\n      if (!!shaderMaterial.uniforms.curtain) {\n        shaderMaterial.uniforms.curtain.value = this._curtain;\n      }\n    }\n  };\n\n  SliderGLRenderer.prototype._updateFrameId = function (frameId) {\n    this._frameId = frameId;\n  };\n\n  SliderGLRenderer.prototype._updateImagePlanes = function (state, mode) {\n    var currentChanged = state.currentNode != null && this._currentKey !== state.currentNode.key;\n    var previousChanged = state.previousNode != null && this._previousKey !== state.previousNode.key;\n    var modeChanged = this._mode !== mode;\n\n    if (!(currentChanged || previousChanged || modeChanged)) {\n      return;\n    }\n\n    this._setDisabled(state);\n\n    this._needsRender = true;\n    this._mode = mode;\n    var motionless = state.motionless || mode === Component_1.SliderMode.Stationary || state.currentNode.pano;\n\n    if (this.disabled || previousChanged) {\n      if (this._previousKey in this._previousProviderDisposers) {\n        this._previousProviderDisposers[this._previousKey]();\n\n        delete this._previousProviderDisposers[this._previousKey];\n      }\n    }\n\n    if (this.disabled) {\n      this._scene.setImagePlanesOld({});\n    } else {\n      if (previousChanged || modeChanged) {\n        var previousNode = state.previousNode;\n        this._previousKey = previousNode.key;\n        var elements = state.currentTransform.rt.elements;\n        var translation = [elements[12], elements[13], elements[14]];\n        var currentAspect = state.currentTransform.basicAspect;\n        var previousAspect = state.previousTransform.basicAspect;\n        var textureScale = currentAspect > previousAspect ? [1, previousAspect / currentAspect] : [currentAspect / previousAspect, 1];\n        var rotation = state.currentNode.rotation;\n        var width = state.currentNode.width;\n        var height = state.currentNode.height;\n\n        if (previousNode.fullPano) {\n          rotation = state.previousNode.rotation;\n          translation = this._spatial.rotate(this._spatial.opticalCenter(state.currentNode.rotation, translation).toArray(), rotation).multiplyScalar(-1).toArray();\n          width = state.previousNode.width;\n          height = state.previousNode.height;\n        }\n\n        var transform = new Geo_1.Transform(state.currentNode.orientation, width, height, state.currentNode.focal, state.currentNode.scale, previousNode.gpano, rotation, translation, previousNode.image, textureScale);\n        var mesh = undefined;\n\n        if (previousNode.fullPano) {\n          mesh = this._factory.createMesh(previousNode, motionless || state.currentNode.fullPano ? transform : state.previousTransform);\n        } else {\n          if (motionless) {\n            var _a = this._getBasicCorners(currentAspect, previousAspect),\n                _b = _a[0],\n                basicX0 = _b[0],\n                basicY0 = _b[1],\n                _c = _a[1],\n                basicX1 = _c[0],\n                basicY1 = _c[1];\n\n            mesh = this._factory.createFlatMesh(state.previousNode, transform, basicX0, basicX1, basicY0, basicY1);\n          } else {\n            mesh = this._factory.createMesh(state.previousNode, state.previousTransform);\n          }\n        }\n\n        var previousPlanes = {};\n        previousPlanes[previousNode.key] = mesh;\n\n        this._scene.setImagePlanesOld(previousPlanes);\n      }\n    }\n\n    if (currentChanged || modeChanged) {\n      if (this._currentKey in this._currentProviderDisposers) {\n        this._currentProviderDisposers[this._currentKey]();\n\n        delete this._currentProviderDisposers[this._currentKey];\n      }\n\n      this._currentKey = state.currentNode.key;\n      var planes = {};\n\n      if (state.currentNode.fullPano) {\n        planes[state.currentNode.key] = this._factory.createCurtainMesh(state.currentNode, state.currentTransform);\n      } else if (state.currentNode.pano && !state.currentNode.fullPano) {\n        planes[state.currentNode.key] = this._factory.createMesh(state.currentNode, state.currentTransform);\n      } else {\n        if (motionless) {\n          planes[state.currentNode.key] = this._factory.createDistortedCurtainMesh(state.currentNode, state.currentTransform);\n        } else {\n          planes[state.currentNode.key] = this._factory.createCurtainMesh(state.currentNode, state.currentTransform);\n        }\n      }\n\n      this._scene.setImagePlanes(planes);\n\n      this._updateCurtain();\n    }\n  };\n\n  SliderGLRenderer.prototype._updateTexture = function (texture) {\n    this._needsRender = true;\n    var planes = this._scene.planes;\n\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n      var material = plane.material;\n      var oldTexture = material.uniforms.projectorTex.value;\n      material.uniforms.projectorTex.value = null;\n      oldTexture.dispose();\n      material.uniforms.projectorTex.value = texture;\n    }\n  };\n\n  SliderGLRenderer.prototype._updateTexturePrev = function (texture) {\n    this._needsRender = true;\n    var planes = this._scene.planesOld;\n\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n      var material = plane.material;\n      var oldTexture = material.uniforms.projectorTex.value;\n      material.uniforms.projectorTex.value = null;\n      oldTexture.dispose();\n      material.uniforms.projectorTex.value = texture;\n    }\n  };\n\n  return SliderGLRenderer;\n}();\n\nexports.SliderGLRenderer = SliderGLRenderer;\nexports.default = SliderGLRenderer;\n\n//# sourceURL=webpack://Mapillary/./src/component/slider/SliderGLRenderer.ts?");

/***/ }),

/***/ "./src/component/spatialdata/SpatialDataCache.ts":
/*!*******************************************************!*\
  !*** ./src/component/spatialdata/SpatialDataCache.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar geohash = __webpack_require__(/*! latlon-geohash */ \"./node_modules/latlon-geohash/latlon-geohash.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Error_1 = __webpack_require__(/*! ../../Error */ \"./src/Error.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../../Utils */ \"./src/Utils.ts\");\n\nvar SpatialDataCache =\n/** @class */\nfunction () {\n  function SpatialDataCache(graphService) {\n    this._graphService = graphService;\n    this._tiles = {};\n    this._cacheRequests = {};\n    this._reconstructions = {};\n    this._cachingReconstructions$ = {};\n    this._cachingTiles$ = {};\n  }\n\n  SpatialDataCache.prototype.cacheReconstructions$ = function (hash) {\n    var _this = this;\n\n    if (!this.hasTile(hash)) {\n      throw new Error(\"Cannot cache reconstructions of a non-existing tile.\");\n    }\n\n    if (this.hasReconstructions(hash)) {\n      throw new Error(\"Cannot cache reconstructions that already exists.\");\n    }\n\n    if (this.isCachingReconstructions(hash)) {\n      return this._cachingReconstructions$[hash];\n    }\n\n    var tile = [];\n\n    if (hash in this._reconstructions) {\n      var reconstructionKeys = this.getReconstructions(hash).map(function (reconstruction) {\n        return reconstruction.data.key;\n      });\n\n      for (var _i = 0, _a = this.getTile(hash); _i < _a.length; _i++) {\n        var node = _a[_i];\n\n        if (reconstructionKeys.indexOf(node.key) === -1) {\n          tile.push(node);\n        }\n      }\n    } else {\n      tile.push.apply(tile, this.getTile(hash));\n      this._reconstructions[hash] = [];\n    }\n\n    this._cacheRequests[hash] = [];\n    this._cachingReconstructions$[hash] = rxjs_1.from(tile).pipe(operators_1.mergeMap(function (nodeData) {\n      return !_this._cacheRequests[hash] ? rxjs_1.empty() : rxjs_1.zip(rxjs_1.of(nodeData), _this._getAtomicReconstruction(nodeData.key, _this._cacheRequests[hash])).pipe(operators_1.catchError(function (error) {\n        if (error instanceof Error_1.AbortMapillaryError) {\n          return rxjs_1.empty();\n        }\n\n        console.error(error);\n        return rxjs_1.of([nodeData, null]);\n      }));\n    }, 6), operators_1.map(function (_a) {\n      var nodeData = _a[0],\n          reconstruction = _a[1];\n      return {\n        data: nodeData,\n        reconstruction: reconstruction\n      };\n    }), operators_1.filter(function () {\n      return hash in _this._reconstructions;\n    }), operators_1.tap(function (data) {\n      _this._reconstructions[hash].push(data);\n    }), operators_1.filter(function (data) {\n      return !!data.reconstruction;\n    }), operators_1.finalize(function () {\n      if (hash in _this._cachingReconstructions$) {\n        delete _this._cachingReconstructions$[hash];\n      }\n\n      if (hash in _this._cacheRequests) {\n        delete _this._cacheRequests[hash];\n      }\n    }), operators_1.publish(), operators_1.refCount());\n    return this._cachingReconstructions$[hash];\n  };\n\n  SpatialDataCache.prototype.cacheTile$ = function (hash) {\n    var _this = this;\n\n    if (hash.length !== 8) {\n      throw new Error(\"Hash needs to be level 8.\");\n    }\n\n    if (this.hasTile(hash)) {\n      throw new Error(\"Cannot cache tile that already exists.\");\n    }\n\n    if (this.hasTile(hash)) {\n      return this._cachingTiles$[hash];\n    }\n\n    var bounds = geohash.bounds(hash);\n    var sw = {\n      lat: bounds.sw.lat,\n      lon: bounds.sw.lon\n    };\n    var ne = {\n      lat: bounds.ne.lat,\n      lon: bounds.ne.lon\n    };\n    this._tiles[hash] = [];\n    this._cachingTiles$[hash] = this._graphService.cacheBoundingBox$(sw, ne).pipe(operators_1.catchError(function (error) {\n      console.error(error);\n      delete _this._tiles[hash];\n      return rxjs_1.empty();\n    }), operators_1.map(function (nodes) {\n      return nodes.map(function (n) {\n        return _this._createNodeData(n);\n      });\n    }), operators_1.filter(function () {\n      return hash in _this._tiles;\n    }), operators_1.tap(function (nodeData) {\n      var _a;\n\n      (_a = _this._tiles[hash]).push.apply(_a, nodeData);\n\n      delete _this._cachingTiles$[hash];\n    }), operators_1.finalize(function () {\n      if (hash in _this._cachingTiles$) {\n        delete _this._cachingTiles$[hash];\n      }\n    }), operators_1.publish(), operators_1.refCount());\n    return this._cachingTiles$[hash];\n  };\n\n  SpatialDataCache.prototype.isCachingReconstructions = function (hash) {\n    return hash in this._cachingReconstructions$;\n  };\n\n  SpatialDataCache.prototype.isCachingTile = function (hash) {\n    return hash in this._cachingTiles$;\n  };\n\n  SpatialDataCache.prototype.hasReconstructions = function (hash) {\n    return !(hash in this._cachingReconstructions$) && hash in this._reconstructions && this._reconstructions[hash].length === this._tiles[hash].length;\n  };\n\n  SpatialDataCache.prototype.hasTile = function (hash) {\n    return !(hash in this._cachingTiles$) && hash in this._tiles;\n  };\n\n  SpatialDataCache.prototype.getReconstructions = function (hash) {\n    return hash in this._reconstructions ? this._reconstructions[hash].filter(function (data) {\n      return !!data.reconstruction;\n    }) : [];\n  };\n\n  SpatialDataCache.prototype.getTile = function (hash) {\n    return hash in this._tiles ? this._tiles[hash] : [];\n  };\n\n  SpatialDataCache.prototype.uncache = function (keepHashes) {\n    for (var _i = 0, _a = Object.keys(this._cacheRequests); _i < _a.length; _i++) {\n      var hash = _a[_i];\n\n      if (!!keepHashes && keepHashes.indexOf(hash) !== -1) {\n        continue;\n      }\n\n      for (var _b = 0, _c = this._cacheRequests[hash]; _b < _c.length; _b++) {\n        var request = _c[_b];\n        request.abort();\n      }\n\n      delete this._cacheRequests[hash];\n    }\n\n    for (var _d = 0, _e = Object.keys(this._reconstructions); _d < _e.length; _d++) {\n      var hash = _e[_d];\n\n      if (!!keepHashes && keepHashes.indexOf(hash) !== -1) {\n        continue;\n      }\n\n      delete this._reconstructions[hash];\n    }\n\n    for (var _f = 0, _g = Object.keys(this._tiles); _f < _g.length; _f++) {\n      var hash = _g[_f];\n\n      if (!!keepHashes && keepHashes.indexOf(hash) !== -1) {\n        continue;\n      }\n\n      delete this._tiles[hash];\n    }\n  };\n\n  SpatialDataCache.prototype._createNodeData = function (node) {\n    return {\n      alt: node.alt,\n      cameraProjection: node.cameraProjection,\n      focal: node.focal,\n      gpano: node.gpano,\n      height: node.height,\n      k1: node.ck1,\n      k2: node.ck2,\n      key: node.key,\n      lat: node.latLon.lat,\n      lon: node.latLon.lon,\n      mergeCC: node.mergeCC,\n      orientation: node.orientation,\n      originalLat: node.originalLatLon.lat,\n      originalLon: node.originalLatLon.lon,\n      rotation: [node.rotation[0], node.rotation[1], node.rotation[2]],\n      scale: node.scale,\n      width: node.width\n    };\n  };\n\n  SpatialDataCache.prototype._getAtomicReconstruction = function (key, requests) {\n    return rxjs_1.Observable.create(function (subscriber) {\n      var xmlHTTP = new XMLHttpRequest();\n      xmlHTTP.open(\"GET\", Utils_1.Urls.atomicReconstruction(key), true);\n      xmlHTTP.responseType = \"json\";\n      xmlHTTP.timeout = 15000;\n\n      xmlHTTP.onload = function () {\n        if (!xmlHTTP.response) {\n          subscriber.error(new Error(\"Atomic reconstruction does not exist (\" + key + \")\"));\n        } else {\n          subscriber.next(xmlHTTP.response);\n          subscriber.complete();\n        }\n      };\n\n      xmlHTTP.onerror = function () {\n        subscriber.error(new Error(\"Failed to get atomic reconstruction (\" + key + \")\"));\n      };\n\n      xmlHTTP.ontimeout = function () {\n        subscriber.error(new Error(\"Atomic reconstruction request timed out (\" + key + \")\"));\n      };\n\n      xmlHTTP.onabort = function () {\n        subscriber.error(new Error_1.AbortMapillaryError(\"Atomic reconstruction request was aborted (\" + key + \")\"));\n      };\n\n      requests.push(xmlHTTP);\n      xmlHTTP.send(null);\n    });\n  };\n\n  return SpatialDataCache;\n}();\n\nexports.SpatialDataCache = SpatialDataCache;\nexports.default = SpatialDataCache;\n\n//# sourceURL=webpack://Mapillary/./src/component/spatialdata/SpatialDataCache.ts?");

/***/ }),

/***/ "./src/component/spatialdata/SpatialDataComponent.ts":
/*!***********************************************************!*\
  !*** ./src/component/spatialdata/SpatialDataComponent.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar geohash = __webpack_require__(/*! latlon-geohash */ \"./node_modules/latlon-geohash/latlon-geohash.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n\nvar Render_1 = __webpack_require__(/*! ../../Render */ \"./src/Render.ts\");\n\nvar PlayService_1 = __webpack_require__(/*! ../../viewer/PlayService */ \"./src/viewer/PlayService.ts\");\n\nvar State_1 = __webpack_require__(/*! ../../state/State */ \"./src/state/State.ts\");\n\nvar SpatialDataComponent =\n/** @class */\nfunction (_super) {\n  __extends(SpatialDataComponent, _super);\n\n  function SpatialDataComponent(name, container, navigator) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._cache = new Component_1.SpatialDataCache(navigator.graphService);\n    _this._scene = new Component_1.SpatialDataScene(_this._getDefaultConfiguration());\n    _this._viewportCoords = new Geo_1.ViewportCoords();\n    _this._geoCoords = new Geo_1.GeoCoords();\n    return _this;\n  }\n\n  SpatialDataComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._earthControlsSubscription = this._configuration$.pipe(operators_1.map(function (configuration) {\n      return configuration.earthControls;\n    }), operators_1.distinctUntilChanged(), operators_1.withLatestFrom(this._navigator.stateService.state$)).subscribe(function (_a) {\n      var earth = _a[0],\n          state = _a[1];\n\n      if (earth && state !== State_1.default.Earth) {\n        _this._navigator.stateService.earth();\n      } else if (!earth && state === State_1.default.Earth) {\n        _this._navigator.stateService.traverse();\n      }\n    });\n\n    var direction$ = this._container.renderService.bearing$.pipe(operators_1.map(function (bearing) {\n      var direction = \"\";\n\n      if (bearing > 292.5 || bearing <= 67.5) {\n        direction += \"n\";\n      }\n\n      if (bearing > 112.5 && bearing <= 247.5) {\n        direction += \"s\";\n      }\n\n      if (bearing > 22.5 && bearing <= 157.5) {\n        direction += \"e\";\n      }\n\n      if (bearing > 202.5 && bearing <= 337.5) {\n        direction += \"w\";\n      }\n\n      return direction;\n    }), operators_1.distinctUntilChanged(), operators_1.publishReplay(1), operators_1.refCount());\n\n    var hash$ = this._navigator.stateService.reference$.pipe(operators_1.tap(function () {\n      _this._scene.uncache();\n    }), operators_1.switchMap(function () {\n      return _this._navigator.stateService.currentNode$.pipe(operators_1.map(function (node) {\n        return geohash.encode(node.latLon.lat, node.latLon.lon, 8);\n      }), operators_1.distinctUntilChanged());\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    var sequencePlay$ = rxjs_1.combineLatest(this._navigator.playService.playing$, this._navigator.playService.speed$).pipe(operators_1.map(function (_a) {\n      var playing = _a[0],\n          speed = _a[1];\n      return playing && speed > PlayService_1.default.sequenceSpeed;\n    }), operators_1.distinctUntilChanged(), operators_1.publishReplay(1), operators_1.refCount());\n    this._addSubscription = rxjs_1.combineLatest(this._navigator.stateService.state$.pipe(operators_1.map(function (state) {\n      return state === State_1.default.Earth;\n    }), operators_1.distinctUntilChanged()), hash$, sequencePlay$, direction$).pipe(operators_1.distinctUntilChanged(function (_a, _b) {\n      var e1 = _a[0],\n          h1 = _a[1],\n          s1 = _a[2],\n          d1 = _a[3];\n      var e2 = _b[0],\n          h2 = _b[1],\n          s2 = _b[2],\n          d2 = _b[3];\n\n      if (e1 !== e2) {\n        return false;\n      }\n\n      if (e1) {\n        return h1 === h2 && s1 === s2;\n      }\n\n      return h1 === h2 && s1 === s2 && d1 === d2;\n    }), operators_1.concatMap(function (_a) {\n      var earth = _a[0],\n          hash = _a[1],\n          sequencePlay = _a[2],\n          direction = _a[3];\n\n      if (earth) {\n        return sequencePlay ? rxjs_1.of([hash]) : rxjs_1.of(_this._adjacentComponent(hash, 4));\n      }\n\n      return sequencePlay ? rxjs_1.of([hash, geohash.neighbours(hash)[direction]]) : rxjs_1.of(_this._computeTiles(hash, direction));\n    }), operators_1.switchMap(function (hashes) {\n      return rxjs_1.from(hashes).pipe(operators_1.mergeMap(function (h) {\n        var tile$;\n\n        if (_this._cache.hasTile(h)) {\n          tile$ = rxjs_1.of(_this._cache.getTile(h));\n        } else if (_this._cache.isCachingTile(h)) {\n          tile$ = _this._cache.cacheTile$(h).pipe(operators_1.last(null, {}), operators_1.switchMap(function () {\n            return rxjs_1.of(_this._cache.getTile(h));\n          }));\n        } else {\n          tile$ = _this._cache.cacheTile$(h);\n        }\n\n        return rxjs_1.combineLatest(rxjs_1.of(h), tile$);\n      }, 1), operators_1.map(function (_a) {\n        var hash = _a[0];\n        return hash;\n      }));\n    }), operators_1.concatMap(function (hash) {\n      var reconstructions$;\n\n      if (_this._cache.hasReconstructions(hash)) {\n        reconstructions$ = rxjs_1.from(_this._cache.getReconstructions(hash));\n      } else if (_this._cache.isCachingReconstructions(hash)) {\n        reconstructions$ = _this._cache.cacheReconstructions$(hash).pipe(operators_1.last(null, {}), operators_1.switchMap(function () {\n          return rxjs_1.from(_this._cache.getReconstructions(hash));\n        }));\n      } else if (_this._cache.hasTile(hash)) {\n        reconstructions$ = _this._cache.cacheReconstructions$(hash);\n      } else {\n        reconstructions$ = rxjs_1.empty();\n      }\n\n      return rxjs_1.combineLatest(rxjs_1.of(hash), reconstructions$);\n    }), operators_1.withLatestFrom(this._navigator.stateService.reference$), operators_1.tap(function (_a) {\n      var hash = _a[0][0],\n          reference = _a[1];\n\n      if (_this._scene.hasTile(hash)) {\n        return;\n      }\n\n      _this._scene.addTile(_this._computeTileBBox(hash, reference), hash);\n    }), operators_1.filter(function (_a) {\n      var _b = _a[0],\n          hash = _b[0],\n          data = _b[1];\n      return !_this._scene.hasReconstruction(data.reconstruction.main_shot, hash);\n    }), operators_1.map(function (_a) {\n      var _b = _a[0],\n          hash = _b[0],\n          data = _b[1],\n          reference = _a[1];\n      return [data, _this._createTransform(data.data, reference), _this._computeOriginalPosition(data.data, reference), hash];\n    })).subscribe(function (_a) {\n      var data = _a[0],\n          transform = _a[1],\n          position = _a[2],\n          hash = _a[3];\n\n      _this._scene.addReconstruction(data.reconstruction, transform, position, !!data.data.mergeCC ? data.data.mergeCC.toString() : \"\", hash);\n    });\n    this._cameraVisibilitySubscription = this._configuration$.pipe(operators_1.map(function (configuration) {\n      return configuration.camerasVisible;\n    }), operators_1.distinctUntilChanged()).subscribe(function (visible) {\n      _this._scene.setCameraVisibility(visible);\n    });\n    this._pointVisibilitySubscription = this._configuration$.pipe(operators_1.map(function (configuration) {\n      return configuration.pointsVisible;\n    }), operators_1.distinctUntilChanged()).subscribe(function (visible) {\n      _this._scene.setPointVisibility(visible);\n    });\n    this._positionVisibilitySubscription = this._configuration$.pipe(operators_1.map(function (configuration) {\n      return configuration.positionsVisible;\n    }), operators_1.distinctUntilChanged()).subscribe(function (visible) {\n      _this._scene.setPositionVisibility(visible);\n    });\n    this._tileVisibilitySubscription = this._configuration$.pipe(operators_1.map(function (configuration) {\n      return configuration.tilesVisible;\n    }), operators_1.distinctUntilChanged()).subscribe(function (visible) {\n      _this._scene.setTileVisibility(visible);\n    });\n    this._visualizeConnectedComponentSubscription = this._configuration$.pipe(operators_1.map(function (configuration) {\n      return configuration.connectedComponents;\n    }), operators_1.distinctUntilChanged()).subscribe(function (visualize) {\n      _this._scene.setConnectedComponentVisualization(visualize);\n    });\n    this._uncacheSubscription = hash$.subscribe(function (hash) {\n      var keepHashes = _this._adjacentComponent(hash, 4);\n\n      _this._scene.uncache(keepHashes);\n\n      _this._cache.uncache(keepHashes);\n    });\n    this._moveSubscription = this._navigator.playService.playing$.pipe(operators_1.switchMap(function (playing) {\n      return playing ? rxjs_1.empty() : _this._container.mouseService.dblClick$;\n    }), operators_1.withLatestFrom(this._container.renderService.renderCamera$), operators_1.switchMap(function (_a) {\n      var event = _a[0],\n          render = _a[1];\n      var element = _this._container.element;\n\n      var _b = _this._viewportCoords.canvasPosition(event, element),\n          canvasX = _b[0],\n          canvasY = _b[1];\n\n      var viewport = _this._viewportCoords.canvasToViewport(canvasX, canvasY, element);\n\n      var key = _this._scene.intersectObjects(viewport, render.perspective);\n\n      return !!key ? _this._navigator.moveToKey$(key).pipe(operators_1.catchError(function () {\n        return rxjs_1.empty();\n      })) : rxjs_1.empty();\n    })).subscribe();\n    this._renderSubscription = this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      var scene = _this._scene;\n      return {\n        name: _this._name,\n        render: {\n          frameId: frame.id,\n          needsRender: scene.needsRender,\n          render: scene.render.bind(scene),\n          stage: Render_1.GLRenderStage.Foreground\n        }\n      };\n    })).subscribe(this._container.glRenderer.render$);\n  };\n\n  SpatialDataComponent.prototype._deactivate = function () {\n    var _this = this;\n\n    this._cache.uncache();\n\n    this._scene.uncache();\n\n    this._addSubscription.unsubscribe();\n\n    this._cameraVisibilitySubscription.unsubscribe();\n\n    this._earthControlsSubscription.unsubscribe();\n\n    this._moveSubscription.unsubscribe();\n\n    this._pointVisibilitySubscription.unsubscribe();\n\n    this._positionVisibilitySubscription.unsubscribe();\n\n    this._renderSubscription.unsubscribe();\n\n    this._tileVisibilitySubscription.unsubscribe();\n\n    this._uncacheSubscription.unsubscribe();\n\n    this._visualizeConnectedComponentSubscription.unsubscribe();\n\n    this._navigator.stateService.state$.pipe(operators_1.first()).subscribe(function (state) {\n      if (state === State_1.default.Earth) {\n        _this._navigator.stateService.traverse();\n      }\n    });\n  };\n\n  SpatialDataComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      camerasVisible: false,\n      pointsVisible: true,\n      positionsVisible: false,\n      tilesVisible: false\n    };\n  };\n\n  SpatialDataComponent.prototype._adjacentComponent = function (hash, depth) {\n    var hashSet = new Set();\n    hashSet.add(hash);\n\n    this._adjacentComponentRecursive(hashSet, [hash], 0, depth);\n\n    return this._setToArray(hashSet);\n  };\n\n  SpatialDataComponent.prototype._adjacentComponentRecursive = function (hashSet, currentHashes, currentDepth, maxDepth) {\n    if (currentDepth === maxDepth) {\n      return;\n    }\n\n    var neighbours = [];\n\n    for (var _i = 0, currentHashes_1 = currentHashes; _i < currentHashes_1.length; _i++) {\n      var hash = currentHashes_1[_i];\n      var hashNeighbours = geohash.neighbours(hash);\n\n      for (var direction in hashNeighbours) {\n        if (!hashNeighbours.hasOwnProperty(direction)) {\n          continue;\n        }\n\n        neighbours.push(hashNeighbours[direction]);\n      }\n    }\n\n    var newHashes = [];\n\n    for (var _a = 0, neighbours_1 = neighbours; _a < neighbours_1.length; _a++) {\n      var neighbour = neighbours_1[_a];\n\n      if (!hashSet.has(neighbour)) {\n        hashSet.add(neighbour);\n        newHashes.push(neighbour);\n      }\n    }\n\n    this._adjacentComponentRecursive(hashSet, newHashes, currentDepth + 1, maxDepth);\n  };\n\n  SpatialDataComponent.prototype._computeOriginalPosition = function (data, reference) {\n    return this._geoCoords.geodeticToEnu(data.originalLat, data.originalLon, data.alt, reference.lat, reference.lon, reference.alt);\n  };\n\n  SpatialDataComponent.prototype._computeTileBBox = function (hash, reference) {\n    var bounds = geohash.bounds(hash);\n\n    var sw = this._geoCoords.geodeticToEnu(bounds.sw.lat, bounds.sw.lon, 0, reference.lat, reference.lon, reference.alt);\n\n    var ne = this._geoCoords.geodeticToEnu(bounds.ne.lat, bounds.ne.lon, 0, reference.lat, reference.lon, reference.alt);\n\n    return [sw, ne];\n  };\n\n  SpatialDataComponent.prototype._createTransform = function (data, reference) {\n    var translation = Geo_1.Geo.computeTranslation({\n      alt: data.alt,\n      lat: data.lat,\n      lon: data.lon\n    }, data.rotation, reference);\n    var transform = new Geo_1.Transform(data.orientation, data.width, data.height, data.focal, data.scale, data.gpano, data.rotation, translation, undefined, undefined, data.k1, data.k2, data.cameraProjection);\n    return transform;\n  };\n\n  SpatialDataComponent.prototype._computeTiles = function (hash, direction) {\n    var hashSet = new Set();\n    var directions = [\"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\"];\n\n    this._computeTilesRecursive(hashSet, hash, direction, directions, 0, 2);\n\n    return this._setToArray(hashSet);\n  };\n\n  SpatialDataComponent.prototype._computeTilesRecursive = function (hashSet, currentHash, direction, directions, currentDepth, maxDepth) {\n    hashSet.add(currentHash);\n\n    if (currentDepth === maxDepth) {\n      return;\n    }\n\n    var neighbours = geohash.neighbours(currentHash);\n    var directionIndex = directions.indexOf(direction);\n    var length = directions.length;\n    var directionNeighbours = [neighbours[directions[this._modulo(directionIndex - 1, length)]], neighbours[direction], neighbours[directions[this._modulo(directionIndex + 1, length)]]];\n\n    for (var _i = 0, directionNeighbours_1 = directionNeighbours; _i < directionNeighbours_1.length; _i++) {\n      var directionNeighbour = directionNeighbours_1[_i];\n\n      this._computeTilesRecursive(hashSet, directionNeighbour, direction, directions, currentDepth + 1, maxDepth);\n    }\n  };\n\n  SpatialDataComponent.prototype._modulo = function (a, n) {\n    return (a % n + n) % n;\n  };\n\n  SpatialDataComponent.prototype._setToArray = function (s) {\n    var a = [];\n    s.forEach(function (value) {\n      a.push(value);\n    });\n    return a;\n  };\n\n  SpatialDataComponent.componentName = \"spatialData\";\n  return SpatialDataComponent;\n}(Component_1.Component);\n\nexports.SpatialDataComponent = SpatialDataComponent;\nComponent_1.ComponentService.register(SpatialDataComponent);\nexports.default = SpatialDataComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/spatialdata/SpatialDataComponent.ts?");

/***/ }),

/***/ "./src/component/spatialdata/SpatialDataScene.ts":
/*!*******************************************************!*\
  !*** ./src/component/spatialdata/SpatialDataScene.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar SpatialDataScene =\n/** @class */\nfunction () {\n  function SpatialDataScene(configuration, scene, raycaster) {\n    this._scene = !!scene ? scene : new THREE.Scene();\n    this._raycaster = !!raycaster ? raycaster : new THREE.Raycaster(undefined, undefined, 0.8);\n    this._connectedComponentColors = {};\n    this._needsRender = false;\n    this._interactiveObjects = [];\n    this._reconstructions = {};\n    this._tiles = {};\n    this._camerasVisible = configuration.camerasVisible;\n    this._pointsVisible = configuration.pointsVisible;\n    this._positionsVisible = configuration.positionsVisible;\n    this._tilesVisible = configuration.tilesVisible;\n    this._visualizeConnectedComponents = configuration.connectedComponents;\n  }\n\n  Object.defineProperty(SpatialDataScene.prototype, \"needsRender\", {\n    get: function get() {\n      return this._needsRender;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SpatialDataScene.prototype.addReconstruction = function (reconstruction, transform, originalPosition, connectedComponent, hash) {\n    if (!(hash in this._reconstructions)) {\n      this._reconstructions[hash] = {\n        cameraKeys: {},\n        cameras: new THREE.Object3D(),\n        connectedComponents: {},\n        keys: [],\n        points: new THREE.Object3D(),\n        positions: new THREE.Object3D()\n      };\n      this._reconstructions[hash].cameras.visible = this._camerasVisible;\n      this._reconstructions[hash].points.visible = this._pointsVisible;\n      this._reconstructions[hash].positions.visible = this._positionsVisible;\n\n      this._scene.add(this._reconstructions[hash].cameras, this._reconstructions[hash].points, this._reconstructions[hash].positions);\n    }\n\n    if (!(connectedComponent in this._reconstructions[hash].connectedComponents)) {\n      this._reconstructions[hash].connectedComponents[connectedComponent] = [];\n    }\n\n    if (transform.hasValidScale) {\n      this._reconstructions[hash].points.add(this._createPoints(reconstruction, transform));\n    }\n\n    var camera = this._createCamera(transform);\n\n    this._reconstructions[hash].cameras.add(camera);\n\n    for (var _i = 0, _a = camera.children; _i < _a.length; _i++) {\n      var child = _a[_i];\n      this._reconstructions[hash].cameraKeys[child.uuid] = reconstruction.main_shot;\n\n      this._interactiveObjects.push(child);\n    }\n\n    this._reconstructions[hash].connectedComponents[connectedComponent].push(camera);\n\n    var color = this._getColor(connectedComponent, this._visualizeConnectedComponents);\n\n    this._setCameraColor(color, camera);\n\n    this._reconstructions[hash].positions.add(this._createPosition(transform, originalPosition));\n\n    this._reconstructions[hash].keys.push(reconstruction.main_shot);\n\n    this._needsRender = true;\n  };\n\n  SpatialDataScene.prototype.addTile = function (tileBBox, hash) {\n    if (this.hasTile(hash)) {\n      return;\n    }\n\n    var sw = tileBBox[0];\n    var ne = tileBBox[1];\n    var geometry = new THREE.Geometry();\n    geometry.vertices.push(new THREE.Vector3().fromArray(sw), new THREE.Vector3(sw[0], ne[1], (sw[2] + ne[2]) / 2), new THREE.Vector3().fromArray(ne), new THREE.Vector3(ne[0], sw[1], (sw[2] + ne[2]) / 2), new THREE.Vector3().fromArray(sw));\n    var tile = new THREE.Line(geometry, new THREE.LineBasicMaterial());\n    this._tiles[hash] = new THREE.Object3D();\n    this._tiles[hash].visible = this._tilesVisible;\n\n    this._tiles[hash].add(tile);\n\n    this._scene.add(this._tiles[hash]);\n\n    this._needsRender = true;\n  };\n\n  SpatialDataScene.prototype.uncache = function (keepHashes) {\n    for (var _i = 0, _a = Object.keys(this._reconstructions); _i < _a.length; _i++) {\n      var hash = _a[_i];\n\n      if (!!keepHashes && keepHashes.indexOf(hash) !== -1) {\n        continue;\n      }\n\n      this._disposeReconstruction(hash);\n    }\n\n    for (var _b = 0, _c = Object.keys(this._tiles); _b < _c.length; _b++) {\n      var hash = _c[_b];\n\n      if (!!keepHashes && keepHashes.indexOf(hash) !== -1) {\n        continue;\n      }\n\n      this._disposeTile(hash);\n    }\n\n    this._needsRender = true;\n  };\n\n  SpatialDataScene.prototype.hasReconstruction = function (key, hash) {\n    return hash in this._reconstructions && this._reconstructions[hash].keys.indexOf(key) !== -1;\n  };\n\n  SpatialDataScene.prototype.hasTile = function (hash) {\n    return hash in this._tiles;\n  };\n\n  SpatialDataScene.prototype.intersectObjects = function (_a, camera) {\n    var viewportX = _a[0],\n        viewportY = _a[1];\n\n    if (!this._camerasVisible) {\n      return null;\n    }\n\n    this._raycaster.setFromCamera(new THREE.Vector2(viewportX, viewportY), camera);\n\n    var intersects = this._raycaster.intersectObjects(this._interactiveObjects);\n\n    for (var _i = 0, intersects_1 = intersects; _i < intersects_1.length; _i++) {\n      var intersect = intersects_1[_i];\n\n      for (var hash in this._reconstructions) {\n        if (!this._reconstructions.hasOwnProperty(hash)) {\n          continue;\n        }\n\n        if (intersect.object.uuid in this._reconstructions[hash].cameraKeys) {\n          return this._reconstructions[hash].cameraKeys[intersect.object.uuid];\n        }\n      }\n    }\n\n    return null;\n  };\n\n  SpatialDataScene.prototype.setCameraVisibility = function (visible) {\n    if (visible === this._camerasVisible) {\n      return;\n    }\n\n    for (var hash in this._reconstructions) {\n      if (!this._reconstructions.hasOwnProperty(hash)) {\n        continue;\n      }\n\n      this._reconstructions[hash].cameras.visible = visible;\n    }\n\n    this._camerasVisible = visible;\n    this._needsRender = true;\n  };\n\n  SpatialDataScene.prototype.setPointVisibility = function (visible) {\n    if (visible === this._pointsVisible) {\n      return;\n    }\n\n    for (var hash in this._reconstructions) {\n      if (!this._reconstructions.hasOwnProperty(hash)) {\n        continue;\n      }\n\n      this._reconstructions[hash].points.visible = visible;\n    }\n\n    this._pointsVisible = visible;\n    this._needsRender = true;\n  };\n\n  SpatialDataScene.prototype.setPositionVisibility = function (visible) {\n    if (visible === this._positionsVisible) {\n      return;\n    }\n\n    for (var hash in this._reconstructions) {\n      if (!this._reconstructions.hasOwnProperty(hash)) {\n        continue;\n      }\n\n      this._reconstructions[hash].positions.visible = visible;\n    }\n\n    this._positionsVisible = visible;\n    this._needsRender = true;\n  };\n\n  SpatialDataScene.prototype.setTileVisibility = function (visible) {\n    if (visible === this._tilesVisible) {\n      return;\n    }\n\n    for (var hash in this._tiles) {\n      if (!this._tiles.hasOwnProperty(hash)) {\n        continue;\n      }\n\n      this._tiles[hash].visible = visible;\n    }\n\n    this._tilesVisible = visible;\n    this._needsRender = true;\n  };\n\n  SpatialDataScene.prototype.setConnectedComponentVisualization = function (visualize) {\n    if (visualize === this._visualizeConnectedComponents) {\n      return;\n    }\n\n    for (var hash in this._reconstructions) {\n      if (!this._reconstructions.hasOwnProperty(hash)) {\n        continue;\n      }\n\n      var connectedComponents = this._reconstructions[hash].connectedComponents;\n\n      for (var connectedComponent in connectedComponents) {\n        if (!connectedComponents.hasOwnProperty(connectedComponent)) {\n          continue;\n        }\n\n        var color = this._getColor(connectedComponent, visualize);\n\n        for (var _i = 0, _a = connectedComponents[connectedComponent]; _i < _a.length; _i++) {\n          var camera = _a[_i];\n\n          this._setCameraColor(color, camera);\n        }\n      }\n    }\n\n    this._visualizeConnectedComponents = visualize;\n    this._needsRender = true;\n  };\n\n  SpatialDataScene.prototype.render = function (perspectiveCamera, renderer) {\n    renderer.render(this._scene, perspectiveCamera);\n    this._needsRender = false;\n  };\n\n  SpatialDataScene.prototype._arrayToFloatArray = function (a, columns) {\n    var n = a.length;\n    var f = new Float32Array(n * columns);\n\n    for (var i = 0; i < n; i++) {\n      var item = a[i];\n      var index = 3 * i;\n      f[index + 0] = item[0];\n      f[index + 1] = item[1];\n      f[index + 2] = item[2];\n    }\n\n    return f;\n  };\n\n  SpatialDataScene.prototype._createAxis = function (transform) {\n    var north = transform.unprojectBasic([0.5, 0], 0.22);\n    var south = transform.unprojectBasic([0.5, 1], 0.16);\n    var axis = new THREE.BufferGeometry();\n    axis.addAttribute(\"position\", new THREE.BufferAttribute(this._arrayToFloatArray([north, south], 3), 3));\n    return new THREE.Line(axis, new THREE.LineBasicMaterial());\n  };\n\n  SpatialDataScene.prototype._createCamera = function (transform) {\n    return !!transform.gpano ? this._createPanoCamera(transform) : this._createPrespectiveCamera(transform);\n  };\n\n  SpatialDataScene.prototype._createDiagonals = function (transform, depth) {\n    var origin = transform.unprojectBasic([0, 0], 0, true);\n    var topLeft = transform.unprojectBasic([0, 0], depth, true);\n    var topRight = transform.unprojectBasic([1, 0], depth, true);\n    var bottomRight = transform.unprojectBasic([1, 1], depth, true);\n    var bottomLeft = transform.unprojectBasic([0, 1], depth, true);\n    var vertices = [origin, topLeft, origin, topRight, origin, bottomRight, origin, bottomLeft];\n    var diagonals = new THREE.BufferGeometry();\n    diagonals.addAttribute(\"position\", new THREE.BufferAttribute(this._arrayToFloatArray(vertices, 3), 3));\n    return new THREE.LineSegments(diagonals, new THREE.LineBasicMaterial());\n  };\n\n  SpatialDataScene.prototype._createFrame = function (transform, depth) {\n    var vertices2d = [];\n    vertices2d.push.apply(vertices2d, this._subsample([0, 1], [0, 0], 20));\n    vertices2d.push.apply(vertices2d, this._subsample([0, 0], [1, 0], 20));\n    vertices2d.push.apply(vertices2d, this._subsample([1, 0], [1, 1], 20));\n    var vertices3d = vertices2d.map(function (basic) {\n      return transform.unprojectBasic(basic, depth, true);\n    });\n    var frame = new THREE.BufferGeometry();\n    frame.addAttribute(\"position\", new THREE.BufferAttribute(this._arrayToFloatArray(vertices3d, 3), 3));\n    return new THREE.Line(frame, new THREE.LineBasicMaterial());\n  };\n\n  SpatialDataScene.prototype._createLatitude = function (basicY, numVertices, transform) {\n    var positions = new Float32Array((numVertices + 1) * 3);\n\n    for (var i = 0; i <= numVertices; i++) {\n      var position = transform.unprojectBasic([i / numVertices, basicY], 0.16);\n      var index = 3 * i;\n      positions[index + 0] = position[0];\n      positions[index + 1] = position[1];\n      positions[index + 2] = position[2];\n    }\n\n    var latitude = new THREE.BufferGeometry();\n    latitude.addAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    return new THREE.Line(latitude, new THREE.LineBasicMaterial());\n  };\n\n  SpatialDataScene.prototype._createLongitude = function (basicX, numVertices, transform) {\n    var positions = new Float32Array((numVertices + 1) * 3);\n\n    for (var i = 0; i <= numVertices; i++) {\n      var position = transform.unprojectBasic([basicX, i / numVertices], 0.16);\n      var index = 3 * i;\n      positions[index + 0] = position[0];\n      positions[index + 1] = position[1];\n      positions[index + 2] = position[2];\n    }\n\n    var latitude = new THREE.BufferGeometry();\n    latitude.addAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    return new THREE.Line(latitude, new THREE.LineBasicMaterial());\n  };\n\n  SpatialDataScene.prototype._createPanoCamera = function (transform) {\n    var camera = new THREE.Object3D();\n    camera.children.push(this._createAxis(transform));\n    camera.children.push(this._createLatitude(0.5, 10, transform));\n    camera.children.push(this._createLongitude(0, 6, transform));\n    camera.children.push(this._createLongitude(0.25, 6, transform));\n    camera.children.push(this._createLongitude(0.5, 6, transform));\n    camera.children.push(this._createLongitude(0.75, 6, transform));\n    return camera;\n  };\n\n  SpatialDataScene.prototype._createPoints = function (reconstruction, transform) {\n    var srtInverse = new THREE.Matrix4().getInverse(transform.srt);\n    var points = Object.keys(reconstruction.points).map(function (key) {\n      return reconstruction.points[key];\n    });\n    var numPoints = points.length;\n    var positions = new Float32Array(numPoints * 3);\n    var colors = new Float32Array(numPoints * 3);\n\n    for (var i = 0; i < numPoints; i++) {\n      var index = 3 * i;\n      var coords = points[i].coordinates;\n      var point = new THREE.Vector3(coords[0], coords[1], coords[2]).applyMatrix4(srtInverse);\n      positions[index + 0] = point.x;\n      positions[index + 1] = point.y;\n      positions[index + 2] = point.z;\n      var color = points[i].color;\n      colors[index + 0] = color[0] / 255.0;\n      colors[index + 1] = color[1] / 255.0;\n      colors[index + 2] = color[2] / 255.0;\n    }\n\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    geometry.addAttribute(\"color\", new THREE.BufferAttribute(colors, 3));\n    var material = new THREE.PointsMaterial({\n      size: 0.1,\n      vertexColors: THREE.VertexColors\n    });\n    return new THREE.Points(geometry, material);\n  };\n\n  SpatialDataScene.prototype._createPosition = function (transform, originalPosition) {\n    var computedPosition = transform.unprojectBasic([0, 0], 0);\n    var vertices = [originalPosition, computedPosition];\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute(\"position\", new THREE.BufferAttribute(this._arrayToFloatArray(vertices, 3), 3));\n    return new THREE.Line(geometry, new THREE.LineBasicMaterial({\n      color: new THREE.Color(1, 0, 0)\n    }));\n  };\n\n  SpatialDataScene.prototype._createPrespectiveCamera = function (transform) {\n    var depth = 0.2;\n    var camera = new THREE.Object3D();\n    camera.children.push(this._createDiagonals(transform, depth));\n    camera.children.push(this._createFrame(transform, depth));\n    return camera;\n  };\n\n  SpatialDataScene.prototype._disposeCameras = function (hash) {\n    var tileCameras = this._reconstructions[hash].cameras;\n\n    for (var _i = 0, _a = tileCameras.children.slice(); _i < _a.length; _i++) {\n      var camera = _a[_i];\n\n      for (var _b = 0, _c = camera.children; _b < _c.length; _b++) {\n        var child = _c[_b];\n        child.geometry.dispose();\n        child.material.dispose();\n\n        var index = this._interactiveObjects.indexOf(child);\n\n        if (index !== -1) {\n          this._interactiveObjects.splice(index, 1);\n        } else {\n          console.warn(\"Object does not exist (\" + child.id + \") for \" + hash);\n        }\n      }\n\n      tileCameras.remove(camera);\n    }\n\n    this._scene.remove(tileCameras);\n  };\n\n  SpatialDataScene.prototype._disposePoints = function (hash) {\n    var tilePoints = this._reconstructions[hash].points;\n\n    for (var _i = 0, _a = tilePoints.children.slice(); _i < _a.length; _i++) {\n      var points = _a[_i];\n      points.geometry.dispose();\n      points.material.dispose();\n      tilePoints.remove(points);\n    }\n\n    this._scene.remove(tilePoints);\n  };\n\n  SpatialDataScene.prototype._disposePositions = function (hash) {\n    var tilePositions = this._reconstructions[hash].positions;\n\n    for (var _i = 0, _a = tilePositions.children.slice(); _i < _a.length; _i++) {\n      var position = _a[_i];\n      position.geometry.dispose();\n      position.material.dispose();\n      tilePositions.remove(position);\n    }\n\n    this._scene.remove(tilePositions);\n  };\n\n  SpatialDataScene.prototype._disposeReconstruction = function (hash) {\n    this._disposeCameras(hash);\n\n    this._disposePoints(hash);\n\n    this._disposePositions(hash);\n\n    delete this._reconstructions[hash];\n  };\n\n  SpatialDataScene.prototype._disposeTile = function (hash) {\n    var tile = this._tiles[hash];\n\n    for (var _i = 0, _a = tile.children.slice(); _i < _a.length; _i++) {\n      var line = _a[_i];\n      line.geometry.dispose();\n      line.material.dispose();\n      tile.remove(line);\n    }\n\n    this._scene.remove(tile);\n\n    delete this._tiles[hash];\n  };\n\n  SpatialDataScene.prototype._getColor = function (connectedComponent, visualizeConnectedComponents) {\n    return visualizeConnectedComponents ? this._getConnectedComponentColor(connectedComponent) : \"#FFFFFF\";\n  };\n\n  SpatialDataScene.prototype._getConnectedComponentColor = function (connectedComponent) {\n    if (!(connectedComponent in this._connectedComponentColors)) {\n      this._connectedComponentColors[connectedComponent] = this._randomColor();\n    }\n\n    return this._connectedComponentColors[connectedComponent];\n  };\n\n  SpatialDataScene.prototype._interpolate = function (a, b, alpha) {\n    return a + alpha * (b - a);\n  };\n\n  SpatialDataScene.prototype._randomColor = function () {\n    return \"hsl(\" + Math.floor(360 * Math.random()) + \", 100%, 65%)\";\n  };\n\n  SpatialDataScene.prototype._setCameraColor = function (color, camera) {\n    for (var _i = 0, _a = camera.children; _i < _a.length; _i++) {\n      var child = _a[_i];\n      child.material.color = new THREE.Color(color);\n    }\n  };\n\n  SpatialDataScene.prototype._subsample = function (p1, p2, subsamples) {\n    if (subsamples < 1) {\n      return [p1, p2];\n    }\n\n    var samples = [];\n\n    for (var i = 0; i <= subsamples + 1; i++) {\n      var p = [];\n\n      for (var j = 0; j < 3; j++) {\n        p.push(this._interpolate(p1[j], p2[j], i / (subsamples + 1)));\n      }\n\n      samples.push(p);\n    }\n\n    return samples;\n  };\n\n  return SpatialDataScene;\n}();\n\nexports.SpatialDataScene = SpatialDataScene;\nexports.default = SpatialDataScene;\n\n//# sourceURL=webpack://Mapillary/./src/component/spatialdata/SpatialDataScene.ts?");

/***/ }),

/***/ "./src/component/tag/Tag.ts":
/*!**********************************!*\
  !*** ./src/component/tag/Tag.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar GeometryTagError_1 = __webpack_require__(/*! ./error/GeometryTagError */ \"./src/component/tag/error/GeometryTagError.ts\");\n\nexports.GeometryTagError = GeometryTagError_1.GeometryTagError;\n\nvar PointGeometry_1 = __webpack_require__(/*! ./geometry/PointGeometry */ \"./src/component/tag/geometry/PointGeometry.ts\");\n\nexports.PointGeometry = PointGeometry_1.PointGeometry;\n\nvar RectGeometry_1 = __webpack_require__(/*! ./geometry/RectGeometry */ \"./src/component/tag/geometry/RectGeometry.ts\");\n\nexports.RectGeometry = RectGeometry_1.RectGeometry;\n\nvar PolygonGeometry_1 = __webpack_require__(/*! ./geometry/PolygonGeometry */ \"./src/component/tag/geometry/PolygonGeometry.ts\");\n\nexports.PolygonGeometry = PolygonGeometry_1.PolygonGeometry;\n\nvar OutlineTag_1 = __webpack_require__(/*! ./tag/OutlineTag */ \"./src/component/tag/tag/OutlineTag.ts\");\n\nexports.OutlineTag = OutlineTag_1.OutlineTag;\n\nvar SpotTag_1 = __webpack_require__(/*! ./tag/SpotTag */ \"./src/component/tag/tag/SpotTag.ts\");\n\nexports.SpotTag = SpotTag_1.SpotTag;\n\nvar TagDomain_1 = __webpack_require__(/*! ./tag/TagDomain */ \"./src/component/tag/tag/TagDomain.ts\");\n\nexports.TagDomain = TagDomain_1.TagDomain;\n\nvar TagComponent_1 = __webpack_require__(/*! ./TagComponent */ \"./src/component/tag/TagComponent.ts\");\n\nexports.TagComponent = TagComponent_1.TagComponent;\n\nvar TagMode_1 = __webpack_require__(/*! ./TagMode */ \"./src/component/tag/TagMode.ts\");\n\nexports.TagMode = TagMode_1.TagMode;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/Tag.ts?");

/***/ }),

/***/ "./src/component/tag/TagComponent.ts":
/*!*******************************************!*\
  !*** ./src/component/tag/TagComponent.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar when = __webpack_require__(/*! when */ \"./node_modules/when/when.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n\nvar Render_1 = __webpack_require__(/*! ../../Render */ \"./src/Render.ts\");\n/**\n * @class TagComponent\n *\n * @classdesc Component for showing and editing tags with different\n * geometries composed from 2D basic image coordinates (see the\n * {@link Viewer} class documentation for more information about coordinate\n * systems).\n *\n * The `add` method is used for adding new tags or replacing\n * tags already in the set. Tags are removed by id.\n *\n * If a tag already in the set has the same\n * id as one of the tags added, the old tag will be removed and\n * the added tag will take its place.\n *\n * The tag component mode can be set to either be non interactive or\n * to be in creating mode of a certain geometry type.\n *\n * The tag properties can be updated at any time and the change will\n * be visibile immediately.\n *\n * Tags are only relevant to a single image because they are based on\n * 2D basic image coordinates. Tags related to a certain image should\n * be removed when the viewer is moved to another node.\n *\n * To retrive and use the tag component\n *\n * @example\n * ```\n * var viewer = new Mapillary.Viewer(\n *     \"<element-id>\",\n *     \"<client-id>\",\n *     \"<my key>\",\n *     { component: { tag: true } });\n *\n * var tagComponent = viewer.getComponent(\"tag\");\n * ```\n */\n\n\nvar TagComponent =\n/** @class */\nfunction (_super) {\n  __extends(TagComponent, _super);\n  /** @ignore */\n\n\n  function TagComponent(name, container, navigator) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._tagDomRenderer = new Component_1.TagDOMRenderer();\n    _this._tagScene = new Component_1.TagScene();\n    _this._tagSet = new Component_1.TagSet();\n    _this._tagCreator = new Component_1.TagCreator(_this, navigator);\n    _this._viewportCoords = new Geo_1.ViewportCoords();\n    _this._createHandlers = {\n      \"CreatePoint\": new Component_1.CreatePointHandler(_this, container, navigator, _this._viewportCoords, _this._tagCreator),\n      \"CreatePolygon\": new Component_1.CreatePolygonHandler(_this, container, navigator, _this._viewportCoords, _this._tagCreator),\n      \"CreateRect\": new Component_1.CreateRectHandler(_this, container, navigator, _this._viewportCoords, _this._tagCreator),\n      \"CreateRectDrag\": new Component_1.CreateRectDragHandler(_this, container, navigator, _this._viewportCoords, _this._tagCreator),\n      \"Default\": undefined\n    };\n    _this._editVertexHandler = new Component_1.EditVertexHandler(_this, container, navigator, _this._viewportCoords, _this._tagSet);\n    _this._renderTags$ = _this._tagSet.changed$.pipe(operators_1.map(function (tagSet) {\n      var tags = tagSet.getAll(); // ensure that tags are always rendered in the same order\n      // to avoid hover tracking problems on first resize.\n\n      tags.sort(function (t1, t2) {\n        var id1 = t1.tag.id;\n        var id2 = t2.tag.id;\n\n        if (id1 < id2) {\n          return -1;\n        }\n\n        if (id1 > id2) {\n          return 1;\n        }\n\n        return 0;\n      });\n      return tags;\n    }), operators_1.share());\n    _this._tagChanged$ = _this._renderTags$.pipe(operators_1.switchMap(function (tags) {\n      return rxjs_1.from(tags).pipe(operators_1.mergeMap(function (tag) {\n        return rxjs_1.merge(tag.tag.changed$, tag.tag.geometryChanged$);\n      }));\n    }), operators_1.share());\n    _this._renderTagGLChanged$ = _this._renderTags$.pipe(operators_1.switchMap(function (tags) {\n      return rxjs_1.from(tags).pipe(operators_1.mergeMap(function (tag) {\n        return tag.glObjectsChanged$;\n      }));\n    }), operators_1.share());\n    _this._createGeometryChanged$ = _this._tagCreator.tag$.pipe(operators_1.switchMap(function (tag) {\n      return tag != null ? tag.geometryChanged$ : rxjs_1.empty();\n    }), operators_1.share());\n    _this._createGLObjectsChanged$ = _this._tagCreator.tag$.pipe(operators_1.switchMap(function (tag) {\n      return tag != null ? tag.glObjectsChanged$ : rxjs_1.empty();\n    }), operators_1.share());\n    _this._creatingConfiguration$ = _this._configuration$.pipe(operators_1.distinctUntilChanged(function (c1, c2) {\n      return c1.mode === c2.mode;\n    }, function (configuration) {\n      return {\n        createColor: configuration.createColor,\n        mode: configuration.mode\n      };\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    _this._creatingConfiguration$.subscribe(function (configuration) {\n      _this.fire(TagComponent.modechanged, configuration.mode);\n    });\n\n    return _this;\n  }\n  /**\n   * Add tags to the tag set or replace tags in the tag set.\n   *\n   * @description If a tag already in the set has the same\n   * id as one of the tags added, the old tag will be removed\n   * the added tag will take its place.\n   *\n   * @param {Array<Tag>} tags - Tags to add.\n   *\n   * @example ```tagComponent.add([tag1, tag2]);```\n   */\n\n\n  TagComponent.prototype.add = function (tags) {\n    var _this = this;\n\n    if (this._activated) {\n      this._navigator.stateService.currentTransform$.pipe(operators_1.first()).subscribe(function (transform) {\n        _this._tagSet.add(tags, transform);\n\n        var renderTags = tags.map(function (tag) {\n          return _this._tagSet.get(tag.id);\n        });\n\n        _this._tagScene.add(renderTags);\n      });\n    } else {\n      this._tagSet.addDeactivated(tags);\n    }\n  };\n  /**\n   * Change the current tag mode.\n   *\n   * @description Change the tag mode to one of the create modes for creating new geometries.\n   *\n   * @param {TagMode} mode - New tag mode.\n   *\n   * @fires TagComponent#modechanged\n   *\n   * @example ```tagComponent.changeMode(Mapillary.TagComponent.TagMode.CreateRect);```\n   */\n\n\n  TagComponent.prototype.changeMode = function (mode) {\n    this.configure({\n      mode: mode\n    });\n  };\n  /**\n   * Returns the tag in the tag set with the specified id, or\n   * undefined if the id matches no tag.\n   *\n   * @param {string} tagId - Id of the tag.\n   *\n   * @example ```var tag = tagComponent.get(\"tagId\");```\n   */\n\n\n  TagComponent.prototype.get = function (tagId) {\n    if (this._activated) {\n      var renderTag = this._tagSet.get(tagId);\n\n      return renderTag !== undefined ? renderTag.tag : undefined;\n    } else {\n      return this._tagSet.getDeactivated(tagId);\n    }\n  };\n  /**\n   * Returns an array of all tags.\n   *\n   * @example ```var tags = tagComponent.getAll();```\n   */\n\n\n  TagComponent.prototype.getAll = function () {\n    if (this.activated) {\n      return this._tagSet.getAll().map(function (renderTag) {\n        return renderTag.tag;\n      });\n    } else {\n      return this._tagSet.getAllDeactivated();\n    }\n  };\n  /**\n   * Returns an array of tag ids for tags that contain the specified point.\n   *\n   * @description The pixel point must lie inside the polygon or rectangle\n   * of an added tag for the tag id to be returned. Tag ids for\n   * tags that do not have a fill will also be returned if the point is inside\n   * the geometry of the tag. Tags with point geometries can not be retrieved.\n   *\n   * No tag ids will be returned for polygons rendered in cropped panoramas or\n   * rectangles rendered in panoramas.\n   *\n   * Notice that the pixelPoint argument requires x, y coordinates from pixel space.\n   *\n   * With this function, you can use the coordinates provided by mouse\n   * events to get information out of the tag component.\n   *\n   * If no tag at exist the pixel point, an empty array will be returned.\n   *\n   * @param {Array<number>} pixelPoint - Pixel coordinates on the viewer element.\n   * @returns {Array<string>} Ids of the tags that contain the specified pixel point.\n   *\n   * @example\n   * ```\n   * tagComponent.getTagIdsAt([100, 100])\n   *     .then((tagIds) => { console.log(tagIds); });\n   * ```\n   */\n\n\n  TagComponent.prototype.getTagIdsAt = function (pixelPoint) {\n    var _this = this;\n\n    return when.promise(function (resolve, reject) {\n      _this._container.renderService.renderCamera$.pipe(operators_1.first(), operators_1.map(function (render) {\n        var viewport = _this._viewportCoords.canvasToViewport(pixelPoint[0], pixelPoint[1], _this._container.element);\n\n        var ids = _this._tagScene.intersectObjects(viewport, render.perspective);\n\n        return ids;\n      })).subscribe(function (ids) {\n        resolve(ids);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Check if a tag exist in the tag set.\n   *\n   * @param {string} tagId - Id of the tag.\n   *\n   * @example ```var tagExists = tagComponent.has(\"tagId\");```\n   */\n\n\n  TagComponent.prototype.has = function (tagId) {\n    return this._activated ? this._tagSet.has(tagId) : this._tagSet.hasDeactivated(tagId);\n  };\n  /**\n   * Remove tags with the specified ids from the tag set.\n   *\n   * @param {Array<string>} tagIds - Ids for tags to remove.\n   *\n   * @example ```tagComponent.remove([\"id-1\", \"id-2\"]);```\n   */\n\n\n  TagComponent.prototype.remove = function (tagIds) {\n    if (this._activated) {\n      this._tagSet.remove(tagIds);\n\n      this._tagScene.remove(tagIds);\n    } else {\n      this._tagSet.removeDeactivated(tagIds);\n    }\n  };\n  /**\n   * Remove all tags from the tag set.\n   *\n   * @example ```tagComponent.removeAll();```\n   */\n\n\n  TagComponent.prototype.removeAll = function () {\n    if (this._activated) {\n      this._tagSet.removeAll();\n\n      this._tagScene.removeAll();\n    } else {\n      this._tagSet.removeAllDeactivated();\n    }\n  };\n\n  TagComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._editVertexHandler.enable();\n\n    var handlerGeometryCreated$ = rxjs_1.from(Object.keys(this._createHandlers)).pipe(operators_1.map(function (key) {\n      return _this._createHandlers[key];\n    }), operators_1.filter(function (handler) {\n      return !!handler;\n    }), operators_1.mergeMap(function (handler) {\n      return handler.geometryCreated$;\n    }), operators_1.share());\n    this._fireGeometryCreatedSubscription = handlerGeometryCreated$.subscribe(function (geometry) {\n      _this.fire(TagComponent.geometrycreated, geometry);\n    });\n    this._fireCreateGeometryEventSubscription = this._tagCreator.tag$.pipe(operators_1.skipWhile(function (tag) {\n      return tag == null;\n    }), operators_1.distinctUntilChanged()).subscribe(function (tag) {\n      var eventType = tag != null ? TagComponent.creategeometrystart : TagComponent.creategeometryend;\n\n      _this.fire(eventType, _this);\n    });\n    this._handlerStopCreateSubscription = handlerGeometryCreated$.subscribe(function () {\n      _this.changeMode(Component_1.TagMode.Default);\n    });\n    this._handlerEnablerSubscription = this._creatingConfiguration$.subscribe(function (configuration) {\n      _this._disableCreateHandlers();\n\n      var mode = Component_1.TagMode[configuration.mode];\n      var handler = _this._createHandlers[mode];\n\n      if (!!handler) {\n        handler.enable();\n      }\n    });\n    this._fireTagsChangedSubscription = this._renderTags$.subscribe(function (tags) {\n      _this.fire(TagComponent.tagschanged, _this);\n    });\n    this._stopCreateSubscription = this._tagCreator.tag$.pipe(operators_1.switchMap(function (tag) {\n      return tag != null ? tag.aborted$.pipe(operators_1.map(function (t) {\n        return null;\n      })) : rxjs_1.empty();\n    })).subscribe(function () {\n      _this.changeMode(Component_1.TagMode.Default);\n    });\n    this._setGLCreateTagSubscription = this._tagCreator.tag$.subscribe(function (tag) {\n      if (_this._tagScene.hasCreateTag()) {\n        _this._tagScene.removeCreateTag();\n      }\n\n      if (tag != null) {\n        _this._tagScene.addCreateTag(tag);\n      }\n    });\n    this._createGLObjectsChangedSubscription = this._createGLObjectsChanged$.subscribe(function (tag) {\n      _this._tagScene.updateCreateTagObjects(tag);\n    });\n    this._updateGLObjectsSubscription = this._renderTagGLChanged$.subscribe(function (tag) {\n      _this._tagScene.updateObjects(tag);\n    });\n    this._updateTagSceneSubscription = this._tagChanged$.subscribe(function (tag) {\n      _this._tagScene.update();\n    });\n    this._domSubscription = rxjs_1.combineLatest(this._renderTags$.pipe(operators_1.startWith([]), operators_1.tap(function (tags) {\n      _this._container.domRenderer.render$.next({\n        name: _this._name,\n        vnode: _this._tagDomRenderer.clear()\n      });\n    })), this._container.renderService.renderCamera$, this._container.spriteService.spriteAtlas$, this._container.renderService.size$, this._tagChanged$.pipe(operators_1.startWith(null)), rxjs_1.merge(this._tagCreator.tag$, this._createGeometryChanged$).pipe(operators_1.startWith(null))).pipe(operators_1.map(function (_a) {\n      var renderTags = _a[0],\n          rc = _a[1],\n          atlas = _a[2],\n          size = _a[3],\n          tag = _a[4],\n          ct = _a[5];\n      return {\n        name: _this._name,\n        vnode: _this._tagDomRenderer.render(renderTags, ct, atlas, rc.perspective, size)\n      };\n    })).subscribe(this._container.domRenderer.render$);\n    this._glSubscription = this._navigator.stateService.currentState$.pipe(operators_1.map(function (frame) {\n      var tagScene = _this._tagScene;\n      return {\n        name: _this._name,\n        render: {\n          frameId: frame.id,\n          needsRender: tagScene.needsRender,\n          render: tagScene.render.bind(tagScene),\n          stage: Render_1.GLRenderStage.Foreground\n        }\n      };\n    })).subscribe(this._container.glRenderer.render$);\n\n    this._navigator.stateService.currentTransform$.pipe(operators_1.first()).subscribe(function (transform) {\n      _this._tagSet.activate(transform);\n\n      _this._tagScene.add(_this._tagSet.getAll());\n    });\n  };\n\n  TagComponent.prototype._deactivate = function () {\n    this._editVertexHandler.disable();\n\n    this._disableCreateHandlers();\n\n    this._tagScene.clear();\n\n    this._tagSet.deactivate();\n\n    this._tagCreator.delete$.next(null);\n\n    this._updateGLObjectsSubscription.unsubscribe();\n\n    this._updateTagSceneSubscription.unsubscribe();\n\n    this._stopCreateSubscription.unsubscribe();\n\n    this._setGLCreateTagSubscription.unsubscribe();\n\n    this._createGLObjectsChangedSubscription.unsubscribe();\n\n    this._domSubscription.unsubscribe();\n\n    this._glSubscription.unsubscribe();\n\n    this._fireCreateGeometryEventSubscription.unsubscribe();\n\n    this._fireGeometryCreatedSubscription.unsubscribe();\n\n    this._fireTagsChangedSubscription.unsubscribe();\n\n    this._handlerStopCreateSubscription.unsubscribe();\n\n    this._handlerEnablerSubscription.unsubscribe();\n\n    this._container.element.classList.remove(\"component-tag-create\");\n  };\n\n  TagComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      createColor: 0xFFFFFF,\n      mode: Component_1.TagMode.Default\n    };\n  };\n\n  TagComponent.prototype._disableCreateHandlers = function () {\n    var createHandlers = this._createHandlers;\n\n    for (var key in createHandlers) {\n      if (!createHandlers.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var handler = createHandlers[key];\n\n      if (!!handler) {\n        handler.disable();\n      }\n    }\n  };\n  /** @inheritdoc */\n\n\n  TagComponent.componentName = \"tag\";\n  /**\n   * Event fired when an interaction to create a geometry ends.\n   *\n   * @description A create interaction can by a geometry being created\n   * or by the creation being aborted.\n   *\n   * @event TagComponent#creategeometryend\n   * @type {TagComponent} Tag component.\n   * @example\n   * ```\n   * tagComponent.on(\"creategeometryend\", function(component) {\n   *     console.log(component);\n   * });\n   * ```\n   */\n\n  TagComponent.creategeometryend = \"creategeometryend\";\n  /**\n   * Event fired when an interaction to create a geometry starts.\n   *\n   * @description A create interaction starts when the first vertex\n   * is created in the geometry.\n   *\n   * @event TagComponent#creategeometrystart\n   * @type {TagComponent} Tag component.\n   * @example\n   * ```\n   * tagComponent.on(\"creategeometrystart\", function(component) {\n   *     console.log(component);\n   * });\n   * ```\n   */\n\n  TagComponent.creategeometrystart = \"creategeometrystart\";\n  /**\n   * Event fired when the create mode is changed.\n   *\n   * @event TagComponent#modechanged\n   * @type {TagMode} Tag mode\n   * @example\n   * ```\n   * tagComponent.on(\"modechanged\", function(mode) {\n   *     console.log(mode);\n   * });\n   * ```\n   */\n\n  TagComponent.modechanged = \"modechanged\";\n  /**\n   * Event fired when a geometry has been created.\n   *\n   * @event TagComponent#geometrycreated\n   * @type {Geometry} Created geometry.\n   * @example\n   * ```\n   * tagComponent.on(\"geometrycreated\", function(geometry) {\n   *     console.log(geometry);\n   * });\n   * ```\n   */\n\n  TagComponent.geometrycreated = \"geometrycreated\";\n  /**\n   * Event fired when the tags collection has changed.\n   *\n   * @event TagComponent#tagschanged\n   * @type {TagComponent} Tag component.\n   * @example\n   * ```\n   * tagComponent.on(\"tagschanged\", function(component) {\n   *     console.log(component.getAll());\n   * });\n   * ```\n   */\n\n  TagComponent.tagschanged = \"tagschanged\";\n  return TagComponent;\n}(Component_1.Component);\n\nexports.TagComponent = TagComponent;\nComponent_1.ComponentService.register(TagComponent);\nexports.default = TagComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/TagComponent.ts?");

/***/ }),

/***/ "./src/component/tag/TagCreator.ts":
/*!*****************************************!*\
  !*** ./src/component/tag/TagCreator.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar TagCreator =\n/** @class */\nfunction () {\n  function TagCreator(component, navigator) {\n    this._component = component;\n    this._navigator = navigator;\n    this._tagOperation$ = new rxjs_1.Subject();\n    this._createPolygon$ = new rxjs_1.Subject();\n    this._createRect$ = new rxjs_1.Subject();\n    this._delete$ = new rxjs_1.Subject();\n    this._tag$ = this._tagOperation$.pipe(operators_1.scan(function (tag, operation) {\n      return operation(tag);\n    }, null), operators_1.share());\n\n    this._createRect$.pipe(operators_1.withLatestFrom(this._component.configuration$, this._navigator.stateService.currentTransform$), operators_1.map(function (_a) {\n      var coord = _a[0],\n          conf = _a[1],\n          transform = _a[2];\n      return function (tag) {\n        var geometry = new Component_1.RectGeometry([coord[0], coord[1], coord[0], coord[1]]);\n        return new Component_1.OutlineCreateTag(geometry, {\n          color: conf.createColor\n        }, transform);\n      };\n    })).subscribe(this._tagOperation$);\n\n    this._createPolygon$.pipe(operators_1.withLatestFrom(this._component.configuration$, this._navigator.stateService.currentTransform$), operators_1.map(function (_a) {\n      var coord = _a[0],\n          conf = _a[1],\n          transform = _a[2];\n      return function (tag) {\n        var geometry = new Component_1.PolygonGeometry([[coord[0], coord[1]], [coord[0], coord[1]], [coord[0], coord[1]]]);\n        return new Component_1.OutlineCreateTag(geometry, {\n          color: conf.createColor\n        }, transform);\n      };\n    })).subscribe(this._tagOperation$);\n\n    this._delete$.pipe(operators_1.map(function () {\n      return function (tag) {\n        return null;\n      };\n    })).subscribe(this._tagOperation$);\n  }\n\n  Object.defineProperty(TagCreator.prototype, \"createRect$\", {\n    get: function get() {\n      return this._createRect$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TagCreator.prototype, \"createPolygon$\", {\n    get: function get() {\n      return this._createPolygon$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TagCreator.prototype, \"delete$\", {\n    get: function get() {\n      return this._delete$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TagCreator.prototype, \"tag$\", {\n    get: function get() {\n      return this._tag$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return TagCreator;\n}();\n\nexports.TagCreator = TagCreator;\nexports.default = TagCreator;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/TagCreator.ts?");

/***/ }),

/***/ "./src/component/tag/TagDOMRenderer.ts":
/*!*********************************************!*\
  !*** ./src/component/tag/TagDOMRenderer.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar TagDOMRenderer =\n/** @class */\nfunction () {\n  function TagDOMRenderer() {}\n\n  TagDOMRenderer.prototype.render = function (tags, createTag, atlas, camera, size) {\n    var vNodes = [];\n\n    for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {\n      var tag = tags_1[_i];\n      vNodes = vNodes.concat(tag.getDOMObjects(atlas, camera, size));\n    }\n\n    if (createTag != null) {\n      vNodes = vNodes.concat(createTag.getDOMObjects(camera, size));\n    }\n\n    return vd.h(\"div.TagContainer\", {}, vNodes);\n  };\n\n  TagDOMRenderer.prototype.clear = function () {\n    return vd.h(\"div\", {}, []);\n  };\n\n  return TagDOMRenderer;\n}();\n\nexports.TagDOMRenderer = TagDOMRenderer;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/TagDOMRenderer.ts?");

/***/ }),

/***/ "./src/component/tag/TagMode.ts":
/*!**************************************!*\
  !*** ./src/component/tag/TagMode.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enumeration for tag modes\n * @enum {number}\n * @readonly\n * @description Modes for the interaction in the tag component.\n */\n\nvar TagMode;\n\n(function (TagMode) {\n  /**\n   * Disables creating tags.\n   */\n  TagMode[TagMode[\"Default\"] = 0] = \"Default\";\n  /**\n   * Create a point geometry through a click.\n   */\n\n  TagMode[TagMode[\"CreatePoint\"] = 1] = \"CreatePoint\";\n  /**\n   * Create a polygon geometry through clicks.\n   */\n\n  TagMode[TagMode[\"CreatePolygon\"] = 2] = \"CreatePolygon\";\n  /**\n   * Create a rect geometry through clicks.\n   */\n\n  TagMode[TagMode[\"CreateRect\"] = 3] = \"CreateRect\";\n  /**\n   * Create a rect geometry through drag.\n   *\n   * @description Claims the mouse which results in mouse handlers like\n   * drag pan and scroll zoom becoming inactive.\n   */\n\n  TagMode[TagMode[\"CreateRectDrag\"] = 4] = \"CreateRectDrag\";\n})(TagMode = exports.TagMode || (exports.TagMode = {}));\n\nexports.default = TagMode;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/TagMode.ts?");

/***/ }),

/***/ "./src/component/tag/TagOperation.ts":
/*!*******************************************!*\
  !*** ./src/component/tag/TagOperation.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar TagOperation;\n\n(function (TagOperation) {\n  TagOperation[TagOperation[\"None\"] = 0] = \"None\";\n  TagOperation[TagOperation[\"Centroid\"] = 1] = \"Centroid\";\n  TagOperation[TagOperation[\"Vertex\"] = 2] = \"Vertex\";\n})(TagOperation = exports.TagOperation || (exports.TagOperation = {}));\n\nexports.default = TagOperation;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/TagOperation.ts?");

/***/ }),

/***/ "./src/component/tag/TagScene.ts":
/*!***************************************!*\
  !*** ./src/component/tag/TagScene.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar TagScene =\n/** @class */\nfunction () {\n  function TagScene(scene, raycaster) {\n    this._createTag = null;\n    this._needsRender = false;\n    this._raycaster = !!raycaster ? raycaster : new THREE.Raycaster();\n    this._scene = !!scene ? scene : new THREE.Scene();\n    this._objectTags = {};\n    this._retrievableObjects = [];\n    this._tags = {};\n  }\n\n  Object.defineProperty(TagScene.prototype, \"needsRender\", {\n    get: function get() {\n      return this._needsRender;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TagScene.prototype.add = function (tags) {\n    for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {\n      var tag = tags_1[_i];\n\n      if (tag.tag.id in this._tags) {\n        this._remove(tag.tag.id);\n      }\n\n      this._add(tag);\n    }\n\n    this._needsRender = true;\n  };\n\n  TagScene.prototype.addCreateTag = function (tag) {\n    for (var _i = 0, _a = tag.glObjects; _i < _a.length; _i++) {\n      var object = _a[_i];\n\n      this._scene.add(object);\n    }\n\n    this._createTag = {\n      tag: tag,\n      objects: tag.glObjects\n    };\n    this._needsRender = true;\n  };\n\n  TagScene.prototype.clear = function () {\n    for (var _i = 0, _a = Object.keys(this._tags); _i < _a.length; _i++) {\n      var id = _a[_i];\n\n      this._remove(id);\n    }\n\n    this._needsRender = false;\n  };\n\n  TagScene.prototype.get = function (id) {\n    return this.has(id) ? this._tags[id].tag : undefined;\n  };\n\n  TagScene.prototype.has = function (id) {\n    return id in this._tags;\n  };\n\n  TagScene.prototype.hasCreateTag = function () {\n    return this._createTag != null;\n  };\n\n  TagScene.prototype.intersectObjects = function (_a, camera) {\n    var viewportX = _a[0],\n        viewportY = _a[1];\n\n    this._raycaster.setFromCamera(new THREE.Vector2(viewportX, viewportY), camera);\n\n    var intersects = this._raycaster.intersectObjects(this._retrievableObjects);\n\n    var intersectedIds = [];\n\n    for (var _i = 0, intersects_1 = intersects; _i < intersects_1.length; _i++) {\n      var intersect = intersects_1[_i];\n\n      if (intersect.object.uuid in this._objectTags) {\n        intersectedIds.push(this._objectTags[intersect.object.uuid]);\n      }\n    }\n\n    return intersectedIds;\n  };\n\n  TagScene.prototype.remove = function (ids) {\n    for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {\n      var id = ids_1[_i];\n\n      this._remove(id);\n    }\n\n    this._needsRender = true;\n  };\n\n  TagScene.prototype.removeAll = function () {\n    for (var _i = 0, _a = Object.keys(this._tags); _i < _a.length; _i++) {\n      var id = _a[_i];\n\n      this._remove(id);\n    }\n\n    this._needsRender = true;\n  };\n\n  TagScene.prototype.removeCreateTag = function () {\n    if (this._createTag == null) {\n      return;\n    }\n\n    for (var _i = 0, _a = this._createTag.objects; _i < _a.length; _i++) {\n      var object = _a[_i];\n\n      this._scene.remove(object);\n    }\n\n    this._createTag.tag.dispose();\n\n    this._createTag = null;\n    this._needsRender = true;\n  };\n\n  TagScene.prototype.render = function (perspectiveCamera, renderer) {\n    renderer.render(this._scene, perspectiveCamera);\n    this._needsRender = false;\n  };\n\n  TagScene.prototype.update = function () {\n    this._needsRender = true;\n  };\n\n  TagScene.prototype.updateCreateTagObjects = function (tag) {\n    if (this._createTag.tag !== tag) {\n      throw new Error(\"Create tags do not have the same reference.\");\n    }\n\n    for (var _i = 0, _a = this._createTag.objects; _i < _a.length; _i++) {\n      var object = _a[_i];\n\n      this._scene.remove(object);\n    }\n\n    for (var _b = 0, _c = tag.glObjects; _b < _c.length; _b++) {\n      var object = _c[_b];\n\n      this._scene.add(object);\n    }\n\n    this._createTag.objects = tag.glObjects;\n    this._needsRender = true;\n  };\n\n  TagScene.prototype.updateObjects = function (tag) {\n    var id = tag.tag.id;\n\n    if (this._tags[id].tag !== tag) {\n      throw new Error(\"Tags do not have the same reference.\");\n    }\n\n    var tagObjects = this._tags[id];\n\n    this._removeObjects(tagObjects);\n\n    delete this._tags[id];\n\n    this._add(tag);\n\n    this._needsRender = true;\n  };\n\n  TagScene.prototype._add = function (tag) {\n    var id = tag.tag.id;\n    var tagObjects = {\n      tag: tag,\n      objects: [],\n      retrievableObjects: []\n    };\n    this._tags[id] = tagObjects;\n\n    for (var _i = 0, _a = tag.getGLObjects(); _i < _a.length; _i++) {\n      var object = _a[_i];\n      tagObjects.objects.push(object);\n\n      this._scene.add(object);\n    }\n\n    for (var _b = 0, _c = tag.getRetrievableObjects(); _b < _c.length; _b++) {\n      var retrievableObject = _c[_b];\n      tagObjects.retrievableObjects.push(retrievableObject);\n\n      this._retrievableObjects.push(retrievableObject);\n\n      this._objectTags[retrievableObject.uuid] = tag.tag.id;\n    }\n  };\n\n  TagScene.prototype._remove = function (id) {\n    var tagObjects = this._tags[id];\n\n    this._removeObjects(tagObjects);\n\n    tagObjects.tag.dispose();\n    delete this._tags[id];\n  };\n\n  TagScene.prototype._removeObjects = function (tagObjects) {\n    for (var _i = 0, _a = tagObjects.objects; _i < _a.length; _i++) {\n      var object = _a[_i];\n\n      this._scene.remove(object);\n    }\n\n    for (var _b = 0, _c = tagObjects.retrievableObjects; _b < _c.length; _b++) {\n      var retrievableObject = _c[_b];\n\n      var index = this._retrievableObjects.indexOf(retrievableObject);\n\n      if (index !== -1) {\n        this._retrievableObjects.splice(index, 1);\n      }\n    }\n  };\n\n  return TagScene;\n}();\n\nexports.TagScene = TagScene;\nexports.default = TagScene;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/TagScene.ts?");

/***/ }),

/***/ "./src/component/tag/TagSet.ts":
/*!*************************************!*\
  !*** ./src/component/tag/TagSet.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar TagSet =\n/** @class */\nfunction () {\n  function TagSet() {\n    this._active = false;\n    this._hash = {};\n    this._hashDeactivated = {};\n    this._notifyChanged$ = new rxjs_1.Subject();\n  }\n\n  Object.defineProperty(TagSet.prototype, \"active\", {\n    get: function get() {\n      return this._active;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TagSet.prototype, \"changed$\", {\n    get: function get() {\n      return this._notifyChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TagSet.prototype.activate = function (transform) {\n    if (this._active) {\n      return;\n    }\n\n    for (var id in this._hashDeactivated) {\n      if (!this._hashDeactivated.hasOwnProperty(id)) {\n        continue;\n      }\n\n      var tag = this._hashDeactivated[id];\n\n      this._add(tag, transform);\n    }\n\n    this._hashDeactivated = {};\n    this._active = true;\n\n    this._notifyChanged$.next(this);\n  };\n\n  TagSet.prototype.deactivate = function () {\n    if (!this._active) {\n      return;\n    }\n\n    for (var id in this._hash) {\n      if (!this._hash.hasOwnProperty(id)) {\n        continue;\n      }\n\n      this._hashDeactivated[id] = this._hash[id].tag;\n    }\n\n    this._hash = {};\n    this._active = false;\n  };\n\n  TagSet.prototype.add = function (tags, transform) {\n    this._assertActivationState(true);\n\n    for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {\n      var tag = tags_1[_i];\n\n      this._add(tag, transform);\n    }\n\n    this._notifyChanged$.next(this);\n  };\n\n  TagSet.prototype.addDeactivated = function (tags) {\n    this._assertActivationState(false);\n\n    for (var _i = 0, tags_2 = tags; _i < tags_2.length; _i++) {\n      var tag = tags_2[_i];\n\n      if (!(tag instanceof Component_1.OutlineTag || tag instanceof Component_1.SpotTag)) {\n        throw new Error(\"Tag type not supported\");\n      }\n\n      this._hashDeactivated[tag.id] = tag;\n    }\n  };\n\n  TagSet.prototype.get = function (id) {\n    return this.has(id) ? this._hash[id] : undefined;\n  };\n\n  TagSet.prototype.getAll = function () {\n    var hash = this._hash;\n    return Object.keys(hash).map(function (id) {\n      return hash[id];\n    });\n  };\n\n  TagSet.prototype.getAllDeactivated = function () {\n    var hashDeactivated = this._hashDeactivated;\n    return Object.keys(hashDeactivated).map(function (id) {\n      return hashDeactivated[id];\n    });\n  };\n\n  TagSet.prototype.getDeactivated = function (id) {\n    return this.hasDeactivated(id) ? this._hashDeactivated[id] : undefined;\n  };\n\n  TagSet.prototype.has = function (id) {\n    return id in this._hash;\n  };\n\n  TagSet.prototype.hasDeactivated = function (id) {\n    return id in this._hashDeactivated;\n  };\n\n  TagSet.prototype.remove = function (ids) {\n    this._assertActivationState(true);\n\n    var hash = this._hash;\n\n    for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {\n      var id = ids_1[_i];\n\n      if (!(id in hash)) {\n        continue;\n      }\n\n      delete hash[id];\n    }\n\n    this._notifyChanged$.next(this);\n  };\n\n  TagSet.prototype.removeAll = function () {\n    this._assertActivationState(true);\n\n    this._hash = {};\n\n    this._notifyChanged$.next(this);\n  };\n\n  TagSet.prototype.removeAllDeactivated = function () {\n    this._assertActivationState(false);\n\n    this._hashDeactivated = {};\n  };\n\n  TagSet.prototype.removeDeactivated = function (ids) {\n    this._assertActivationState(false);\n\n    var hashDeactivated = this._hashDeactivated;\n\n    for (var _i = 0, ids_2 = ids; _i < ids_2.length; _i++) {\n      var id = ids_2[_i];\n\n      if (!(id in hashDeactivated)) {\n        continue;\n      }\n\n      delete hashDeactivated[id];\n    }\n  };\n\n  TagSet.prototype._add = function (tag, transform) {\n    if (tag instanceof Component_1.OutlineTag) {\n      this._hash[tag.id] = new Component_1.OutlineRenderTag(tag, transform);\n    } else if (tag instanceof Component_1.SpotTag) {\n      this._hash[tag.id] = new Component_1.SpotRenderTag(tag, transform);\n    } else {\n      throw new Error(\"Tag type not supported\");\n    }\n  };\n\n  TagSet.prototype._assertActivationState = function (should) {\n    if (should !== this._active) {\n      throw new Error(\"Tag set not in correct state for operation.\");\n    }\n  };\n\n  return TagSet;\n}();\n\nexports.TagSet = TagSet;\nexports.default = TagSet;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/TagSet.ts?");

/***/ }),

/***/ "./src/component/tag/error/GeometryTagError.ts":
/*!*****************************************************!*\
  !*** ./src/component/tag/error/GeometryTagError.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Error_1 = __webpack_require__(/*! ../../../Error */ \"./src/Error.ts\");\n\nvar GeometryTagError =\n/** @class */\nfunction (_super) {\n  __extends(GeometryTagError, _super);\n\n  function GeometryTagError(message) {\n    var _this = _super.call(this, message != null ? message : \"The provided geometry value is incorrect\") || this;\n\n    _this.name = \"GeometryTagError\";\n    return _this;\n  }\n\n  return GeometryTagError;\n}(Error_1.MapillaryError);\n\nexports.GeometryTagError = GeometryTagError;\nexports.default = Error_1.MapillaryError;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/error/GeometryTagError.ts?");

/***/ }),

/***/ "./src/component/tag/geometry/Geometry.ts":
/*!************************************************!*\
  !*** ./src/component/tag/geometry/Geometry.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n/**\n * @class Geometry\n * @abstract\n * @classdesc Represents a geometry.\n */\n\n\nvar Geometry =\n/** @class */\nfunction () {\n  /**\n   * Create a geometry.\n   *\n   * @constructor\n   * @ignore\n   */\n  function Geometry() {\n    this._notifyChanged$ = new rxjs_1.Subject();\n  }\n\n  Object.defineProperty(Geometry.prototype, \"changed$\", {\n    /**\n     * Get changed observable.\n     *\n     * @description Emits the geometry itself every time the geometry\n     * has changed.\n     *\n     * @returns {Observable<Geometry>} Observable emitting the geometry instance.\n     * @ignore\n     */\n    get: function get() {\n      return this._notifyChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Geometry;\n}();\n\nexports.Geometry = Geometry;\nexports.default = Geometry;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/geometry/Geometry.ts?");

/***/ }),

/***/ "./src/component/tag/geometry/PointGeometry.ts":
/*!*****************************************************!*\
  !*** ./src/component/tag/geometry/PointGeometry.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n/**\n * @class PointGeometry\n *\n * @classdesc Represents a point geometry in the 2D basic image coordinate system.\n *\n * @example\n * ```\n * var basicPoint = [0.5, 0.7];\n * var pointGeometry = new Mapillary.TagComponent.PointGeometry(basicPoint);\n * ```\n */\n\n\nvar PointGeometry =\n/** @class */\nfunction (_super) {\n  __extends(PointGeometry, _super);\n  /**\n   * Create a point geometry.\n   *\n   * @constructor\n   * @param {Array<number>} point - An array representing the basic coordinates of\n   * the point.\n   *\n   * @throws {GeometryTagError} Point coordinates must be valid basic coordinates.\n   */\n\n\n  function PointGeometry(point) {\n    var _this = _super.call(this) || this;\n\n    var x = point[0];\n    var y = point[1];\n\n    if (x < 0 || x > 1 || y < 0 || y > 1) {\n      throw new Component_1.GeometryTagError(\"Basic coordinates must be on the interval [0, 1].\");\n    }\n\n    _this._point = point.slice();\n    return _this;\n  }\n\n  Object.defineProperty(PointGeometry.prototype, \"point\", {\n    /**\n     * Get point property.\n     * @returns {Array<number>} Array representing the basic coordinates of the point.\n     */\n    get: function get() {\n      return this._point;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Get the 2D basic coordinates for the centroid of the point, i.e. the 2D\n   * basic coordinates of the point itself.\n   *\n   * @returns {Array<number>} 2D basic coordinates representing the centroid.\n   * @ignore\n   */\n\n  PointGeometry.prototype.getCentroid2d = function () {\n    return this._point.slice();\n  };\n  /**\n   * Get the 3D world coordinates for the centroid of the point, i.e. the 3D\n   * world coordinates of the point itself.\n   *\n   * @param {Transform} transform - The transform of the node related to the point.\n   * @returns {Array<number>} 3D world coordinates representing the centroid.\n   * @ignore\n   */\n\n\n  PointGeometry.prototype.getCentroid3d = function (transform) {\n    return transform.unprojectBasic(this._point, 200);\n  };\n  /**\n   * Set the centroid of the point, i.e. the point coordinates.\n   *\n   * @param {Array<number>} value - The new value of the centroid.\n   * @param {Transform} transform - The transform of the node related to the point.\n   * @ignore\n   */\n\n\n  PointGeometry.prototype.setCentroid2d = function (value, transform) {\n    var changed = [Math.max(0, Math.min(1, value[0])), Math.max(0, Math.min(1, value[1]))];\n    this._point[0] = changed[0];\n    this._point[1] = changed[1];\n\n    this._notifyChanged$.next(this);\n  };\n\n  return PointGeometry;\n}(Component_1.Geometry);\n\nexports.PointGeometry = PointGeometry;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/geometry/PointGeometry.ts?");

/***/ }),

/***/ "./src/component/tag/geometry/PolygonGeometry.ts":
/*!*******************************************************!*\
  !*** ./src/component/tag/geometry/PolygonGeometry.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n/**\n * @class PolygonGeometry\n *\n * @classdesc Represents a polygon geometry in the 2D basic image coordinate system.\n * All polygons and holes provided to the constructor needs to be closed.\n *\n * @example\n * ```\n * var basicPolygon = [[0.5, 0.3], [0.7, 0.3], [0.6, 0.5], [0.5, 0.3]];\n * var polygonGeometry = new Mapillary.TagComponent.PolygonGeometry(basicPolygon);\n * ```\n */\n\n\nvar PolygonGeometry =\n/** @class */\nfunction (_super) {\n  __extends(PolygonGeometry, _super);\n  /**\n   * Create a polygon geometry.\n   *\n   * @constructor\n   * @param {Array<Array<number>>} polygon - Array of polygon vertices. Must be closed.\n   * @param {Array<Array<Array<number>>>} [holes] - Array of arrays of hole vertices.\n   * Each array of holes vertices must be closed.\n   *\n   * @throws {GeometryTagError} Polygon coordinates must be valid basic coordinates.\n   */\n\n\n  function PolygonGeometry(polygon, holes) {\n    var _this = _super.call(this) || this;\n\n    var polygonLength = polygon.length;\n\n    if (polygonLength < 3) {\n      throw new Component_1.GeometryTagError(\"A polygon must have three or more positions.\");\n    }\n\n    if (polygon[0][0] !== polygon[polygonLength - 1][0] || polygon[0][1] !== polygon[polygonLength - 1][1]) {\n      throw new Component_1.GeometryTagError(\"First and last positions must be equivalent.\");\n    }\n\n    _this._polygon = [];\n\n    for (var _i = 0, polygon_1 = polygon; _i < polygon_1.length; _i++) {\n      var vertex = polygon_1[_i];\n\n      if (vertex[0] < 0 || vertex[0] > 1 || vertex[1] < 0 || vertex[1] > 1) {\n        throw new Component_1.GeometryTagError(\"Basic coordinates of polygon must be on the interval [0, 1].\");\n      }\n\n      _this._polygon.push(vertex.slice());\n    }\n\n    _this._holes = [];\n\n    if (holes == null) {\n      return _this;\n    }\n\n    for (var i = 0; i < holes.length; i++) {\n      var hole = holes[i];\n      var holeLength = hole.length;\n\n      if (holeLength < 3) {\n        throw new Component_1.GeometryTagError(\"A polygon hole must have three or more positions.\");\n      }\n\n      if (hole[0][0] !== hole[holeLength - 1][0] || hole[0][1] !== hole[holeLength - 1][1]) {\n        throw new Component_1.GeometryTagError(\"First and last positions of hole must be equivalent.\");\n      }\n\n      _this._holes.push([]);\n\n      for (var _a = 0, hole_1 = hole; _a < hole_1.length; _a++) {\n        var vertex = hole_1[_a];\n\n        if (vertex[0] < 0 || vertex[0] > 1 || vertex[1] < 0 || vertex[1] > 1) {\n          throw new Component_1.GeometryTagError(\"Basic coordinates of hole must be on the interval [0, 1].\");\n        }\n\n        _this._holes[i].push(vertex.slice());\n      }\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(PolygonGeometry.prototype, \"polygon\", {\n    /**\n     * Get polygon property.\n     * @returns {Array<Array<number>>} Closed 2d polygon.\n     */\n    get: function get() {\n      return this._polygon;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PolygonGeometry.prototype, \"holes\", {\n    /**\n     * Get holes property.\n     * @returns {Array<Array<Array<number>>>} Holes of 2d polygon.\n     */\n    get: function get() {\n      return this._holes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Add a vertex to the polygon by appending it after the last vertex.\n   *\n   * @param {Array<number>} vertex - Vertex to add.\n   * @ignore\n   */\n\n  PolygonGeometry.prototype.addVertex2d = function (vertex) {\n    var clamped = [Math.max(0, Math.min(1, vertex[0])), Math.max(0, Math.min(1, vertex[1]))];\n\n    this._polygon.splice(this._polygon.length - 1, 0, clamped);\n\n    this._notifyChanged$.next(this);\n  };\n  /**\n   * Get the coordinates of a vertex from the polygon representation of the geometry.\n   *\n   * @description The first vertex represents the bottom-left corner with the rest of\n   * the vertices following in clockwise order.\n   *\n   * @param {number} index - Vertex index.\n   * @returns {Array<number>} Array representing the 2D basic coordinates of the vertex.\n   * @ignore\n   */\n\n\n  PolygonGeometry.prototype.getVertex2d = function (index) {\n    return this._polygon[index].slice();\n  };\n  /**\n   * Remove a vertex from the polygon.\n   *\n   * @param {number} index - The index of the vertex to remove.\n   * @ignore\n   */\n\n\n  PolygonGeometry.prototype.removeVertex2d = function (index) {\n    if (index < 0 || index >= this._polygon.length || this._polygon.length < 4) {\n      throw new Component_1.GeometryTagError(\"Index for removed vertex must be valid.\");\n    }\n\n    if (index > 0 && index < this._polygon.length - 1) {\n      this._polygon.splice(index, 1);\n    } else {\n      this._polygon.splice(0, 1);\n\n      this._polygon.pop();\n\n      var closing = this._polygon[0].slice();\n\n      this._polygon.push(closing);\n    }\n\n    this._notifyChanged$.next(this);\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.setVertex2d = function (index, value, transform) {\n    var changed = [Math.max(0, Math.min(1, value[0])), Math.max(0, Math.min(1, value[1]))];\n\n    if (index === 0 || index === this._polygon.length - 1) {\n      this._polygon[0] = changed.slice();\n      this._polygon[this._polygon.length - 1] = changed.slice();\n    } else {\n      this._polygon[index] = changed.slice();\n    }\n\n    this._notifyChanged$.next(this);\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.setCentroid2d = function (value, transform) {\n    var xs = this._polygon.map(function (point) {\n      return point[0];\n    });\n\n    var ys = this._polygon.map(function (point) {\n      return point[1];\n    });\n\n    var minX = Math.min.apply(Math, xs);\n    var maxX = Math.max.apply(Math, xs);\n    var minY = Math.min.apply(Math, ys);\n    var maxY = Math.max.apply(Math, ys);\n    var centroid = this.getCentroid2d();\n    var minTranslationX = -minX;\n    var maxTranslationX = 1 - maxX;\n    var minTranslationY = -minY;\n    var maxTranslationY = 1 - maxY;\n    var translationX = Math.max(minTranslationX, Math.min(maxTranslationX, value[0] - centroid[0]));\n    var translationY = Math.max(minTranslationY, Math.min(maxTranslationY, value[1] - centroid[1]));\n\n    for (var _i = 0, _a = this._polygon; _i < _a.length; _i++) {\n      var point = _a[_i];\n      point[0] += translationX;\n      point[1] += translationY;\n    }\n\n    this._notifyChanged$.next(this);\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.getPoints3d = function (transform) {\n    return this._getPoints3d(this._subsample(this._polygon), transform);\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.getVertex3d = function (index, transform) {\n    return transform.unprojectBasic(this._polygon[index], 200);\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.getVertices2d = function () {\n    return this._polygon.slice();\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.getVertices3d = function (transform) {\n    return this._getPoints3d(this._polygon, transform);\n  };\n  /**\n   * Get a polygon representation of the 3D coordinates for the vertices of each hole\n   * of the geometry. Line segments between vertices will possibly be subsampled\n   * resulting in a larger number of points than the total number of vertices.\n   *\n   * @param {Transform} transform - The transform of the node related to the geometry.\n   * @returns {Array<Array<Array<number>>>} Array of hole polygons in 3D world coordinates\n   * representing the vertices of each hole of the geometry.\n   * @ignore\n   */\n\n\n  PolygonGeometry.prototype.getHolePoints3d = function (transform) {\n    var _this = this;\n\n    return this._holes.map(function (hole2d) {\n      return _this._getPoints3d(_this._subsample(hole2d), transform);\n    });\n  };\n  /**\n   * Get a polygon representation of the 3D coordinates for the vertices of each hole\n   * of the geometry.\n   *\n   * @param {Transform} transform - The transform of the node related to the geometry.\n   * @returns {Array<Array<Array<number>>>} Array of hole polygons in 3D world coordinates\n   * representing the vertices of each hole of the geometry.\n   * @ignore\n   */\n\n\n  PolygonGeometry.prototype.getHoleVertices3d = function (transform) {\n    var _this = this;\n\n    return this._holes.map(function (hole2d) {\n      return _this._getPoints3d(hole2d, transform);\n    });\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.getCentroid2d = function () {\n    var polygon = this._polygon;\n    var area = 0;\n    var centroidX = 0;\n    var centroidY = 0;\n\n    for (var i = 0; i < polygon.length - 1; i++) {\n      var xi = polygon[i][0];\n      var yi = polygon[i][1];\n      var xi1 = polygon[i + 1][0];\n      var yi1 = polygon[i + 1][1];\n      var a = xi * yi1 - xi1 * yi;\n      area += a;\n      centroidX += (xi + xi1) * a;\n      centroidY += (yi + yi1) * a;\n    }\n\n    area /= 2;\n    centroidX /= 6 * area;\n    centroidY /= 6 * area;\n    return [centroidX, centroidY];\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.getCentroid3d = function (transform) {\n    var centroid2d = this.getCentroid2d();\n    return transform.unprojectBasic(centroid2d, 200);\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.get3dDomainTriangles3d = function (transform) {\n    var _this = this;\n\n    return this._triangulate(this._project(this._polygon, transform), this.getVertices3d(transform), this._holes.map(function (hole2d) {\n      return _this._project(hole2d, transform);\n    }), this.getHoleVertices3d(transform));\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.getTriangles3d = function (transform) {\n    var _this = this;\n\n    if (transform.fullPano) {\n      return this._triangulatePano(this._polygon.slice(), this.holes.slice(), transform);\n    }\n\n    var points2d = this._project(this._subsample(this._polygon), transform);\n\n    var points3d = this.getPoints3d(transform);\n\n    var holes2d = this._holes.map(function (hole) {\n      return _this._project(_this._subsample(hole), transform);\n    });\n\n    var holes3d = this.getHolePoints3d(transform);\n    return this._triangulate(points2d, points3d, holes2d, holes3d);\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.getPoleOfInaccessibility2d = function () {\n    return this._getPoleOfInaccessibility2d(this._polygon.slice());\n  };\n  /** @ignore */\n\n\n  PolygonGeometry.prototype.getPoleOfInaccessibility3d = function (transform) {\n    var pole2d = this._getPoleOfInaccessibility2d(this._polygon.slice());\n\n    return transform.unprojectBasic(pole2d, 200);\n  };\n\n  PolygonGeometry.prototype._getPoints3d = function (points2d, transform) {\n    return points2d.map(function (point) {\n      return transform.unprojectBasic(point, 200);\n    });\n  };\n\n  return PolygonGeometry;\n}(Component_1.VertexGeometry);\n\nexports.PolygonGeometry = PolygonGeometry;\nexports.default = PolygonGeometry;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/geometry/PolygonGeometry.ts?");

/***/ }),

/***/ "./src/component/tag/geometry/RectGeometry.ts":
/*!****************************************************!*\
  !*** ./src/component/tag/geometry/RectGeometry.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n/**\n * @class RectGeometry\n *\n * @classdesc Represents a rectangle geometry in the 2D basic image coordinate system.\n *\n * @example\n * ```\n * var basicRect = [0.5, 0.3, 0.7, 0.4];\n * var rectGeometry = new Mapillary.TagComponent.RectGeometry(basicRect);\n * ```\n */\n\n\nvar RectGeometry =\n/** @class */\nfunction (_super) {\n  __extends(RectGeometry, _super);\n  /**\n   * Create a rectangle geometry.\n   *\n   * @constructor\n   * @param {Array<number>} rect - An array representing the top-left and bottom-right\n   * corners of the rectangle in basic coordinates. Ordered according to [x0, y0, x1, y1].\n   *\n   * @throws {GeometryTagError} Rectangle coordinates must be valid basic coordinates.\n   */\n\n\n  function RectGeometry(rect) {\n    var _this = _super.call(this) || this;\n\n    if (rect[1] > rect[3]) {\n      throw new Component_1.GeometryTagError(\"Basic Y coordinates values can not be inverted.\");\n    }\n\n    for (var _i = 0, rect_1 = rect; _i < rect_1.length; _i++) {\n      var coord = rect_1[_i];\n\n      if (coord < 0 || coord > 1) {\n        throw new Component_1.GeometryTagError(\"Basic coordinates must be on the interval [0, 1].\");\n      }\n    }\n\n    _this._anchorIndex = undefined;\n    _this._rect = rect.slice(0, 4);\n    _this._inverted = _this._rect[0] > _this._rect[2];\n    return _this;\n  }\n\n  Object.defineProperty(RectGeometry.prototype, \"anchorIndex\", {\n    /**\n     * Get anchor index property.\n     *\n     * @returns {number} Index representing the current anchor property if\n     * achoring indexing has been initialized. If anchor indexing has not been\n     * initialized or has been terminated undefined will be returned.\n     * @ignore\n     */\n    get: function get() {\n      return this._anchorIndex;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RectGeometry.prototype, \"inverted\", {\n    /**\n     * Get inverted property.\n     *\n     * @returns {boolean} Boolean determining whether the rect geometry is\n     * inverted. For panoramas the rect geometrye may be inverted.\n     * @ignore\n     */\n    get: function get() {\n      return this._inverted;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RectGeometry.prototype, \"rect\", {\n    /**\n     * Get rect property.\n     *\n     * @returns {Array<number>} Array representing the top-left and bottom-right\n     * corners of the rectangle in basic coordinates.\n     */\n    get: function get() {\n      return this._rect;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Initialize anchor indexing to enable setting opposite vertex.\n   *\n   * @param {number} [index] - The index of the vertex to use as anchor.\n   *\n   * @throws {Error} If anchor indexing has already been initialized.\n   * @throws {Error} If index is not valid (0 to 3).\n   * @ignore\n   */\n\n  RectGeometry.prototype.initializeAnchorIndexing = function (index) {\n    if (this._anchorIndex !== undefined) {\n      throw new Error(\"Anchor indexing is already initialized.\");\n    }\n\n    if (index < 0 || index > 3) {\n      throw new Error(\"Invalid anchor index: \" + index + \".\");\n    }\n\n    this._anchorIndex = index === undefined ? 0 : index;\n  };\n  /**\n   * Terminate anchor indexing to disable setting pposite vertex.\n   * @ignore\n   */\n\n\n  RectGeometry.prototype.terminateAnchorIndexing = function () {\n    this._anchorIndex = undefined;\n  };\n  /**\n   * Set the value of the vertex opposite to the anchor in the polygon\n   * representation of the rectangle.\n   *\n   * @description Setting the opposite vertex may change the anchor index.\n   *\n   * @param {Array<number>} opposite - The new value of the vertex opposite to the anchor.\n   * @param {Transform} transform - The transform of the node related to the rectangle.\n   *\n   * @throws {Error} When anchor indexing has not been initialized.\n   * @ignore\n   */\n\n\n  RectGeometry.prototype.setOppositeVertex2d = function (opposite, transform) {\n    if (this._anchorIndex === undefined) {\n      throw new Error(\"Anchor indexing needs to be initialized.\");\n    }\n\n    var changed = [Math.max(0, Math.min(1, opposite[0])), Math.max(0, Math.min(1, opposite[1]))];\n\n    var original = this._rect.slice();\n\n    var anchor = this._anchorIndex === 0 ? [original[0], original[3]] : this._anchorIndex === 1 ? [original[0], original[1]] : this._anchorIndex === 2 ? [original[2], original[1]] : [original[2], original[3]];\n\n    if (transform.fullPano) {\n      var deltaX = this._anchorIndex < 2 ? changed[0] - original[2] : changed[0] - original[0];\n\n      if (!this._inverted && this._anchorIndex < 2 && changed[0] < 0.25 && original[2] > 0.75 && deltaX < -0.5) {\n        // right side passes boundary rightward\n        this._inverted = true;\n        this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;\n      } else if (!this._inverted && this._anchorIndex >= 2 && changed[0] < 0.25 && original[2] > 0.75 && deltaX < -0.5) {\n        // left side passes right side and boundary rightward\n        this._inverted = true;\n        this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;\n      } else if (this._inverted && this._anchorIndex >= 2 && changed[0] < 0.25 && original[0] > 0.75 && deltaX < -0.5) {\n        this._inverted = false;\n\n        if (anchor[0] > changed[0]) {\n          // left side passes boundary rightward\n          this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;\n        } else {\n          // left side passes right side and boundary rightward\n          this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;\n        }\n      } else if (!this._inverted && this._anchorIndex >= 2 && changed[0] > 0.75 && original[0] < 0.25 && deltaX > 0.5) {\n        // left side passes boundary leftward\n        this._inverted = true;\n        this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;\n      } else if (!this._inverted && this._anchorIndex < 2 && changed[0] > 0.75 && original[0] < 0.25 && deltaX > 0.5) {\n        // right side passes left side and boundary leftward\n        this._inverted = true;\n        this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;\n      } else if (this._inverted && this._anchorIndex < 2 && changed[0] > 0.75 && original[2] < 0.25 && deltaX > 0.5) {\n        this._inverted = false;\n\n        if (anchor[0] > changed[0]) {\n          // right side passes boundary leftward\n          this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;\n        } else {\n          // right side passes left side and boundary leftward\n          this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;\n        }\n      } else if (this._inverted && this._anchorIndex < 2 && changed[0] > original[0]) {\n        // inverted and right side passes left side completing a loop\n        this._inverted = false;\n        this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;\n      } else if (this._inverted && this._anchorIndex >= 2 && changed[0] < original[2]) {\n        // inverted and left side passes right side completing a loop\n        this._inverted = false;\n        this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;\n      } else if (this._inverted) {\n        // if still inverted only top and bottom can switch\n        if (this._anchorIndex < 2) {\n          this._anchorIndex = anchor[1] > changed[1] ? 0 : 1;\n        } else {\n          this._anchorIndex = anchor[1] > changed[1] ? 3 : 2;\n        }\n      } else {\n        // if still not inverted treat as non full pano\n        if (anchor[0] <= changed[0] && anchor[1] > changed[1]) {\n          this._anchorIndex = 0;\n        } else if (anchor[0] <= changed[0] && anchor[1] <= changed[1]) {\n          this._anchorIndex = 1;\n        } else if (anchor[0] > changed[0] && anchor[1] <= changed[1]) {\n          this._anchorIndex = 2;\n        } else {\n          this._anchorIndex = 3;\n        }\n      }\n\n      var rect = [];\n\n      if (this._anchorIndex === 0) {\n        rect[0] = anchor[0];\n        rect[1] = changed[1];\n        rect[2] = changed[0];\n        rect[3] = anchor[1];\n      } else if (this._anchorIndex === 1) {\n        rect[0] = anchor[0];\n        rect[1] = anchor[1];\n        rect[2] = changed[0];\n        rect[3] = changed[1];\n      } else if (this._anchorIndex === 2) {\n        rect[0] = changed[0];\n        rect[1] = anchor[1];\n        rect[2] = anchor[0];\n        rect[3] = changed[1];\n      } else {\n        rect[0] = changed[0];\n        rect[1] = changed[1];\n        rect[2] = anchor[0];\n        rect[3] = anchor[1];\n      }\n\n      if (!this._inverted && rect[0] > rect[2] || this._inverted && rect[0] < rect[2]) {\n        rect[0] = original[0];\n        rect[2] = original[2];\n      }\n\n      if (rect[1] > rect[3]) {\n        rect[1] = original[1];\n        rect[3] = original[3];\n      }\n\n      this._rect[0] = rect[0];\n      this._rect[1] = rect[1];\n      this._rect[2] = rect[2];\n      this._rect[3] = rect[3];\n    } else {\n      if (anchor[0] <= changed[0] && anchor[1] > changed[1]) {\n        this._anchorIndex = 0;\n      } else if (anchor[0] <= changed[0] && anchor[1] <= changed[1]) {\n        this._anchorIndex = 1;\n      } else if (anchor[0] > changed[0] && anchor[1] <= changed[1]) {\n        this._anchorIndex = 2;\n      } else {\n        this._anchorIndex = 3;\n      }\n\n      var rect = [];\n\n      if (this._anchorIndex === 0) {\n        rect[0] = anchor[0];\n        rect[1] = changed[1];\n        rect[2] = changed[0];\n        rect[3] = anchor[1];\n      } else if (this._anchorIndex === 1) {\n        rect[0] = anchor[0];\n        rect[1] = anchor[1];\n        rect[2] = changed[0];\n        rect[3] = changed[1];\n      } else if (this._anchorIndex === 2) {\n        rect[0] = changed[0];\n        rect[1] = anchor[1];\n        rect[2] = anchor[0];\n        rect[3] = changed[1];\n      } else {\n        rect[0] = changed[0];\n        rect[1] = changed[1];\n        rect[2] = anchor[0];\n        rect[3] = anchor[1];\n      }\n\n      if (rect[0] > rect[2]) {\n        rect[0] = original[0];\n        rect[2] = original[2];\n      }\n\n      if (rect[1] > rect[3]) {\n        rect[1] = original[1];\n        rect[3] = original[3];\n      }\n\n      this._rect[0] = rect[0];\n      this._rect[1] = rect[1];\n      this._rect[2] = rect[2];\n      this._rect[3] = rect[3];\n    }\n\n    this._notifyChanged$.next(this);\n  };\n  /**\n   * Set the value of a vertex in the polygon representation of the rectangle.\n   *\n   * @description The polygon is defined to have the first vertex at the\n   * bottom-left corner with the rest of the vertices following in clockwise order.\n   *\n   * @param {number} index - The index of the vertex to be set.\n   * @param {Array<number>} value - The new value of the vertex.\n   * @param {Transform} transform - The transform of the node related to the rectangle.\n   * @ignore\n   */\n\n\n  RectGeometry.prototype.setVertex2d = function (index, value, transform) {\n    var original = this._rect.slice();\n\n    var changed = [Math.max(0, Math.min(1, value[0])), Math.max(0, Math.min(1, value[1]))];\n    var rect = [];\n\n    if (index === 0) {\n      rect[0] = changed[0];\n      rect[1] = original[1];\n      rect[2] = original[2];\n      rect[3] = changed[1];\n    } else if (index === 1) {\n      rect[0] = changed[0];\n      rect[1] = changed[1];\n      rect[2] = original[2];\n      rect[3] = original[3];\n    } else if (index === 2) {\n      rect[0] = original[0];\n      rect[1] = changed[1];\n      rect[2] = changed[0];\n      rect[3] = original[3];\n    } else if (index === 3) {\n      rect[0] = original[0];\n      rect[1] = original[1];\n      rect[2] = changed[0];\n      rect[3] = changed[1];\n    }\n\n    if (transform.fullPano) {\n      var passingBoundaryLeftward = index < 2 && changed[0] > 0.75 && original[0] < 0.25 || index >= 2 && this._inverted && changed[0] > 0.75 && original[2] < 0.25;\n      var passingBoundaryRightward = index < 2 && this._inverted && changed[0] < 0.25 && original[0] > 0.75 || index >= 2 && changed[0] < 0.25 && original[2] > 0.75;\n\n      if (passingBoundaryLeftward || passingBoundaryRightward) {\n        this._inverted = !this._inverted;\n      } else {\n        if (rect[0] - original[0] < -0.25) {\n          rect[0] = original[0];\n        }\n\n        if (rect[2] - original[2] > 0.25) {\n          rect[2] = original[2];\n        }\n      }\n\n      if (!this._inverted && rect[0] > rect[2] || this._inverted && rect[0] < rect[2]) {\n        rect[0] = original[0];\n        rect[2] = original[2];\n      }\n    } else {\n      if (rect[0] > rect[2]) {\n        rect[0] = original[0];\n        rect[2] = original[2];\n      }\n    }\n\n    if (rect[1] > rect[3]) {\n      rect[1] = original[1];\n      rect[3] = original[3];\n    }\n\n    this._rect[0] = rect[0];\n    this._rect[1] = rect[1];\n    this._rect[2] = rect[2];\n    this._rect[3] = rect[3];\n\n    this._notifyChanged$.next(this);\n  };\n  /** @ignore */\n\n\n  RectGeometry.prototype.setCentroid2d = function (value, transform) {\n    var original = this._rect.slice();\n\n    var x0 = original[0];\n    var x1 = this._inverted ? original[2] + 1 : original[2];\n    var y0 = original[1];\n    var y1 = original[3];\n    var centerX = x0 + (x1 - x0) / 2;\n    var centerY = y0 + (y1 - y0) / 2;\n    var translationX = 0;\n\n    if (transform.gpano != null && transform.gpano.CroppedAreaImageWidthPixels === transform.gpano.FullPanoWidthPixels) {\n      translationX = this._inverted ? value[0] + 1 - centerX : value[0] - centerX;\n    } else {\n      var minTranslationX = -x0;\n      var maxTranslationX = 1 - x1;\n      translationX = Math.max(minTranslationX, Math.min(maxTranslationX, value[0] - centerX));\n    }\n\n    var minTranslationY = -y0;\n    var maxTranslationY = 1 - y1;\n    var translationY = Math.max(minTranslationY, Math.min(maxTranslationY, value[1] - centerY));\n    this._rect[0] = original[0] + translationX;\n    this._rect[1] = original[1] + translationY;\n    this._rect[2] = original[2] + translationX;\n    this._rect[3] = original[3] + translationY;\n\n    if (this._rect[0] < 0) {\n      this._rect[0] += 1;\n      this._inverted = !this._inverted;\n    } else if (this._rect[0] > 1) {\n      this._rect[0] -= 1;\n      this._inverted = !this._inverted;\n    }\n\n    if (this._rect[2] < 0) {\n      this._rect[2] += 1;\n      this._inverted = !this._inverted;\n    } else if (this._rect[2] > 1) {\n      this._rect[2] -= 1;\n      this._inverted = !this._inverted;\n    }\n\n    this._notifyChanged$.next(this);\n  };\n  /**\n   * Get the 3D coordinates for the vertices of the rectangle with\n   * interpolated points along the lines.\n   *\n   * @param {Transform} transform - The transform of the node related to\n   * the rectangle.\n   * @returns {Array<Array<number>>} Polygon array of 3D world coordinates\n   * representing the rectangle.\n   * @ignore\n   */\n\n\n  RectGeometry.prototype.getPoints3d = function (transform) {\n    return this._getPoints2d().map(function (point) {\n      return transform.unprojectBasic(point, 200);\n    });\n  };\n  /**\n   * Get the coordinates of a vertex from the polygon representation of the geometry.\n   *\n   * @description The first vertex represents the bottom-left corner with the rest of\n   * the vertices following in clockwise order. The method shifts the right side\n   * coordinates of the rectangle by one unit to ensure that the vertices are ordered\n   * clockwise.\n   *\n   * @param {number} index - Vertex index.\n   * @returns {Array<number>} Array representing the 2D basic coordinates of the vertex.\n   * @ignore\n   */\n\n\n  RectGeometry.prototype.getVertex2d = function (index) {\n    return this._rectToVertices2d(this._rect)[index];\n  };\n  /**\n   * Get the coordinates of a vertex from the polygon representation of the geometry.\n   *\n   * @description The first vertex represents the bottom-left corner with the rest of\n   * the vertices following in clockwise order. The coordinates will not be shifted\n   * so they may not appear in clockwise order when layed out on the plane.\n   *\n   * @param {number} index - Vertex index.\n   * @returns {Array<number>} Array representing the 2D basic coordinates of the vertex.\n   * @ignore\n   */\n\n\n  RectGeometry.prototype.getNonAdjustedVertex2d = function (index) {\n    return this._rectToNonAdjustedVertices2d(this._rect)[index];\n  };\n  /**\n   * Get a vertex from the polygon representation of the 3D coordinates for the\n   * vertices of the geometry.\n   *\n   * @description The first vertex represents the bottom-left corner with the rest of\n   * the vertices following in clockwise order.\n   *\n   * @param {number} index - Vertex index.\n   * @param {Transform} transform - The transform of the node related to the geometry.\n   * @returns {Array<Array<number>>} Polygon array of 3D world coordinates representing\n   * the vertices of the geometry.\n   * @ignore\n   */\n\n\n  RectGeometry.prototype.getVertex3d = function (index, transform) {\n    return transform.unprojectBasic(this._rectToVertices2d(this._rect)[index], 200);\n  };\n  /**\n   * Get a polygon representation of the 2D basic coordinates for the vertices of the rectangle.\n   *\n   * @description The first vertex represents the bottom-left corner with the rest of\n   * the vertices following in clockwise order.\n   *\n   * @returns {Array<Array<number>>} Polygon array of 2D basic coordinates representing\n   * the rectangle vertices.\n   * @ignore\n   */\n\n\n  RectGeometry.prototype.getVertices2d = function () {\n    return this._rectToVertices2d(this._rect);\n  };\n  /**\n   * Get a polygon representation of the 3D coordinates for the vertices of the rectangle.\n   *\n   * @description The first vertex represents the bottom-left corner with the rest of\n   * the vertices following in clockwise order.\n   *\n   * @param {Transform} transform - The transform of the node related to the rectangle.\n   * @returns {Array<Array<number>>} Polygon array of 3D world coordinates representing\n   * the rectangle vertices.\n   * @ignore\n   */\n\n\n  RectGeometry.prototype.getVertices3d = function (transform) {\n    return this._rectToVertices2d(this._rect).map(function (vertex) {\n      return transform.unprojectBasic(vertex, 200);\n    });\n  };\n  /** @ignore */\n\n\n  RectGeometry.prototype.getCentroid2d = function () {\n    var rect = this._rect;\n    var x0 = rect[0];\n    var x1 = this._inverted ? rect[2] + 1 : rect[2];\n    var y0 = rect[1];\n    var y1 = rect[3];\n    var centroidX = (x0 + x1) / 2;\n    var centroidY = (y0 + y1) / 2;\n    return [centroidX, centroidY];\n  };\n  /** @ignore */\n\n\n  RectGeometry.prototype.getCentroid3d = function (transform) {\n    var centroid2d = this.getCentroid2d();\n    return transform.unprojectBasic(centroid2d, 200);\n  };\n  /**\n   * @ignore\n   */\n\n\n  RectGeometry.prototype.getPoleOfInaccessibility2d = function () {\n    return this._getPoleOfInaccessibility2d(this._rectToVertices2d(this._rect));\n  };\n  /** @ignore */\n\n\n  RectGeometry.prototype.getPoleOfInaccessibility3d = function (transform) {\n    var pole2d = this._getPoleOfInaccessibility2d(this._rectToVertices2d(this._rect));\n\n    return transform.unprojectBasic(pole2d, 200);\n  };\n  /** @ignore */\n\n\n  RectGeometry.prototype.getTriangles3d = function (transform) {\n    return transform.fullPano ? [] : this._triangulate(this._project(this._getPoints2d(), transform), this.getPoints3d(transform));\n  };\n  /**\n   * Check if a particular bottom-right value is valid according to the current\n   * rectangle coordinates.\n   *\n   * @param {Array<number>} bottomRight - The bottom-right coordinates to validate\n   * @returns {boolean} Value indicating whether the provided bottom-right coordinates\n   * are valid.\n   * @ignore\n   */\n\n\n  RectGeometry.prototype.validate = function (bottomRight) {\n    var rect = this._rect;\n\n    if (!this._inverted && bottomRight[0] < rect[0] || bottomRight[0] - rect[2] > 0.25 || bottomRight[1] < rect[1]) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Get the 2D coordinates for the vertices of the rectangle with\n   * interpolated points along the lines.\n   *\n   * @returns {Array<Array<number>>} Polygon array of 2D basic coordinates\n   * representing the rectangle.\n   */\n\n\n  RectGeometry.prototype._getPoints2d = function () {\n    var vertices2d = this._rectToVertices2d(this._rect);\n\n    var sides = vertices2d.length - 1;\n    var sections = 10;\n    var points2d = [];\n\n    for (var i = 0; i < sides; ++i) {\n      var startX = vertices2d[i][0];\n      var startY = vertices2d[i][1];\n      var endX = vertices2d[i + 1][0];\n      var endY = vertices2d[i + 1][1];\n      var intervalX = (endX - startX) / (sections - 1);\n      var intervalY = (endY - startY) / (sections - 1);\n\n      for (var j = 0; j < sections; ++j) {\n        var point = [startX + j * intervalX, startY + j * intervalY];\n        points2d.push(point);\n      }\n    }\n\n    return points2d;\n  };\n  /**\n   * Convert the top-left, bottom-right representation of a rectangle to a polygon\n   * representation of the vertices starting at the bottom-left corner going\n   * clockwise.\n   *\n   * @description The method shifts the right side coordinates of the rectangle\n   * by one unit to ensure that the vertices are ordered clockwise.\n   *\n   * @param {Array<number>} rect - Top-left, bottom-right representation of a\n   * rectangle.\n   * @returns {Array<Array<number>>} Polygon representation of the vertices of the\n   * rectangle.\n   */\n\n\n  RectGeometry.prototype._rectToVertices2d = function (rect) {\n    return [[rect[0], rect[3]], [rect[0], rect[1]], [this._inverted ? rect[2] + 1 : rect[2], rect[1]], [this._inverted ? rect[2] + 1 : rect[2], rect[3]], [rect[0], rect[3]]];\n  };\n  /**\n   * Convert the top-left, bottom-right representation of a rectangle to a polygon\n   * representation of the vertices starting at the bottom-left corner going\n   * clockwise.\n   *\n   * @description The first vertex represents the bottom-left corner with the rest of\n   * the vertices following in clockwise order. The coordinates will not be shifted\n   * to ensure that the vertices are ordered clockwise when layed out on the plane.\n   *\n   * @param {Array<number>} rect - Top-left, bottom-right representation of a\n   * rectangle.\n   * @returns {Array<Array<number>>} Polygon representation of the vertices of the\n   * rectangle.\n   */\n\n\n  RectGeometry.prototype._rectToNonAdjustedVertices2d = function (rect) {\n    return [[rect[0], rect[3]], [rect[0], rect[1]], [rect[2], rect[1]], [rect[2], rect[3]], [rect[0], rect[3]]];\n  };\n\n  return RectGeometry;\n}(Component_1.VertexGeometry);\n\nexports.RectGeometry = RectGeometry;\nexports.default = RectGeometry;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/geometry/RectGeometry.ts?");

/***/ }),

/***/ "./src/component/tag/geometry/VertexGeometry.ts":
/*!******************************************************!*\
  !*** ./src/component/tag/geometry/VertexGeometry.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar earcut_1 = __webpack_require__(/*! earcut */ \"./node_modules/earcut/src/earcut.js\");\n\nvar martinez = __webpack_require__(/*! martinez-polygon-clipping */ \"./node_modules/martinez-polygon-clipping/dist/martinez.umd.js\");\n\nvar polylabel = __webpack_require__(/*! @mapbox/polylabel */ \"./node_modules/@mapbox/polylabel/polylabel.js\");\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n/**\n * @class VertexGeometry\n * @abstract\n * @classdesc Represents a vertex geometry.\n */\n\n\nvar VertexGeometry =\n/** @class */\nfunction (_super) {\n  __extends(VertexGeometry, _super);\n  /**\n   * Create a vertex geometry.\n   *\n   * @constructor\n   * @ignore\n   */\n\n\n  function VertexGeometry() {\n    var _this = _super.call(this) || this;\n\n    _this._subsampleThreshold = 0.005;\n    return _this;\n  }\n  /**\n   * Finds the polygon pole of inaccessibility, the most distant internal\n   * point from the polygon outline.\n   *\n   * @param {Array<Array<number>>} points2d - 2d points of outline to triangulate.\n   * @returns {Array<number>} Point of inaccessibility.\n   * @ignore\n   */\n\n\n  VertexGeometry.prototype._getPoleOfInaccessibility2d = function (points2d) {\n    var pole2d = polylabel([points2d], 3e-2);\n    return pole2d;\n  };\n\n  VertexGeometry.prototype._project = function (points2d, transform) {\n    var camera = this._createCamera(transform.upVector().toArray(), transform.unprojectSfM([0, 0], 0), transform.unprojectSfM([0, 0], 10));\n\n    return this._deunproject(points2d, transform, camera);\n  };\n\n  VertexGeometry.prototype._subsample = function (points2d, threshold) {\n    if (threshold === void 0) {\n      threshold = this._subsampleThreshold;\n    }\n\n    var subsampled = [];\n    var length = points2d.length;\n\n    for (var index = 0; index < length; index++) {\n      var p1 = points2d[index];\n      var p2 = points2d[(index + 1) % length];\n      subsampled.push(p1);\n      var dist = Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2));\n      var subsamples = Math.floor(dist / threshold);\n      var coeff = 1 / (subsamples + 1);\n\n      for (var i = 1; i <= subsamples; i++) {\n        var alpha = i * coeff;\n        var subsample = [(1 - alpha) * p1[0] + alpha * p2[0], (1 - alpha) * p1[1] + alpha * p2[1]];\n        subsampled.push(subsample);\n      }\n    }\n\n    return subsampled;\n  };\n  /**\n   * Triangulates a 2d polygon and returns the triangle\n   * representation as a flattened array of 3d points.\n   *\n   * @param {Array<Array<number>>} points2d - 2d points of outline to triangulate.\n   * @param {Array<Array<number>>} points3d - 3d points of outline corresponding to the 2d points.\n   * @param {Array<Array<Array<number>>>} [holes2d] - 2d points of holes to triangulate.\n   * @param {Array<Array<Array<number>>>} [holes3d] - 3d points of holes corresponding to the 2d points.\n   * @returns {Array<number>} Flattened array of 3d points ordered based on the triangles.\n   * @ignore\n   */\n\n\n  VertexGeometry.prototype._triangulate = function (points2d, points3d, holes2d, holes3d) {\n    var data = [points2d.slice(0, -1)];\n\n    for (var _i = 0, _a = holes2d != null ? holes2d : []; _i < _a.length; _i++) {\n      var hole2d = _a[_i];\n      data.push(hole2d.slice(0, -1));\n    }\n\n    var points = points3d.slice(0, -1);\n\n    for (var _b = 0, _c = holes3d != null ? holes3d : []; _b < _c.length; _b++) {\n      var hole3d = _c[_b];\n      points = points.concat(hole3d.slice(0, -1));\n    }\n\n    var flattened = earcut_1.default.flatten(data);\n    var indices = earcut_1.default(flattened.vertices, flattened.holes, flattened.dimensions);\n    var triangles = [];\n\n    for (var i = 0; i < indices.length; ++i) {\n      var point = points[indices[i]];\n      triangles.push(point[0]);\n      triangles.push(point[1]);\n      triangles.push(point[2]);\n    }\n\n    return triangles;\n  };\n\n  VertexGeometry.prototype._triangulatePano = function (points2d, holes2d, transform) {\n    var triangles = [];\n    var epsilon = 1e-9;\n    var subareasX = 3;\n    var subareasY = 3;\n\n    for (var x = 0; x < subareasX; x++) {\n      for (var y = 0; y < subareasY; y++) {\n        var epsilonX0 = x === 0 ? -epsilon : epsilon;\n        var epsilonY0 = y === 0 ? -epsilon : epsilon;\n        var x0 = x / subareasX + epsilonX0;\n        var y0 = y / subareasY + epsilonY0;\n        var x1 = (x + 1) / subareasX + epsilon;\n        var y1 = (y + 1) / subareasY + epsilon;\n        var bbox2d = [[x0, y0], [x0, y1], [x1, y1], [x1, y0], [x0, y0]];\n        var lookat2d = [(2 * x + 1) / (2 * subareasX), (2 * y + 1) / (2 * subareasY)];\n        triangles.push.apply(triangles, this._triangulateSubarea(points2d, holes2d, bbox2d, lookat2d, transform));\n      }\n    }\n\n    return triangles;\n  };\n\n  VertexGeometry.prototype._unproject = function (points2d, transform, distance) {\n    if (distance === void 0) {\n      distance = 200;\n    }\n\n    return points2d.map(function (point) {\n      return transform.unprojectBasic(point, distance);\n    });\n  };\n\n  VertexGeometry.prototype._createCamera = function (upVector, position, lookAt) {\n    var camera = new THREE.Camera();\n    camera.up.copy(new THREE.Vector3().fromArray(upVector));\n    camera.position.copy(new THREE.Vector3().fromArray(position));\n    camera.lookAt(new THREE.Vector3().fromArray(lookAt));\n    camera.updateMatrix();\n    camera.updateMatrixWorld(true);\n    return camera;\n  };\n\n  VertexGeometry.prototype._deunproject = function (points2d, transform, camera) {\n    return points2d.map(function (point2d) {\n      var pointWorld = transform.unprojectBasic(point2d, 10000);\n      var pointCamera = new THREE.Vector3(pointWorld[0], pointWorld[1], pointWorld[2]).applyMatrix4(camera.matrixWorldInverse);\n      return [pointCamera.x / pointCamera.z, pointCamera.y / pointCamera.z];\n    });\n  };\n\n  VertexGeometry.prototype._triangulateSubarea = function (points2d, holes2d, bbox2d, lookat2d, transform) {\n    var intersections = martinez.intersection([points2d].concat(holes2d), [bbox2d]);\n\n    if (!intersections) {\n      return [];\n    }\n\n    var triangles = [];\n    var threshold = this._subsampleThreshold;\n\n    var camera = this._createCamera(transform.upVector().toArray(), transform.unprojectSfM([0, 0], 0), transform.unprojectBasic(lookat2d, 10));\n\n    for (var _i = 0, intersections_1 = intersections; _i < intersections_1.length; _i++) {\n      var intersection = intersections_1[_i];\n\n      var subsampledPolygon2d = this._subsample(intersection[0], threshold);\n\n      var polygon2d = this._deunproject(subsampledPolygon2d, transform, camera);\n\n      var polygon3d = this._unproject(subsampledPolygon2d, transform);\n\n      var polygonHoles2d = [];\n      var polygonHoles3d = [];\n\n      for (var i = 1; i < intersection.length; i++) {\n        var subsampledHole2d = this._subsample(intersection[i], threshold);\n\n        var hole2d = this._deunproject(subsampledHole2d, transform, camera);\n\n        var hole3d = this._unproject(subsampledHole2d, transform);\n\n        polygonHoles2d.push(hole2d);\n        polygonHoles3d.push(hole3d);\n      }\n\n      triangles.push.apply(triangles, this._triangulate(polygon2d, polygon3d, polygonHoles2d, polygonHoles3d));\n    }\n\n    return triangles;\n  };\n\n  return VertexGeometry;\n}(Component_1.Geometry);\n\nexports.VertexGeometry = VertexGeometry;\nexports.default = VertexGeometry;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/geometry/VertexGeometry.ts?");

/***/ }),

/***/ "./src/component/tag/handlers/CreateHandlerBase.ts":
/*!*********************************************************!*\
  !*** ./src/component/tag/handlers/CreateHandlerBase.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n\nvar CreateHandlerBase =\n/** @class */\nfunction (_super) {\n  __extends(CreateHandlerBase, _super);\n\n  function CreateHandlerBase(component, container, navigator, viewportCoords, tagCreator) {\n    var _this = _super.call(this, component, container, navigator, viewportCoords) || this;\n\n    _this._tagCreator = tagCreator;\n    _this._geometryCreated$ = new rxjs_1.Subject();\n    return _this;\n  }\n\n  Object.defineProperty(CreateHandlerBase.prototype, \"geometryCreated$\", {\n    get: function get() {\n      return this._geometryCreated$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CreateHandlerBase.prototype._enable = function () {\n    this._enableCreate();\n\n    this._container.element.classList.add(\"component-tag-create\");\n  };\n\n  CreateHandlerBase.prototype._disable = function () {\n    this._container.element.classList.remove(\"component-tag-create\");\n\n    this._disableCreate();\n  };\n\n  CreateHandlerBase.prototype._validateBasic = function (basic) {\n    var x = basic[0];\n    var y = basic[1];\n    return 0 <= x && x <= 1 && 0 <= y && y <= 1;\n  };\n\n  CreateHandlerBase.prototype._mouseEventToBasic$ = function (mouseEvent$) {\n    var _this = this;\n\n    return mouseEvent$.pipe(operators_1.withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$), operators_1.map(function (_a) {\n      var event = _a[0],\n          camera = _a[1],\n          transform = _a[2];\n      return _this._mouseEventToBasic(event, _this._container.element, camera, transform);\n    }));\n  };\n\n  return CreateHandlerBase;\n}(Component_1.TagHandlerBase);\n\nexports.CreateHandlerBase = CreateHandlerBase;\nexports.default = CreateHandlerBase;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/handlers/CreateHandlerBase.ts?");

/***/ }),

/***/ "./src/component/tag/handlers/CreatePointHandler.ts":
/*!**********************************************************!*\
  !*** ./src/component/tag/handlers/CreatePointHandler.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n\nvar CreatePointHandler =\n/** @class */\nfunction (_super) {\n  __extends(CreatePointHandler, _super);\n\n  function CreatePointHandler() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  CreatePointHandler.prototype._enableCreate = function () {\n    this._container.mouseService.deferPixels(this._name, 4);\n\n    this._geometryCreatedSubscription = this._mouseEventToBasic$(this._container.mouseService.proximateClick$).pipe(operators_1.filter(this._validateBasic), operators_1.map(function (basic) {\n      return new Component_1.PointGeometry(basic);\n    })).subscribe(this._geometryCreated$);\n  };\n\n  CreatePointHandler.prototype._disableCreate = function () {\n    this._container.mouseService.undeferPixels(this._name);\n\n    this._geometryCreatedSubscription.unsubscribe();\n  };\n\n  CreatePointHandler.prototype._getNameExtension = function () {\n    return \"create-point\";\n  };\n\n  return CreatePointHandler;\n}(Component_1.CreateHandlerBase);\n\nexports.CreatePointHandler = CreatePointHandler;\nexports.default = CreatePointHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/handlers/CreatePointHandler.ts?");

/***/ }),

/***/ "./src/component/tag/handlers/CreatePolygonHandler.ts":
/*!************************************************************!*\
  !*** ./src/component/tag/handlers/CreatePolygonHandler.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n\nvar CreatePolygonHandler =\n/** @class */\nfunction (_super) {\n  __extends(CreatePolygonHandler, _super);\n\n  function CreatePolygonHandler() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  CreatePolygonHandler.prototype._addPoint = function (tag, basicPoint) {\n    tag.addPoint(basicPoint);\n  };\n\n  Object.defineProperty(CreatePolygonHandler.prototype, \"_create$\", {\n    get: function get() {\n      return this._tagCreator.createPolygon$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CreatePolygonHandler.prototype._getNameExtension = function () {\n    return \"create-polygon\";\n  };\n\n  CreatePolygonHandler.prototype._setVertex2d = function (tag, basicPoint, transform) {\n    tag.geometry.setVertex2d(tag.geometry.polygon.length - 2, basicPoint, transform);\n  };\n\n  return CreatePolygonHandler;\n}(Component_1.CreateVertexHandler);\n\nexports.CreatePolygonHandler = CreatePolygonHandler;\nexports.default = CreatePolygonHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/handlers/CreatePolygonHandler.ts?");

/***/ }),

/***/ "./src/component/tag/handlers/CreateRectDragHandler.ts":
/*!*************************************************************!*\
  !*** ./src/component/tag/handlers/CreateRectDragHandler.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n\nvar CreateRectDragHandler =\n/** @class */\nfunction (_super) {\n  __extends(CreateRectDragHandler, _super);\n\n  function CreateRectDragHandler() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  CreateRectDragHandler.prototype._enableCreate = function () {\n    var _this = this;\n\n    this._container.mouseService.claimMouse(this._name, 2);\n\n    this._deleteSubscription = this._navigator.stateService.currentTransform$.pipe(operators_1.map(function (transform) {\n      return null;\n    }), operators_1.skip(1)).subscribe(this._tagCreator.delete$);\n    this._createSubscription = this._mouseEventToBasic$(this._container.mouseService.filtered$(this._name, this._container.mouseService.mouseDragStart$)).pipe(operators_1.filter(this._validateBasic)).subscribe(this._tagCreator.createRect$);\n    this._initializeAnchorIndexingSubscription = this._tagCreator.tag$.pipe(operators_1.filter(function (tag) {\n      return !!tag;\n    })).subscribe(function (tag) {\n      tag.geometry.initializeAnchorIndexing();\n    });\n    var basicMouse$ = rxjs_1.combineLatest(rxjs_1.merge(this._container.mouseService.filtered$(this._name, this._container.mouseService.mouseMove$), this._container.mouseService.filtered$(this._name, this._container.mouseService.domMouseMove$)), this._container.renderService.renderCamera$).pipe(operators_1.withLatestFrom(this._navigator.stateService.currentTransform$), operators_1.map(function (_a) {\n      var _b = _a[0],\n          event = _b[0],\n          camera = _b[1],\n          transform = _a[1];\n      return _this._mouseEventToBasic(event, _this._container.element, camera, transform);\n    }));\n    this._setVertexSubscription = this._tagCreator.tag$.pipe(operators_1.switchMap(function (tag) {\n      return !!tag ? rxjs_1.combineLatest(rxjs_1.of(tag), basicMouse$, _this._navigator.stateService.currentTransform$) : rxjs_1.empty();\n    })).subscribe(function (_a) {\n      var tag = _a[0],\n          basicPoint = _a[1],\n          transform = _a[2];\n      tag.geometry.setOppositeVertex2d(basicPoint, transform);\n    });\n\n    var basicMouseDragEnd$ = this._container.mouseService.mouseDragEnd$.pipe(operators_1.withLatestFrom(this._mouseEventToBasic$(this._container.mouseService.filtered$(this._name, this._container.mouseService.mouseDrag$)).pipe(operators_1.filter(this._validateBasic)), function (event, basicPoint) {\n      return basicPoint;\n    }), operators_1.share());\n\n    this._addPointSubscription = this._tagCreator.tag$.pipe(operators_1.switchMap(function (tag) {\n      return !!tag ? rxjs_1.combineLatest(rxjs_1.of(tag), basicMouseDragEnd$) : rxjs_1.empty();\n    })).subscribe(function (_a) {\n      var tag = _a[0],\n          basicPoint = _a[1];\n      var rectGeometry = tag.geometry;\n\n      if (!rectGeometry.validate(basicPoint)) {\n        basicPoint = rectGeometry.getNonAdjustedVertex2d(3);\n      }\n\n      tag.addPoint(basicPoint);\n    });\n    this._geometryCreatedSubscription = this._tagCreator.tag$.pipe(operators_1.switchMap(function (tag) {\n      return !!tag ? tag.created$.pipe(operators_1.map(function (t) {\n        return t.geometry;\n      })) : rxjs_1.empty();\n    })).subscribe(this._geometryCreated$);\n  };\n\n  CreateRectDragHandler.prototype._disableCreate = function () {\n    this._container.mouseService.unclaimMouse(this._name);\n\n    this._tagCreator.delete$.next(null);\n\n    this._addPointSubscription.unsubscribe();\n\n    this._createSubscription.unsubscribe();\n\n    this._deleteSubscription.unsubscribe();\n\n    this._geometryCreatedSubscription.unsubscribe();\n\n    this._initializeAnchorIndexingSubscription.unsubscribe();\n\n    this._setVertexSubscription.unsubscribe();\n  };\n\n  CreateRectDragHandler.prototype._getNameExtension = function () {\n    return \"create-rect-drag\";\n  };\n\n  return CreateRectDragHandler;\n}(Component_1.CreateHandlerBase);\n\nexports.CreateRectDragHandler = CreateRectDragHandler;\nexports.default = CreateRectDragHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/handlers/CreateRectDragHandler.ts?");

/***/ }),

/***/ "./src/component/tag/handlers/CreateRectHandler.ts":
/*!*********************************************************!*\
  !*** ./src/component/tag/handlers/CreateRectHandler.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n\nvar CreateRectHandler =\n/** @class */\nfunction (_super) {\n  __extends(CreateRectHandler, _super);\n\n  function CreateRectHandler() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(CreateRectHandler.prototype, \"_create$\", {\n    get: function get() {\n      return this._tagCreator.createRect$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CreateRectHandler.prototype._addPoint = function (tag, basicPoint) {\n    var rectGeometry = tag.geometry;\n\n    if (!rectGeometry.validate(basicPoint)) {\n      basicPoint = rectGeometry.getNonAdjustedVertex2d(3);\n    }\n\n    tag.addPoint(basicPoint);\n  };\n\n  CreateRectHandler.prototype._enable = function () {\n    _super.prototype._enable.call(this);\n\n    this._initializeAnchorIndexingSubscription = this._tagCreator.tag$.pipe(operators_1.filter(function (tag) {\n      return !!tag;\n    })).subscribe(function (tag) {\n      tag.geometry.initializeAnchorIndexing();\n    });\n  };\n\n  CreateRectHandler.prototype._disable = function () {\n    _super.prototype._disable.call(this);\n\n    this._initializeAnchorIndexingSubscription.unsubscribe();\n  };\n\n  CreateRectHandler.prototype._getNameExtension = function () {\n    return \"create-rect\";\n  };\n\n  CreateRectHandler.prototype._setVertex2d = function (tag, basicPoint, transform) {\n    tag.geometry.setOppositeVertex2d(basicPoint, transform);\n  };\n\n  return CreateRectHandler;\n}(Component_1.CreateVertexHandler);\n\nexports.CreateRectHandler = CreateRectHandler;\nexports.default = CreateRectHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/handlers/CreateRectHandler.ts?");

/***/ }),

/***/ "./src/component/tag/handlers/CreateVertexHandler.ts":
/*!***********************************************************!*\
  !*** ./src/component/tag/handlers/CreateVertexHandler.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n\nvar CreateVertexHandler =\n/** @class */\nfunction (_super) {\n  __extends(CreateVertexHandler, _super);\n\n  function CreateVertexHandler() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  CreateVertexHandler.prototype._enableCreate = function () {\n    var _this = this;\n\n    this._container.mouseService.deferPixels(this._name, 4);\n\n    var transformChanged$ = this._navigator.stateService.currentTransform$.pipe(operators_1.map(function (transform) {}), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._deleteSubscription = transformChanged$.pipe(operators_1.skip(1)).subscribe(this._tagCreator.delete$);\n\n    var basicClick$ = this._mouseEventToBasic$(this._container.mouseService.proximateClick$).pipe(operators_1.share());\n\n    this._createSubscription = transformChanged$.pipe(operators_1.switchMap(function () {\n      return basicClick$.pipe(operators_1.filter(_this._validateBasic), operators_1.take(1));\n    })).subscribe(this._create$);\n    this._setVertexSubscription = this._tagCreator.tag$.pipe(operators_1.switchMap(function (tag) {\n      return !!tag ? rxjs_1.combineLatest(rxjs_1.of(tag), rxjs_1.merge(_this._container.mouseService.mouseMove$, _this._container.mouseService.domMouseMove$), _this._container.renderService.renderCamera$, _this._navigator.stateService.currentTransform$) : rxjs_1.empty();\n    })).subscribe(function (_a) {\n      var tag = _a[0],\n          event = _a[1],\n          camera = _a[2],\n          transform = _a[3];\n\n      var basicPoint = _this._mouseEventToBasic(event, _this._container.element, camera, transform);\n\n      _this._setVertex2d(tag, basicPoint, transform);\n    });\n    this._addPointSubscription = this._tagCreator.tag$.pipe(operators_1.switchMap(function (tag) {\n      return !!tag ? rxjs_1.combineLatest(rxjs_1.of(tag), basicClick$) : rxjs_1.empty();\n    })).subscribe(function (_a) {\n      var tag = _a[0],\n          basicPoint = _a[1];\n\n      _this._addPoint(tag, basicPoint);\n    });\n    this._geometryCreateSubscription = this._tagCreator.tag$.pipe(operators_1.switchMap(function (tag) {\n      return !!tag ? tag.created$.pipe(operators_1.map(function (t) {\n        return t.geometry;\n      })) : rxjs_1.empty();\n    })).subscribe(this._geometryCreated$);\n  };\n\n  CreateVertexHandler.prototype._disableCreate = function () {\n    this._container.mouseService.undeferPixels(this._name);\n\n    this._tagCreator.delete$.next(null);\n\n    this._addPointSubscription.unsubscribe();\n\n    this._createSubscription.unsubscribe();\n\n    this._deleteSubscription.unsubscribe();\n\n    this._geometryCreateSubscription.unsubscribe();\n\n    this._setVertexSubscription.unsubscribe();\n  };\n\n  return CreateVertexHandler;\n}(Component_1.CreateHandlerBase);\n\nexports.CreateVertexHandler = CreateVertexHandler;\nexports.default = CreateVertexHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/handlers/CreateVertexHandler.ts?");

/***/ }),

/***/ "./src/component/tag/handlers/EditVertexHandler.ts":
/*!*********************************************************!*\
  !*** ./src/component/tag/handlers/EditVertexHandler.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n\nvar EditVertexHandler =\n/** @class */\nfunction (_super) {\n  __extends(EditVertexHandler, _super);\n\n  function EditVertexHandler(component, container, navigator, viewportCoords, tagSet) {\n    var _this = _super.call(this, component, container, navigator, viewportCoords) || this;\n\n    _this._tagSet = tagSet;\n    return _this;\n  }\n\n  EditVertexHandler.prototype._enable = function () {\n    var _this = this;\n\n    var interaction$ = this._tagSet.changed$.pipe(operators_1.map(function (tagSet) {\n      return tagSet.getAll();\n    }), operators_1.switchMap(function (tags) {\n      return rxjs_1.from(tags).pipe(operators_1.mergeMap(function (tag) {\n        return tag.interact$;\n      }));\n    }), operators_1.switchMap(function (interaction) {\n      return rxjs_1.concat(rxjs_1.of(interaction), _this._container.mouseService.documentMouseUp$.pipe(operators_1.map(function () {\n        return {\n          offsetX: 0,\n          offsetY: 0,\n          operation: Component_1.TagOperation.None,\n          tag: null\n        };\n      }), operators_1.first()));\n    }), operators_1.share());\n\n    var mouseMove$ = rxjs_1.merge(this._container.mouseService.mouseMove$, this._container.mouseService.domMouseMove$).pipe(operators_1.share());\n    this._claimMouseSubscription = interaction$.pipe(operators_1.switchMap(function (interaction) {\n      return !!interaction.tag ? _this._container.mouseService.domMouseDragStart$ : rxjs_1.empty();\n    })).subscribe(function () {\n      _this._container.mouseService.claimMouse(_this._name, 3);\n    });\n    this._cursorSubscription = interaction$.pipe(operators_1.map(function (interaction) {\n      return interaction.cursor;\n    }), operators_1.distinctUntilChanged()).subscribe(function (cursor) {\n      var interactionCursors = [\"crosshair\", \"move\", \"nesw-resize\", \"nwse-resize\"];\n\n      for (var _i = 0, interactionCursors_1 = interactionCursors; _i < interactionCursors_1.length; _i++) {\n        var interactionCursor = interactionCursors_1[_i];\n\n        _this._container.element.classList.remove(\"component-tag-edit-\" + interactionCursor);\n      }\n\n      if (!!cursor) {\n        _this._container.element.classList.add(\"component-tag-edit-\" + cursor);\n      }\n    });\n    this._unclaimMouseSubscription = this._container.mouseService.filtered$(this._name, this._container.mouseService.domMouseDragEnd$).subscribe(function (e) {\n      _this._container.mouseService.unclaimMouse(_this._name);\n    });\n    this._preventDefaultSubscription = interaction$.pipe(operators_1.switchMap(function (interaction) {\n      return !!interaction.tag ? _this._container.mouseService.documentMouseMove$ : rxjs_1.empty();\n    })).subscribe(function (event) {\n      event.preventDefault(); // prevent selection of content outside the viewer\n    });\n    this._updateGeometrySubscription = interaction$.pipe(operators_1.switchMap(function (interaction) {\n      if (interaction.operation === Component_1.TagOperation.None || !interaction.tag) {\n        return rxjs_1.empty();\n      }\n\n      var mouseDrag$ = _this._container.mouseService.filtered$(_this._name, _this._container.mouseService.domMouseDrag$).pipe(operators_1.filter(function (event) {\n        return _this._viewportCoords.insideElement(event, _this._container.element);\n      }));\n\n      return rxjs_1.combineLatest(mouseDrag$, _this._container.renderService.renderCamera$).pipe(operators_1.withLatestFrom(rxjs_1.of(interaction), _this._navigator.stateService.currentTransform$, function (_a, i, transform) {\n        var event = _a[0],\n            render = _a[1];\n        return [event, render, i, transform];\n      }));\n    })).subscribe(function (_a) {\n      var mouseEvent = _a[0],\n          renderCamera = _a[1],\n          interaction = _a[2],\n          transform = _a[3];\n\n      var basic = _this._mouseEventToBasic(mouseEvent, _this._container.element, renderCamera, transform, interaction.offsetX, interaction.offsetY);\n\n      var geometry = interaction.tag.geometry;\n\n      if (interaction.operation === Component_1.TagOperation.Centroid) {\n        geometry.setCentroid2d(basic, transform);\n      } else if (interaction.operation === Component_1.TagOperation.Vertex) {\n        geometry.setVertex2d(interaction.vertexIndex, basic, transform);\n      }\n    });\n  };\n\n  EditVertexHandler.prototype._disable = function () {\n    this._claimMouseSubscription.unsubscribe();\n\n    this._cursorSubscription.unsubscribe();\n\n    this._preventDefaultSubscription.unsubscribe();\n\n    this._unclaimMouseSubscription.unsubscribe();\n\n    this._updateGeometrySubscription.unsubscribe();\n  };\n\n  EditVertexHandler.prototype._getNameExtension = function () {\n    return \"edit-vertex\";\n  };\n\n  return EditVertexHandler;\n}(Component_1.TagHandlerBase);\n\nexports.EditVertexHandler = EditVertexHandler;\nexports.default = EditVertexHandler;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/handlers/EditVertexHandler.ts?");

/***/ }),

/***/ "./src/component/tag/handlers/TagHandlerBase.ts":
/*!******************************************************!*\
  !*** ./src/component/tag/handlers/TagHandlerBase.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n\nvar TagHandlerBase =\n/** @class */\nfunction (_super) {\n  __extends(TagHandlerBase, _super);\n\n  function TagHandlerBase(component, container, navigator, viewportCoords) {\n    var _this = _super.call(this, component, container, navigator) || this;\n\n    _this._name = _this._component.name + \"-\" + _this._getNameExtension();\n    _this._viewportCoords = viewportCoords;\n    return _this;\n  }\n\n  TagHandlerBase.prototype._getConfiguration = function (enable) {\n    return {};\n  };\n\n  TagHandlerBase.prototype._mouseEventToBasic = function (event, element, camera, transform, offsetX, offsetY) {\n    offsetX = offsetX != null ? offsetX : 0;\n    offsetY = offsetY != null ? offsetY : 0;\n\n    var _a = this._viewportCoords.canvasPosition(event, element),\n        canvasX = _a[0],\n        canvasY = _a[1];\n\n    var basic = this._viewportCoords.canvasToBasic(canvasX - offsetX, canvasY - offsetY, element, transform, camera.perspective);\n\n    return basic;\n  };\n\n  return TagHandlerBase;\n}(Component_1.HandlerBase);\n\nexports.TagHandlerBase = TagHandlerBase;\nexports.default = TagHandlerBase;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/handlers/TagHandlerBase.ts?");

/***/ }),

/***/ "./src/component/tag/tag/OutlineCreateTag.ts":
/*!***************************************************!*\
  !*** ./src/component/tag/tag/OutlineCreateTag.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../../Geo */ \"./src/Geo.ts\");\n\nvar OutlineCreateTag =\n/** @class */\nfunction () {\n  function OutlineCreateTag(geometry, options, transform, viewportCoords) {\n    var _this = this;\n\n    this._geometry = geometry;\n    this._options = {\n      color: options.color == null ? 0xFFFFFF : options.color\n    };\n    this._transform = transform;\n    this._viewportCoords = !!viewportCoords ? viewportCoords : new Geo_1.ViewportCoords();\n    this._outline = this._createOutine();\n    this._glObjects = [this._outline];\n    this._aborted$ = new rxjs_1.Subject();\n    this._created$ = new rxjs_1.Subject();\n    this._glObjectsChanged$ = new rxjs_1.Subject();\n    this._geometryChangedSubscription = this._geometry.changed$.subscribe(function (vertexGeometry) {\n      _this._disposeOutline();\n\n      _this._outline = _this._createOutine();\n      _this._glObjects = [_this._outline];\n\n      _this._glObjectsChanged$.next(_this);\n    });\n  }\n\n  Object.defineProperty(OutlineCreateTag.prototype, \"geometry\", {\n    get: function get() {\n      return this._geometry;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineCreateTag.prototype, \"glObjects\", {\n    get: function get() {\n      return this._glObjects;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineCreateTag.prototype, \"aborted$\", {\n    get: function get() {\n      return this._aborted$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineCreateTag.prototype, \"created$\", {\n    get: function get() {\n      return this._created$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineCreateTag.prototype, \"glObjectsChanged$\", {\n    get: function get() {\n      return this._glObjectsChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineCreateTag.prototype, \"geometryChanged$\", {\n    get: function get() {\n      var _this = this;\n\n      return this._geometry.changed$.pipe(operators_1.map(function (geometry) {\n        return _this;\n      }));\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  OutlineCreateTag.prototype.dispose = function () {\n    this._disposeOutline();\n\n    this._geometryChangedSubscription.unsubscribe();\n  };\n\n  OutlineCreateTag.prototype.getDOMObjects = function (camera, size) {\n    var _this = this;\n\n    var vNodes = [];\n    var container = {\n      offsetHeight: size.height,\n      offsetWidth: size.width\n    };\n\n    var abort = function abort(e) {\n      e.stopPropagation();\n\n      _this._aborted$.next(_this);\n    };\n\n    if (this._geometry instanceof Component_1.RectGeometry) {\n      var anchorIndex = this._geometry.anchorIndex;\n      var vertexIndex = anchorIndex === undefined ? 1 : anchorIndex;\n\n      var _a = this._geometry.getVertex2d(vertexIndex),\n          basicX = _a[0],\n          basicY = _a[1];\n\n      var canvasPoint = this._viewportCoords.basicToCanvasSafe(basicX, basicY, container, this._transform, camera);\n\n      if (canvasPoint != null) {\n        var background = this._colorToBackground(this._options.color);\n\n        var transform = this._canvasToTransform(canvasPoint);\n\n        var pointProperties = {\n          style: {\n            background: background,\n            transform: transform\n          }\n        };\n        var completerProperties = {\n          onclick: abort,\n          style: {\n            transform: transform\n          }\n        };\n        vNodes.push(vd.h(\"div.TagInteractor\", completerProperties, []));\n        vNodes.push(vd.h(\"div.TagVertex\", pointProperties, []));\n      }\n    } else if (this._geometry instanceof Component_1.PolygonGeometry) {\n      var polygonGeometry_1 = this._geometry;\n\n      var _b = polygonGeometry_1.getVertex2d(0),\n          firstVertexBasicX = _b[0],\n          firstVertexBasicY = _b[1];\n\n      var firstVertexCanvas = this._viewportCoords.basicToCanvasSafe(firstVertexBasicX, firstVertexBasicY, container, this._transform, camera);\n\n      if (firstVertexCanvas != null) {\n        var firstOnclick = polygonGeometry_1.polygon.length > 4 ? function (e) {\n          e.stopPropagation();\n          polygonGeometry_1.removeVertex2d(polygonGeometry_1.polygon.length - 2);\n\n          _this._created$.next(_this);\n        } : abort;\n\n        var transform = this._canvasToTransform(firstVertexCanvas);\n\n        var completerProperties = {\n          onclick: firstOnclick,\n          style: {\n            transform: transform\n          }\n        };\n        var firstClass = polygonGeometry_1.polygon.length > 4 ? \"TagCompleter\" : \"TagInteractor\";\n        vNodes.push(vd.h(\"div.\" + firstClass, completerProperties, []));\n      }\n\n      if (polygonGeometry_1.polygon.length > 3) {\n        var _c = polygonGeometry_1.getVertex2d(polygonGeometry_1.polygon.length - 3),\n            lastVertexBasicX = _c[0],\n            lastVertexBasicY = _c[1];\n\n        var lastVertexCanvas = this._viewportCoords.basicToCanvasSafe(lastVertexBasicX, lastVertexBasicY, container, this._transform, camera);\n\n        if (lastVertexCanvas != null) {\n          var remove = function remove(e) {\n            e.stopPropagation();\n            polygonGeometry_1.removeVertex2d(polygonGeometry_1.polygon.length - 3);\n          };\n\n          var transform = this._canvasToTransform(lastVertexCanvas);\n\n          var completerProperties = {\n            onclick: remove,\n            style: {\n              transform: transform\n            }\n          };\n          vNodes.push(vd.h(\"div.TagInteractor\", completerProperties, []));\n        }\n      }\n\n      var verticesBasic = polygonGeometry_1.polygon.slice();\n      verticesBasic.splice(-2, 2);\n\n      for (var _i = 0, verticesBasic_1 = verticesBasic; _i < verticesBasic_1.length; _i++) {\n        var vertexBasic = verticesBasic_1[_i];\n\n        var vertexCanvas = this._viewportCoords.basicToCanvasSafe(vertexBasic[0], vertexBasic[1], container, this._transform, camera);\n\n        if (vertexCanvas != null) {\n          var background = this._colorToBackground(this._options.color);\n\n          var transform = this._canvasToTransform(vertexCanvas);\n\n          var pointProperties = {\n            style: {\n              background: background,\n              transform: transform\n            }\n          };\n          vNodes.push(vd.h(\"div.TagVertex\", pointProperties, []));\n        }\n      }\n    }\n\n    return vNodes;\n  };\n\n  OutlineCreateTag.prototype.addPoint = function (point) {\n    if (this._geometry instanceof Component_1.RectGeometry) {\n      var rectGeometry = this._geometry;\n\n      if (!rectGeometry.validate(point)) {\n        return;\n      }\n\n      this._created$.next(this);\n    } else if (this._geometry instanceof Component_1.PolygonGeometry) {\n      var polygonGeometry = this._geometry;\n      polygonGeometry.addVertex2d(point);\n    }\n  };\n\n  OutlineCreateTag.prototype._canvasToTransform = function (canvas) {\n    var canvasX = Math.round(canvas[0]);\n    var canvasY = Math.round(canvas[1]);\n    var transform = \"translate(-50%,-50%) translate(\" + canvasX + \"px,\" + canvasY + \"px)\";\n    return transform;\n  };\n\n  OutlineCreateTag.prototype._colorToBackground = function (color) {\n    return \"#\" + (\"000000\" + color.toString(16)).substr(-6);\n  };\n\n  OutlineCreateTag.prototype._createOutine = function () {\n    var polygon3d = this._geometry instanceof Component_1.RectGeometry ? this._geometry.getPoints3d(this._transform) : this._geometry.getVertices3d(this._transform);\n\n    var positions = this._getLinePositions(polygon3d);\n\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    var material = new THREE.LineBasicMaterial({\n      color: this._options.color,\n      linewidth: 1\n    });\n    return new THREE.Line(geometry, material);\n  };\n\n  OutlineCreateTag.prototype._disposeOutline = function () {\n    if (this._outline == null) {\n      return;\n    }\n\n    var line = this._outline;\n    line.geometry.dispose();\n    line.material.dispose();\n    this._outline = null;\n    this._glObjects = [];\n  };\n\n  OutlineCreateTag.prototype._getLinePositions = function (polygon3d) {\n    var length = polygon3d.length;\n    var positions = new Float32Array(length * 3);\n\n    for (var i = 0; i < length; ++i) {\n      var index = 3 * i;\n      var position = polygon3d[i];\n      positions[index] = position[0];\n      positions[index + 1] = position[1];\n      positions[index + 2] = position[2];\n    }\n\n    return positions;\n  };\n\n  return OutlineCreateTag;\n}();\n\nexports.OutlineCreateTag = OutlineCreateTag;\nexports.default = OutlineCreateTag;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/tag/OutlineCreateTag.ts?");

/***/ }),

/***/ "./src/component/tag/tag/OutlineRenderTag.ts":
/*!***************************************************!*\
  !*** ./src/component/tag/tag/OutlineRenderTag.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n/**\n * @class OutlineRenderTag\n * @classdesc Tag visualizing the properties of an OutlineTag.\n */\n\n\nvar OutlineRenderTag =\n/** @class */\nfunction (_super) {\n  __extends(OutlineRenderTag, _super);\n\n  function OutlineRenderTag(tag, transform) {\n    var _this = _super.call(this, tag, transform) || this;\n\n    _this._fill = !transform.gpano ? _this._createFill() : transform.fullPano && tag.domain === Component_1.TagDomain.TwoDimensional && tag.geometry instanceof Component_1.PolygonGeometry ? _this._createFill() : null;\n    _this._holes = _this._tag.lineWidth >= 1 ? _this._createHoles() : [];\n    _this._outline = _this._tag.lineWidth >= 1 ? _this._createOutline() : null;\n    _this._geometryChangedSubscription = _this._tag.geometry.changed$.subscribe(function () {\n      if (_this._fill != null) {\n        _this._updateFillGeometry();\n      }\n\n      if (_this._holes.length > 0) {\n        _this._updateHoleGeometries();\n      }\n\n      if (_this._outline != null) {\n        _this._updateOulineGeometry();\n      }\n    });\n    _this._changedSubscription = _this._tag.changed$.subscribe(function () {\n      var glObjectsChanged = false;\n\n      if (_this._fill != null) {\n        _this._updateFillMaterial(_this._fill.material);\n      }\n\n      if (_this._outline == null) {\n        if (_this._tag.lineWidth >= 1) {\n          _this._holes = _this._createHoles();\n          _this._outline = _this._createOutline();\n          glObjectsChanged = true;\n        }\n      } else {\n        _this._updateHoleMaterials();\n\n        _this._updateOutlineMaterial();\n      }\n\n      if (glObjectsChanged) {\n        _this._glObjectsChanged$.next(_this);\n      }\n    });\n    return _this;\n  }\n\n  OutlineRenderTag.prototype.dispose = function () {\n    this._disposeFill();\n\n    this._disposeHoles();\n\n    this._disposeOutline();\n\n    this._changedSubscription.unsubscribe();\n\n    this._geometryChangedSubscription.unsubscribe();\n  };\n\n  OutlineRenderTag.prototype.getDOMObjects = function (atlas, camera, size) {\n    var _this = this;\n\n    var vNodes = [];\n    var isRect = this._tag.geometry instanceof Component_1.RectGeometry;\n    var isPerspective = !this._transform.gpano;\n    var container = {\n      offsetHeight: size.height,\n      offsetWidth: size.width\n    };\n\n    if (this._tag.icon != null && (isRect || isPerspective)) {\n      var _a = this._tag.geometry instanceof Component_1.RectGeometry ? this._tag.geometry.getVertex2d(this._tag.iconIndex) : this._tag.geometry.getPoleOfInaccessibility2d(),\n          iconBasicX = _a[0],\n          iconBasicY = _a[1];\n\n      var iconCanvas = this._viewportCoords.basicToCanvasSafe(iconBasicX, iconBasicY, container, this._transform, camera);\n\n      if (iconCanvas != null) {\n        var interact = function interact(e) {\n          _this._interact$.next({\n            offsetX: 0,\n            offsetY: 0,\n            operation: Component_1.TagOperation.None,\n            tag: _this._tag\n          });\n        };\n\n        if (atlas.loaded) {\n          var sprite = atlas.getDOMSprite(this._tag.icon, this._tag.iconFloat);\n          var iconCanvasX = Math.round(iconCanvas[0]);\n          var iconCanvasY = Math.round(iconCanvas[1]);\n          var transform = \"translate(\" + iconCanvasX + \"px,\" + iconCanvasY + \"px)\";\n\n          var click = function click(e) {\n            e.stopPropagation();\n\n            _this._tag.click$.next(_this._tag);\n          };\n\n          var properties = {\n            onclick: click,\n            onmousedown: interact,\n            style: {\n              transform: transform\n            }\n          };\n          vNodes.push(vd.h(\"div.TagSymbol\", properties, [sprite]));\n        }\n      }\n    } else if (this._tag.text != null && (isRect || isPerspective)) {\n      var _b = this._tag.geometry instanceof Component_1.RectGeometry ? this._tag.geometry.getVertex2d(3) : this._tag.geometry.getPoleOfInaccessibility2d(),\n          textBasicX = _b[0],\n          textBasicY = _b[1];\n\n      var textCanvas = this._viewportCoords.basicToCanvasSafe(textBasicX, textBasicY, container, this._transform, camera);\n\n      if (textCanvas != null) {\n        var textCanvasX = Math.round(textCanvas[0]);\n        var textCanvasY = Math.round(textCanvas[1]);\n        var transform = this._tag.geometry instanceof Component_1.RectGeometry ? \"translate(\" + textCanvasX + \"px,\" + textCanvasY + \"px)\" : \"translate(-50%, -50%) translate(\" + textCanvasX + \"px,\" + textCanvasY + \"px)\";\n\n        var interact = function interact(e) {\n          _this._interact$.next({\n            offsetX: 0,\n            offsetY: 0,\n            operation: Component_1.TagOperation.None,\n            tag: _this._tag\n          });\n        };\n\n        var properties = {\n          onmousedown: interact,\n          style: {\n            color: this._colorToCss(this._tag.textColor),\n            transform: transform\n          },\n          textContent: this._tag.text\n        };\n        vNodes.push(vd.h(\"span.TagSymbol\", properties, []));\n      }\n    }\n\n    if (!this._tag.editable) {\n      return vNodes;\n    }\n\n    var lineColor = this._colorToCss(this._tag.lineColor);\n\n    if (this._tag.geometry instanceof Component_1.RectGeometry) {\n      var _c = this._tag.geometry.getCentroid2d(),\n          centroidBasicX = _c[0],\n          centroidBasicY = _c[1];\n\n      var centroidCanvas = this._viewportCoords.basicToCanvasSafe(centroidBasicX, centroidBasicY, container, this._transform, camera);\n\n      if (centroidCanvas != null) {\n        var interact = this._interact(Component_1.TagOperation.Centroid, \"move\");\n\n        var centroidCanvasX = Math.round(centroidCanvas[0]);\n        var centroidCanvasY = Math.round(centroidCanvas[1]);\n        var transform = \"translate(-50%, -50%) translate(\" + centroidCanvasX + \"px,\" + centroidCanvasY + \"px)\";\n        var properties = {\n          onmousedown: interact,\n          style: {\n            background: lineColor,\n            transform: transform\n          }\n        };\n        vNodes.push(vd.h(\"div.TagMover\", properties, []));\n      }\n    }\n\n    var vertices2d = this._tag.geometry.getVertices2d();\n\n    for (var i = 0; i < vertices2d.length - 1; i++) {\n      if (isRect && (this._tag.icon != null && i === this._tag.iconIndex || this._tag.icon == null && this._tag.text != null && i === 3)) {\n        continue;\n      }\n\n      var _d = vertices2d[i],\n          vertexBasicX = _d[0],\n          vertexBasicY = _d[1];\n\n      var vertexCanvas = this._viewportCoords.basicToCanvasSafe(vertexBasicX, vertexBasicY, container, this._transform, camera);\n\n      if (vertexCanvas == null) {\n        continue;\n      }\n\n      var cursor = isRect ? i % 2 === 0 ? \"nesw-resize\" : \"nwse-resize\" : \"crosshair\";\n\n      var interact = this._interact(Component_1.TagOperation.Vertex, cursor, i);\n\n      var vertexCanvasX = Math.round(vertexCanvas[0]);\n      var vertexCanvasY = Math.round(vertexCanvas[1]);\n      var transform = \"translate(-50%, -50%) translate(\" + vertexCanvasX + \"px,\" + vertexCanvasY + \"px)\";\n      var properties = {\n        onmousedown: interact,\n        style: {\n          background: lineColor,\n          transform: transform,\n          cursor: cursor\n        }\n      };\n      vNodes.push(vd.h(\"div.TagResizer\", properties, []));\n\n      if (!this._tag.indicateVertices) {\n        continue;\n      }\n\n      var pointProperties = {\n        style: {\n          background: lineColor,\n          transform: transform\n        }\n      };\n      vNodes.push(vd.h(\"div.TagVertex\", pointProperties, []));\n    }\n\n    return vNodes;\n  };\n\n  OutlineRenderTag.prototype.getGLObjects = function () {\n    var glObjects = [];\n\n    if (this._fill != null) {\n      glObjects.push(this._fill);\n    }\n\n    for (var _i = 0, _a = this._holes; _i < _a.length; _i++) {\n      var hole = _a[_i];\n      glObjects.push(hole);\n    }\n\n    if (this._outline != null) {\n      glObjects.push(this._outline);\n    }\n\n    return glObjects;\n  };\n\n  OutlineRenderTag.prototype.getRetrievableObjects = function () {\n    return this._fill != null ? [this._fill] : [];\n  };\n\n  OutlineRenderTag.prototype._colorToCss = function (color) {\n    return \"#\" + (\"000000\" + color.toString(16)).substr(-6);\n  };\n\n  OutlineRenderTag.prototype._createFill = function () {\n    var triangles = this._getTriangles();\n\n    var positions = new Float32Array(triangles);\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    geometry.computeBoundingSphere();\n    var material = new THREE.MeshBasicMaterial({\n      side: THREE.DoubleSide,\n      transparent: true\n    });\n\n    this._updateFillMaterial(material);\n\n    return new THREE.Mesh(geometry, material);\n  };\n\n  OutlineRenderTag.prototype._createHoles = function () {\n    var holes = [];\n\n    if (this._tag.geometry instanceof Component_1.PolygonGeometry) {\n      var holes3d = this._getHoles3d();\n\n      for (var _i = 0, holes3d_1 = holes3d; _i < holes3d_1.length; _i++) {\n        var holePoints3d = holes3d_1[_i];\n\n        var hole = this._createLine(holePoints3d);\n\n        holes.push(hole);\n      }\n    }\n\n    return holes;\n  };\n\n  OutlineRenderTag.prototype._createLine = function (points3d) {\n    var positions = this._getLinePositions(points3d);\n\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    geometry.computeBoundingSphere();\n    var material = new THREE.LineBasicMaterial();\n\n    this._updateLineBasicMaterial(material);\n\n    var line = new THREE.Line(geometry, material);\n    line.renderOrder = 1;\n    return line;\n  };\n\n  OutlineRenderTag.prototype._createOutline = function () {\n    return this._createLine(this._getPoints3d());\n  };\n\n  OutlineRenderTag.prototype._disposeFill = function () {\n    if (this._fill == null) {\n      return;\n    }\n\n    this._fill.geometry.dispose();\n\n    this._fill.material.dispose();\n\n    this._fill = null;\n  };\n\n  OutlineRenderTag.prototype._disposeHoles = function () {\n    for (var _i = 0, _a = this._holes; _i < _a.length; _i++) {\n      var hole = _a[_i];\n      hole.geometry.dispose();\n      hole.material.dispose();\n    }\n\n    this._holes = [];\n  };\n\n  OutlineRenderTag.prototype._disposeOutline = function () {\n    if (this._outline == null) {\n      return;\n    }\n\n    this._outline.geometry.dispose();\n\n    this._outline.material.dispose();\n\n    this._outline = null;\n  };\n\n  OutlineRenderTag.prototype._getLinePositions = function (points3d) {\n    var length = points3d.length;\n    var positions = new Float32Array(length * 3);\n\n    for (var i = 0; i < length; ++i) {\n      var index = 3 * i;\n      var position = points3d[i];\n      positions[index + 0] = position[0];\n      positions[index + 1] = position[1];\n      positions[index + 2] = position[2];\n    }\n\n    return positions;\n  };\n\n  OutlineRenderTag.prototype._getHoles3d = function () {\n    var polygonGeometry = this._tag.geometry;\n    return this._in3dDomain() ? polygonGeometry.getHoleVertices3d(this._transform) : polygonGeometry.getHolePoints3d(this._transform);\n  };\n\n  OutlineRenderTag.prototype._getPoints3d = function () {\n    return this._in3dDomain() ? this._tag.geometry.getVertices3d(this._transform) : this._tag.geometry.getPoints3d(this._transform);\n  };\n\n  OutlineRenderTag.prototype._getTriangles = function () {\n    return this._in3dDomain() ? this._tag.geometry.get3dDomainTriangles3d(this._transform) : this._tag.geometry.getTriangles3d(this._transform);\n  };\n\n  OutlineRenderTag.prototype._in3dDomain = function () {\n    return this._tag.geometry instanceof Component_1.PolygonGeometry && this._tag.domain === Component_1.TagDomain.ThreeDimensional;\n  };\n\n  OutlineRenderTag.prototype._interact = function (operation, cursor, vertexIndex) {\n    var _this = this;\n\n    return function (e) {\n      var offsetX = e.offsetX - e.target.offsetWidth / 2;\n      var offsetY = e.offsetY - e.target.offsetHeight / 2;\n\n      _this._interact$.next({\n        cursor: cursor,\n        offsetX: offsetX,\n        offsetY: offsetY,\n        operation: operation,\n        tag: _this._tag,\n        vertexIndex: vertexIndex\n      });\n    };\n  };\n\n  OutlineRenderTag.prototype._updateFillGeometry = function () {\n    var triangles = this._getTriangles();\n\n    var positions = new Float32Array(triangles);\n    var geometry = this._fill.geometry;\n    var attribute = geometry.getAttribute(\"position\");\n\n    if (attribute.array.length === positions.length) {\n      attribute.set(positions);\n      attribute.needsUpdate = true;\n    } else {\n      geometry.removeAttribute(\"position\");\n      geometry.addAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    }\n\n    geometry.computeBoundingSphere();\n  };\n\n  OutlineRenderTag.prototype._updateFillMaterial = function (material) {\n    material.color = new THREE.Color(this._tag.fillColor);\n    material.opacity = this._tag.fillOpacity;\n    material.needsUpdate = true;\n  };\n\n  OutlineRenderTag.prototype._updateHoleGeometries = function () {\n    var holes3d = this._getHoles3d();\n\n    if (holes3d.length !== this._holes.length) {\n      throw new Error(\"Changing the number of holes is not supported.\");\n    }\n\n    for (var i = 0; i < this._holes.length; i++) {\n      var holePoints3d = holes3d[i];\n      var hole = this._holes[i];\n\n      this._updateLine(hole, holePoints3d);\n    }\n  };\n\n  OutlineRenderTag.prototype._updateHoleMaterials = function () {\n    for (var _i = 0, _a = this._holes; _i < _a.length; _i++) {\n      var hole = _a[_i];\n      var material = hole.material;\n\n      this._updateLineBasicMaterial(material);\n    }\n  };\n\n  OutlineRenderTag.prototype._updateLine = function (line, points3d) {\n    var positions = this._getLinePositions(points3d);\n\n    var geometry = line.geometry;\n    var attribute = geometry.getAttribute(\"position\");\n    attribute.set(positions);\n    attribute.needsUpdate = true;\n    geometry.computeBoundingSphere();\n  };\n\n  OutlineRenderTag.prototype._updateOulineGeometry = function () {\n    this._updateLine(this._outline, this._getPoints3d());\n  };\n\n  OutlineRenderTag.prototype._updateOutlineMaterial = function () {\n    var material = this._outline.material;\n\n    this._updateLineBasicMaterial(material);\n  };\n\n  OutlineRenderTag.prototype._updateLineBasicMaterial = function (material) {\n    material.color = new THREE.Color(this._tag.lineColor);\n    material.linewidth = Math.max(this._tag.lineWidth, 1);\n    material.visible = this._tag.lineWidth >= 1 && this._tag.lineOpacity > 0;\n    material.opacity = this._tag.lineOpacity;\n    material.transparent = this._tag.lineOpacity < 1;\n    material.needsUpdate = true;\n  };\n\n  return OutlineRenderTag;\n}(Component_1.RenderTag);\n\nexports.OutlineRenderTag = OutlineRenderTag;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/tag/OutlineRenderTag.ts?");

/***/ }),

/***/ "./src/component/tag/tag/OutlineTag.ts":
/*!*********************************************!*\
  !*** ./src/component/tag/tag/OutlineTag.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n\nvar Viewer_1 = __webpack_require__(/*! ../../../Viewer */ \"./src/Viewer.ts\");\n/**\n * @class OutlineTag\n *\n * @classdesc Tag holding properties for visualizing a geometry outline.\n *\n * @example\n * ```\n * var geometry = new Mapillary.TagComponent.RectGeometry([0.3, 0.3, 0.5, 0.4]);\n * var tag = new Mapillary.TagComponent.OutlineTag(\n *     \"id-1\",\n *     geometry\n *     { editable: true, lineColor: 0xff0000 });\n *\n * tagComponent.add([tag]);\n * ```\n */\n\n\nvar OutlineTag =\n/** @class */\nfunction (_super) {\n  __extends(OutlineTag, _super);\n  /**\n   * Create an outline tag.\n   *\n   * @override\n   * @constructor\n   * @param {string} id - Unique identifier of the tag.\n   * @param {VertexGeometry} geometry - Geometry defining vertices of tag.\n   * @param {IOutlineTagOptions} options - Options defining the visual appearance and\n   * behavior of the outline tag.\n   */\n\n\n  function OutlineTag(id, geometry, options) {\n    var _this = _super.call(this, id, geometry) || this;\n\n    options = !!options ? options : {};\n    var domain = options.domain != null && geometry instanceof Component_1.PolygonGeometry ? options.domain : Component_1.TagDomain.TwoDimensional;\n\n    var twoDimensionalPolygon = _this._twoDimensionalPolygon(domain, geometry);\n\n    _this._domain = domain;\n    _this._editable = options.editable == null || twoDimensionalPolygon ? false : options.editable;\n    _this._fillColor = options.fillColor == null ? 0xFFFFFF : options.fillColor;\n    _this._fillOpacity = options.fillOpacity == null ? 0.0 : options.fillOpacity;\n    _this._icon = options.icon === undefined ? null : options.icon;\n    _this._iconFloat = options.iconFloat == null ? Viewer_1.Alignment.Center : options.iconFloat;\n    _this._iconIndex = options.iconIndex == null ? 3 : options.iconIndex;\n    _this._indicateVertices = options.indicateVertices == null ? true : options.indicateVertices;\n    _this._lineColor = options.lineColor == null ? 0xFFFFFF : options.lineColor;\n    _this._lineOpacity = options.lineOpacity == null ? 1 : options.lineOpacity;\n    _this._lineWidth = options.lineWidth == null ? 1 : options.lineWidth;\n    _this._text = options.text === undefined ? null : options.text;\n    _this._textColor = options.textColor == null ? 0xFFFFFF : options.textColor;\n    _this._click$ = new rxjs_1.Subject();\n\n    _this._click$.subscribe(function (t) {\n      _this.fire(OutlineTag.click, _this);\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(OutlineTag.prototype, \"click$\", {\n    /**\n     * Click observable.\n     *\n     * @description An observable emitting the tag when the icon of the\n     * tag has been clicked.\n     *\n     * @returns {Observable<Tag>}\n     */\n    get: function get() {\n      return this._click$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"domain\", {\n    /**\n     * Get domain property.\n     *\n     * @description Readonly property that can only be set in constructor.\n     *\n     * @returns Value indicating the domain of the tag.\n     */\n    get: function get() {\n      return this._domain;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"editable\", {\n    /**\n     * Get editable property.\n     * @returns {boolean} Value indicating if tag is editable.\n     */\n    get: function get() {\n      return this._editable;\n    },\n\n    /**\n     * Set editable property.\n     * @param {boolean}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      if (this._twoDimensionalPolygon(this._domain, this._geometry)) {\n        return;\n      }\n\n      this._editable = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"fillColor\", {\n    /**\n     * Get fill color property.\n     * @returns {number}\n     */\n    get: function get() {\n      return this._fillColor;\n    },\n\n    /**\n     * Set fill color property.\n     * @param {number}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._fillColor = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"fillOpacity\", {\n    /**\n     * Get fill opacity property.\n     * @returns {number}\n     */\n    get: function get() {\n      return this._fillOpacity;\n    },\n\n    /**\n     * Set fill opacity property.\n     * @param {number}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._fillOpacity = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"geometry\", {\n    /** @inheritdoc */\n    get: function get() {\n      return this._geometry;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"icon\", {\n    /**\n     * Get icon property.\n     * @returns {string}\n     */\n    get: function get() {\n      return this._icon;\n    },\n\n    /**\n     * Set icon property.\n     * @param {string}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._icon = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"iconFloat\", {\n    /**\n     * Get icon float property.\n     * @returns {Alignment}\n     */\n    get: function get() {\n      return this._iconFloat;\n    },\n\n    /**\n     * Set icon float property.\n     * @param {Alignment}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._iconFloat = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"iconIndex\", {\n    /**\n     * Get icon index property.\n     * @returns {number}\n     */\n    get: function get() {\n      return this._iconIndex;\n    },\n\n    /**\n     * Set icon index property.\n     * @param {number}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._iconIndex = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"indicateVertices\", {\n    /**\n     * Get indicate vertices property.\n     * @returns {boolean} Value indicating if vertices should be indicated\n     * when tag is editable.\n     */\n    get: function get() {\n      return this._indicateVertices;\n    },\n\n    /**\n     * Set indicate vertices property.\n     * @param {boolean}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._indicateVertices = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"lineColor\", {\n    /**\n     * Get line color property.\n     * @returns {number}\n     */\n    get: function get() {\n      return this._lineColor;\n    },\n\n    /**\n     * Set line color property.\n     * @param {number}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._lineColor = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"lineOpacity\", {\n    /**\n     * Get line opacity property.\n     * @returns {number}\n     */\n    get: function get() {\n      return this._lineOpacity;\n    },\n\n    /**\n     * Set line opacity property.\n     * @param {number}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._lineOpacity = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"lineWidth\", {\n    /**\n     * Get line width property.\n     * @returns {number}\n     */\n    get: function get() {\n      return this._lineWidth;\n    },\n\n    /**\n     * Set line width property.\n     * @param {number}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._lineWidth = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"text\", {\n    /**\n     * Get text property.\n     * @returns {string}\n     */\n    get: function get() {\n      return this._text;\n    },\n\n    /**\n     * Set text property.\n     * @param {string}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._text = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OutlineTag.prototype, \"textColor\", {\n    /**\n     * Get text color property.\n     * @returns {number}\n     */\n    get: function get() {\n      return this._textColor;\n    },\n\n    /**\n     * Set text color property.\n     * @param {number}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._textColor = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Set options for tag.\n   *\n   * @description Sets all the option properties provided and keeps\n   * the rest of the values as is.\n   *\n   * @param {IOutlineTagOptions} options - Outline tag options\n   *\n   * @fires {Tag#changed}\n   */\n\n  OutlineTag.prototype.setOptions = function (options) {\n    var twoDimensionalPolygon = this._twoDimensionalPolygon(this._domain, this._geometry);\n\n    this._editable = twoDimensionalPolygon || options.editable == null ? this._editable : options.editable;\n    this._icon = options.icon === undefined ? this._icon : options.icon;\n    this._iconFloat = options.iconFloat == null ? this._iconFloat : options.iconFloat;\n    this._iconIndex = options.iconIndex == null ? this._iconIndex : options.iconIndex;\n    this._indicateVertices = options.indicateVertices == null ? this._indicateVertices : options.indicateVertices;\n    this._lineColor = options.lineColor == null ? this._lineColor : options.lineColor;\n    this._lineWidth = options.lineWidth == null ? this._lineWidth : options.lineWidth;\n    this._fillColor = options.fillColor == null ? this._fillColor : options.fillColor;\n    this._fillOpacity = options.fillOpacity == null ? this._fillOpacity : options.fillOpacity;\n    this._text = options.text === undefined ? this._text : options.text;\n    this._textColor = options.textColor == null ? this._textColor : options.textColor;\n\n    this._notifyChanged$.next(this);\n  };\n\n  OutlineTag.prototype._twoDimensionalPolygon = function (domain, geometry) {\n    return domain !== Component_1.TagDomain.ThreeDimensional && geometry instanceof Component_1.PolygonGeometry;\n  };\n  /**\n   * Event fired when the icon of the outline tag is clicked.\n   *\n   * @event OutlineTag#click\n   * @type {OutlineTag} The tag instance that was clicked.\n   */\n\n\n  OutlineTag.click = \"click\";\n  return OutlineTag;\n}(Component_1.Tag);\n\nexports.OutlineTag = OutlineTag;\nexports.default = OutlineTag;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/tag/OutlineTag.ts?");

/***/ }),

/***/ "./src/component/tag/tag/RenderTag.ts":
/*!********************************************!*\
  !*** ./src/component/tag/tag/RenderTag.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Geo_1 = __webpack_require__(/*! ../../../Geo */ \"./src/Geo.ts\");\n\nvar RenderTag =\n/** @class */\nfunction () {\n  function RenderTag(tag, transform, viewportCoords) {\n    this._tag = tag;\n    this._transform = transform;\n    this._viewportCoords = !!viewportCoords ? viewportCoords : new Geo_1.ViewportCoords();\n    this._glObjectsChanged$ = new rxjs_1.Subject();\n    this._interact$ = new rxjs_1.Subject();\n  }\n\n  Object.defineProperty(RenderTag.prototype, \"glObjectsChanged$\", {\n    get: function get() {\n      return this._glObjectsChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderTag.prototype, \"interact$\", {\n    get: function get() {\n      return this._interact$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderTag.prototype, \"tag\", {\n    get: function get() {\n      return this._tag;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return RenderTag;\n}();\n\nexports.RenderTag = RenderTag;\nexports.default = RenderTag;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/tag/RenderTag.ts?");

/***/ }),

/***/ "./src/component/tag/tag/SpotRenderTag.ts":
/*!************************************************!*\
  !*** ./src/component/tag/tag/SpotRenderTag.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n\nvar Viewer_1 = __webpack_require__(/*! ../../../Viewer */ \"./src/Viewer.ts\");\n/**\n * @class SpotRenderTag\n * @classdesc Tag visualizing the properties of a SpotTag.\n */\n\n\nvar SpotRenderTag =\n/** @class */\nfunction (_super) {\n  __extends(SpotRenderTag, _super);\n\n  function SpotRenderTag() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SpotRenderTag.prototype.dispose = function () {};\n\n  SpotRenderTag.prototype.getDOMObjects = function (atlas, camera, size) {\n    var _this = this;\n\n    var tag = this._tag;\n    var container = {\n      offsetHeight: size.height,\n      offsetWidth: size.width\n    };\n    var vNodes = [];\n\n    var _a = tag.geometry.getCentroid2d(),\n        centroidBasicX = _a[0],\n        centroidBasicY = _a[1];\n\n    var centroidCanvas = this._viewportCoords.basicToCanvasSafe(centroidBasicX, centroidBasicY, container, this._transform, camera);\n\n    if (centroidCanvas != null) {\n      var interactNone = function interactNone(e) {\n        _this._interact$.next({\n          offsetX: 0,\n          offsetY: 0,\n          operation: Component_1.TagOperation.None,\n          tag: tag\n        });\n      };\n\n      var canvasX = Math.round(centroidCanvas[0]);\n      var canvasY = Math.round(centroidCanvas[1]);\n\n      if (tag.icon != null) {\n        if (atlas.loaded) {\n          var sprite = atlas.getDOMSprite(tag.icon, Viewer_1.Alignment.Bottom);\n          var iconTransform = \"translate(\" + canvasX + \"px,\" + (canvasY + 8) + \"px)\";\n          var properties = {\n            onmousedown: interactNone,\n            style: {\n              pointerEvents: \"all\",\n              transform: iconTransform\n            }\n          };\n          vNodes.push(vd.h(\"div\", properties, [sprite]));\n        }\n      } else if (tag.text != null) {\n        var textTransform = \"translate(-50%,0%) translate(\" + canvasX + \"px,\" + (canvasY + 8) + \"px)\";\n        var properties = {\n          onmousedown: interactNone,\n          style: {\n            color: this._colorToCss(tag.textColor),\n            transform: textTransform\n          },\n          textContent: tag.text\n        };\n        vNodes.push(vd.h(\"span.TagSymbol\", properties, []));\n      }\n\n      var interact = this._interact(Component_1.TagOperation.Centroid, tag, \"move\");\n\n      var background = this._colorToCss(tag.color);\n\n      var transform = \"translate(-50%,-50%) translate(\" + canvasX + \"px,\" + canvasY + \"px)\";\n\n      if (tag.editable) {\n        var interactorProperties = {\n          onmousedown: interact,\n          style: {\n            background: background,\n            transform: transform\n          }\n        };\n        vNodes.push(vd.h(\"div.TagSpotInteractor\", interactorProperties, []));\n      }\n\n      var pointProperties = {\n        style: {\n          background: background,\n          transform: transform\n        }\n      };\n      vNodes.push(vd.h(\"div.TagVertex\", pointProperties, []));\n    }\n\n    return vNodes;\n  };\n\n  SpotRenderTag.prototype.getGLObjects = function () {\n    return [];\n  };\n\n  SpotRenderTag.prototype.getRetrievableObjects = function () {\n    return [];\n  };\n\n  SpotRenderTag.prototype._colorToCss = function (color) {\n    return \"#\" + (\"000000\" + color.toString(16)).substr(-6);\n  };\n\n  SpotRenderTag.prototype._interact = function (operation, tag, cursor, vertexIndex) {\n    var _this = this;\n\n    return function (e) {\n      var offsetX = e.offsetX - e.target.offsetWidth / 2;\n      var offsetY = e.offsetY - e.target.offsetHeight / 2;\n\n      _this._interact$.next({\n        cursor: cursor,\n        offsetX: offsetX,\n        offsetY: offsetY,\n        operation: operation,\n        tag: tag,\n        vertexIndex: vertexIndex\n      });\n    };\n  };\n\n  return SpotRenderTag;\n}(Component_1.RenderTag);\n\nexports.SpotRenderTag = SpotRenderTag;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/tag/SpotRenderTag.ts?");

/***/ }),

/***/ "./src/component/tag/tag/SpotTag.ts":
/*!******************************************!*\
  !*** ./src/component/tag/tag/SpotTag.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Component_1 = __webpack_require__(/*! ../../../Component */ \"./src/Component.ts\");\n/**\n * @class SpotTag\n *\n * @classdesc Tag holding properties for visualizing the centroid of a geometry.\n *\n * @example\n * ```\n * var geometry = new Mapillary.TagComponent.PointGeometry([0.3, 0.3]);\n * var tag = new Mapillary.TagComponent.SpotTag(\n *     \"id-1\",\n *     geometry\n *     { editable: true, color: 0xff0000 });\n *\n * tagComponent.add([tag]);\n * ```\n */\n\n\nvar SpotTag =\n/** @class */\nfunction (_super) {\n  __extends(SpotTag, _super);\n  /**\n   * Create a spot tag.\n   *\n   * @override\n   * @constructor\n   * @param {string} id\n   * @param {Geometry} geometry\n   * @param {IOutlineTagOptions} options - Options defining the visual appearance and\n   * behavior of the spot tag.\n   */\n\n\n  function SpotTag(id, geometry, options) {\n    var _this = _super.call(this, id, geometry) || this;\n\n    options = !!options ? options : {};\n    _this._color = options.color == null ? 0xFFFFFF : options.color;\n    _this._editable = options.editable == null ? false : options.editable;\n    _this._icon = options.icon === undefined ? null : options.icon;\n    _this._text = options.text === undefined ? null : options.text;\n    _this._textColor = options.textColor == null ? 0xFFFFFF : options.textColor;\n    return _this;\n  }\n\n  Object.defineProperty(SpotTag.prototype, \"color\", {\n    /**\n     * Get color property.\n     * @returns {number} The color of the spot as a hexagonal number;\n     */\n    get: function get() {\n      return this._color;\n    },\n\n    /**\n     * Set color property.\n     * @param {number}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._color = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SpotTag.prototype, \"editable\", {\n    /**\n     * Get editable property.\n     * @returns {boolean} Value indicating if tag is editable.\n     */\n    get: function get() {\n      return this._editable;\n    },\n\n    /**\n     * Set editable property.\n     * @param {boolean}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._editable = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SpotTag.prototype, \"icon\", {\n    /**\n     * Get icon property.\n     * @returns {string}\n     */\n    get: function get() {\n      return this._icon;\n    },\n\n    /**\n     * Set icon property.\n     * @param {string}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._icon = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SpotTag.prototype, \"text\", {\n    /**\n     * Get text property.\n     * @returns {string}\n     */\n    get: function get() {\n      return this._text;\n    },\n\n    /**\n     * Set text property.\n     * @param {string}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._text = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SpotTag.prototype, \"textColor\", {\n    /**\n     * Get text color property.\n     * @returns {number}\n     */\n    get: function get() {\n      return this._textColor;\n    },\n\n    /**\n     * Set text color property.\n     * @param {number}\n     *\n     * @fires Tag#changed\n     */\n    set: function set(value) {\n      this._textColor = value;\n\n      this._notifyChanged$.next(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Set options for tag.\n   *\n   * @description Sets all the option properties provided and keps\n   * the rest of the values as is.\n   *\n   * @param {ISpotTagOptions} options - Spot tag options\n   *\n   * @fires {Tag#changed}\n   */\n\n  SpotTag.prototype.setOptions = function (options) {\n    this._color = options.color == null ? this._color : options.color;\n    this._editable = options.editable == null ? this._editable : options.editable;\n    this._icon = options.icon === undefined ? this._icon : options.icon;\n    this._text = options.text === undefined ? this._text : options.text;\n    this._textColor = options.textColor == null ? this._textColor : options.textColor;\n\n    this._notifyChanged$.next(this);\n  };\n\n  return SpotTag;\n}(Component_1.Tag);\n\nexports.SpotTag = SpotTag;\nexports.default = SpotTag;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/tag/SpotTag.ts?");

/***/ }),

/***/ "./src/component/tag/tag/Tag.ts":
/*!**************************************!*\
  !*** ./src/component/tag/tag/Tag.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Utils_1 = __webpack_require__(/*! ../../../Utils */ \"./src/Utils.ts\");\n/**\n * @class Tag\n * @abstract\n * @classdesc Abstract class representing the basic functionality of for a tag.\n */\n\n\nvar Tag =\n/** @class */\nfunction (_super) {\n  __extends(Tag, _super);\n  /**\n   * Create a tag.\n   *\n   * @constructor\n   * @param {string} id\n   * @param {Geometry} geometry\n   */\n\n\n  function Tag(id, geometry) {\n    var _this = _super.call(this) || this;\n\n    _this._id = id;\n    _this._geometry = geometry;\n    _this._notifyChanged$ = new rxjs_1.Subject();\n\n    _this._notifyChanged$.subscribe(function (t) {\n      _this.fire(Tag.changed, _this);\n    });\n\n    _this._geometry.changed$.subscribe(function (g) {\n      _this.fire(Tag.geometrychanged, _this);\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(Tag.prototype, \"id\", {\n    /**\n     * Get id property.\n     * @returns {string}\n     */\n    get: function get() {\n      return this._id;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tag.prototype, \"geometry\", {\n    /**\n     * Get geometry property.\n     * @returns {Geometry} The geometry of the tag.\n     */\n    get: function get() {\n      return this._geometry;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tag.prototype, \"changed$\", {\n    /**\n     * Get changed observable.\n     * @returns {Observable<Tag>}\n     * @ignore\n     */\n    get: function get() {\n      return this._notifyChanged$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tag.prototype, \"geometryChanged$\", {\n    /**\n     * Get geometry changed observable.\n     * @returns {Observable<Tag>}\n     * @ignore\n     */\n    get: function get() {\n      var _this = this;\n\n      return this._geometry.changed$.pipe(operators_1.map(function (geometry) {\n        return _this;\n      }), operators_1.share());\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Event fired when a property related to the visual appearance of the\n   * tag has changed.\n   *\n   * @event Tag#changed\n   * @type {Tag} The tag instance that has changed.\n   */\n\n  Tag.changed = \"changed\";\n  /**\n   * Event fired when the geometry of the tag has changed.\n   *\n   * @event Tag#geometrychanged\n   * @type {Tag} The tag instance whose geometry has changed.\n   */\n\n  Tag.geometrychanged = \"geometrychanged\";\n  return Tag;\n}(Utils_1.EventEmitter);\n\nexports.Tag = Tag;\nexports.default = Tag;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/tag/Tag.ts?");

/***/ }),

/***/ "./src/component/tag/tag/TagDomain.ts":
/*!********************************************!*\
  !*** ./src/component/tag/tag/TagDomain.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enumeration for tag domains.\n * @enum {number}\n * @readonly\n * @description Defines where lines between two vertices are treated\n * as straight.\n *\n * Only applicable for polygons. For rectangles lines between\n * vertices are always treated as straight in the distorted 2D\n * projection and bended in the undistorted 3D space.\n */\n\nvar TagDomain;\n\n(function (TagDomain) {\n  /**\n   * Treats lines between two vertices as straight in the\n   * distorted 2D projection, i.e. on the image. If the image\n   * is distorted this will result in bended lines when rendered\n   * in the undistorted 3D space.\n   */\n  TagDomain[TagDomain[\"TwoDimensional\"] = 0] = \"TwoDimensional\";\n  /**\n   * Treats lines as straight in the undistorted 3D space. If the\n   * image is distorted this will result in bended lines when rendered\n   * on the distorted 2D projection of the image.\n   */\n\n  TagDomain[TagDomain[\"ThreeDimensional\"] = 1] = \"ThreeDimensional\";\n})(TagDomain = exports.TagDomain || (exports.TagDomain = {}));\n\nexports.default = TagDomain;\n\n//# sourceURL=webpack://Mapillary/./src/component/tag/tag/TagDomain.ts?");

/***/ }),

/***/ "./src/component/utils/ComponentSize.ts":
/*!**********************************************!*\
  !*** ./src/component/utils/ComponentSize.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enumeration for component size.\n * @enum {number}\n * @readonly\n * @description May be used by a component to allow for resizing\n * of the UI elements rendered by the component.\n */\n\nvar ComponentSize;\n\n(function (ComponentSize) {\n  /**\n   * Automatic size. The size of the elements will automatically\n   * change at a predefined threshold.\n   */\n  ComponentSize[ComponentSize[\"Automatic\"] = 0] = \"Automatic\";\n  /**\n   * Large size. The size of the elements will be fixed until another\n   * component size is configured.\n   */\n\n  ComponentSize[ComponentSize[\"Large\"] = 1] = \"Large\";\n  /**\n   * Small size. The size of the elements will be fixed until another\n   * component size is configured.\n   */\n\n  ComponentSize[ComponentSize[\"Small\"] = 2] = \"Small\";\n})(ComponentSize = exports.ComponentSize || (exports.ComponentSize = {}));\n\nexports.default = ComponentSize;\n\n//# sourceURL=webpack://Mapillary/./src/component/utils/ComponentSize.ts?");

/***/ }),

/***/ "./src/component/utils/HandlerBase.ts":
/*!********************************************!*\
  !*** ./src/component/utils/HandlerBase.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar HandlerBase =\n/** @class */\nfunction () {\n  /** @ignore */\n  function HandlerBase(component, container, navigator) {\n    this._component = component;\n    this._container = container;\n    this._navigator = navigator;\n    this._enabled = false;\n  }\n\n  Object.defineProperty(HandlerBase.prototype, \"isEnabled\", {\n    /**\n     * Returns a Boolean indicating whether the interaction is enabled.\n     *\n     * @returns {boolean} `true` if the interaction is enabled.\n     */\n    get: function get() {\n      return this._enabled;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Enables the interaction.\n   *\n   * @example ```<component-name>.<handler-name>.enable();```\n   */\n\n  HandlerBase.prototype.enable = function () {\n    if (this._enabled || !this._component.activated) {\n      return;\n    }\n\n    this._enable();\n\n    this._enabled = true;\n\n    this._component.configure(this._getConfiguration(true));\n  };\n  /**\n   * Disables the interaction.\n   *\n   * @example ```<component-name>.<handler-name>.disable();```\n   */\n\n\n  HandlerBase.prototype.disable = function () {\n    if (!this._enabled) {\n      return;\n    }\n\n    this._disable();\n\n    this._enabled = false;\n\n    if (this._component.activated) {\n      this._component.configure(this._getConfiguration(false));\n    }\n  };\n\n  return HandlerBase;\n}();\n\nexports.HandlerBase = HandlerBase;\nexports.default = HandlerBase;\n\n//# sourceURL=webpack://Mapillary/./src/component/utils/HandlerBase.ts?");

/***/ }),

/***/ "./src/component/utils/MeshFactory.ts":
/*!********************************************!*\
  !*** ./src/component/utils/MeshFactory.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar MeshFactory =\n/** @class */\nfunction () {\n  function MeshFactory(imagePlaneDepth, imageSphereRadius) {\n    this._imagePlaneDepth = imagePlaneDepth != null ? imagePlaneDepth : 200;\n    this._imageSphereRadius = imageSphereRadius != null ? imageSphereRadius : 200;\n  }\n\n  MeshFactory.prototype.createMesh = function (node, transform) {\n    if (node.pano) {\n      return this._createImageSphere(node, transform);\n    } else if (transform.cameraProjection === \"fisheye\") {\n      return this._createImagePlaneFisheye(node, transform);\n    } else {\n      return this._createImagePlane(node, transform);\n    }\n  };\n\n  MeshFactory.prototype.createFlatMesh = function (node, transform, basicX0, basicX1, basicY0, basicY1) {\n    var texture = this._createTexture(node.image);\n\n    var materialParameters = this._createDistortedPlaneMaterialParameters(transform, texture);\n\n    var material = new THREE.ShaderMaterial(materialParameters);\n\n    var geometry = this._getFlatImagePlaneGeoFromBasic(transform, basicX0, basicX1, basicY0, basicY1);\n\n    return new THREE.Mesh(geometry, material);\n  };\n\n  MeshFactory.prototype.createCurtainMesh = function (node, transform) {\n    if (node.pano && !node.fullPano) {\n      throw new Error(\"Cropped panoramas cannot have curtain.\");\n    }\n\n    if (node.pano) {\n      return this._createSphereCurtainMesh(node, transform);\n    } else if (transform.cameraProjection === \"fisheye\") {\n      return this._createCurtainMeshFisheye(node, transform);\n    } else {\n      return this._createCurtainMesh(node, transform);\n    }\n  };\n\n  MeshFactory.prototype.createDistortedCurtainMesh = function (node, transform) {\n    if (node.pano) {\n      throw new Error(\"Cropped panoramas cannot have curtain.\");\n    }\n\n    return this._createDistortedCurtainMesh(node, transform);\n  };\n\n  MeshFactory.prototype._createCurtainMesh = function (node, transform) {\n    var texture = this._createTexture(node.image);\n\n    var materialParameters = this._createCurtainPlaneMaterialParameters(transform, texture);\n\n    var material = new THREE.ShaderMaterial(materialParameters);\n    var geometry = this._useMesh(transform, node) ? this._getImagePlaneGeo(transform, node) : this._getRegularFlatImagePlaneGeo(transform);\n    return new THREE.Mesh(geometry, material);\n  };\n\n  MeshFactory.prototype._createCurtainMeshFisheye = function (node, transform) {\n    var texture = this._createTexture(node.image);\n\n    var materialParameters = this._createCurtainPlaneMaterialParametersFisheye(transform, texture);\n\n    var material = new THREE.ShaderMaterial(materialParameters);\n    var geometry = this._useMesh(transform, node) ? this._getImagePlaneGeoFisheye(transform, node) : this._getRegularFlatImagePlaneGeo(transform);\n    return new THREE.Mesh(geometry, material);\n  };\n\n  MeshFactory.prototype._createDistortedCurtainMesh = function (node, transform) {\n    var texture = this._createTexture(node.image);\n\n    var materialParameters = this._createDistortedCurtainPlaneMaterialParameters(transform, texture);\n\n    var material = new THREE.ShaderMaterial(materialParameters);\n\n    var geometry = this._getRegularFlatImagePlaneGeo(transform);\n\n    return new THREE.Mesh(geometry, material);\n  };\n\n  MeshFactory.prototype._createSphereCurtainMesh = function (node, transform) {\n    var texture = this._createTexture(node.image);\n\n    var materialParameters = this._createCurtainSphereMaterialParameters(transform, texture);\n\n    var material = new THREE.ShaderMaterial(materialParameters);\n    return this._useMesh(transform, node) ? new THREE.Mesh(this._getImageSphereGeo(transform, node), material) : new THREE.Mesh(this._getFlatImageSphereGeo(transform), material);\n  };\n\n  MeshFactory.prototype._createImageSphere = function (node, transform) {\n    var texture = this._createTexture(node.image);\n\n    var materialParameters = this._createSphereMaterialParameters(transform, texture);\n\n    var material = new THREE.ShaderMaterial(materialParameters);\n    var mesh = this._useMesh(transform, node) ? new THREE.Mesh(this._getImageSphereGeo(transform, node), material) : new THREE.Mesh(this._getFlatImageSphereGeo(transform), material);\n    return mesh;\n  };\n\n  MeshFactory.prototype._createImagePlane = function (node, transform) {\n    var texture = this._createTexture(node.image);\n\n    var materialParameters = this._createPlaneMaterialParameters(transform, texture);\n\n    var material = new THREE.ShaderMaterial(materialParameters);\n    var geometry = this._useMesh(transform, node) ? this._getImagePlaneGeo(transform, node) : this._getRegularFlatImagePlaneGeo(transform);\n    return new THREE.Mesh(geometry, material);\n  };\n\n  MeshFactory.prototype._createImagePlaneFisheye = function (node, transform) {\n    var texture = this._createTexture(node.image);\n\n    var materialParameters = this._createPlaneMaterialParametersFisheye(transform, texture);\n\n    var material = new THREE.ShaderMaterial(materialParameters);\n    var geometry = this._useMesh(transform, node) ? this._getImagePlaneGeoFisheye(transform, node) : this._getRegularFlatImagePlaneGeoFisheye(transform);\n    return new THREE.Mesh(geometry, material);\n  };\n\n  MeshFactory.prototype._createSphereMaterialParameters = function (transform, texture) {\n    var gpano = transform.gpano;\n    var halfCroppedWidth = (gpano.FullPanoWidthPixels - gpano.CroppedAreaImageWidthPixels) / 2;\n    var phiShift = 2 * Math.PI * (gpano.CroppedAreaLeftPixels - halfCroppedWidth) / gpano.FullPanoWidthPixels;\n    var phiLength = 2 * Math.PI * gpano.CroppedAreaImageWidthPixels / gpano.FullPanoWidthPixels;\n    var halfCroppedHeight = (gpano.FullPanoHeightPixels - gpano.CroppedAreaImageHeightPixels) / 2;\n    var thetaShift = Math.PI * (halfCroppedHeight - gpano.CroppedAreaTopPixels) / gpano.FullPanoHeightPixels;\n    var thetaLength = Math.PI * gpano.CroppedAreaImageHeightPixels / gpano.FullPanoHeightPixels;\n    var materialParameters = {\n      depthWrite: false,\n      fragmentShader: Component_1.Shaders.equirectangular.fragment,\n      side: THREE.DoubleSide,\n      transparent: true,\n      uniforms: {\n        opacity: {\n          type: \"f\",\n          value: 1\n        },\n        phiLength: {\n          type: \"f\",\n          value: phiLength\n        },\n        phiShift: {\n          type: \"f\",\n          value: phiShift\n        },\n        projectorMat: {\n          type: \"m4\",\n          value: transform.rt\n        },\n        projectorTex: {\n          type: \"t\",\n          value: texture\n        },\n        thetaLength: {\n          type: \"f\",\n          value: thetaLength\n        },\n        thetaShift: {\n          type: \"f\",\n          value: thetaShift\n        }\n      },\n      vertexShader: Component_1.Shaders.equirectangular.vertex\n    };\n    return materialParameters;\n  };\n\n  MeshFactory.prototype._createCurtainSphereMaterialParameters = function (transform, texture) {\n    var gpano = transform.gpano;\n    var halfCroppedWidth = (gpano.FullPanoWidthPixels - gpano.CroppedAreaImageWidthPixels) / 2;\n    var phiShift = 2 * Math.PI * (gpano.CroppedAreaLeftPixels - halfCroppedWidth) / gpano.FullPanoWidthPixels;\n    var phiLength = 2 * Math.PI * gpano.CroppedAreaImageWidthPixels / gpano.FullPanoWidthPixels;\n    var halfCroppedHeight = (gpano.FullPanoHeightPixels - gpano.CroppedAreaImageHeightPixels) / 2;\n    var thetaShift = Math.PI * (halfCroppedHeight - gpano.CroppedAreaTopPixels) / gpano.FullPanoHeightPixels;\n    var thetaLength = Math.PI * gpano.CroppedAreaImageHeightPixels / gpano.FullPanoHeightPixels;\n    var materialParameters = {\n      depthWrite: false,\n      fragmentShader: Component_1.Shaders.equirectangularCurtain.fragment,\n      side: THREE.DoubleSide,\n      transparent: true,\n      uniforms: {\n        curtain: {\n          type: \"f\",\n          value: 1\n        },\n        opacity: {\n          type: \"f\",\n          value: 1\n        },\n        phiLength: {\n          type: \"f\",\n          value: phiLength\n        },\n        phiShift: {\n          type: \"f\",\n          value: phiShift\n        },\n        projectorMat: {\n          type: \"m4\",\n          value: transform.rt\n        },\n        projectorTex: {\n          type: \"t\",\n          value: texture\n        },\n        thetaLength: {\n          type: \"f\",\n          value: thetaLength\n        },\n        thetaShift: {\n          type: \"f\",\n          value: thetaShift\n        }\n      },\n      vertexShader: Component_1.Shaders.equirectangularCurtain.vertex\n    };\n    return materialParameters;\n  };\n\n  MeshFactory.prototype._createPlaneMaterialParameters = function (transform, texture) {\n    var materialParameters = {\n      depthWrite: false,\n      fragmentShader: Component_1.Shaders.perspective.fragment,\n      side: THREE.DoubleSide,\n      transparent: true,\n      uniforms: {\n        focal: {\n          type: \"f\",\n          value: transform.focal\n        },\n        k1: {\n          type: \"f\",\n          value: transform.ck1\n        },\n        k2: {\n          type: \"f\",\n          value: transform.ck2\n        },\n        opacity: {\n          type: \"f\",\n          value: 1\n        },\n        projectorMat: {\n          type: \"m4\",\n          value: transform.basicRt\n        },\n        projectorTex: {\n          type: \"t\",\n          value: texture\n        },\n        radial_peak: {\n          type: \"f\",\n          value: !!transform.radialPeak ? transform.radialPeak : 0\n        },\n        scale_x: {\n          type: \"f\",\n          value: Math.max(transform.basicHeight, transform.basicWidth) / transform.basicWidth\n        },\n        scale_y: {\n          type: \"f\",\n          value: Math.max(transform.basicWidth, transform.basicHeight) / transform.basicHeight\n        }\n      },\n      vertexShader: Component_1.Shaders.perspective.vertex\n    };\n    return materialParameters;\n  };\n\n  MeshFactory.prototype._createPlaneMaterialParametersFisheye = function (transform, texture) {\n    var materialParameters = {\n      depthWrite: false,\n      fragmentShader: Component_1.Shaders.fisheye.fragment,\n      side: THREE.DoubleSide,\n      transparent: true,\n      uniforms: {\n        focal: {\n          type: \"f\",\n          value: transform.focal\n        },\n        k1: {\n          type: \"f\",\n          value: transform.ck1\n        },\n        k2: {\n          type: \"f\",\n          value: transform.ck2\n        },\n        opacity: {\n          type: \"f\",\n          value: 1\n        },\n        projectorMat: {\n          type: \"m4\",\n          value: transform.basicRt\n        },\n        projectorTex: {\n          type: \"t\",\n          value: texture\n        },\n        radial_peak: {\n          type: \"f\",\n          value: !!transform.radialPeak ? transform.radialPeak : 0\n        },\n        scale_x: {\n          type: \"f\",\n          value: Math.max(transform.basicHeight, transform.basicWidth) / transform.basicWidth\n        },\n        scale_y: {\n          type: \"f\",\n          value: Math.max(transform.basicWidth, transform.basicHeight) / transform.basicHeight\n        }\n      },\n      vertexShader: Component_1.Shaders.fisheye.vertex\n    };\n    return materialParameters;\n  };\n\n  MeshFactory.prototype._createCurtainPlaneMaterialParametersFisheye = function (transform, texture) {\n    var materialParameters = {\n      depthWrite: false,\n      fragmentShader: Component_1.Shaders.fisheyeCurtain.fragment,\n      side: THREE.DoubleSide,\n      transparent: true,\n      uniforms: {\n        curtain: {\n          type: \"f\",\n          value: 1\n        },\n        focal: {\n          type: \"f\",\n          value: transform.focal\n        },\n        k1: {\n          type: \"f\",\n          value: transform.ck1\n        },\n        k2: {\n          type: \"f\",\n          value: transform.ck2\n        },\n        opacity: {\n          type: \"f\",\n          value: 1\n        },\n        projectorMat: {\n          type: \"m4\",\n          value: transform.basicRt\n        },\n        projectorTex: {\n          type: \"t\",\n          value: texture\n        },\n        radial_peak: {\n          type: \"f\",\n          value: !!transform.radialPeak ? transform.radialPeak : 0\n        },\n        scale_x: {\n          type: \"f\",\n          value: Math.max(transform.basicHeight, transform.basicWidth) / transform.basicWidth\n        },\n        scale_y: {\n          type: \"f\",\n          value: Math.max(transform.basicWidth, transform.basicHeight) / transform.basicHeight\n        }\n      },\n      vertexShader: Component_1.Shaders.fisheyeCurtain.vertex\n    };\n    return materialParameters;\n  };\n\n  MeshFactory.prototype._createCurtainPlaneMaterialParameters = function (transform, texture) {\n    var materialParameters = {\n      depthWrite: false,\n      fragmentShader: Component_1.Shaders.perspectiveCurtain.fragment,\n      side: THREE.DoubleSide,\n      transparent: true,\n      uniforms: {\n        curtain: {\n          type: \"f\",\n          value: 1\n        },\n        focal: {\n          type: \"f\",\n          value: transform.focal\n        },\n        k1: {\n          type: \"f\",\n          value: transform.ck1\n        },\n        k2: {\n          type: \"f\",\n          value: transform.ck2\n        },\n        opacity: {\n          type: \"f\",\n          value: 1\n        },\n        projectorMat: {\n          type: \"m4\",\n          value: transform.basicRt\n        },\n        projectorTex: {\n          type: \"t\",\n          value: texture\n        },\n        radial_peak: {\n          type: \"f\",\n          value: !!transform.radialPeak ? transform.radialPeak : 0\n        },\n        scale_x: {\n          type: \"f\",\n          value: Math.max(transform.basicHeight, transform.basicWidth) / transform.basicWidth\n        },\n        scale_y: {\n          type: \"f\",\n          value: Math.max(transform.basicWidth, transform.basicHeight) / transform.basicHeight\n        }\n      },\n      vertexShader: Component_1.Shaders.perspectiveCurtain.vertex\n    };\n    return materialParameters;\n  };\n\n  MeshFactory.prototype._createDistortedCurtainPlaneMaterialParameters = function (transform, texture) {\n    var materialParameters = {\n      depthWrite: false,\n      fragmentShader: Component_1.Shaders.perspectiveDistortedCurtain.fragment,\n      side: THREE.DoubleSide,\n      transparent: true,\n      uniforms: {\n        curtain: {\n          type: \"f\",\n          value: 1\n        },\n        opacity: {\n          type: \"f\",\n          value: 1\n        },\n        projectorMat: {\n          type: \"m4\",\n          value: transform.projectorMatrix()\n        },\n        projectorTex: {\n          type: \"t\",\n          value: texture\n        }\n      },\n      vertexShader: Component_1.Shaders.perspectiveDistortedCurtain.vertex\n    };\n    return materialParameters;\n  };\n\n  MeshFactory.prototype._createDistortedPlaneMaterialParameters = function (transform, texture) {\n    var materialParameters = {\n      depthWrite: false,\n      fragmentShader: Component_1.Shaders.perspectiveDistorted.fragment,\n      side: THREE.DoubleSide,\n      transparent: true,\n      uniforms: {\n        opacity: {\n          type: \"f\",\n          value: 1\n        },\n        projectorMat: {\n          type: \"m4\",\n          value: transform.projectorMatrix()\n        },\n        projectorTex: {\n          type: \"t\",\n          value: texture\n        }\n      },\n      vertexShader: Component_1.Shaders.perspectiveDistorted.vertex\n    };\n    return materialParameters;\n  };\n\n  MeshFactory.prototype._createTexture = function (image) {\n    var texture = new THREE.Texture(image);\n    texture.minFilter = THREE.LinearFilter;\n    texture.needsUpdate = true;\n    return texture;\n  };\n\n  MeshFactory.prototype._useMesh = function (transform, node) {\n    return node.mesh.vertices.length && transform.hasValidScale;\n  };\n\n  MeshFactory.prototype._getImageSphereGeo = function (transform, node) {\n    var t = new THREE.Matrix4().getInverse(transform.srt); // push everything at least 5 meters in front of the camera\n\n    var minZ = 5.0 * transform.scale;\n    var maxZ = this._imageSphereRadius * transform.scale;\n    var vertices = node.mesh.vertices;\n    var numVertices = vertices.length / 3;\n    var positions = new Float32Array(vertices.length);\n\n    for (var i = 0; i < numVertices; ++i) {\n      var index = 3 * i;\n      var x = vertices[index + 0];\n      var y = vertices[index + 1];\n      var z = vertices[index + 2];\n      var l = Math.sqrt(x * x + y * y + z * z);\n      var boundedL = Math.max(minZ, Math.min(l, maxZ));\n      var factor = boundedL / l;\n      var p = new THREE.Vector3(x * factor, y * factor, z * factor);\n      p.applyMatrix4(t);\n      positions[index + 0] = p.x;\n      positions[index + 1] = p.y;\n      positions[index + 2] = p.z;\n    }\n\n    var faces = node.mesh.faces;\n    var indices = new Uint16Array(faces.length);\n\n    for (var i = 0; i < faces.length; ++i) {\n      indices[i] = faces[i];\n    }\n\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    geometry.setIndex(new THREE.BufferAttribute(indices, 1));\n    return geometry;\n  };\n\n  MeshFactory.prototype._getImagePlaneGeo = function (transform, node) {\n    var undistortionMarginFactor = 3;\n    var t = new THREE.Matrix4().getInverse(transform.srt); // push everything at least 5 meters in front of the camera\n\n    var minZ = 5.0 * transform.scale;\n    var maxZ = this._imagePlaneDepth * transform.scale;\n    var vertices = node.mesh.vertices;\n    var numVertices = vertices.length / 3;\n    var positions = new Float32Array(vertices.length);\n\n    for (var i = 0; i < numVertices; ++i) {\n      var index = 3 * i;\n      var x = vertices[index + 0];\n      var y = vertices[index + 1];\n      var z = vertices[index + 2];\n\n      if (i < 4) {\n        x *= undistortionMarginFactor;\n        y *= undistortionMarginFactor;\n      }\n\n      var boundedZ = Math.max(minZ, Math.min(z, maxZ));\n      var factor = boundedZ / z;\n      var p = new THREE.Vector3(x * factor, y * factor, boundedZ);\n      p.applyMatrix4(t);\n      positions[index + 0] = p.x;\n      positions[index + 1] = p.y;\n      positions[index + 2] = p.z;\n    }\n\n    var faces = node.mesh.faces;\n    var indices = new Uint16Array(faces.length);\n\n    for (var i = 0; i < faces.length; ++i) {\n      indices[i] = faces[i];\n    }\n\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    geometry.setIndex(new THREE.BufferAttribute(indices, 1));\n    return geometry;\n  };\n\n  MeshFactory.prototype._getImagePlaneGeoFisheye = function (transform, node) {\n    var t = new THREE.Matrix4().getInverse(transform.srt); // push everything at least 5 meters in front of the camera\n\n    var minZ = 5.0 * transform.scale;\n    var maxZ = this._imagePlaneDepth * transform.scale;\n    var vertices = node.mesh.vertices;\n    var numVertices = vertices.length / 3;\n    var positions = new Float32Array(vertices.length);\n\n    for (var i = 0; i < numVertices; ++i) {\n      var index = 3 * i;\n      var x = vertices[index + 0];\n      var y = vertices[index + 1];\n      var z = vertices[index + 2];\n      var l = Math.sqrt(x * x + y * y + z * z);\n      var boundedL = Math.max(minZ, Math.min(l, maxZ));\n      var factor = boundedL / l;\n      var p = new THREE.Vector3(x * factor, y * factor, z * factor);\n      p.applyMatrix4(t);\n      positions[index + 0] = p.x;\n      positions[index + 1] = p.y;\n      positions[index + 2] = p.z;\n    }\n\n    var faces = node.mesh.faces;\n    var indices = new Uint16Array(faces.length);\n\n    for (var i = 0; i < faces.length; ++i) {\n      indices[i] = faces[i];\n    }\n\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    geometry.setIndex(new THREE.BufferAttribute(indices, 1));\n    return geometry;\n  };\n\n  MeshFactory.prototype._getFlatImageSphereGeo = function (transform) {\n    var gpano = transform.gpano;\n    var phiStart = 2 * Math.PI * gpano.CroppedAreaLeftPixels / gpano.FullPanoWidthPixels;\n    var phiLength = 2 * Math.PI * gpano.CroppedAreaImageWidthPixels / gpano.FullPanoWidthPixels;\n    var thetaStart = Math.PI * (gpano.FullPanoHeightPixels - gpano.CroppedAreaImageHeightPixels - gpano.CroppedAreaTopPixels) / gpano.FullPanoHeightPixels;\n    var thetaLength = Math.PI * gpano.CroppedAreaImageHeightPixels / gpano.FullPanoHeightPixels;\n    var geometry = new THREE.SphereGeometry(this._imageSphereRadius, 20, 40, phiStart - Math.PI / 2, phiLength, thetaStart, thetaLength);\n    geometry.applyMatrix(new THREE.Matrix4().getInverse(transform.rt));\n    return geometry;\n  };\n\n  MeshFactory.prototype._getRegularFlatImagePlaneGeo = function (transform) {\n    var width = transform.width;\n    var height = transform.height;\n    var size = Math.max(width, height);\n    var dx = width / 2.0 / size;\n    var dy = height / 2.0 / size;\n    return this._getFlatImagePlaneGeo(transform, dx, dy);\n  };\n\n  MeshFactory.prototype._getFlatImagePlaneGeo = function (transform, dx, dy) {\n    var vertices = [];\n    vertices.push(transform.unprojectSfM([-dx, -dy], this._imagePlaneDepth));\n    vertices.push(transform.unprojectSfM([dx, -dy], this._imagePlaneDepth));\n    vertices.push(transform.unprojectSfM([dx, dy], this._imagePlaneDepth));\n    vertices.push(transform.unprojectSfM([-dx, dy], this._imagePlaneDepth));\n    return this._createFlatGeometry(vertices);\n  };\n\n  MeshFactory.prototype._getRegularFlatImagePlaneGeoFisheye = function (transform) {\n    var width = transform.width;\n    var height = transform.height;\n    var size = Math.max(width, height);\n    var dx = width / 2.0 / size;\n    var dy = height / 2.0 / size;\n    return this._getFlatImagePlaneGeoFisheye(transform, dx, dy);\n  };\n\n  MeshFactory.prototype._getFlatImagePlaneGeoFisheye = function (transform, dx, dy) {\n    var vertices = [];\n    vertices.push(transform.unprojectSfM([-dx, -dy], this._imagePlaneDepth));\n    vertices.push(transform.unprojectSfM([dx, -dy], this._imagePlaneDepth));\n    vertices.push(transform.unprojectSfM([dx, dy], this._imagePlaneDepth));\n    vertices.push(transform.unprojectSfM([-dx, dy], this._imagePlaneDepth));\n    return this._createFlatGeometry(vertices);\n  };\n\n  MeshFactory.prototype._getFlatImagePlaneGeoFromBasic = function (transform, basicX0, basicX1, basicY0, basicY1) {\n    var vertices = [];\n    vertices.push(transform.unprojectBasic([basicX0, basicY0], this._imagePlaneDepth));\n    vertices.push(transform.unprojectBasic([basicX1, basicY0], this._imagePlaneDepth));\n    vertices.push(transform.unprojectBasic([basicX1, basicY1], this._imagePlaneDepth));\n    vertices.push(transform.unprojectBasic([basicX0, basicY1], this._imagePlaneDepth));\n    return this._createFlatGeometry(vertices);\n  };\n\n  MeshFactory.prototype._createFlatGeometry = function (vertices) {\n    var positions = new Float32Array(12);\n\n    for (var i = 0; i < vertices.length; i++) {\n      var index = 3 * i;\n      positions[index + 0] = vertices[i][0];\n      positions[index + 1] = vertices[i][1];\n      positions[index + 2] = vertices[i][2];\n    }\n\n    var indices = new Uint16Array(6);\n    indices[0] = 0;\n    indices[1] = 1;\n    indices[2] = 3;\n    indices[3] = 1;\n    indices[4] = 2;\n    indices[5] = 3;\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    geometry.setIndex(new THREE.BufferAttribute(indices, 1));\n    return geometry;\n  };\n\n  return MeshFactory;\n}();\n\nexports.MeshFactory = MeshFactory;\nexports.default = MeshFactory;\n\n//# sourceURL=webpack://Mapillary/./src/component/utils/MeshFactory.ts?");

/***/ }),

/***/ "./src/component/utils/MeshScene.ts":
/*!******************************************!*\
  !*** ./src/component/utils/MeshScene.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar MeshScene =\n/** @class */\nfunction () {\n  function MeshScene() {\n    this._planes = {};\n    this._planesOld = {};\n    this._planesPeriphery = {};\n    this._scene = new THREE.Scene();\n    this._sceneOld = new THREE.Scene();\n    this._scenePeriphery = new THREE.Scene();\n  }\n\n  Object.defineProperty(MeshScene.prototype, \"planes\", {\n    get: function get() {\n      return this._planes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MeshScene.prototype, \"planesOld\", {\n    get: function get() {\n      return this._planesOld;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MeshScene.prototype, \"planesPeriphery\", {\n    get: function get() {\n      return this._planesPeriphery;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MeshScene.prototype, \"scene\", {\n    get: function get() {\n      return this._scene;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MeshScene.prototype, \"sceneOld\", {\n    get: function get() {\n      return this._sceneOld;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MeshScene.prototype, \"scenePeriphery\", {\n    get: function get() {\n      return this._scenePeriphery;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MeshScene.prototype.updateImagePlanes = function (planes) {\n    this._dispose(this._planesOld, this.sceneOld);\n\n    for (var key in this._planes) {\n      if (!this._planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = this._planes[key];\n\n      this._scene.remove(plane);\n\n      this._sceneOld.add(plane);\n    }\n\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      this._scene.add(planes[key]);\n    }\n\n    this._planesOld = this._planes;\n    this._planes = planes;\n  };\n\n  MeshScene.prototype.addImagePlanes = function (planes) {\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n\n      this._scene.add(plane);\n\n      this._planes[key] = plane;\n    }\n  };\n\n  MeshScene.prototype.addImagePlanesOld = function (planes) {\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n\n      this._sceneOld.add(plane);\n\n      this._planesOld[key] = plane;\n    }\n  };\n\n  MeshScene.prototype.setImagePlanes = function (planes) {\n    this._clear();\n\n    this.addImagePlanes(planes);\n  };\n\n  MeshScene.prototype.addPeripheryPlanes = function (planes) {\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n\n      this._scenePeriphery.add(plane);\n\n      this._planesPeriphery[key] = plane;\n    }\n  };\n\n  MeshScene.prototype.setPeripheryPlanes = function (planes) {\n    this._clearPeriphery();\n\n    this.addPeripheryPlanes(planes);\n  };\n\n  MeshScene.prototype.setImagePlanesOld = function (planes) {\n    this._clearOld();\n\n    this.addImagePlanesOld(planes);\n  };\n\n  MeshScene.prototype.clear = function () {\n    this._clear();\n\n    this._clearOld();\n  };\n\n  MeshScene.prototype._clear = function () {\n    this._dispose(this._planes, this._scene);\n\n    this._planes = {};\n  };\n\n  MeshScene.prototype._clearOld = function () {\n    this._dispose(this._planesOld, this._sceneOld);\n\n    this._planesOld = {};\n  };\n\n  MeshScene.prototype._clearPeriphery = function () {\n    this._dispose(this._planesPeriphery, this._scenePeriphery);\n\n    this._planesPeriphery = {};\n  };\n\n  MeshScene.prototype._dispose = function (planes, scene) {\n    for (var key in planes) {\n      if (!planes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var plane = planes[key];\n      scene.remove(plane);\n      plane.geometry.dispose();\n      plane.material.dispose();\n      var texture = plane.material.uniforms.projectorTex.value;\n\n      if (texture != null) {\n        texture.dispose();\n      }\n    }\n  };\n\n  return MeshScene;\n}();\n\nexports.MeshScene = MeshScene;\nexports.default = MeshScene;\n\n//# sourceURL=webpack://Mapillary/./src/component/utils/MeshScene.ts?");

/***/ }),

/***/ "./src/component/utils/MouseOperator.ts":
/*!**********************************************!*\
  !*** ./src/component/utils/MouseOperator.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar MouseOperator =\n/** @class */\nfunction () {\n  function MouseOperator() {}\n\n  MouseOperator.filteredPairwiseMouseDrag$ = function (name, mouseService) {\n    return mouseService.filtered$(name, mouseService.mouseDragStart$).pipe(operators_1.switchMap(function (mouseDragStart) {\n      var mouseDragging$ = rxjs_1.concat(rxjs_1.of(mouseDragStart), mouseService.filtered$(name, mouseService.mouseDrag$));\n      var mouseDragEnd$ = mouseService.filtered$(name, mouseService.mouseDragEnd$).pipe(operators_1.map(function () {\n        return null;\n      }));\n      return rxjs_1.merge(mouseDragging$, mouseDragEnd$).pipe(operators_1.takeWhile(function (e) {\n        return !!e;\n      }), operators_1.startWith(null));\n    }), operators_1.pairwise(), operators_1.filter(function (pair) {\n      return pair[0] != null && pair[1] != null;\n    }));\n  };\n\n  return MouseOperator;\n}();\n\nexports.MouseOperator = MouseOperator;\nexports.default = MouseOperator;\n\n//# sourceURL=webpack://Mapillary/./src/component/utils/MouseOperator.ts?");

/***/ }),

/***/ "./src/component/zoom/ZoomComponent.ts":
/*!*********************************************!*\
  !*** ./src/component/zoom/ZoomComponent.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar Component_1 = __webpack_require__(/*! ../../Component */ \"./src/Component.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n\nvar State_1 = __webpack_require__(/*! ../../State */ \"./src/State.ts\");\n\nvar ComponentSize_1 = __webpack_require__(/*! ../utils/ComponentSize */ \"./src/component/utils/ComponentSize.ts\");\n/**\n * @class ZoomComponent\n *\n * @classdesc Component rendering UI elements used for zooming.\n *\n * @example\n * ```\n * var viewer = new Mapillary.Viewer(\n *     \"<element-id>\",\n *     \"<client-id>\",\n *     \"<my key>\");\n *\n * var zoomComponent = viewer.getComponent(\"zoom\");\n * zoomComponent.configure({ size: Mapillary.ComponentSize.Small });\n * ```\n */\n\n\nvar ZoomComponent =\n/** @class */\nfunction (_super) {\n  __extends(ZoomComponent, _super);\n\n  function ZoomComponent(name, container, navigator) {\n    var _this = _super.call(this, name, container, navigator) || this;\n\n    _this._viewportCoords = new Geo_1.ViewportCoords();\n    _this._zoomDelta$ = new rxjs_1.Subject();\n    return _this;\n  }\n\n  ZoomComponent.prototype._activate = function () {\n    var _this = this;\n\n    this._renderSubscription = rxjs_1.combineLatest(this._navigator.stateService.currentState$, this._navigator.stateService.state$, this._configuration$, this._container.renderService.size$).pipe(operators_1.map(function (_a) {\n      var frame = _a[0],\n          state = _a[1],\n          configuration = _a[2],\n          size = _a[3];\n      var zoom = frame.state.zoom;\n      var zoomInIcon = vd.h(\"div.ZoomInIcon\", []);\n      var zoomInButton = zoom >= 3 || state === State_1.State.Waiting ? vd.h(\"div.ZoomInButtonDisabled\", [zoomInIcon]) : vd.h(\"div.ZoomInButton\", {\n        onclick: function onclick() {\n          _this._zoomDelta$.next(1);\n        }\n      }, [zoomInIcon]);\n      var zoomOutIcon = vd.h(\"div.ZoomOutIcon\", []);\n      var zoomOutButton = zoom <= 0 || state === State_1.State.Waiting ? vd.h(\"div.ZoomOutButtonDisabled\", [zoomOutIcon]) : vd.h(\"div.ZoomOutButton\", {\n        onclick: function onclick() {\n          _this._zoomDelta$.next(-1);\n        }\n      }, [zoomOutIcon]);\n      var compact = configuration.size === ComponentSize_1.default.Small || configuration.size === ComponentSize_1.default.Automatic && size.width < 640 ? \".ZoomCompact\" : \"\";\n      return {\n        name: _this._name,\n        vnode: vd.h(\"div.ZoomContainer\" + compact, {\n          oncontextmenu: function oncontextmenu(event) {\n            event.preventDefault();\n          }\n        }, [zoomInButton, zoomOutButton])\n      };\n    })).subscribe(this._container.domRenderer.render$);\n    this._zoomSubscription = this._zoomDelta$.pipe(operators_1.withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$)).subscribe(function (_a) {\n      var zoomDelta = _a[0],\n          render = _a[1],\n          transform = _a[2];\n\n      var unprojected = _this._viewportCoords.unprojectFromViewport(0, 0, render.perspective);\n\n      var reference = transform.projectBasic(unprojected.toArray());\n\n      _this._navigator.stateService.zoomIn(zoomDelta, reference);\n    });\n  };\n\n  ZoomComponent.prototype._deactivate = function () {\n    this._renderSubscription.unsubscribe();\n\n    this._zoomSubscription.unsubscribe();\n  };\n\n  ZoomComponent.prototype._getDefaultConfiguration = function () {\n    return {\n      size: ComponentSize_1.default.Automatic\n    };\n  };\n\n  ZoomComponent.componentName = \"zoom\";\n  return ZoomComponent;\n}(Component_1.Component);\n\nexports.ZoomComponent = ZoomComponent;\nComponent_1.ComponentService.register(ZoomComponent);\nexports.default = ZoomComponent;\n\n//# sourceURL=webpack://Mapillary/./src/component/zoom/ZoomComponent.ts?");

/***/ }),

/***/ "./src/error/AbortMapillaryError.ts":
/*!******************************************!*\
  !*** ./src/error/AbortMapillaryError.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar MapillaryError_1 = __webpack_require__(/*! ./MapillaryError */ \"./src/error/MapillaryError.ts\");\n/**\n * @class AbortMapillaryError\n *\n * @classdesc Error thrown when a move to request has been\n * aborted before completing because of a subsequent request.\n */\n\n\nvar AbortMapillaryError =\n/** @class */\nfunction (_super) {\n  __extends(AbortMapillaryError, _super);\n\n  function AbortMapillaryError(message) {\n    var _this = _super.call(this, message != null ? message : \"The request was aborted.\") || this;\n\n    Object.setPrototypeOf(_this, AbortMapillaryError.prototype);\n    _this.name = \"AbortMapillaryError\";\n    return _this;\n  }\n\n  return AbortMapillaryError;\n}(MapillaryError_1.MapillaryError);\n\nexports.AbortMapillaryError = AbortMapillaryError;\nexports.default = AbortMapillaryError;\n\n//# sourceURL=webpack://Mapillary/./src/error/AbortMapillaryError.ts?");

/***/ }),

/***/ "./src/error/ArgumentMapillaryError.ts":
/*!*********************************************!*\
  !*** ./src/error/ArgumentMapillaryError.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar MapillaryError_1 = __webpack_require__(/*! ./MapillaryError */ \"./src/error/MapillaryError.ts\");\n\nvar ArgumentMapillaryError =\n/** @class */\nfunction (_super) {\n  __extends(ArgumentMapillaryError, _super);\n\n  function ArgumentMapillaryError(message) {\n    var _this = _super.call(this, message != null ? message : \"The argument is not valid.\") || this;\n\n    Object.setPrototypeOf(_this, ArgumentMapillaryError.prototype);\n    _this.name = \"ArgumentMapillaryError\";\n    return _this;\n  }\n\n  return ArgumentMapillaryError;\n}(MapillaryError_1.MapillaryError);\n\nexports.ArgumentMapillaryError = ArgumentMapillaryError;\nexports.default = ArgumentMapillaryError;\n\n//# sourceURL=webpack://Mapillary/./src/error/ArgumentMapillaryError.ts?");

/***/ }),

/***/ "./src/error/GraphMapillaryError.ts":
/*!******************************************!*\
  !*** ./src/error/GraphMapillaryError.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar MapillaryError_1 = __webpack_require__(/*! ./MapillaryError */ \"./src/error/MapillaryError.ts\");\n\nvar GraphMapillaryError =\n/** @class */\nfunction (_super) {\n  __extends(GraphMapillaryError, _super);\n\n  function GraphMapillaryError(message) {\n    var _this = _super.call(this, message) || this;\n\n    Object.setPrototypeOf(_this, GraphMapillaryError.prototype);\n    _this.name = \"GraphMapillaryError\";\n    return _this;\n  }\n\n  return GraphMapillaryError;\n}(MapillaryError_1.MapillaryError);\n\nexports.GraphMapillaryError = GraphMapillaryError;\nexports.default = GraphMapillaryError;\n\n//# sourceURL=webpack://Mapillary/./src/error/GraphMapillaryError.ts?");

/***/ }),

/***/ "./src/error/MapillaryError.ts":
/*!*************************************!*\
  !*** ./src/error/MapillaryError.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar MapillaryError =\n/** @class */\nfunction (_super) {\n  __extends(MapillaryError, _super);\n\n  function MapillaryError(message) {\n    var _this = _super.call(this, message) || this;\n\n    Object.setPrototypeOf(_this, MapillaryError.prototype);\n    _this.name = \"MapillaryError\";\n    return _this;\n  }\n\n  return MapillaryError;\n}(Error);\n\nexports.MapillaryError = MapillaryError;\nexports.default = MapillaryError;\n\n//# sourceURL=webpack://Mapillary/./src/error/MapillaryError.ts?");

/***/ }),

/***/ "./src/geo/Camera.ts":
/*!***************************!*\
  !*** ./src/geo/Camera.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n/**\n * @class Camera\n *\n * @classdesc Holds information about a camera.\n */\n\n\nvar Camera =\n/** @class */\nfunction () {\n  /**\n   * Create a new camera instance.\n   * @param {Transform} [transform] - Optional transform instance.\n   */\n  function Camera(transform) {\n    if (transform != null) {\n      this._position = new THREE.Vector3().fromArray(transform.unprojectSfM([0, 0], 0));\n      this._lookat = new THREE.Vector3().fromArray(transform.unprojectSfM([0, 0], 10));\n      this._up = transform.upVector();\n      this._focal = this._getFocal(transform);\n    } else {\n      this._position = new THREE.Vector3(0, 0, 0);\n      this._lookat = new THREE.Vector3(0, 0, 1);\n      this._up = new THREE.Vector3(0, -1, 0);\n      this._focal = 1;\n    }\n  }\n\n  Object.defineProperty(Camera.prototype, \"position\", {\n    /**\n     * Get position.\n     * @returns {THREE.Vector3} The position vector.\n     */\n    get: function get() {\n      return this._position;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Camera.prototype, \"lookat\", {\n    /**\n     * Get lookat.\n     * @returns {THREE.Vector3} The lookat vector.\n     */\n    get: function get() {\n      return this._lookat;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Camera.prototype, \"up\", {\n    /**\n     * Get up.\n     * @returns {THREE.Vector3} The up vector.\n     */\n    get: function get() {\n      return this._up;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Camera.prototype, \"focal\", {\n    /**\n     * Get focal.\n     * @returns {number} The focal length.\n     */\n    get: function get() {\n      return this._focal;\n    },\n\n    /**\n     * Set focal.\n     */\n    set: function set(value) {\n      this._focal = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Update this camera to the linearly interpolated value of two other cameras.\n   *\n   * @param {Camera} a - First camera.\n   * @param {Camera} b - Second camera.\n   * @param {number} alpha - Interpolation value on the interval [0, 1].\n   */\n\n  Camera.prototype.lerpCameras = function (a, b, alpha) {\n    this._position.subVectors(b.position, a.position).multiplyScalar(alpha).add(a.position);\n\n    this._lookat.subVectors(b.lookat, a.lookat).multiplyScalar(alpha).add(a.lookat);\n\n    this._up.subVectors(b.up, a.up).multiplyScalar(alpha).add(a.up);\n\n    this._focal = (1 - alpha) * a.focal + alpha * b.focal;\n  };\n  /**\n   * Copy the properties of another camera to this camera.\n   *\n   * @param {Camera} other - Another camera.\n   */\n\n\n  Camera.prototype.copy = function (other) {\n    this._position.copy(other.position);\n\n    this._lookat.copy(other.lookat);\n\n    this._up.copy(other.up);\n\n    this._focal = other.focal;\n  };\n  /**\n   * Clone this camera.\n   *\n   * @returns {Camera} A camera with cloned properties equal to this camera.\n   */\n\n\n  Camera.prototype.clone = function () {\n    var camera = new Camera();\n    camera.position.copy(this._position);\n    camera.lookat.copy(this._lookat);\n    camera.up.copy(this._up);\n    camera.focal = this._focal;\n    return camera;\n  };\n  /**\n   * Determine the distance between this camera and another camera.\n   *\n   * @param {Camera} other - Another camera.\n   * @returns {number} The distance between the cameras.\n   */\n\n\n  Camera.prototype.diff = function (other) {\n    var pd = this._position.distanceToSquared(other.position);\n\n    var ld = this._lookat.distanceToSquared(other.lookat);\n\n    var ud = this._up.distanceToSquared(other.up);\n\n    var fd = 100 * Math.abs(this._focal - other.focal);\n    return Math.max(pd, ld, ud, fd);\n  };\n  /**\n   * Get the focal length based on the transform.\n   *\n   * @description Returns the focal length of the transform if gpano info is not available.\n   * Returns a focal length corresponding to a vertical fov clamped to [45, 90] degrees based on\n   * the gpano information if available.\n   *\n   * @returns {number} Focal length.\n   */\n\n\n  Camera.prototype._getFocal = function (transform) {\n    if (transform.gpano == null) {\n      return transform.focal;\n    }\n\n    var vFov = Math.PI * transform.gpano.CroppedAreaImageHeightPixels / transform.gpano.FullPanoHeightPixels;\n    var focal = 0.5 / Math.tan(vFov / 2);\n    return Math.min(1 / (2 * (Math.sqrt(2) - 1)), Math.max(0.5, focal));\n  };\n\n  return Camera;\n}();\n\nexports.Camera = Camera;\n\n//# sourceURL=webpack://Mapillary/./src/geo/Camera.ts?");

/***/ }),

/***/ "./src/geo/Geo.ts":
/*!************************!*\
  !*** ./src/geo/Geo.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar Geo_1 = __webpack_require__(/*! ../Geo */ \"./src/Geo.ts\");\n\nvar geoCoords = new Geo_1.GeoCoords();\nvar spatial = new Geo_1.Spatial();\n\nfunction computeTranslation(position, rotation, reference) {\n  var C = geoCoords.geodeticToEnu(position.lat, position.lon, position.alt, reference.lat, reference.lon, reference.alt);\n  var RC = spatial.rotate(C, rotation);\n  var translation = [-RC.x, -RC.y, -RC.z];\n  return translation;\n}\n\nexports.computeTranslation = computeTranslation;\n\nfunction computeProjectedPoints(transform, basicVertices, basicDirections, pointsPerLine, viewportCoords) {\n  var basicPoints = [];\n\n  for (var side = 0; side < basicVertices.length; ++side) {\n    var v = basicVertices[side];\n    var d = basicDirections[side];\n\n    for (var i = 0; i <= pointsPerLine; ++i) {\n      basicPoints.push([v[0] + d[0] * i / pointsPerLine, v[1] + d[1] * i / pointsPerLine]);\n    }\n  }\n\n  var camera = new THREE.Camera();\n  camera.up.copy(transform.upVector());\n  camera.position.copy(new THREE.Vector3().fromArray(transform.unprojectSfM([0, 0], 0)));\n  camera.lookAt(new THREE.Vector3().fromArray(transform.unprojectSfM([0, 0], 10)));\n  camera.updateMatrix();\n  camera.updateMatrixWorld(true);\n  var projectedPoints = basicPoints.map(function (basicPoint) {\n    var worldPoint = transform.unprojectBasic(basicPoint, 10000);\n    var cameraPoint = viewportCoords.worldToCamera(worldPoint, camera);\n    return [Math.abs(cameraPoint[0] / cameraPoint[2]), Math.abs(cameraPoint[1] / cameraPoint[2])];\n  });\n  return projectedPoints;\n}\n\nexports.computeProjectedPoints = computeProjectedPoints;\n\n//# sourceURL=webpack://Mapillary/./src/geo/Geo.ts?");

/***/ }),

/***/ "./src/geo/GeoCoords.ts":
/*!******************************!*\
  !*** ./src/geo/GeoCoords.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @class GeoCoords\n *\n * @classdesc Converts coordinates between the geodetic (WGS84),\n * Earth-Centered, Earth-Fixed (ECEF) and local topocentric\n * East, North, Up (ENU) reference frames.\n *\n * The WGS84 has latitude (degrees), longitude (degrees) and\n * altitude (meters) values.\n *\n * The ECEF Z-axis pierces the north pole and the\n * XY-axis defines the equatorial plane. The X-axis extends\n * from the geocenter to the intersection of the Equator and\n * the Greenwich Meridian. All values in meters.\n *\n * The WGS84 parameters are:\n *\n * a = 6378137\n * b = a * (1 - f)\n * f = 1 / 298.257223563\n * e = Math.sqrt((a^2 - b^2) / a^2)\n * e' = Math.sqrt((a^2 - b^2) / b^2)\n *\n * The WGS84 to ECEF conversion is performed using the following:\n *\n * X = (N - h) * cos(phi) * cos(lambda)\n * Y = (N + h) * cos(phi) * sin(lambda)\n * Z = (b^2 * N / a^2 + h) * sin(phi)\n *\n * where\n *\n * phi = latitude\n * lambda = longitude\n * h = height above ellipsoid (altitude)\n * N = Radius of curvature (meters)\n *   = a / Math.sqrt(1 - e^2 * sin(phi)^2)\n *\n * The ECEF to WGS84 conversion is performed using the following:\n *\n * phi = arctan((Z + e'^2 * b * sin(theta)^3) / (p - e^2 * a * cos(theta)^3))\n * lambda = arctan(Y / X)\n * h = p / cos(phi) - N\n *\n * where\n *\n * p = Math.sqrt(X^2 + Y^2)\n * theta = arctan(Z * a / p * b)\n *\n * In the ENU reference frame the x-axis points to the\n * East, the y-axis to the North and the z-axis Up. All values\n * in meters.\n *\n * The ECEF to ENU conversion is performed using the following:\n *\n * | x |   |       -sin(lambda_r)                cos(lambda_r)             0      | | X - X_r |\n * | y | = | -sin(phi_r) * cos(lambda_r)  -sin(phi_r) * sin(lambda_r)  cos(phi_r) | | Y - Y_r |\n * | z |   |  cos(phi_r) * cos(lambda_r)   cos(phi_r) * sin(lambda_r)  sin(phi_r) | | Z - Z_r |\n *\n * where\n *\n * phi_r = latitude of reference\n * lambda_r = longitude of reference\n * X_r, Y_r, Z_r = ECEF coordinates of reference\n *\n * The ENU to ECEF conversion is performed by solving the above equation for X, Y, Z.\n *\n * WGS84 to ENU and ENU to WGS84 are two step conversions with ECEF calculated in\n * the first step for both conversions.\n */\n\nvar GeoCoords =\n/** @class */\nfunction () {\n  function GeoCoords() {\n    this._wgs84a = 6378137.0;\n    this._wgs84b = 6356752.31424518;\n  }\n  /**\n   * Convert coordinates from geodetic (WGS84) reference to local topocentric\n   * (ENU) reference.\n   *\n   * @param {number} lat Latitude in degrees.\n   * @param {number} lon Longitude in degrees.\n   * @param {number} alt Altitude in meters.\n   * @param {number} refLat Reference latitude in degrees.\n   * @param {number} refLon Reference longitude in degrees.\n   * @param {number} refAlt Reference altitude in meters.\n   * @returns {Array<number>} The x, y, z local topocentric ENU coordinates.\n   */\n\n\n  GeoCoords.prototype.geodeticToEnu = function (lat, lon, alt, refLat, refLon, refAlt) {\n    var ecef = this.geodeticToEcef(lat, lon, alt);\n    return this.ecefToEnu(ecef[0], ecef[1], ecef[2], refLat, refLon, refAlt);\n  };\n  /**\n   * Convert coordinates from local topocentric (ENU) reference to\n   * geodetic (WGS84) reference.\n   *\n   * @param {number} x Topocentric ENU coordinate in East direction.\n   * @param {number} y Topocentric ENU coordinate in North direction.\n   * @param {number} z Topocentric ENU coordinate in Up direction.\n   * @param {number} refLat Reference latitude in degrees.\n   * @param {number} refLon Reference longitude in degrees.\n   * @param {number} refAlt Reference altitude in meters.\n   * @returns {Array<number>} The latitude and longitude in degrees\n   *                          as well as altitude in meters.\n   */\n\n\n  GeoCoords.prototype.enuToGeodetic = function (x, y, z, refLat, refLon, refAlt) {\n    var ecef = this.enuToEcef(x, y, z, refLat, refLon, refAlt);\n    return this.ecefToGeodetic(ecef[0], ecef[1], ecef[2]);\n  };\n  /**\n   * Convert coordinates from Earth-Centered, Earth-Fixed (ECEF) reference\n   * to local topocentric (ENU) reference.\n   *\n   * @param {number} X ECEF X-value.\n   * @param {number} Y ECEF Y-value.\n   * @param {number} Z ECEF Z-value.\n   * @param {number} refLat Reference latitude in degrees.\n   * @param {number} refLon Reference longitude in degrees.\n   * @param {number} refAlt Reference altitude in meters.\n   * @returns {Array<number>} The x, y, z topocentric ENU coordinates in East, North\n   * and Up directions respectively.\n   */\n\n\n  GeoCoords.prototype.ecefToEnu = function (X, Y, Z, refLat, refLon, refAlt) {\n    var refEcef = this.geodeticToEcef(refLat, refLon, refAlt);\n    var V = [X - refEcef[0], Y - refEcef[1], Z - refEcef[2]];\n    refLat = refLat * Math.PI / 180.0;\n    refLon = refLon * Math.PI / 180.0;\n    var cosLat = Math.cos(refLat);\n    var sinLat = Math.sin(refLat);\n    var cosLon = Math.cos(refLon);\n    var sinLon = Math.sin(refLon);\n    var x = -sinLon * V[0] + cosLon * V[1];\n    var y = -sinLat * cosLon * V[0] - sinLat * sinLon * V[1] + cosLat * V[2];\n    var z = cosLat * cosLon * V[0] + cosLat * sinLon * V[1] + sinLat * V[2];\n    return [x, y, z];\n  };\n  /**\n   * Convert coordinates from local topocentric (ENU) reference\n   * to Earth-Centered, Earth-Fixed (ECEF) reference.\n   *\n   * @param {number} x Topocentric ENU coordinate in East direction.\n   * @param {number} y Topocentric ENU coordinate in North direction.\n   * @param {number} z Topocentric ENU coordinate in Up direction.\n   * @param {number} refLat Reference latitude in degrees.\n   * @param {number} refLon Reference longitude in degrees.\n   * @param {number} refAlt Reference altitude in meters.\n   * @returns {Array<number>} The X, Y, Z ECEF coordinates.\n   */\n\n\n  GeoCoords.prototype.enuToEcef = function (x, y, z, refLat, refLon, refAlt) {\n    var refEcef = this.geodeticToEcef(refLat, refLon, refAlt);\n    refLat = refLat * Math.PI / 180.0;\n    refLon = refLon * Math.PI / 180.0;\n    var cosLat = Math.cos(refLat);\n    var sinLat = Math.sin(refLat);\n    var cosLon = Math.cos(refLon);\n    var sinLon = Math.sin(refLon);\n    var X = -sinLon * x - sinLat * cosLon * y + cosLat * cosLon * z + refEcef[0];\n    var Y = cosLon * x - sinLat * sinLon * y + cosLat * sinLon * z + refEcef[1];\n    var Z = cosLat * y + sinLat * z + refEcef[2];\n    return [X, Y, Z];\n  };\n  /**\n   * Convert coordinates from geodetic reference (WGS84) to Earth-Centered,\n   * Earth-Fixed (ECEF) reference.\n   *\n   * @param {number} lat Latitude in degrees.\n   * @param {number} lon Longitude in degrees.\n   * @param {number} alt Altitude in meters.\n   * @returns {Array<number>} The X, Y, Z ECEF coordinates.\n   */\n\n\n  GeoCoords.prototype.geodeticToEcef = function (lat, lon, alt) {\n    var a = this._wgs84a;\n    var b = this._wgs84b;\n    lat = lat * Math.PI / 180.0;\n    lon = lon * Math.PI / 180.0;\n    var cosLat = Math.cos(lat);\n    var sinLat = Math.sin(lat);\n    var cosLon = Math.cos(lon);\n    var sinLon = Math.sin(lon);\n    var a2 = a * a;\n    var b2 = b * b;\n    var L = 1.0 / Math.sqrt(a2 * cosLat * cosLat + b2 * sinLat * sinLat);\n    var nhcl = (a2 * L + alt) * cosLat;\n    var X = nhcl * cosLon;\n    var Y = nhcl * sinLon;\n    var Z = (b2 * L + alt) * sinLat;\n    return [X, Y, Z];\n  };\n  /**\n   * Convert coordinates from Earth-Centered, Earth-Fixed (ECEF) reference\n   * to geodetic reference (WGS84).\n   *\n   * @param {number} X ECEF X-value.\n   * @param {number} Y ECEF Y-value.\n   * @param {number} Z ECEF Z-value.\n   * @returns {Array<number>} The latitude and longitude in degrees\n   *                          as well as altitude in meters.\n   */\n\n\n  GeoCoords.prototype.ecefToGeodetic = function (X, Y, Z) {\n    var a = this._wgs84a;\n    var b = this._wgs84b;\n    var a2 = a * a;\n    var b2 = b * b;\n    var a2mb2 = a2 - b2;\n    var ea = Math.sqrt(a2mb2 / a2);\n    var eb = Math.sqrt(a2mb2 / b2);\n    var p = Math.sqrt(X * X + Y * Y);\n    var theta = Math.atan2(Z * a, p * b);\n    var sinTheta = Math.sin(theta);\n    var cosTheta = Math.cos(theta);\n    var lon = Math.atan2(Y, X);\n    var lat = Math.atan2(Z + eb * eb * b * sinTheta * sinTheta * sinTheta, p - ea * ea * a * cosTheta * cosTheta * cosTheta);\n    var sinLat = Math.sin(lat);\n    var cosLat = Math.cos(lat);\n    var N = a / Math.sqrt(1 - ea * ea * sinLat * sinLat);\n    var alt = p / cosLat - N;\n    return [lat * 180.0 / Math.PI, lon * 180.0 / Math.PI, alt];\n  };\n\n  return GeoCoords;\n}();\n\nexports.GeoCoords = GeoCoords;\nexports.default = GeoCoords;\n\n//# sourceURL=webpack://Mapillary/./src/geo/GeoCoords.ts?");

/***/ }),

/***/ "./src/geo/Lines.ts":
/*!**************************!*\
  !*** ./src/geo/Lines.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction sign(n) {\n  return n > 0 ? 1 : n < 0 ? -1 : 0;\n}\n\nfunction colinearPointOnSegment(p, s) {\n  return p.x <= Math.max(s.p1.x, s.p2.x) && p.x >= Math.min(s.p1.x, s.p2.x) && p.y >= Math.max(s.p1.y, s.p2.y) && p.y >= Math.min(s.p1.y, s.p2.y);\n}\n\nfunction parallel(s1, s2) {\n  var ux = s1.p2.x - s1.p1.x;\n  var uy = s1.p2.y - s1.p1.y;\n  var vx = s2.p2.x - s2.p1.x;\n  var vy = s2.p2.y - s2.p1.y;\n  var cross = ux * vy - uy * vx;\n  var u2 = ux * ux + uy * uy;\n  var v2 = vx * vx + vy * vy;\n  var epsilon2 = 1e-10;\n  return cross * cross < epsilon2 * u2 * v2;\n}\n\nfunction tripletOrientation(p1, p2, p3) {\n  var orientation = (p2.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p2.x - p1.x);\n  return sign(orientation);\n}\n\nfunction segmentsIntersect(s1, s2) {\n  if (parallel(s1, s2)) {\n    return false;\n  }\n\n  var o1 = tripletOrientation(s1.p1, s1.p2, s2.p1);\n  var o2 = tripletOrientation(s1.p1, s1.p2, s2.p2);\n  var o3 = tripletOrientation(s2.p1, s2.p2, s1.p1);\n  var o4 = tripletOrientation(s2.p1, s2.p2, s1.p2);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  if (o1 === 0 && colinearPointOnSegment(s2.p1, s1)) {\n    return true;\n  }\n\n  if (o2 === 0 && colinearPointOnSegment(s2.p2, s1)) {\n    return true;\n  }\n\n  if (o3 === 0 && colinearPointOnSegment(s1.p1, s2)) {\n    return true;\n  }\n\n  if (o4 === 0 && colinearPointOnSegment(s1.p2, s2)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.segmentsIntersect = segmentsIntersect;\n\nfunction segmentIntersection(s1, s2) {\n  if (parallel(s1, s2)) {\n    return undefined;\n  }\n\n  var x1 = s1.p1.x;\n  var x2 = s1.p2.x;\n  var y1 = s1.p1.y;\n  var y2 = s1.p2.y;\n  var x3 = s2.p1.x;\n  var x4 = s2.p2.x;\n  var y3 = s2.p1.y;\n  var y4 = s2.p2.y;\n  var den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n  var xNum = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);\n  var yNum = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);\n  return {\n    x: xNum / den,\n    y: yNum / den\n  };\n}\n\nexports.segmentIntersection = segmentIntersection;\n\n//# sourceURL=webpack://Mapillary/./src/geo/Lines.ts?");

/***/ }),

/***/ "./src/geo/Spatial.ts":
/*!****************************!*\
  !*** ./src/geo/Spatial.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n/**\n * @class Spatial\n *\n * @classdesc Provides methods for scalar, vector and matrix calculations.\n */\n\n\nvar Spatial =\n/** @class */\nfunction () {\n  function Spatial() {\n    this._epsilon = 1e-9;\n  }\n  /**\n   * Converts azimuthal phi rotation (counter-clockwise with origin on X-axis) to\n   * bearing (clockwise with origin at north or Y-axis).\n   *\n   * @param {number} phi - Azimuthal phi angle in radians.\n   * @returns {number} Bearing in radians.\n   */\n\n\n  Spatial.prototype.azimuthalToBearing = function (phi) {\n    return -phi + Math.PI / 2;\n  };\n  /**\n   * Converts degrees to radians.\n   *\n   * @param {number} deg - Degrees.\n   * @returns {number} Radians.\n   */\n\n\n  Spatial.prototype.degToRad = function (deg) {\n    return Math.PI * deg / 180;\n  };\n  /**\n   * Converts radians to degrees.\n   *\n   * @param {number} rad - Radians.\n   * @returns {number} Degrees.\n   */\n\n\n  Spatial.prototype.radToDeg = function (rad) {\n    return 180 * rad / Math.PI;\n  };\n  /**\n   * Creates a rotation matrix from an angle-axis vector.\n   *\n   * @param {Array<number>} angleAxis - Angle-axis representation of a rotation.\n   * @returns {THREE.Matrix4} Rotation matrix.\n   */\n\n\n  Spatial.prototype.rotationMatrix = function (angleAxis) {\n    var axis = new THREE.Vector3(angleAxis[0], angleAxis[1], angleAxis[2]);\n    var angle = axis.length();\n\n    if (angle > 0) {\n      axis.normalize();\n    }\n\n    return new THREE.Matrix4().makeRotationAxis(axis, angle);\n  };\n  /**\n   * Rotates a vector according to a angle-axis rotation vector.\n   *\n   * @param {Array<number>} vector - Vector to rotate.\n   * @param {Array<number>} angleAxis - Angle-axis representation of a rotation.\n   * @returns {THREE.Vector3} Rotated vector.\n   */\n\n\n  Spatial.prototype.rotate = function (vector, angleAxis) {\n    var v = new THREE.Vector3(vector[0], vector[1], vector[2]);\n    var rotationMatrix = this.rotationMatrix(angleAxis);\n    v.applyMatrix4(rotationMatrix);\n    return v;\n  };\n  /**\n   * Calculates the optical center from a rotation vector\n   * on the angle-axis representation and a translation vector\n   * according to C = -R^T t.\n   *\n   * @param {Array<number>} rotation - Angle-axis representation of a rotation.\n   * @param {Array<number>} translation - Translation vector.\n   * @returns {THREE.Vector3} Optical center.\n   */\n\n\n  Spatial.prototype.opticalCenter = function (rotation, translation) {\n    var angleAxis = [-rotation[0], -rotation[1], -rotation[2]];\n    var vector = [-translation[0], -translation[1], -translation[2]];\n    return this.rotate(vector, angleAxis);\n  };\n  /**\n   * Calculates the viewing direction from a rotation vector\n   * on the angle-axis representation.\n   *\n   * @param {number[]} rotation - Angle-axis representation of a rotation.\n   * @returns {THREE.Vector3} Viewing direction.\n   */\n\n\n  Spatial.prototype.viewingDirection = function (rotation) {\n    var angleAxis = [-rotation[0], -rotation[1], -rotation[2]];\n    return this.rotate([0, 0, 1], angleAxis);\n  };\n  /**\n   * Wrap a number on the interval [min, max].\n   *\n   * @param {number} value - Value to wrap.\n   * @param {number} min - Lower endpoint of interval.\n   * @param {number} max - Upper endpoint of interval.\n   * @returns {number} The wrapped number.\n   */\n\n\n  Spatial.prototype.wrap = function (value, min, max) {\n    if (max < min) {\n      throw new Error(\"Invalid arguments: max must be larger than min.\");\n    }\n\n    var interval = max - min;\n\n    while (value > max || value < min) {\n      if (value > max) {\n        value = value - interval;\n      } else if (value < min) {\n        value = value + interval;\n      }\n    }\n\n    return value;\n  };\n  /**\n   * Wrap an angle on the interval [-Pi, Pi].\n   *\n   * @param {number} angle - Value to wrap.\n   * @returns {number} Wrapped angle.\n   */\n\n\n  Spatial.prototype.wrapAngle = function (angle) {\n    return this.wrap(angle, -Math.PI, Math.PI);\n  };\n  /**\n   * Limit the value to the interval [min, max] by changing the value to\n   * the nearest available one when it is outside the interval.\n   *\n   * @param {number} value - Value to clamp.\n   * @param {number} min - Minimum of the interval.\n   * @param {number} max - Maximum of the interval.\n   * @returns {number} Clamped value.\n   */\n\n\n  Spatial.prototype.clamp = function (value, min, max) {\n    if (value < min) {\n      return min;\n    }\n\n    if (value > max) {\n      return max;\n    }\n\n    return value;\n  };\n  /**\n   * Calculates the counter-clockwise angle from the first\n   * vector (x1, y1)^T to the second (x2, y2)^T.\n   *\n   * @param {number} x1 - X coordinate of first vector.\n   * @param {number} y1 - Y coordinate of first vector.\n   * @param {number} x2 - X coordinate of second vector.\n   * @param {number} y2 - Y coordinate of second vector.\n   * @returns {number} Counter clockwise angle between the vectors.\n   */\n\n\n  Spatial.prototype.angleBetweenVector2 = function (x1, y1, x2, y2) {\n    var angle = Math.atan2(y2, x2) - Math.atan2(y1, x1);\n    return this.wrapAngle(angle);\n  };\n  /**\n   * Calculates the minimum (absolute) angle change for rotation\n   * from one angle to another on the [-Pi, Pi] interval.\n   *\n   * @param {number} angle1 - Start angle.\n   * @param {number} angle2 - Destination angle.\n   * @returns {number} Absolute angle change between angles.\n   */\n\n\n  Spatial.prototype.angleDifference = function (angle1, angle2) {\n    var angle = angle2 - angle1;\n    return this.wrapAngle(angle);\n  };\n  /**\n   * Calculates the relative rotation angle between two\n   * angle-axis vectors.\n   *\n   * @param {number} rotation1 - First angle-axis vector.\n   * @param {number} rotation2 - Second angle-axis vector.\n   * @returns {number} Relative rotation angle.\n   */\n\n\n  Spatial.prototype.relativeRotationAngle = function (rotation1, rotation2) {\n    var R1T = this.rotationMatrix([-rotation1[0], -rotation1[1], -rotation1[2]]);\n    var R2 = this.rotationMatrix(rotation2);\n    var R = R1T.multiply(R2);\n    var elements = R.elements; // from Tr(R) = 1 + 2 * cos(theta)\n\n    var tr = elements[0] + elements[5] + elements[10];\n    var theta = Math.acos(Math.max(Math.min((tr - 1) / 2, 1), -1));\n    return theta;\n  };\n  /**\n   * Calculates the angle from a vector to a plane.\n   *\n   * @param {Array<number>} vector - The vector.\n   * @param {Array<number>} planeNormal - Normal of the plane.\n   * @returns {number} Angle from between plane and vector.\n   */\n\n\n  Spatial.prototype.angleToPlane = function (vector, planeNormal) {\n    var v = new THREE.Vector3().fromArray(vector);\n    var norm = v.length();\n\n    if (norm < this._epsilon) {\n      return 0;\n    }\n\n    var projection = v.dot(new THREE.Vector3().fromArray(planeNormal));\n    return Math.asin(projection / norm);\n  };\n\n  Spatial.prototype.azimuthal = function (direction, up) {\n    var directionVector = new THREE.Vector3().fromArray(direction);\n    var upVector = new THREE.Vector3().fromArray(up);\n    var upProjection = directionVector.clone().dot(upVector);\n    var planeProjection = directionVector.clone().sub(upVector.clone().multiplyScalar(upProjection));\n    return Math.atan2(planeProjection.y, planeProjection.x);\n  };\n  /**\n   * Calculates the distance between two coordinates\n   * (latitude longitude pairs) in meters according to\n   * the haversine formula.\n   *\n   * @param {number} lat1 - Latitude of the first coordinate in degrees.\n   * @param {number} lon1 - Longitude of the first coordinate in degrees.\n   * @param {number} lat2 - Latitude of the second coordinate in degrees.\n   * @param {number} lon2 - Longitude of the second coordinate in degrees.\n   * @returns {number} Distance between lat lon positions in meters.\n   */\n\n\n  Spatial.prototype.distanceFromLatLon = function (lat1, lon1, lat2, lon2) {\n    var r = 6371000;\n    var dLat = this.degToRad(lat2 - lat1);\n    var dLon = this.degToRad(lon2 - lon1);\n    var hav = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.degToRad(lat1)) * Math.cos(this.degToRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    var d = 2 * r * Math.atan2(Math.sqrt(hav), Math.sqrt(1 - hav));\n    return d;\n  };\n\n  return Spatial;\n}();\n\nexports.Spatial = Spatial;\nexports.default = Spatial;\n\n//# sourceURL=webpack://Mapillary/./src/geo/Spatial.ts?");

/***/ }),

/***/ "./src/geo/Transform.ts":
/*!******************************!*\
  !*** ./src/geo/Transform.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n/**\n * @class Transform\n *\n * @classdesc Class used for calculating coordinate transformations\n * and projections.\n */\n\n\nvar Transform =\n/** @class */\nfunction () {\n  /**\n   * Create a new transform instance.\n   * @param {number} orientation - Image orientation.\n   * @param {number} width - Image height.\n   * @param {number} height - Image width.\n   * @param {number} focal - Focal length.\n   * @param {number} scale - Atomic scale.\n   * @param {IGPano} gpano - Panorama properties.\n   * @param {Array<number>} rotation - Rotation vector in three dimensions.\n   * @param {Array<number>} translation - Translation vector in three dimensions.\n   * @param {HTMLImageElement} image - Image for fallback size calculations.\n   */\n  function Transform(orientation, width, height, focal, scale, gpano, rotation, translation, image, textureScale, ck1, ck2, cameraProjection) {\n    this._orientation = this._getValue(orientation, 1);\n    var imageWidth = image != null ? image.width : 4;\n    var imageHeight = image != null ? image.height : 3;\n    var keepOrientation = this._orientation < 5;\n    this._width = this._getValue(width, keepOrientation ? imageWidth : imageHeight);\n    this._height = this._getValue(height, keepOrientation ? imageHeight : imageWidth);\n    this._basicAspect = keepOrientation ? this._width / this._height : this._height / this._width;\n    this._basicWidth = keepOrientation ? width : height;\n    this._basicHeight = keepOrientation ? height : width;\n    this._focal = this._getValue(focal, 1);\n    this._scale = this._getValue(scale, 0);\n    this._gpano = gpano != null ? gpano : null;\n    this._rt = this._getRt(rotation, translation);\n    this._srt = this._getSrt(this._rt, this._scale);\n    this._basicRt = this._getBasicRt(this._rt, orientation);\n    this._textureScale = !!textureScale ? textureScale : [1, 1];\n    this._ck1 = !!ck1 ? ck1 : 0;\n    this._ck2 = !!ck2 ? ck2 : 0;\n    this._cameraProjection = !!cameraProjection ? cameraProjection : !!gpano ? \"equirectangular\" : \"perspective\";\n    this._radialPeak = this._getRadialPeak(this._ck1, this._ck2);\n  }\n\n  Object.defineProperty(Transform.prototype, \"ck1\", {\n    get: function get() {\n      return this._ck1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"ck2\", {\n    get: function get() {\n      return this._ck2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"cameraProjection\", {\n    get: function get() {\n      return this._cameraProjection;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"basicAspect\", {\n    /**\n     * Get basic aspect.\n     * @returns {number} The orientation adjusted aspect ratio.\n     */\n    get: function get() {\n      return this._basicAspect;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"basicHeight\", {\n    /**\n     * Get basic height.\n     *\n     * @description Does not fall back to node image height but\n     * uses original value from API so can be faulty.\n     *\n     * @returns {number} The height of the basic version image\n     * (adjusted for orientation).\n     */\n    get: function get() {\n      return this._basicHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"basicRt\", {\n    get: function get() {\n      return this._basicRt;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"basicWidth\", {\n    /**\n     * Get basic width.\n     *\n     * @description Does not fall back to node image width but\n     * uses original value from API so can be faulty.\n     *\n     * @returns {number} The width of the basic version image\n     * (adjusted for orientation).\n     */\n    get: function get() {\n      return this._basicWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"focal\", {\n    /**\n     * Get focal.\n     * @returns {number} The node focal length.\n     */\n    get: function get() {\n      return this._focal;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"fullPano\", {\n    /**\n     * Get fullPano.\n     *\n     * @returns {boolean} Value indicating whether the node is a complete\n     * 360 panorama.\n     */\n    get: function get() {\n      return this._gpano != null && this._gpano.CroppedAreaLeftPixels === 0 && this._gpano.CroppedAreaTopPixels === 0 && this._gpano.CroppedAreaImageWidthPixels === this._gpano.FullPanoWidthPixels && this._gpano.CroppedAreaImageHeightPixels === this._gpano.FullPanoHeightPixels;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"gpano\", {\n    /**\n     * Get gpano.\n     * @returns {number} The node gpano information.\n     */\n    get: function get() {\n      return this._gpano;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"height\", {\n    /**\n     * Get height.\n     *\n     * @description Falls back to the node image height if\n     * the API data is faulty.\n     *\n     * @returns {number} The orientation adjusted image height.\n     */\n    get: function get() {\n      return this._height;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"orientation\", {\n    /**\n     * Get orientation.\n     * @returns {number} The image orientation.\n     */\n    get: function get() {\n      return this._orientation;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"rt\", {\n    /**\n     * Get rt.\n     * @returns {THREE.Matrix4} The extrinsic camera matrix.\n     */\n    get: function get() {\n      return this._rt;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"srt\", {\n    /**\n     * Get srt.\n     * @returns {THREE.Matrix4} The scaled extrinsic camera matrix.\n     */\n    get: function get() {\n      return this._srt;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"scale\", {\n    /**\n     * Get scale.\n     * @returns {number} The node atomic reconstruction scale.\n     */\n    get: function get() {\n      return this._scale;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"hasValidScale\", {\n    /**\n     * Get has valid scale.\n     * @returns {boolean} Value indicating if the scale of the transform is valid.\n     */\n    get: function get() {\n      return this._scale > 1e-2 && this._scale < 50;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"radialPeak\", {\n    /**\n     * Get radial peak.\n     * @returns {number} Value indicating the radius where the radial\n     * undistortion function peaks.\n     */\n    get: function get() {\n      return this._radialPeak;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Transform.prototype, \"width\", {\n    /**\n     * Get width.\n     *\n     * @description Falls back to the node image width if\n     * the API data is faulty.\n     *\n     * @returns {number} The orientation adjusted image width.\n     */\n    get: function get() {\n      return this._width;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Calculate the up vector for the node transform.\n   *\n   * @returns {THREE.Vector3} Normalized and orientation adjusted up vector.\n   */\n\n  Transform.prototype.upVector = function () {\n    var rte = this._rt.elements;\n\n    switch (this._orientation) {\n      case 1:\n        return new THREE.Vector3(-rte[1], -rte[5], -rte[9]);\n\n      case 3:\n        return new THREE.Vector3(rte[1], rte[5], rte[9]);\n\n      case 6:\n        return new THREE.Vector3(-rte[0], -rte[4], -rte[8]);\n\n      case 8:\n        return new THREE.Vector3(rte[0], rte[4], rte[8]);\n\n      default:\n        return new THREE.Vector3(-rte[1], -rte[5], -rte[9]);\n    }\n  };\n  /**\n   * Calculate projector matrix for projecting 3D points to texture map\n   * coordinates (u and v).\n   *\n   * @returns {THREE.Matrix4} Projection matrix for 3D point to texture\n   * map coordinate calculations.\n   */\n\n\n  Transform.prototype.projectorMatrix = function () {\n    var projector = this._normalizedToTextureMatrix();\n\n    var f = this._focal;\n    var projection = new THREE.Matrix4().set(f, 0, 0, 0, 0, f, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0);\n    projector.multiply(projection);\n    projector.multiply(this._rt);\n    return projector;\n  };\n  /**\n   * Project 3D world coordinates to basic coordinates.\n   *\n   * @param {Array<number>} point3d - 3D world coordinates.\n   * @return {Array<number>} 2D basic coordinates.\n   */\n\n\n  Transform.prototype.projectBasic = function (point3d) {\n    var sfm = this.projectSfM(point3d);\n    return this._sfmToBasic(sfm);\n  };\n  /**\n   * Unproject basic coordinates to 3D world coordinates.\n   *\n   * @param {Array<number>} basic - 2D basic coordinates.\n   * @param {Array<number>} distance - Distance to unproject from camera center.\n   * @param {boolean} [depth] - Treat the distance value as depth from camera center.\n   *                            Only applicable for perspective images. Will be\n   *                            ignored for panoramas.\n   * @returns {Array<number>} Unprojected 3D world coordinates.\n   */\n\n\n  Transform.prototype.unprojectBasic = function (basic, distance, depth) {\n    var sfm = this._basicToSfm(basic);\n\n    return this.unprojectSfM(sfm, distance, depth);\n  };\n  /**\n   * Project 3D world coordinates to SfM coordinates.\n   *\n   * @param {Array<number>} point3d - 3D world coordinates.\n   * @return {Array<number>} 2D SfM coordinates.\n   */\n\n\n  Transform.prototype.projectSfM = function (point3d) {\n    var v = new THREE.Vector4(point3d[0], point3d[1], point3d[2], 1);\n    v.applyMatrix4(this._rt);\n    return this._bearingToSfm([v.x, v.y, v.z]);\n  };\n  /**\n   * Unproject SfM coordinates to a 3D world coordinates.\n   *\n   * @param {Array<number>} sfm - 2D SfM coordinates.\n   * @param {Array<number>} distance - Distance to unproject from camera center.\n   * @param {boolean} [depth] - Treat the distance value as depth from camera center.\n   *                            Only applicable for perspective images. Will be\n   *                            ignored for panoramas.\n   * @returns {Array<number>} Unprojected 3D world coordinates.\n   */\n\n\n  Transform.prototype.unprojectSfM = function (sfm, distance, depth) {\n    var bearing = this._sfmToBearing(sfm);\n\n    var v = depth && !this.gpano ? new THREE.Vector4(distance * bearing[0] / bearing[2], distance * bearing[1] / bearing[2], distance, 1) : new THREE.Vector4(distance * bearing[0], distance * bearing[1], distance * bearing[2], 1);\n    v.applyMatrix4(new THREE.Matrix4().getInverse(this._rt));\n    return [v.x / v.w, v.y / v.w, v.z / v.w];\n  };\n  /**\n   * Transform SfM coordinates to bearing vector (3D cartesian\n   * coordinates on the unit sphere).\n   *\n   * @param {Array<number>} sfm - 2D SfM coordinates.\n   * @returns {Array<number>} Bearing vector (3D cartesian coordinates\n   * on the unit sphere).\n   */\n\n\n  Transform.prototype._sfmToBearing = function (sfm) {\n    if (this._fullPano()) {\n      var lon = sfm[0] * 2 * Math.PI;\n      var lat = -sfm[1] * 2 * Math.PI;\n      var x = Math.cos(lat) * Math.sin(lon);\n      var y = -Math.sin(lat);\n      var z = Math.cos(lat) * Math.cos(lon);\n      return [x, y, z];\n    } else if (this._gpano) {\n      var size = Math.max(this.gpano.CroppedAreaImageWidthPixels, this.gpano.CroppedAreaImageHeightPixels);\n      var fullPanoPixel = [sfm[0] * size + this.gpano.CroppedAreaImageWidthPixels / 2 + this.gpano.CroppedAreaLeftPixels, sfm[1] * size + this.gpano.CroppedAreaImageHeightPixels / 2 + this.gpano.CroppedAreaTopPixels];\n      var lon = 2 * Math.PI * (fullPanoPixel[0] / this.gpano.FullPanoWidthPixels - 0.5);\n      var lat = -Math.PI * (fullPanoPixel[1] / this.gpano.FullPanoHeightPixels - 0.5);\n      var x = Math.cos(lat) * Math.sin(lon);\n      var y = -Math.sin(lat);\n      var z = Math.cos(lat) * Math.cos(lon);\n      return [x, y, z];\n    } else if (this._cameraProjection === \"fisheye\") {\n      var _a = [sfm[0] / this._focal, sfm[1] / this._focal],\n          dxn = _a[0],\n          dyn = _a[1];\n      var dTheta = Math.sqrt(dxn * dxn + dyn * dyn);\n\n      var d = this._distortionFromDistortedRadius(dTheta, this._ck1, this._ck2, this._radialPeak);\n\n      var theta = dTheta / d;\n      var z = Math.cos(theta);\n      var r = Math.sin(theta);\n      var x = r * dxn / dTheta;\n      var y = r * dyn / dTheta;\n      return [x, y, z];\n    } else {\n      var _b = [sfm[0] / this._focal, sfm[1] / this._focal],\n          dxn = _b[0],\n          dyn = _b[1];\n      var dr = Math.sqrt(dxn * dxn + dyn * dyn);\n\n      var d = this._distortionFromDistortedRadius(dr, this._ck1, this._ck2, this._radialPeak);\n\n      var xn = dxn / d;\n      var yn = dyn / d;\n      var v = new THREE.Vector3(xn, yn, 1);\n      v.normalize();\n      return [v.x, v.y, v.z];\n    }\n  };\n  /** Compute distortion given the distorted radius.\n   *\n   *  Solves for d in the equation\n   *    y = d(x, k1, k2) * x\n   * given the distorted radius, y.\n   */\n\n\n  Transform.prototype._distortionFromDistortedRadius = function (distortedRadius, k1, k2, radialPeak) {\n    var d = 1.0;\n\n    for (var i = 0; i < 10; i++) {\n      var radius = distortedRadius / d;\n\n      if (radius > radialPeak) {\n        radius = radialPeak;\n      }\n\n      d = 1 + k1 * Math.pow(radius, 2) + k2 * Math.pow(radius, 4);\n    }\n\n    return d;\n  };\n  /**\n   * Transform bearing vector (3D cartesian coordiantes on the unit sphere) to\n   * SfM coordinates.\n   *\n   * @param {Array<number>} bearing - Bearing vector (3D cartesian coordinates on the\n   * unit sphere).\n   * @returns {Array<number>} 2D SfM coordinates.\n   */\n\n\n  Transform.prototype._bearingToSfm = function (bearing) {\n    if (this._fullPano()) {\n      var x = bearing[0];\n      var y = bearing[1];\n      var z = bearing[2];\n      var lon = Math.atan2(x, z);\n      var lat = Math.atan2(-y, Math.sqrt(x * x + z * z));\n      return [lon / (2 * Math.PI), -lat / (2 * Math.PI)];\n    } else if (this._gpano) {\n      var x = bearing[0];\n      var y = bearing[1];\n      var z = bearing[2];\n      var lon = Math.atan2(x, z);\n      var lat = Math.atan2(-y, Math.sqrt(x * x + z * z));\n      var fullPanoPixel = [(lon / (2 * Math.PI) + 0.5) * this.gpano.FullPanoWidthPixels, (-lat / Math.PI + 0.5) * this.gpano.FullPanoHeightPixels];\n      var size = Math.max(this.gpano.CroppedAreaImageWidthPixels, this.gpano.CroppedAreaImageHeightPixels);\n      return [(fullPanoPixel[0] - this.gpano.CroppedAreaLeftPixels - this.gpano.CroppedAreaImageWidthPixels / 2) / size, (fullPanoPixel[1] - this.gpano.CroppedAreaTopPixels - this.gpano.CroppedAreaImageHeightPixels / 2) / size];\n    } else if (this._cameraProjection === \"fisheye\") {\n      if (bearing[2] > 0) {\n        var x = bearing[0],\n            y = bearing[1],\n            z = bearing[2];\n        var r = Math.sqrt(x * x + y * y);\n        var theta = Math.atan2(r, z);\n\n        if (theta > this._radialPeak) {\n          theta = this._radialPeak;\n        }\n\n        var distortion = 1.0 + Math.pow(theta, 2) * (this._ck1 + Math.pow(theta, 2) * this._ck2);\n\n        var s = this._focal * distortion * theta / r;\n        return [s * x, s * y];\n      } else {\n        return [bearing[0] < 0 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, bearing[1] < 0 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY];\n      }\n    } else {\n      if (bearing[2] > 0) {\n        var _a = [bearing[0] / bearing[2], bearing[1] / bearing[2]],\n            xn = _a[0],\n            yn = _a[1];\n        var r2 = xn * xn + yn * yn;\n        var rp2 = Math.pow(this._radialPeak, 2);\n\n        if (r2 > rp2) {\n          r2 = rp2;\n        }\n\n        var d = 1 + this._ck1 * r2 + this._ck2 * Math.pow(r2, 2);\n        return [this._focal * d * xn, this._focal * d * yn];\n      } else {\n        return [bearing[0] < 0 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, bearing[1] < 0 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY];\n      }\n    }\n  };\n  /**\n   * Convert basic coordinates to SfM coordinates.\n   *\n   * @param {Array<number>} basic - 2D basic coordinates.\n   * @returns {Array<number>} 2D SfM coordinates.\n   */\n\n\n  Transform.prototype._basicToSfm = function (basic) {\n    var rotatedX;\n    var rotatedY;\n\n    switch (this._orientation) {\n      case 1:\n        rotatedX = basic[0];\n        rotatedY = basic[1];\n        break;\n\n      case 3:\n        rotatedX = 1 - basic[0];\n        rotatedY = 1 - basic[1];\n        break;\n\n      case 6:\n        rotatedX = basic[1];\n        rotatedY = 1 - basic[0];\n        break;\n\n      case 8:\n        rotatedX = 1 - basic[1];\n        rotatedY = basic[0];\n        break;\n\n      default:\n        rotatedX = basic[0];\n        rotatedY = basic[1];\n        break;\n    }\n\n    var w = this._width;\n    var h = this._height;\n    var s = Math.max(w, h);\n    var sfmX = rotatedX * w / s - w / s / 2;\n    var sfmY = rotatedY * h / s - h / s / 2;\n    return [sfmX, sfmY];\n  };\n  /**\n   * Convert SfM coordinates to basic coordinates.\n   *\n   * @param {Array<number>} sfm - 2D SfM coordinates.\n   * @returns {Array<number>} 2D basic coordinates.\n   */\n\n\n  Transform.prototype._sfmToBasic = function (sfm) {\n    var w = this._width;\n    var h = this._height;\n    var s = Math.max(w, h);\n    var rotatedX = (sfm[0] + w / s / 2) / w * s;\n    var rotatedY = (sfm[1] + h / s / 2) / h * s;\n    var basicX;\n    var basicY;\n\n    switch (this._orientation) {\n      case 1:\n        basicX = rotatedX;\n        basicY = rotatedY;\n        break;\n\n      case 3:\n        basicX = 1 - rotatedX;\n        basicY = 1 - rotatedY;\n        break;\n\n      case 6:\n        basicX = 1 - rotatedY;\n        basicY = rotatedX;\n        break;\n\n      case 8:\n        basicX = rotatedY;\n        basicY = 1 - rotatedX;\n        break;\n\n      default:\n        basicX = rotatedX;\n        basicY = rotatedY;\n        break;\n    }\n\n    return [basicX, basicY];\n  };\n  /**\n   * Determines if the gpano information indicates a full panorama.\n   *\n   * @returns {boolean} Value determining if the gpano information indicates\n   * a full panorama.\n   */\n\n\n  Transform.prototype._fullPano = function () {\n    return this.gpano != null && this.gpano.CroppedAreaLeftPixels === 0 && this.gpano.CroppedAreaTopPixels === 0 && this.gpano.CroppedAreaImageWidthPixels === this.gpano.FullPanoWidthPixels && this.gpano.CroppedAreaImageHeightPixels === this.gpano.FullPanoHeightPixels;\n  };\n  /**\n   * Checks a value and returns it if it exists and is larger than 0.\n   * Fallbacks if it is null.\n   *\n   * @param {number} value - Value to check.\n   * @param {number} fallback - Value to fall back to.\n   * @returns {number} The value or its fallback value if it is not defined or negative.\n   */\n\n\n  Transform.prototype._getValue = function (value, fallback) {\n    return value != null && value > 0 ? value : fallback;\n  };\n  /**\n   * Creates the extrinsic camera matrix [ R | t ].\n   *\n   * @param {Array<number>} rotation - Rotation vector in angle axis representation.\n   * @param {Array<number>} translation - Translation vector.\n   * @returns {THREE.Matrix4} Extrisic camera matrix.\n   */\n\n\n  Transform.prototype._getRt = function (rotation, translation) {\n    var axis = new THREE.Vector3(rotation[0], rotation[1], rotation[2]);\n    var angle = axis.length();\n\n    if (angle > 0) {\n      axis.normalize();\n    }\n\n    var rt = new THREE.Matrix4();\n    rt.makeRotationAxis(axis, angle);\n    rt.setPosition(new THREE.Vector3(translation[0], translation[1], translation[2]));\n    return rt;\n  };\n  /**\n   * Calculates the scaled extrinsic camera matrix scale * [ R | t ].\n   *\n   * @param {THREE.Matrix4} rt - Extrisic camera matrix.\n   * @param {number} scale - Scale factor.\n   * @returns {THREE.Matrix4} Scaled extrisic camera matrix.\n   */\n\n\n  Transform.prototype._getSrt = function (rt, scale) {\n    var srt = rt.clone();\n    var elements = srt.elements;\n    elements[12] = scale * elements[12];\n    elements[13] = scale * elements[13];\n    elements[14] = scale * elements[14];\n    srt.scale(new THREE.Vector3(scale, scale, scale));\n    return srt;\n  };\n\n  Transform.prototype._getBasicRt = function (rt, orientation) {\n    var axis = new THREE.Vector3(0, 0, 1);\n    var angle = 0;\n\n    switch (orientation) {\n      case 3:\n        angle = Math.PI;\n        break;\n\n      case 6:\n        angle = Math.PI / 2;\n        break;\n\n      case 8:\n        angle = 3 * Math.PI / 2;\n        break;\n\n      default:\n        break;\n    }\n\n    return new THREE.Matrix4().makeRotationAxis(axis, angle).multiply(rt);\n  };\n\n  Transform.prototype._getRadialPeak = function (k1, k2) {\n    var a = 5 * k2;\n    var b = 3 * k1;\n    var c = 1;\n    var d = Math.pow(b, 2) - 4 * a * c;\n\n    if (d < 0) {\n      return undefined;\n    }\n\n    var root1 = (-b - Math.sqrt(d)) / 2 / a;\n    var root2 = (-b + Math.sqrt(d)) / 2 / a;\n    var minRoot = Math.min(root1, root2);\n    var maxRoot = Math.max(root1, root2);\n    return minRoot > 0 ? Math.sqrt(minRoot) : maxRoot > 0 ? Math.sqrt(maxRoot) : undefined;\n  };\n  /**\n   * Calculate a transformation matrix from normalized coordinates for\n   * texture map coordinates.\n   *\n   * @returns {THREE.Matrix4} Normalized coordinates to texture map\n   * coordinates transformation matrix.\n   */\n\n\n  Transform.prototype._normalizedToTextureMatrix = function () {\n    var size = Math.max(this._width, this._height);\n    var scaleX = this._orientation < 5 ? this._textureScale[0] : this._textureScale[1];\n    var scaleY = this._orientation < 5 ? this._textureScale[1] : this._textureScale[0];\n    var w = size / this._width * scaleX;\n    var h = size / this._height * scaleY;\n\n    switch (this._orientation) {\n      case 1:\n        return new THREE.Matrix4().set(w, 0, 0, 0.5, 0, -h, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1);\n\n      case 3:\n        return new THREE.Matrix4().set(-w, 0, 0, 0.5, 0, h, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1);\n\n      case 6:\n        return new THREE.Matrix4().set(0, -h, 0, 0.5, -w, 0, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1);\n\n      case 8:\n        return new THREE.Matrix4().set(0, h, 0, 0.5, w, 0, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1);\n\n      default:\n        return new THREE.Matrix4().set(w, 0, 0, 0.5, 0, -h, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1);\n    }\n  };\n\n  return Transform;\n}();\n\nexports.Transform = Transform;\n\n//# sourceURL=webpack://Mapillary/./src/geo/Transform.ts?");

/***/ }),

/***/ "./src/geo/ViewportCoords.ts":
/*!***********************************!*\
  !*** ./src/geo/ViewportCoords.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n/**\n * @class ViewportCoords\n *\n * @classdesc Provides methods for calculating 2D coordinate conversions\n * as well as 3D projection and unprojection.\n *\n * Basic coordinates are 2D coordinates on the [0, 1] interval and\n * have the origin point, (0, 0), at the top left corner and the\n * maximum value, (1, 1), at the bottom right corner of the original\n * image.\n *\n * Viewport coordinates are 2D coordinates on the [-1, 1] interval and\n * have the origin point in the center. The bottom left corner point is\n * (-1, -1) and the top right corner point is (1, 1).\n *\n * Canvas coordiantes are 2D pixel coordinates on the [0, canvasWidth] and\n * [0, canvasHeight] intervals. The origin point (0, 0) is in the top left\n * corner and the maximum value is (canvasWidth, canvasHeight) is in the\n * bottom right corner.\n *\n * 3D coordinates are in the topocentric world reference frame.\n */\n\n\nvar ViewportCoords =\n/** @class */\nfunction () {\n  function ViewportCoords() {\n    this._unprojectDepth = 200;\n  }\n  /**\n   * Convert basic coordinates to canvas coordinates.\n   *\n   * @description Transform origin and camera position needs to be the\n   * equal for reliable return value.\n   *\n   * @param {number} basicX - Basic X coordinate.\n   * @param {number} basicY - Basic Y coordinate.\n   * @param {HTMLElement} container - The viewer container.\n   * @param {Transform} transform - Transform of the node to unproject from.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 2D canvas coordinates.\n   */\n\n\n  ViewportCoords.prototype.basicToCanvas = function (basicX, basicY, container, transform, camera) {\n    var point3d = transform.unprojectBasic([basicX, basicY], this._unprojectDepth);\n    var canvas = this.projectToCanvas(point3d, container, camera);\n    return canvas;\n  };\n  /**\n   * Convert basic coordinates to canvas coordinates safely. If 3D point is\n   * behind camera null will be returned.\n   *\n   * @description Transform origin and camera position needs to be the\n   * equal for reliable return value.\n   *\n   * @param {number} basicX - Basic X coordinate.\n   * @param {number} basicY - Basic Y coordinate.\n   * @param {HTMLElement} container - The viewer container.\n   * @param {Transform} transform - Transform of the node to unproject from.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 2D canvas coordinates if the basic point represents a 3D point\n   * in front of the camera, otherwise null.\n   */\n\n\n  ViewportCoords.prototype.basicToCanvasSafe = function (basicX, basicY, container, transform, camera) {\n    var viewport = this.basicToViewportSafe(basicX, basicY, transform, camera);\n\n    if (viewport === null) {\n      return null;\n    }\n\n    var canvas = this.viewportToCanvas(viewport[0], viewport[1], container);\n    return canvas;\n  };\n  /**\n   * Convert basic coordinates to viewport coordinates.\n   *\n   * @description Transform origin and camera position needs to be the\n   * equal for reliable return value.\n   *\n   * @param {number} basicX - Basic X coordinate.\n   * @param {number} basicY - Basic Y coordinate.\n   * @param {Transform} transform - Transform of the node to unproject from.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 2D viewport coordinates.\n   */\n\n\n  ViewportCoords.prototype.basicToViewport = function (basicX, basicY, transform, camera) {\n    var point3d = transform.unprojectBasic([basicX, basicY], this._unprojectDepth);\n    var viewport = this.projectToViewport(point3d, camera);\n    return viewport;\n  };\n  /**\n   * Convert basic coordinates to viewport coordinates safely. If 3D point is\n   * behind camera null will be returned.\n   *\n   * @description Transform origin and camera position needs to be the\n   * equal for reliable return value.\n   *\n   * @param {number} basicX - Basic X coordinate.\n   * @param {number} basicY - Basic Y coordinate.\n   * @param {Transform} transform - Transform of the node to unproject from.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 2D viewport coordinates.\n   */\n\n\n  ViewportCoords.prototype.basicToViewportSafe = function (basicX, basicY, transform, camera) {\n    var point3d = transform.unprojectBasic([basicX, basicY], this._unprojectDepth);\n    var pointCamera = this.worldToCamera(point3d, camera);\n\n    if (pointCamera[2] > 0) {\n      return null;\n    }\n\n    var viewport = this.projectToViewport(point3d, camera);\n    return viewport;\n  };\n  /**\n   * Convert camera 3D coordinates to viewport coordinates.\n   *\n   * @param {number} pointCamera - 3D point in camera coordinate system.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 2D viewport coordinates.\n   */\n\n\n  ViewportCoords.prototype.cameraToViewport = function (pointCamera, camera) {\n    var viewport = new THREE.Vector3().fromArray(pointCamera).applyMatrix4(camera.projectionMatrix);\n    return [viewport.x, viewport.y];\n  };\n  /**\n   * Get canvas pixel position from event.\n   *\n   * @param {Event} event - Event containing clientX and clientY properties.\n   * @param {HTMLElement} element - HTML element.\n   * @returns {Array<number>} 2D canvas coordinates.\n   */\n\n\n  ViewportCoords.prototype.canvasPosition = function (event, element) {\n    var clientRect = element.getBoundingClientRect();\n    var canvasX = event.clientX - clientRect.left - element.clientLeft;\n    var canvasY = event.clientY - clientRect.top - element.clientTop;\n    return [canvasX, canvasY];\n  };\n  /**\n   * Convert canvas coordinates to basic coordinates.\n   *\n   * @description Transform origin and camera position needs to be the\n   * equal for reliable return value.\n   *\n   * @param {number} canvasX - Canvas X coordinate.\n   * @param {number} canvasY - Canvas Y coordinate.\n   * @param {HTMLElement} container - The viewer container.\n   * @param {Transform} transform - Transform of the node to unproject from.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 2D basic coordinates.\n   */\n\n\n  ViewportCoords.prototype.canvasToBasic = function (canvasX, canvasY, container, transform, camera) {\n    var point3d = this.unprojectFromCanvas(canvasX, canvasY, container, camera).toArray();\n    var basic = transform.projectBasic(point3d);\n    return basic;\n  };\n  /**\n   * Convert canvas coordinates to viewport coordinates.\n   *\n   * @param {number} canvasX - Canvas X coordinate.\n   * @param {number} canvasY - Canvas Y coordinate.\n   * @param {HTMLElement} container - The viewer container.\n   * @returns {Array<number>} 2D viewport coordinates.\n   */\n\n\n  ViewportCoords.prototype.canvasToViewport = function (canvasX, canvasY, container) {\n    var _a = this.containerToCanvas(container),\n        canvasWidth = _a[0],\n        canvasHeight = _a[1];\n\n    var viewportX = 2 * canvasX / canvasWidth - 1;\n    var viewportY = 1 - 2 * canvasY / canvasHeight;\n    return [viewportX, viewportY];\n  };\n  /**\n   * Determines the width and height of the container in canvas coordinates.\n   *\n   * @param {HTMLElement} container - The viewer container.\n   * @returns {Array<number>} 2D canvas coordinates.\n   */\n\n\n  ViewportCoords.prototype.containerToCanvas = function (container) {\n    return [container.offsetWidth, container.offsetHeight];\n  };\n  /**\n   * Determine basic distances from image to canvas corners.\n   *\n   * @description Transform origin and camera position needs to be the\n   * equal for reliable return value.\n   *\n   * Determines the smallest basic distance for every side of the canvas.\n   *\n   * @param {Transform} transform - Transform of the node to unproject from.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} Array of basic distances as [top, right, bottom, left].\n   */\n\n\n  ViewportCoords.prototype.getBasicDistances = function (transform, camera) {\n    var topLeftBasic = this.viewportToBasic(-1, 1, transform, camera);\n    var topRightBasic = this.viewportToBasic(1, 1, transform, camera);\n    var bottomRightBasic = this.viewportToBasic(1, -1, transform, camera);\n    var bottomLeftBasic = this.viewportToBasic(-1, -1, transform, camera);\n    var topBasicDistance = 0;\n    var rightBasicDistance = 0;\n    var bottomBasicDistance = 0;\n    var leftBasicDistance = 0;\n\n    if (topLeftBasic[1] < 0 && topRightBasic[1] < 0) {\n      topBasicDistance = topLeftBasic[1] > topRightBasic[1] ? -topLeftBasic[1] : -topRightBasic[1];\n    }\n\n    if (topRightBasic[0] > 1 && bottomRightBasic[0] > 1) {\n      rightBasicDistance = topRightBasic[0] < bottomRightBasic[0] ? topRightBasic[0] - 1 : bottomRightBasic[0] - 1;\n    }\n\n    if (bottomRightBasic[1] > 1 && bottomLeftBasic[1] > 1) {\n      bottomBasicDistance = bottomRightBasic[1] < bottomLeftBasic[1] ? bottomRightBasic[1] - 1 : bottomLeftBasic[1] - 1;\n    }\n\n    if (bottomLeftBasic[0] < 0 && topLeftBasic[0] < 0) {\n      leftBasicDistance = bottomLeftBasic[0] > topLeftBasic[0] ? -bottomLeftBasic[0] : -topLeftBasic[0];\n    }\n\n    return [topBasicDistance, rightBasicDistance, bottomBasicDistance, leftBasicDistance];\n  };\n  /**\n   * Determine pixel distances from image to canvas corners.\n   *\n   * @description Transform origin and camera position needs to be the\n   * equal for reliable return value.\n   *\n   * Determines the smallest pixel distance for every side of the canvas.\n   *\n   * @param {HTMLElement} container - The viewer container.\n   * @param {Transform} transform - Transform of the node to unproject from.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} Array of pixel distances as [top, right, bottom, left].\n   */\n\n\n  ViewportCoords.prototype.getPixelDistances = function (container, transform, camera) {\n    var topLeftBasic = this.viewportToBasic(-1, 1, transform, camera);\n    var topRightBasic = this.viewportToBasic(1, 1, transform, camera);\n    var bottomRightBasic = this.viewportToBasic(1, -1, transform, camera);\n    var bottomLeftBasic = this.viewportToBasic(-1, -1, transform, camera);\n    var topPixelDistance = 0;\n    var rightPixelDistance = 0;\n    var bottomPixelDistance = 0;\n    var leftPixelDistance = 0;\n\n    var _a = this.containerToCanvas(container),\n        canvasWidth = _a[0],\n        canvasHeight = _a[1];\n\n    if (topLeftBasic[1] < 0 && topRightBasic[1] < 0) {\n      var basicX = topLeftBasic[1] > topRightBasic[1] ? topLeftBasic[0] : topRightBasic[0];\n      var canvas = this.basicToCanvas(basicX, 0, container, transform, camera);\n      topPixelDistance = canvas[1] > 0 ? canvas[1] : 0;\n    }\n\n    if (topRightBasic[0] > 1 && bottomRightBasic[0] > 1) {\n      var basicY = topRightBasic[0] < bottomRightBasic[0] ? topRightBasic[1] : bottomRightBasic[1];\n      var canvas = this.basicToCanvas(1, basicY, container, transform, camera);\n      rightPixelDistance = canvas[0] < canvasWidth ? canvasWidth - canvas[0] : 0;\n    }\n\n    if (bottomRightBasic[1] > 1 && bottomLeftBasic[1] > 1) {\n      var basicX = bottomRightBasic[1] < bottomLeftBasic[1] ? bottomRightBasic[0] : bottomLeftBasic[0];\n      var canvas = this.basicToCanvas(basicX, 1, container, transform, camera);\n      bottomPixelDistance = canvas[1] < canvasHeight ? canvasHeight - canvas[1] : 0;\n    }\n\n    if (bottomLeftBasic[0] < 0 && topLeftBasic[0] < 0) {\n      var basicY = bottomLeftBasic[0] > topLeftBasic[0] ? bottomLeftBasic[1] : topLeftBasic[1];\n      var canvas = this.basicToCanvas(0, basicY, container, transform, camera);\n      leftPixelDistance = canvas[0] > 0 ? canvas[0] : 0;\n    }\n\n    return [topPixelDistance, rightPixelDistance, bottomPixelDistance, leftPixelDistance];\n  };\n  /**\n   * Determine if an event occured inside an element.\n   *\n   * @param {Event} event - Event containing clientX and clientY properties.\n   * @param {HTMLElement} element - HTML element.\n   * @returns {boolean} Value indicating if the event occured inside the element or not.\n   */\n\n\n  ViewportCoords.prototype.insideElement = function (event, element) {\n    var clientRect = element.getBoundingClientRect();\n    var minX = clientRect.left + element.clientLeft;\n    var maxX = minX + element.clientWidth;\n    var minY = clientRect.top + element.clientTop;\n    var maxY = minY + element.clientHeight;\n    return event.clientX > minX && event.clientX < maxX && event.clientY > minY && event.clientY < maxY;\n  };\n  /**\n   * Project 3D world coordinates to canvas coordinates.\n   *\n   * @param {Array<number>} point3D - 3D world coordinates.\n   * @param {HTMLElement} container - The viewer container.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 2D canvas coordinates.\n   */\n\n\n  ViewportCoords.prototype.projectToCanvas = function (point3d, container, camera) {\n    var viewport = this.projectToViewport(point3d, camera);\n    var canvas = this.viewportToCanvas(viewport[0], viewport[1], container);\n    return canvas;\n  };\n  /**\n   * Project 3D world coordinates to viewport coordinates.\n   *\n   * @param {Array<number>} point3D - 3D world coordinates.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 2D viewport coordinates.\n   */\n\n\n  ViewportCoords.prototype.projectToViewport = function (point3d, camera) {\n    var viewport = new THREE.Vector3(point3d[0], point3d[1], point3d[2]).project(camera);\n    return [viewport.x, viewport.y];\n  };\n  /**\n   * Uproject canvas coordinates to 3D world coordinates.\n   *\n   * @param {number} canvasX - Canvas X coordinate.\n   * @param {number} canvasY - Canvas Y coordinate.\n   * @param {HTMLElement} container - The viewer container.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 3D world coordinates.\n   */\n\n\n  ViewportCoords.prototype.unprojectFromCanvas = function (canvasX, canvasY, container, camera) {\n    var viewport = this.canvasToViewport(canvasX, canvasY, container);\n    var point3d = this.unprojectFromViewport(viewport[0], viewport[1], camera);\n    return point3d;\n  };\n  /**\n   * Unproject viewport coordinates to 3D world coordinates.\n   *\n   * @param {number} viewportX - Viewport X coordinate.\n   * @param {number} viewportY - Viewport Y coordinate.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 3D world coordinates.\n   */\n\n\n  ViewportCoords.prototype.unprojectFromViewport = function (viewportX, viewportY, camera) {\n    var point3d = new THREE.Vector3(viewportX, viewportY, 1).unproject(camera);\n    return point3d;\n  };\n  /**\n   * Convert viewport coordinates to basic coordinates.\n   *\n   * @description Transform origin and camera position needs to be the\n   * equal for reliable return value.\n   *\n   * @param {number} viewportX - Viewport X coordinate.\n   * @param {number} viewportY - Viewport Y coordinate.\n   * @param {Transform} transform - Transform of the node to unproject from.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 2D basic coordinates.\n   */\n\n\n  ViewportCoords.prototype.viewportToBasic = function (viewportX, viewportY, transform, camera) {\n    var point3d = new THREE.Vector3(viewportX, viewportY, 1).unproject(camera).toArray();\n    var basic = transform.projectBasic(point3d);\n    return basic;\n  };\n  /**\n   * Convert viewport coordinates to canvas coordinates.\n   *\n   * @param {number} viewportX - Viewport X coordinate.\n   * @param {number} viewportY - Viewport Y coordinate.\n   * @param {HTMLElement} container - The viewer container.\n   * @returns {Array<number>} 2D canvas coordinates.\n   */\n\n\n  ViewportCoords.prototype.viewportToCanvas = function (viewportX, viewportY, container) {\n    var _a = this.containerToCanvas(container),\n        canvasWidth = _a[0],\n        canvasHeight = _a[1];\n\n    var canvasX = canvasWidth * (viewportX + 1) / 2;\n    var canvasY = -canvasHeight * (viewportY - 1) / 2;\n    return [canvasX, canvasY];\n  };\n  /**\n   * Convert 3D world coordinates to 3D camera coordinates.\n   *\n   * @param {number} point3D - 3D point in world coordinate system.\n   * @param {THREE.Camera} camera - Camera used in rendering.\n   * @returns {Array<number>} 3D camera coordinates.\n   */\n\n\n  ViewportCoords.prototype.worldToCamera = function (point3d, camera) {\n    var pointCamera = new THREE.Vector3(point3d[0], point3d[1], point3d[2]).applyMatrix4(camera.matrixWorldInverse);\n    return pointCamera.toArray();\n  };\n\n  return ViewportCoords;\n}();\n\nexports.ViewportCoords = ViewportCoords;\nexports.default = ViewportCoords;\n\n//# sourceURL=webpack://Mapillary/./src/geo/ViewportCoords.ts?");

/***/ }),

/***/ "./src/graph/FilterCreator.ts":
/*!************************************!*\
  !*** ./src/graph/FilterCreator.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @class Filter\n *\n * @classdesc Represents a class for creating node filters. Implementation and\n * definitions based on https://github.com/mapbox/feature-filter.\n */\n\nvar FilterCreator =\n/** @class */\nfunction () {\n  function FilterCreator() {}\n  /**\n   * Create a filter from a filter expression.\n   *\n   * @description The following filters are supported:\n   *\n   * Comparison\n   * `==`\n   * `!=`\n   * `<`\n   * `<=`\n   * `>`\n   * `>=`\n   *\n   * Set membership\n   * `in`\n   * `!in`\n   *\n   * Combining\n   * `all`\n   *\n   * @param {FilterExpression} filter - Comparison, set membership or combinding filter\n   * expression.\n   * @returns {FilterFunction} Function taking a node and returning a boolean that\n   * indicates whether the node passed the test or not.\n   */\n\n\n  FilterCreator.prototype.createFilter = function (filter) {\n    return new Function(\"node\", \"return \" + this._compile(filter) + \";\");\n  };\n\n  FilterCreator.prototype._compile = function (filter) {\n    if (filter == null || filter.length <= 1) {\n      return \"true\";\n    }\n\n    var operator = filter[0];\n    var operation = operator === \"==\" ? this._compileComparisonOp(\"===\", filter[1], filter[2], false) : operator === \"!=\" ? this._compileComparisonOp(\"!==\", filter[1], filter[2], false) : operator === \">\" || operator === \">=\" || operator === \"<\" || operator === \"<=\" ? this._compileComparisonOp(operator, filter[1], filter[2], true) : operator === \"in\" ? this._compileInOp(filter[1], filter.slice(2)) : operator === \"!in\" ? this._compileNegation(this._compileInOp(filter[1], filter.slice(2))) : operator === \"all\" ? this._compileLogicalOp(filter.slice(1), \"&&\") : \"true\";\n    return \"(\" + operation + \")\";\n  };\n\n  FilterCreator.prototype._compare = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n  };\n\n  FilterCreator.prototype._compileComparisonOp = function (operator, property, value, checkType) {\n    var left = this._compilePropertyReference(property);\n\n    var right = JSON.stringify(value);\n    return (checkType ? \"typeof \" + left + \"===typeof \" + right + \"&&\" : \"\") + left + operator + right;\n  };\n\n  FilterCreator.prototype._compileInOp = function (property, values) {\n    var compare = this._compare;\n    var left = JSON.stringify(values.sort(compare));\n\n    var right = this._compilePropertyReference(property);\n\n    return left + \".indexOf(\" + right + \")!==-1\";\n  };\n\n  FilterCreator.prototype._compileLogicalOp = function (filters, operator) {\n    var compile = this._compile.bind(this);\n\n    return filters.map(compile).join(operator);\n  };\n\n  FilterCreator.prototype._compileNegation = function (expression) {\n    return \"!(\" + expression + \")\";\n  };\n\n  FilterCreator.prototype._compilePropertyReference = function (property) {\n    return \"node[\" + JSON.stringify(property) + \"]\";\n  };\n\n  return FilterCreator;\n}();\n\nexports.FilterCreator = FilterCreator;\nexports.default = FilterCreator;\n\n//# sourceURL=webpack://Mapillary/./src/graph/FilterCreator.ts?");

/***/ }),

/***/ "./src/graph/Graph.ts":
/*!****************************!*\
  !*** ./src/graph/Graph.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar rbush = __webpack_require__(/*! rbush */ \"./node_modules/rbush/index.js\");\n\nvar Edge_1 = __webpack_require__(/*! ../Edge */ \"./src/Edge.ts\");\n\nvar Error_1 = __webpack_require__(/*! ../Error */ \"./src/Error.ts\");\n\nvar Graph_1 = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n/**\n * @class Graph\n *\n * @classdesc Represents a graph of nodes with edges.\n */\n\n\nvar Graph =\n/** @class */\nfunction () {\n  /**\n   * Create a new graph instance.\n   *\n   * @param {APIv3} [apiV3] - API instance for retrieving data.\n   * @param {rbush.RBush<NodeIndexItem>} [nodeIndex] - Node index for fast spatial retreival.\n   * @param {GraphCalculator} [graphCalculator] - Instance for graph calculations.\n   * @param {EdgeCalculator} [edgeCalculator] - Instance for edge calculations.\n   * @param {FilterCreator} [filterCreator] - Instance for  filter creation.\n   * @param {IGraphConfiguration} [configuration] - Configuration struct.\n   */\n  function Graph(apiV3, nodeIndex, graphCalculator, edgeCalculator, filterCreator, configuration) {\n    this._apiV3 = apiV3;\n    this._cachedNodes = {};\n    this._cachedNodeTiles = {};\n    this._cachedSequenceNodes = {};\n    this._cachedSpatialEdges = {};\n    this._cachedTiles = {};\n    this._cachingFill$ = {};\n    this._cachingFull$ = {};\n    this._cachingSequenceNodes$ = {};\n    this._cachingSequences$ = {};\n    this._cachingSpatialArea$ = {};\n    this._cachingTiles$ = {};\n    this._changed$ = new rxjs_1.Subject();\n    this._defaultAlt = 2;\n    this._edgeCalculator = edgeCalculator != null ? edgeCalculator : new Edge_1.EdgeCalculator();\n    this._filterCreator = filterCreator != null ? filterCreator : new Graph_1.FilterCreator();\n    this._filter = this._filterCreator.createFilter(undefined);\n    this._graphCalculator = graphCalculator != null ? graphCalculator : new Graph_1.GraphCalculator();\n    this._configuration = configuration != null ? configuration : {\n      maxSequences: 50,\n      maxUnusedNodes: 100,\n      maxUnusedPreStoredNodes: 30,\n      maxUnusedTiles: 20\n    };\n    this._nodes = {};\n    this._nodeIndex = nodeIndex != null ? nodeIndex : rbush(16, [\".lat\", \".lon\", \".lat\", \".lon\"]);\n    this._nodeIndexTiles = {};\n    this._nodeToTile = {};\n    this._preStored = {};\n    this._requiredNodeTiles = {};\n    this._requiredSpatialArea = {};\n    this._sequences = {};\n    this._tilePrecision = 7;\n    this._tileThreshold = 20;\n  }\n\n  Object.defineProperty(Graph.prototype, \"changed$\", {\n    /**\n     * Get changed$.\n     *\n     * @returns {Observable<Graph>} Observable emitting\n     * the graph every time it has changed.\n     */\n    get: function get() {\n      return this._changed$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Caches the full node data for all images within a bounding\n   * box.\n   *\n   * @description The node assets are not cached.\n   *\n   * @param {ILatLon} sw - South west corner of bounding box.\n   * @param {ILatLon} ne - North east corner of bounding box.\n   * @returns {Observable<Graph>} Observable emitting the full\n   * nodes in the bounding box.\n   */\n\n  Graph.prototype.cacheBoundingBox$ = function (sw, ne) {\n    var _this = this;\n\n    var cacheTiles$ = this._graphCalculator.encodeHsFromBoundingBox(sw, ne).filter(function (h) {\n      return !(h in _this._cachedTiles);\n    }).map(function (h) {\n      return h in _this._cachingTiles$ ? _this._cachingTiles$[h] : _this._cacheTile$(h);\n    });\n\n    if (cacheTiles$.length === 0) {\n      cacheTiles$.push(rxjs_1.of(this));\n    }\n\n    return rxjs_1.from(cacheTiles$).pipe(operators_1.mergeAll(), operators_1.last(), operators_1.mergeMap(function (graph) {\n      var nodes = _this._nodeIndex.search({\n        maxX: ne.lat,\n        maxY: ne.lon,\n        minX: sw.lat,\n        minY: sw.lon\n      }).map(function (item) {\n        return item.node;\n      });\n\n      var fullNodes = [];\n      var coreNodes = [];\n\n      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var node = nodes_1[_i];\n\n        if (node.full) {\n          fullNodes.push(node);\n        } else {\n          coreNodes.push(node.key);\n        }\n      }\n\n      var coreNodeBatches = [];\n      var batchSize = 200;\n\n      while (coreNodes.length > 0) {\n        coreNodeBatches.push(coreNodes.splice(0, batchSize));\n      }\n\n      var fullNodes$ = rxjs_1.of(fullNodes);\n      var fillNodes$ = coreNodeBatches.map(function (batch) {\n        return _this._apiV3.imageByKeyFill$(batch).pipe(operators_1.map(function (imageByKeyFill) {\n          var filledNodes = [];\n\n          for (var fillKey in imageByKeyFill) {\n            if (!imageByKeyFill.hasOwnProperty(fillKey)) {\n              continue;\n            }\n\n            if (_this.hasNode(fillKey)) {\n              var node = _this.getNode(fillKey);\n\n              if (!node.full) {\n                _this._makeFull(node, imageByKeyFill[fillKey]);\n              }\n\n              filledNodes.push(node);\n            }\n          }\n\n          return filledNodes;\n        }));\n      });\n      return rxjs_1.merge(fullNodes$, rxjs_1.from(fillNodes$).pipe(operators_1.mergeAll()));\n    }), operators_1.reduce(function (acc, value) {\n      return acc.concat(value);\n    }));\n  };\n  /**\n   * Retrieve and cache node fill properties.\n   *\n   * @param {string} key - Key of node to fill.\n   * @returns {Observable<Graph>} Observable emitting the graph\n   * when the node has been updated.\n   * @throws {GraphMapillaryError} When the operation is not valid on the\n   * current graph.\n   */\n\n\n  Graph.prototype.cacheFill$ = function (key) {\n    var _this = this;\n\n    if (key in this._cachingFull$) {\n      throw new Error_1.GraphMapillaryError(\"Cannot fill node while caching full (\" + key + \").\");\n    }\n\n    if (!this.hasNode(key)) {\n      throw new Error_1.GraphMapillaryError(\"Cannot fill node that does not exist in graph (\" + key + \").\");\n    }\n\n    if (key in this._cachingFill$) {\n      return this._cachingFill$[key];\n    }\n\n    var node = this.getNode(key);\n\n    if (node.full) {\n      throw new Error_1.GraphMapillaryError(\"Cannot fill node that is already full (\" + key + \").\");\n    }\n\n    this._cachingFill$[key] = this._apiV3.imageByKeyFill$([key]).pipe(operators_1.tap(function (imageByKeyFill) {\n      if (!node.full) {\n        _this._makeFull(node, imageByKeyFill[key]);\n      }\n\n      delete _this._cachingFill$[key];\n    }), operators_1.map(function (imageByKeyFill) {\n      return _this;\n    }), operators_1.finalize(function () {\n      if (key in _this._cachingFill$) {\n        delete _this._cachingFill$[key];\n      }\n\n      _this._changed$.next(_this);\n    }), operators_1.publish(), operators_1.refCount());\n    return this._cachingFill$[key];\n  };\n  /**\n   * Retrieve and cache full node properties.\n   *\n   * @param {string} key - Key of node to fill.\n   * @returns {Observable<Graph>} Observable emitting the graph\n   * when the node has been updated.\n   * @throws {GraphMapillaryError} When the operation is not valid on the\n   * current graph.\n   */\n\n\n  Graph.prototype.cacheFull$ = function (key) {\n    var _this = this;\n\n    if (key in this._cachingFull$) {\n      return this._cachingFull$[key];\n    }\n\n    if (this.hasNode(key)) {\n      throw new Error_1.GraphMapillaryError(\"Cannot cache full node that already exist in graph (\" + key + \").\");\n    }\n\n    this._cachingFull$[key] = this._apiV3.imageByKeyFull$([key]).pipe(operators_1.tap(function (imageByKeyFull) {\n      var fn = imageByKeyFull[key];\n\n      if (_this.hasNode(key)) {\n        var node = _this.getNode(key);\n\n        if (!node.full) {\n          _this._makeFull(node, fn);\n        }\n      } else {\n        if (fn.sequence_key == null) {\n          throw new Error_1.GraphMapillaryError(\"Node has no sequence key (\" + key + \").\");\n        }\n\n        var node = new Graph_1.Node(fn);\n\n        _this._makeFull(node, fn);\n\n        var h = _this._graphCalculator.encodeH(node.originalLatLon, _this._tilePrecision);\n\n        _this._preStore(h, node);\n\n        _this._setNode(node);\n\n        delete _this._cachingFull$[key];\n      }\n    }), operators_1.map(function (imageByKeyFull) {\n      return _this;\n    }), operators_1.finalize(function () {\n      if (key in _this._cachingFull$) {\n        delete _this._cachingFull$[key];\n      }\n\n      _this._changed$.next(_this);\n    }), operators_1.publish(), operators_1.refCount());\n    return this._cachingFull$[key];\n  };\n  /**\n   * Retrieve and cache a node sequence.\n   *\n   * @param {string} key - Key of node for which to retrieve sequence.\n   * @returns {Observable<Graph>} Observable emitting the graph\n   * when the sequence has been retrieved.\n   * @throws {GraphMapillaryError} When the operation is not valid on the\n   * current graph.\n   */\n\n\n  Graph.prototype.cacheNodeSequence$ = function (key) {\n    if (!this.hasNode(key)) {\n      throw new Error_1.GraphMapillaryError(\"Cannot cache sequence edges of node that does not exist in graph (\" + key + \").\");\n    }\n\n    var node = this.getNode(key);\n\n    if (node.sequenceKey in this._sequences) {\n      throw new Error_1.GraphMapillaryError(\"Sequence already cached (\" + key + \"), (\" + node.sequenceKey + \").\");\n    }\n\n    return this._cacheSequence$(node.sequenceKey);\n  };\n  /**\n   * Retrieve and cache a sequence.\n   *\n   * @param {string} sequenceKey - Key of sequence to cache.\n   * @returns {Observable<Graph>} Observable emitting the graph\n   * when the sequence has been retrieved.\n   * @throws {GraphMapillaryError} When the operation is not valid on the\n   * current graph.\n   */\n\n\n  Graph.prototype.cacheSequence$ = function (sequenceKey) {\n    if (sequenceKey in this._sequences) {\n      throw new Error_1.GraphMapillaryError(\"Sequence already cached (\" + sequenceKey + \")\");\n    }\n\n    return this._cacheSequence$(sequenceKey);\n  };\n  /**\n   * Cache sequence edges for a node.\n   *\n   * @param {string} key - Key of node.\n   * @throws {GraphMapillaryError} When the operation is not valid on the\n   * current graph.\n   */\n\n\n  Graph.prototype.cacheSequenceEdges = function (key) {\n    var node = this.getNode(key);\n\n    if (!(node.sequenceKey in this._sequences)) {\n      throw new Error_1.GraphMapillaryError(\"Sequence is not cached (\" + key + \"), (\" + node.sequenceKey + \")\");\n    }\n\n    var sequence = this._sequences[node.sequenceKey].sequence;\n\n    var edges = this._edgeCalculator.computeSequenceEdges(node, sequence);\n\n    node.cacheSequenceEdges(edges);\n  };\n  /**\n   * Retrieve and cache full nodes for all keys in a sequence.\n   *\n   * @param {string} sequenceKey - Key of sequence.\n   * @param {string} referenceNodeKey - Key of node to use as reference\n   * for optimized caching.\n   * @returns {Observable<Graph>} Observable emitting the graph\n   * when the nodes of the sequence has been cached.\n   */\n\n\n  Graph.prototype.cacheSequenceNodes$ = function (sequenceKey, referenceNodeKey) {\n    var _this = this;\n\n    if (!this.hasSequence(sequenceKey)) {\n      throw new Error_1.GraphMapillaryError(\"Cannot cache sequence nodes of sequence that does not exist in graph (\" + sequenceKey + \").\");\n    }\n\n    if (this.hasSequenceNodes(sequenceKey)) {\n      throw new Error_1.GraphMapillaryError(\"Sequence nodes already cached (\" + sequenceKey + \").\");\n    }\n\n    var sequence = this.getSequence(sequenceKey);\n\n    if (sequence.key in this._cachingSequenceNodes$) {\n      return this._cachingSequenceNodes$[sequence.key];\n    }\n\n    var batches = [];\n    var keys = sequence.keys.slice();\n    var referenceBatchSize = 50;\n\n    if (!!referenceNodeKey && keys.length > referenceBatchSize) {\n      var referenceIndex = keys.indexOf(referenceNodeKey);\n      var startIndex = Math.max(0, Math.min(referenceIndex - referenceBatchSize / 2, keys.length - referenceBatchSize));\n      batches.push(keys.splice(startIndex, referenceBatchSize));\n    }\n\n    var batchSize = 200;\n\n    while (keys.length > 0) {\n      batches.push(keys.splice(0, batchSize));\n    }\n\n    var batchesToCache = batches.length;\n    var sequenceNodes$ = rxjs_1.from(batches).pipe(operators_1.mergeMap(function (batch) {\n      return _this._apiV3.imageByKeyFull$(batch).pipe(operators_1.tap(function (imageByKeyFull) {\n        for (var fullKey in imageByKeyFull) {\n          if (!imageByKeyFull.hasOwnProperty(fullKey)) {\n            continue;\n          }\n\n          var fn = imageByKeyFull[fullKey];\n\n          if (_this.hasNode(fullKey)) {\n            var node = _this.getNode(fn.key);\n\n            if (!node.full) {\n              _this._makeFull(node, fn);\n            }\n          } else {\n            if (fn.sequence_key == null) {\n              console.warn(\"Sequence missing, discarding node (\" + fn.key + \")\");\n            }\n\n            var node = new Graph_1.Node(fn);\n\n            _this._makeFull(node, fn);\n\n            var h = _this._graphCalculator.encodeH(node.originalLatLon, _this._tilePrecision);\n\n            _this._preStore(h, node);\n\n            _this._setNode(node);\n          }\n        }\n\n        batchesToCache--;\n      }), operators_1.map(function (imageByKeyFull) {\n        return _this;\n      }));\n    }, 6), operators_1.last(), operators_1.finalize(function () {\n      delete _this._cachingSequenceNodes$[sequence.key];\n\n      if (batchesToCache === 0) {\n        _this._cachedSequenceNodes[sequence.key] = true;\n      }\n    }), operators_1.publish(), operators_1.refCount());\n    this._cachingSequenceNodes$[sequence.key] = sequenceNodes$;\n    return sequenceNodes$;\n  };\n  /**\n   * Retrieve and cache full nodes for a node spatial area.\n   *\n   * @param {string} key - Key of node for which to retrieve sequence.\n   * @returns {Observable<Graph>} Observable emitting the graph\n   * when the nodes in the spatial area has been made full.\n   * @throws {GraphMapillaryError} When the operation is not valid on the\n   * current graph.\n   */\n\n\n  Graph.prototype.cacheSpatialArea$ = function (key) {\n    var _this = this;\n\n    if (!this.hasNode(key)) {\n      throw new Error_1.GraphMapillaryError(\"Cannot cache spatial area of node that does not exist in graph (\" + key + \").\");\n    }\n\n    if (key in this._cachedSpatialEdges) {\n      throw new Error_1.GraphMapillaryError(\"Node already spatially cached (\" + key + \").\");\n    }\n\n    if (!(key in this._requiredSpatialArea)) {\n      throw new Error_1.GraphMapillaryError(\"Spatial area not determined (\" + key + \").\");\n    }\n\n    var spatialArea = this._requiredSpatialArea[key];\n\n    if (Object.keys(spatialArea.cacheNodes).length === 0) {\n      throw new Error_1.GraphMapillaryError(\"Spatial nodes already cached (\" + key + \").\");\n    }\n\n    if (key in this._cachingSpatialArea$) {\n      return this._cachingSpatialArea$[key];\n    }\n\n    var batches = [];\n\n    while (spatialArea.cacheKeys.length > 0) {\n      batches.push(spatialArea.cacheKeys.splice(0, 200));\n    }\n\n    var batchesToCache = batches.length;\n    var spatialNodes$ = [];\n\n    var _loop_1 = function _loop_1(batch) {\n      var spatialNodeBatch$ = this_1._apiV3.imageByKeyFill$(batch).pipe(operators_1.tap(function (imageByKeyFill) {\n        for (var fillKey in imageByKeyFill) {\n          if (!imageByKeyFill.hasOwnProperty(fillKey)) {\n            continue;\n          }\n\n          var spatialNode = spatialArea.cacheNodes[fillKey];\n\n          if (spatialNode.full) {\n            delete spatialArea.cacheNodes[fillKey];\n            continue;\n          }\n\n          var fillNode = imageByKeyFill[fillKey];\n\n          _this._makeFull(spatialNode, fillNode);\n\n          delete spatialArea.cacheNodes[fillKey];\n        }\n\n        if (--batchesToCache === 0) {\n          delete _this._cachingSpatialArea$[key];\n        }\n      }), operators_1.map(function (imageByKeyFill) {\n        return _this;\n      }), operators_1.catchError(function (error) {\n        for (var _i = 0, batch_1 = batch; _i < batch_1.length; _i++) {\n          var batchKey = batch_1[_i];\n\n          if (batchKey in spatialArea.all) {\n            delete spatialArea.all[batchKey];\n          }\n\n          if (batchKey in spatialArea.cacheNodes) {\n            delete spatialArea.cacheNodes[batchKey];\n          }\n        }\n\n        if (--batchesToCache === 0) {\n          delete _this._cachingSpatialArea$[key];\n        }\n\n        throw error;\n      }), operators_1.finalize(function () {\n        if (Object.keys(spatialArea.cacheNodes).length === 0) {\n          _this._changed$.next(_this);\n        }\n      }), operators_1.publish(), operators_1.refCount());\n\n      spatialNodes$.push(spatialNodeBatch$);\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n      var batch = batches_1[_i];\n\n      _loop_1(batch);\n    }\n\n    this._cachingSpatialArea$[key] = spatialNodes$;\n    return spatialNodes$;\n  };\n  /**\n   * Cache spatial edges for a node.\n   *\n   * @param {string} key - Key of node.\n   * @throws {GraphMapillaryError} When the operation is not valid on the\n   * current graph.\n   */\n\n\n  Graph.prototype.cacheSpatialEdges = function (key) {\n    if (key in this._cachedSpatialEdges) {\n      throw new Error_1.GraphMapillaryError(\"Spatial edges already cached (\" + key + \").\");\n    }\n\n    var node = this.getNode(key);\n    var sequence = this._sequences[node.sequenceKey].sequence;\n    var fallbackKeys = [];\n    var prevKey = sequence.findPrevKey(node.key);\n\n    if (prevKey != null) {\n      fallbackKeys.push(prevKey);\n    }\n\n    var nextKey = sequence.findNextKey(node.key);\n\n    if (nextKey != null) {\n      fallbackKeys.push(nextKey);\n    }\n\n    var allSpatialNodes = this._requiredSpatialArea[key].all;\n    var potentialNodes = [];\n    var filter = this._filter;\n\n    for (var spatialNodeKey in allSpatialNodes) {\n      if (!allSpatialNodes.hasOwnProperty(spatialNodeKey)) {\n        continue;\n      }\n\n      var spatialNode = allSpatialNodes[spatialNodeKey];\n\n      if (filter(spatialNode)) {\n        potentialNodes.push(spatialNode);\n      }\n    }\n\n    var potentialEdges = this._edgeCalculator.getPotentialEdges(node, potentialNodes, fallbackKeys);\n\n    var edges = this._edgeCalculator.computeStepEdges(node, potentialEdges, prevKey, nextKey);\n\n    edges = edges.concat(this._edgeCalculator.computeTurnEdges(node, potentialEdges));\n    edges = edges.concat(this._edgeCalculator.computePanoEdges(node, potentialEdges));\n    edges = edges.concat(this._edgeCalculator.computePerspectiveToPanoEdges(node, potentialEdges));\n    edges = edges.concat(this._edgeCalculator.computeSimilarEdges(node, potentialEdges));\n    node.cacheSpatialEdges(edges);\n    this._cachedSpatialEdges[key] = node;\n    delete this._requiredSpatialArea[key];\n    delete this._cachedNodeTiles[key];\n  };\n  /**\n   * Retrieve and cache geohash tiles for a node.\n   *\n   * @param {string} key - Key of node for which to retrieve tiles.\n   * @returns {Array<Observable<Graph>>} Array of observables emitting\n   * the graph for each tile required for the node has been cached.\n   * @throws {GraphMapillaryError} When the operation is not valid on the\n   * current graph.\n   */\n\n\n  Graph.prototype.cacheTiles$ = function (key) {\n    var _this = this;\n\n    if (key in this._cachedNodeTiles) {\n      throw new Error_1.GraphMapillaryError(\"Tiles already cached (\" + key + \").\");\n    }\n\n    if (key in this._cachedSpatialEdges) {\n      throw new Error_1.GraphMapillaryError(\"Spatial edges already cached so tiles considered cached (\" + key + \").\");\n    }\n\n    if (!(key in this._requiredNodeTiles)) {\n      throw new Error_1.GraphMapillaryError(\"Tiles have not been determined (\" + key + \").\");\n    }\n\n    var nodeTiles = this._requiredNodeTiles[key];\n\n    if (nodeTiles.cache.length === 0 && nodeTiles.caching.length === 0) {\n      throw new Error_1.GraphMapillaryError(\"Tiles already cached (\" + key + \").\");\n    }\n\n    if (!this.hasNode(key)) {\n      throw new Error_1.GraphMapillaryError(\"Cannot cache tiles of node that does not exist in graph (\" + key + \").\");\n    }\n\n    var hs = nodeTiles.cache.slice();\n    nodeTiles.caching = this._requiredNodeTiles[key].caching.concat(hs);\n    nodeTiles.cache = [];\n    var cacheTiles$ = [];\n\n    var _loop_2 = function _loop_2(h) {\n      var cacheTile$ = h in this_2._cachingTiles$ ? this_2._cachingTiles$[h] : this_2._cacheTile$(h);\n      cacheTiles$.push(cacheTile$.pipe(operators_1.tap(function (graph) {\n        var index = nodeTiles.caching.indexOf(h);\n\n        if (index > -1) {\n          nodeTiles.caching.splice(index, 1);\n        }\n\n        if (nodeTiles.caching.length === 0 && nodeTiles.cache.length === 0) {\n          delete _this._requiredNodeTiles[key];\n          _this._cachedNodeTiles[key] = true;\n        }\n      }), operators_1.catchError(function (error) {\n        var index = nodeTiles.caching.indexOf(h);\n\n        if (index > -1) {\n          nodeTiles.caching.splice(index, 1);\n        }\n\n        if (nodeTiles.caching.length === 0 && nodeTiles.cache.length === 0) {\n          delete _this._requiredNodeTiles[key];\n          _this._cachedNodeTiles[key] = true;\n        }\n\n        throw error;\n      }), operators_1.finalize(function () {\n        _this._changed$.next(_this);\n      }), operators_1.publish(), operators_1.refCount()));\n    };\n\n    var this_2 = this;\n\n    for (var _i = 0, _a = nodeTiles.caching; _i < _a.length; _i++) {\n      var h = _a[_i];\n\n      _loop_2(h);\n    }\n\n    return cacheTiles$;\n  };\n  /**\n   * Initialize the cache for a node.\n   *\n   * @param {string} key - Key of node.\n   * @throws {GraphMapillaryError} When the operation is not valid on the\n   * current graph.\n   */\n\n\n  Graph.prototype.initializeCache = function (key) {\n    if (key in this._cachedNodes) {\n      throw new Error_1.GraphMapillaryError(\"Node already in cache (\" + key + \").\");\n    }\n\n    var node = this.getNode(key);\n    node.initializeCache(new Graph_1.NodeCache());\n    var accessed = new Date().getTime();\n    this._cachedNodes[key] = {\n      accessed: accessed,\n      node: node\n    };\n\n    this._updateCachedTileAccess(key, accessed);\n  };\n  /**\n   * Get a value indicating if the graph is fill caching a node.\n   *\n   * @param {string} key - Key of node.\n   * @returns {boolean} Value indicating if the node is being fill cached.\n   */\n\n\n  Graph.prototype.isCachingFill = function (key) {\n    return key in this._cachingFill$;\n  };\n  /**\n   * Get a value indicating if the graph is fully caching a node.\n   *\n   * @param {string} key - Key of node.\n   * @returns {boolean} Value indicating if the node is being fully cached.\n   */\n\n\n  Graph.prototype.isCachingFull = function (key) {\n    return key in this._cachingFull$;\n  };\n  /**\n   * Get a value indicating if the graph is caching a sequence of a node.\n   *\n   * @param {string} key - Key of node.\n   * @returns {boolean} Value indicating if the sequence of a node is\n   * being cached.\n   */\n\n\n  Graph.prototype.isCachingNodeSequence = function (key) {\n    var node = this.getNode(key);\n    return node.sequenceKey in this._cachingSequences$;\n  };\n  /**\n   * Get a value indicating if the graph is caching a sequence.\n   *\n   * @param {string} sequenceKey - Key of sequence.\n   * @returns {boolean} Value indicating if the sequence is\n   * being cached.\n   */\n\n\n  Graph.prototype.isCachingSequence = function (sequenceKey) {\n    return sequenceKey in this._cachingSequences$;\n  };\n  /**\n   * Get a value indicating if the graph is caching sequence nodes.\n   *\n   * @param {string} sequenceKey - Key of sequence.\n   * @returns {boolean} Value indicating if the sequence nodes are\n   * being cached.\n   */\n\n\n  Graph.prototype.isCachingSequenceNodes = function (sequenceKey) {\n    return sequenceKey in this._cachingSequenceNodes$;\n  };\n  /**\n   * Get a value indicating if the graph is caching the tiles\n   * required for calculating spatial edges of a node.\n   *\n   * @param {string} key - Key of node.\n   * @returns {boolean} Value indicating if the tiles of\n   * a node are being cached.\n   */\n\n\n  Graph.prototype.isCachingTiles = function (key) {\n    return key in this._requiredNodeTiles && this._requiredNodeTiles[key].cache.length === 0 && this._requiredNodeTiles[key].caching.length > 0;\n  };\n  /**\n   * Get a value indicating if the cache has been initialized\n   * for a node.\n   *\n   * @param {string} key - Key of node.\n   * @returns {boolean} Value indicating if the cache has been\n   * initialized for a node.\n   */\n\n\n  Graph.prototype.hasInitializedCache = function (key) {\n    return key in this._cachedNodes;\n  };\n  /**\n   * Get a value indicating if a node exist in the graph.\n   *\n   * @param {string} key - Key of node.\n   * @returns {boolean} Value indicating if a node exist in the graph.\n   */\n\n\n  Graph.prototype.hasNode = function (key) {\n    var accessed = new Date().getTime();\n\n    this._updateCachedNodeAccess(key, accessed);\n\n    this._updateCachedTileAccess(key, accessed);\n\n    return key in this._nodes;\n  };\n  /**\n   * Get a value indicating if a node sequence exist in the graph.\n   *\n   * @param {string} key - Key of node.\n   * @returns {boolean} Value indicating if a node sequence exist\n   * in the graph.\n   */\n\n\n  Graph.prototype.hasNodeSequence = function (key) {\n    var node = this.getNode(key);\n    var sequenceKey = node.sequenceKey;\n    var hasNodeSequence = sequenceKey in this._sequences;\n\n    if (hasNodeSequence) {\n      this._sequences[sequenceKey].accessed = new Date().getTime();\n    }\n\n    return hasNodeSequence;\n  };\n  /**\n   * Get a value indicating if a sequence exist in the graph.\n   *\n   * @param {string} sequenceKey - Key of sequence.\n   * @returns {boolean} Value indicating if a sequence exist\n   * in the graph.\n   */\n\n\n  Graph.prototype.hasSequence = function (sequenceKey) {\n    var hasSequence = sequenceKey in this._sequences;\n\n    if (hasSequence) {\n      this._sequences[sequenceKey].accessed = new Date().getTime();\n    }\n\n    return hasSequence;\n  };\n  /**\n   * Get a value indicating if sequence nodes has been cached in the graph.\n   *\n   * @param {string} sequenceKey - Key of sequence.\n   * @returns {boolean} Value indicating if a sequence nodes has been\n   * cached in the graph.\n   */\n\n\n  Graph.prototype.hasSequenceNodes = function (sequenceKey) {\n    return sequenceKey in this._cachedSequenceNodes;\n  };\n  /**\n   * Get a value indicating if the graph has fully cached\n   * all nodes in the spatial area of a node.\n   *\n   * @param {string} key - Key of node.\n   * @returns {boolean} Value indicating if the spatial area\n   * of a node has been cached.\n   */\n\n\n  Graph.prototype.hasSpatialArea = function (key) {\n    if (!this.hasNode(key)) {\n      throw new Error_1.GraphMapillaryError(\"Spatial area nodes cannot be determined if node not in graph (\" + key + \").\");\n    }\n\n    if (key in this._cachedSpatialEdges) {\n      return true;\n    }\n\n    if (key in this._requiredSpatialArea) {\n      return Object.keys(this._requiredSpatialArea[key].cacheNodes).length === 0;\n    }\n\n    var node = this.getNode(key);\n\n    var bbox = this._graphCalculator.boundingBoxCorners(node.latLon, this._tileThreshold);\n\n    var spatialItems = this._nodeIndex.search({\n      maxX: bbox[1].lat,\n      maxY: bbox[1].lon,\n      minX: bbox[0].lat,\n      minY: bbox[0].lon\n    });\n\n    var spatialNodes = {\n      all: {},\n      cacheKeys: [],\n      cacheNodes: {}\n    };\n\n    for (var _i = 0, spatialItems_1 = spatialItems; _i < spatialItems_1.length; _i++) {\n      var spatialItem = spatialItems_1[_i];\n      spatialNodes.all[spatialItem.node.key] = spatialItem.node;\n\n      if (!spatialItem.node.full) {\n        spatialNodes.cacheKeys.push(spatialItem.node.key);\n        spatialNodes.cacheNodes[spatialItem.node.key] = spatialItem.node;\n      }\n    }\n\n    this._requiredSpatialArea[key] = spatialNodes;\n    return spatialNodes.cacheKeys.length === 0;\n  };\n  /**\n   * Get a value indicating if the graph has a tiles required\n   * for a node.\n   *\n   * @param {string} key - Key of node.\n   * @returns {boolean} Value indicating if the the tiles required\n   * by a node has been cached.\n   */\n\n\n  Graph.prototype.hasTiles = function (key) {\n    var _this = this;\n\n    if (key in this._cachedNodeTiles) {\n      return true;\n    }\n\n    if (key in this._cachedSpatialEdges) {\n      return true;\n    }\n\n    if (!this.hasNode(key)) {\n      throw new Error_1.GraphMapillaryError(\"Node does not exist in graph (\" + key + \").\");\n    }\n\n    var nodeTiles = {\n      cache: [],\n      caching: []\n    };\n\n    if (!(key in this._requiredNodeTiles)) {\n      var node = this.getNode(key);\n      nodeTiles.cache = this._graphCalculator.encodeHs(node.latLon, this._tilePrecision, this._tileThreshold).filter(function (h) {\n        return !(h in _this._cachedTiles);\n      });\n\n      if (nodeTiles.cache.length > 0) {\n        this._requiredNodeTiles[key] = nodeTiles;\n      }\n    } else {\n      nodeTiles = this._requiredNodeTiles[key];\n    }\n\n    return nodeTiles.cache.length === 0 && nodeTiles.caching.length === 0;\n  };\n  /**\n   * Get a node.\n   *\n   * @param {string} key - Key of node.\n   * @returns {Node} Retrieved node.\n   */\n\n\n  Graph.prototype.getNode = function (key) {\n    var accessed = new Date().getTime();\n\n    this._updateCachedNodeAccess(key, accessed);\n\n    this._updateCachedTileAccess(key, accessed);\n\n    return this._nodes[key];\n  };\n  /**\n   * Get a sequence.\n   *\n   * @param {string} sequenceKey - Key of sequence.\n   * @returns {Node} Retrieved sequence.\n   */\n\n\n  Graph.prototype.getSequence = function (sequenceKey) {\n    var sequenceAccess = this._sequences[sequenceKey];\n    sequenceAccess.accessed = new Date().getTime();\n    return sequenceAccess.sequence;\n  };\n  /**\n   * Reset all spatial edges of the graph nodes.\n   */\n\n\n  Graph.prototype.resetSpatialEdges = function () {\n    var cachedKeys = Object.keys(this._cachedSpatialEdges);\n\n    for (var _i = 0, cachedKeys_1 = cachedKeys; _i < cachedKeys_1.length; _i++) {\n      var cachedKey = cachedKeys_1[_i];\n      var node = this._cachedSpatialEdges[cachedKey];\n      node.resetSpatialEdges();\n      delete this._cachedSpatialEdges[cachedKey];\n    }\n  };\n  /**\n   * Reset the complete graph but keep the nodes corresponding\n   * to the supplied keys. All other nodes will be disposed.\n   *\n   * @param {Array<string>} keepKeys - Keys for nodes to keep\n   * in graph after reset.\n   */\n\n\n  Graph.prototype.reset = function (keepKeys) {\n    var nodes = [];\n\n    for (var _i = 0, keepKeys_1 = keepKeys; _i < keepKeys_1.length; _i++) {\n      var key = keepKeys_1[_i];\n\n      if (!this.hasNode(key)) {\n        throw new Error(\"Node does not exist \" + key);\n      }\n\n      var node = this.getNode(key);\n      node.resetSequenceEdges();\n      node.resetSpatialEdges();\n      nodes.push(node);\n    }\n\n    for (var _a = 0, _b = Object.keys(this._cachedNodes); _a < _b.length; _a++) {\n      var cachedKey = _b[_a];\n\n      if (keepKeys.indexOf(cachedKey) !== -1) {\n        continue;\n      }\n\n      this._cachedNodes[cachedKey].node.dispose();\n\n      delete this._cachedNodes[cachedKey];\n    }\n\n    this._cachedNodeTiles = {};\n    this._cachedSpatialEdges = {};\n    this._cachedTiles = {};\n    this._cachingFill$ = {};\n    this._cachingFull$ = {};\n    this._cachingSequences$ = {};\n    this._cachingSpatialArea$ = {};\n    this._cachingTiles$ = {};\n    this._nodes = {};\n    this._nodeToTile = {};\n    this._preStored = {};\n\n    for (var _c = 0, nodes_2 = nodes; _c < nodes_2.length; _c++) {\n      var node = nodes_2[_c];\n      this._nodes[node.key] = node;\n\n      var h = this._graphCalculator.encodeH(node.originalLatLon, this._tilePrecision);\n\n      this._preStore(h, node);\n    }\n\n    this._requiredNodeTiles = {};\n    this._requiredSpatialArea = {};\n    this._sequences = {};\n    this._nodeIndexTiles = {};\n\n    this._nodeIndex.clear();\n  };\n  /**\n   * Set the spatial node filter.\n   *\n   * @param {FilterExpression} filter - Filter expression to be applied\n   * when calculating spatial edges.\n   */\n\n\n  Graph.prototype.setFilter = function (filter) {\n    this._filter = this._filterCreator.createFilter(filter);\n  };\n  /**\n   * Uncache the graph according to the graph configuration.\n   *\n   * @description Uncaches unused tiles, unused nodes and\n   * sequences according to the numbers specified in the\n   * graph configuration. Sequences does not have a direct\n   * reference to either tiles or nodes and may be uncached\n   * even if they are related to the nodes that should be kept.\n   *\n   * @param {Array<string>} keepKeys - Keys of nodes to keep in\n   * graph unrelated to last access. Tiles related to those keys\n   * will also be kept in graph.\n   * @param {string} keepSequenceKey - Optional key of sequence\n   * for which the belonging nodes should not be disposed or\n   * removed from the graph. These nodes may still be uncached if\n   * not specified in keep keys param.\n   */\n\n\n  Graph.prototype.uncache = function (keepKeys, keepSequenceKey) {\n    var keysInUse = {};\n\n    this._addNewKeys(keysInUse, this._cachingFull$);\n\n    this._addNewKeys(keysInUse, this._cachingFill$);\n\n    this._addNewKeys(keysInUse, this._cachingSpatialArea$);\n\n    this._addNewKeys(keysInUse, this._requiredNodeTiles);\n\n    this._addNewKeys(keysInUse, this._requiredSpatialArea);\n\n    for (var _i = 0, keepKeys_2 = keepKeys; _i < keepKeys_2.length; _i++) {\n      var key = keepKeys_2[_i];\n\n      if (key in keysInUse) {\n        continue;\n      }\n\n      keysInUse[key] = true;\n    }\n\n    var keepHs = {};\n\n    for (var key in keysInUse) {\n      if (!keysInUse.hasOwnProperty(key)) {\n        continue;\n      }\n\n      var node = this._nodes[key];\n\n      var nodeHs = this._graphCalculator.encodeHs(node.latLon);\n\n      for (var _a = 0, nodeHs_1 = nodeHs; _a < nodeHs_1.length; _a++) {\n        var nodeH = nodeHs_1[_a];\n\n        if (!(nodeH in keepHs)) {\n          keepHs[nodeH] = true;\n        }\n      }\n    }\n\n    var potentialHs = [];\n\n    for (var h in this._cachedTiles) {\n      if (!this._cachedTiles.hasOwnProperty(h) || h in keepHs) {\n        continue;\n      }\n\n      potentialHs.push([h, this._cachedTiles[h]]);\n    }\n\n    var uncacheHs = potentialHs.sort(function (h1, h2) {\n      return h2[1].accessed - h1[1].accessed;\n    }).slice(this._configuration.maxUnusedTiles).map(function (h) {\n      return h[0];\n    });\n\n    for (var _b = 0, uncacheHs_1 = uncacheHs; _b < uncacheHs_1.length; _b++) {\n      var uncacheH = uncacheHs_1[_b];\n\n      this._uncacheTile(uncacheH, keepSequenceKey);\n    }\n\n    var potentialPreStored = [];\n    var nonCachedPreStored = [];\n\n    for (var h in this._preStored) {\n      if (!this._preStored.hasOwnProperty(h) || h in this._cachingTiles$) {\n        continue;\n      }\n\n      var prestoredNodes = this._preStored[h];\n\n      for (var key in prestoredNodes) {\n        if (!prestoredNodes.hasOwnProperty(key) || key in keysInUse) {\n          continue;\n        }\n\n        if (prestoredNodes[key].sequenceKey === keepSequenceKey) {\n          continue;\n        }\n\n        if (key in this._cachedNodes) {\n          potentialPreStored.push([this._cachedNodes[key], h]);\n        } else {\n          nonCachedPreStored.push([key, h]);\n        }\n      }\n    }\n\n    var uncachePreStored = potentialPreStored.sort(function (_a, _b) {\n      var na1 = _a[0],\n          h1 = _a[1];\n      var na2 = _b[0],\n          h2 = _b[1];\n      return na2.accessed - na1.accessed;\n    }).slice(this._configuration.maxUnusedPreStoredNodes).map(function (_a) {\n      var na = _a[0],\n          h = _a[1];\n      return [na.node.key, h];\n    });\n\n    this._uncachePreStored(nonCachedPreStored);\n\n    this._uncachePreStored(uncachePreStored);\n\n    var potentialNodes = [];\n\n    for (var key in this._cachedNodes) {\n      if (!this._cachedNodes.hasOwnProperty(key) || key in keysInUse) {\n        continue;\n      }\n\n      potentialNodes.push(this._cachedNodes[key]);\n    }\n\n    var uncacheNodes = potentialNodes.sort(function (n1, n2) {\n      return n2.accessed - n1.accessed;\n    }).slice(this._configuration.maxUnusedNodes);\n\n    for (var _c = 0, uncacheNodes_1 = uncacheNodes; _c < uncacheNodes_1.length; _c++) {\n      var nodeAccess = uncacheNodes_1[_c];\n      nodeAccess.node.uncache();\n      var key = nodeAccess.node.key;\n      delete this._cachedNodes[key];\n\n      if (key in this._cachedNodeTiles) {\n        delete this._cachedNodeTiles[key];\n      }\n\n      if (key in this._cachedSpatialEdges) {\n        delete this._cachedSpatialEdges[key];\n      }\n    }\n\n    var potentialSequences = [];\n\n    for (var sequenceKey in this._sequences) {\n      if (!this._sequences.hasOwnProperty(sequenceKey) || sequenceKey in this._cachingSequences$ || sequenceKey === keepSequenceKey) {\n        continue;\n      }\n\n      potentialSequences.push(this._sequences[sequenceKey]);\n    }\n\n    var uncacheSequences = potentialSequences.sort(function (s1, s2) {\n      return s2.accessed - s1.accessed;\n    }).slice(this._configuration.maxSequences);\n\n    for (var _d = 0, uncacheSequences_1 = uncacheSequences; _d < uncacheSequences_1.length; _d++) {\n      var sequenceAccess = uncacheSequences_1[_d];\n      var sequenceKey = sequenceAccess.sequence.key;\n      delete this._sequences[sequenceKey];\n\n      if (sequenceKey in this._cachedSequenceNodes) {\n        delete this._cachedSequenceNodes[sequenceKey];\n      }\n\n      sequenceAccess.sequence.dispose();\n    }\n  };\n\n  Graph.prototype._addNewKeys = function (keys, dict) {\n    for (var key in dict) {\n      if (!dict.hasOwnProperty(key) || !this.hasNode(key)) {\n        continue;\n      }\n\n      if (!(key in keys)) {\n        keys[key] = true;\n      }\n    }\n  };\n\n  Graph.prototype._cacheSequence$ = function (sequenceKey) {\n    var _this = this;\n\n    if (sequenceKey in this._cachingSequences$) {\n      return this._cachingSequences$[sequenceKey];\n    }\n\n    this._cachingSequences$[sequenceKey] = this._apiV3.sequenceByKey$([sequenceKey]).pipe(operators_1.tap(function (sequenceByKey) {\n      if (!(sequenceKey in _this._sequences)) {\n        _this._sequences[sequenceKey] = {\n          accessed: new Date().getTime(),\n          sequence: new Graph_1.Sequence(sequenceByKey[sequenceKey])\n        };\n      }\n\n      delete _this._cachingSequences$[sequenceKey];\n    }), operators_1.map(function (sequenceByKey) {\n      return _this;\n    }), operators_1.finalize(function () {\n      if (sequenceKey in _this._cachingSequences$) {\n        delete _this._cachingSequences$[sequenceKey];\n      }\n\n      _this._changed$.next(_this);\n    }), operators_1.publish(), operators_1.refCount());\n    return this._cachingSequences$[sequenceKey];\n  };\n\n  Graph.prototype._cacheTile$ = function (h) {\n    var _this = this;\n\n    this._cachingTiles$[h] = this._apiV3.imagesByH$([h]).pipe(operators_1.tap(function (imagesByH) {\n      var coreNodes = imagesByH[h];\n\n      if (h in _this._cachedTiles) {\n        return;\n      }\n\n      _this._nodeIndexTiles[h] = [];\n      _this._cachedTiles[h] = {\n        accessed: new Date().getTime(),\n        nodes: []\n      };\n      var hCache = _this._cachedTiles[h].nodes;\n\n      var preStored = _this._removeFromPreStore(h);\n\n      for (var index in coreNodes) {\n        if (!coreNodes.hasOwnProperty(index)) {\n          continue;\n        }\n\n        var coreNode = coreNodes[index];\n\n        if (coreNode == null) {\n          break;\n        }\n\n        if (coreNode.sequence_key == null) {\n          console.warn(\"Sequence missing, discarding node (\" + coreNode.key + \")\");\n          continue;\n        }\n\n        if (preStored != null && coreNode.key in preStored) {\n          var preStoredNode = preStored[coreNode.key];\n          delete preStored[coreNode.key];\n          hCache.push(preStoredNode);\n          var preStoredNodeIndexItem = {\n            lat: preStoredNode.latLon.lat,\n            lon: preStoredNode.latLon.lon,\n            node: preStoredNode\n          };\n\n          _this._nodeIndex.insert(preStoredNodeIndexItem);\n\n          _this._nodeIndexTiles[h].push(preStoredNodeIndexItem);\n\n          _this._nodeToTile[preStoredNode.key] = h;\n          continue;\n        }\n\n        var node = new Graph_1.Node(coreNode);\n        hCache.push(node);\n        var nodeIndexItem = {\n          lat: node.latLon.lat,\n          lon: node.latLon.lon,\n          node: node\n        };\n\n        _this._nodeIndex.insert(nodeIndexItem);\n\n        _this._nodeIndexTiles[h].push(nodeIndexItem);\n\n        _this._nodeToTile[node.key] = h;\n\n        _this._setNode(node);\n      }\n\n      delete _this._cachingTiles$[h];\n    }), operators_1.map(function (imagesByH) {\n      return _this;\n    }), operators_1.catchError(function (error) {\n      delete _this._cachingTiles$[h];\n      throw error;\n    }), operators_1.publish(), operators_1.refCount());\n    return this._cachingTiles$[h];\n  };\n\n  Graph.prototype._makeFull = function (node, fillNode) {\n    if (fillNode.calt == null) {\n      fillNode.calt = this._defaultAlt;\n    }\n\n    if (fillNode.c_rotation == null) {\n      fillNode.c_rotation = this._graphCalculator.rotationFromCompass(fillNode.ca, fillNode.orientation);\n    }\n\n    node.makeFull(fillNode);\n  };\n\n  Graph.prototype._preStore = function (h, node) {\n    if (!(h in this._preStored)) {\n      this._preStored[h] = {};\n    }\n\n    this._preStored[h][node.key] = node;\n  };\n\n  Graph.prototype._removeFromPreStore = function (h) {\n    var preStored = null;\n\n    if (h in this._preStored) {\n      preStored = this._preStored[h];\n      delete this._preStored[h];\n    }\n\n    return preStored;\n  };\n\n  Graph.prototype._setNode = function (node) {\n    var key = node.key;\n\n    if (this.hasNode(key)) {\n      throw new Error_1.GraphMapillaryError(\"Node already exist (\" + key + \").\");\n    }\n\n    this._nodes[key] = node;\n  };\n\n  Graph.prototype._uncacheTile = function (h, keepSequenceKey) {\n    for (var _i = 0, _a = this._cachedTiles[h].nodes; _i < _a.length; _i++) {\n      var node = _a[_i];\n      var key = node.key;\n      delete this._nodeToTile[key];\n\n      if (key in this._cachedNodes) {\n        delete this._cachedNodes[key];\n      }\n\n      if (key in this._cachedNodeTiles) {\n        delete this._cachedNodeTiles[key];\n      }\n\n      if (key in this._cachedSpatialEdges) {\n        delete this._cachedSpatialEdges[key];\n      }\n\n      if (node.sequenceKey === keepSequenceKey) {\n        this._preStore(h, node);\n\n        node.uncache();\n      } else {\n        delete this._nodes[key];\n\n        if (node.sequenceKey in this._cachedSequenceNodes) {\n          delete this._cachedSequenceNodes[node.sequenceKey];\n        }\n\n        node.dispose();\n      }\n    }\n\n    for (var _b = 0, _c = this._nodeIndexTiles[h]; _b < _c.length; _b++) {\n      var nodeIndexItem = _c[_b];\n\n      this._nodeIndex.remove(nodeIndexItem);\n    }\n\n    delete this._nodeIndexTiles[h];\n    delete this._cachedTiles[h];\n  };\n\n  Graph.prototype._uncachePreStored = function (preStored) {\n    var hs = {};\n\n    for (var _i = 0, preStored_1 = preStored; _i < preStored_1.length; _i++) {\n      var _a = preStored_1[_i],\n          key = _a[0],\n          h = _a[1];\n\n      if (key in this._nodes) {\n        delete this._nodes[key];\n      }\n\n      if (key in this._cachedNodes) {\n        delete this._cachedNodes[key];\n      }\n\n      var node = this._preStored[h][key];\n\n      if (node.sequenceKey in this._cachedSequenceNodes) {\n        delete this._cachedSequenceNodes[node.sequenceKey];\n      }\n\n      delete this._preStored[h][key];\n      node.dispose();\n      hs[h] = true;\n    }\n\n    for (var h in hs) {\n      if (!hs.hasOwnProperty(h)) {\n        continue;\n      }\n\n      if (Object.keys(this._preStored[h]).length === 0) {\n        delete this._preStored[h];\n      }\n    }\n  };\n\n  Graph.prototype._updateCachedTileAccess = function (key, accessed) {\n    if (key in this._nodeToTile) {\n      this._cachedTiles[this._nodeToTile[key]].accessed = accessed;\n    }\n  };\n\n  Graph.prototype._updateCachedNodeAccess = function (key, accessed) {\n    if (key in this._cachedNodes) {\n      this._cachedNodes[key].accessed = accessed;\n    }\n  };\n\n  return Graph;\n}();\n\nexports.Graph = Graph;\nexports.default = Graph;\n\n//# sourceURL=webpack://Mapillary/./src/graph/Graph.ts?");

/***/ }),

/***/ "./src/graph/GraphCalculator.ts":
/*!**************************************!*\
  !*** ./src/graph/GraphCalculator.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar geohash = __webpack_require__(/*! latlon-geohash */ \"./node_modules/latlon-geohash/latlon-geohash.js\");\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar Error_1 = __webpack_require__(/*! ../Error */ \"./src/Error.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../Geo */ \"./src/Geo.ts\");\n/**\n * @class GraphCalculator\n *\n * @classdesc Represents a calculator for graph entities.\n */\n\n\nvar GraphCalculator =\n/** @class */\nfunction () {\n  /**\n   * Create a new graph calculator instance.\n   *\n   * @param {GeoCoords} geoCoords - Geo coords instance.\n   */\n  function GraphCalculator(geoCoords) {\n    this._geoCoords = geoCoords != null ? geoCoords : new Geo_1.GeoCoords();\n  }\n  /**\n   * Encode the geohash tile for geodetic coordinates.\n   *\n   * @param {ILatLon} latlon - Latitude and longitude to encode.\n   * @param {number} precision - Precision of the encoding.\n   *\n   * @returns {string} The geohash tile for the lat, lon and precision.\n   */\n\n\n  GraphCalculator.prototype.encodeH = function (latLon, precision) {\n    if (precision === void 0) {\n      precision = 7;\n    }\n\n    return geohash.encode(latLon.lat, latLon.lon, precision);\n  };\n  /**\n   * Encode the geohash tiles within a threshold from a position\n   * using Manhattan distance.\n   *\n   * @param {ILatLon} latlon - Latitude and longitude to encode.\n   * @param {number} precision - Precision of the encoding.\n   * @param {number} threshold - Threshold of the encoding in meters.\n   *\n   * @returns {string} The geohash tiles reachable within the threshold.\n   */\n\n\n  GraphCalculator.prototype.encodeHs = function (latLon, precision, threshold) {\n    if (precision === void 0) {\n      precision = 7;\n    }\n\n    if (threshold === void 0) {\n      threshold = 20;\n    }\n\n    var h = geohash.encode(latLon.lat, latLon.lon, precision);\n    var bounds = geohash.bounds(h);\n    var ne = bounds.ne;\n    var sw = bounds.sw;\n    var neighbours = geohash.neighbours(h);\n    var bl = [0, 0, 0];\n\n    var tr = this._geoCoords.geodeticToEnu(ne.lat, ne.lon, 0, sw.lat, sw.lon, 0);\n\n    var position = this._geoCoords.geodeticToEnu(latLon.lat, latLon.lon, 0, sw.lat, sw.lon, 0);\n\n    var left = position[0] - bl[0];\n    var right = tr[0] - position[0];\n    var bottom = position[1] - bl[1];\n    var top = tr[1] - position[1];\n    var l = left < threshold;\n    var r = right < threshold;\n    var b = bottom < threshold;\n    var t = top < threshold;\n    var hs = [h];\n\n    if (t) {\n      hs.push(neighbours.n);\n    }\n\n    if (t && l) {\n      hs.push(neighbours.nw);\n    }\n\n    if (l) {\n      hs.push(neighbours.w);\n    }\n\n    if (l && b) {\n      hs.push(neighbours.sw);\n    }\n\n    if (b) {\n      hs.push(neighbours.s);\n    }\n\n    if (b && r) {\n      hs.push(neighbours.se);\n    }\n\n    if (r) {\n      hs.push(neighbours.e);\n    }\n\n    if (r && t) {\n      hs.push(neighbours.ne);\n    }\n\n    return hs;\n  };\n  /**\n   * Encode the minimum set of geohash tiles containing a bounding box.\n   *\n   * @description The current algorithm does expect the bounding box\n   * to be sufficiently small to be contained in an area with the size\n   * of maximally four tiles. Up to nine adjacent tiles may be returned.\n   * The method currently uses the largest side as the threshold leading to\n   * more tiles being returned than needed in edge cases.\n   *\n   * @param {ILatLon} sw - South west corner of bounding box.\n   * @param {ILatLon} ne - North east corner of bounding box.\n   * @param {number} precision - Precision of the encoding.\n   *\n   * @returns {string} The geohash tiles containing the bounding box.\n   */\n\n\n  GraphCalculator.prototype.encodeHsFromBoundingBox = function (sw, ne, precision) {\n    if (precision === void 0) {\n      precision = 7;\n    }\n\n    if (ne.lat <= sw.lat || ne.lon <= sw.lon) {\n      throw new Error_1.GraphMapillaryError(\"North east needs to be top right of south west\");\n    }\n\n    var centerLat = (sw.lat + ne.lat) / 2;\n    var centerLon = (sw.lon + ne.lon) / 2;\n\n    var enu = this._geoCoords.geodeticToEnu(ne.lat, ne.lon, 0, centerLat, centerLon, 0);\n\n    var threshold = Math.max(enu[0], enu[1]);\n    return this.encodeHs({\n      lat: centerLat,\n      lon: centerLon\n    }, precision, threshold);\n  };\n  /**\n   * Get the bounding box corners for a circle with radius of a threshold\n   * with center in a geodetic position.\n   *\n   * @param {ILatLon} latlon - Latitude and longitude to encode.\n   * @param {number} threshold - Threshold distance from the position in meters.\n   *\n   * @returns {Array<ILatLon>} The south west and north east corners of the\n   * bounding box.\n   */\n\n\n  GraphCalculator.prototype.boundingBoxCorners = function (latLon, threshold) {\n    var bl = this._geoCoords.enuToGeodetic(-threshold, -threshold, 0, latLon.lat, latLon.lon, 0);\n\n    var tr = this._geoCoords.enuToGeodetic(threshold, threshold, 0, latLon.lat, latLon.lon, 0);\n\n    return [{\n      lat: bl[0],\n      lon: bl[1]\n    }, {\n      lat: tr[0],\n      lon: tr[1]\n    }];\n  };\n  /**\n   * Convert a compass angle to an angle axis rotation vector.\n   *\n   * @param {number} compassAngle - The compass angle in degrees.\n   * @param {number} orientation - The orientation of the original image.\n   *\n   * @returns {Array<number>} Angle axis rotation vector.\n   */\n\n\n  GraphCalculator.prototype.rotationFromCompass = function (compassAngle, orientation) {\n    var x = 0;\n    var y = 0;\n    var z = 0;\n\n    switch (orientation) {\n      case 1:\n        x = Math.PI / 2;\n        break;\n\n      case 3:\n        x = -Math.PI / 2;\n        z = Math.PI;\n        break;\n\n      case 6:\n        y = -Math.PI / 2;\n        z = -Math.PI / 2;\n        break;\n\n      case 8:\n        y = Math.PI / 2;\n        z = Math.PI / 2;\n        break;\n\n      default:\n        break;\n    }\n\n    var rz = new THREE.Matrix4().makeRotationZ(z);\n    var euler = new THREE.Euler(x, y, compassAngle * Math.PI / 180, \"XYZ\");\n    var re = new THREE.Matrix4().makeRotationFromEuler(euler);\n    var rotation = new THREE.Vector4().setAxisAngleFromRotationMatrix(re.multiply(rz));\n    return rotation.multiplyScalar(rotation.w).toArray().slice(0, 3);\n  };\n\n  return GraphCalculator;\n}();\n\nexports.GraphCalculator = GraphCalculator;\nexports.default = GraphCalculator;\n\n//# sourceURL=webpack://Mapillary/./src/graph/GraphCalculator.ts?");

/***/ }),

/***/ "./src/graph/GraphMode.ts":
/*!********************************!*\
  !*** ./src/graph/GraphMode.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enumeration for graph modes.\n * @enum {number}\n * @readonly\n * @description Modes for the retrieval and caching performed\n * by the graph service on the graph.\n */\n\nvar GraphMode;\n\n(function (GraphMode) {\n  /**\n   * Caching is performed on sequences only and sequence edges are\n   * calculated. Spatial tiles\n   * are not retrieved and spatial edges are not calculated when\n   * caching nodes. Complete sequences are being cached for requested\n   * nodes within the graph.\n   */\n  GraphMode[GraphMode[\"Sequence\"] = 0] = \"Sequence\";\n  /**\n   * Caching is performed with emphasis on spatial data. Sequence edges\n   * as well as spatial edges are cached. Sequence data\n   * is still requested but complete sequences are not being cached\n   * for requested nodes.\n   *\n   * This is the initial mode of the graph service.\n   */\n\n  GraphMode[GraphMode[\"Spatial\"] = 1] = \"Spatial\";\n})(GraphMode = exports.GraphMode || (exports.GraphMode = {}));\n\nexports.default = GraphMode;\n\n//# sourceURL=webpack://Mapillary/./src/graph/GraphMode.ts?");

/***/ }),

/***/ "./src/graph/GraphService.ts":
/*!***********************************!*\
  !*** ./src/graph/GraphService.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Graph_1 = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n/**\n * @class GraphService\n *\n * @classdesc Represents a service for graph operations.\n */\n\n\nvar GraphService =\n/** @class */\nfunction () {\n  /**\n   * Create a new graph service instance.\n   *\n   * @param {Graph} graph - Graph instance to be operated on.\n   */\n  function GraphService(graph, imageLoadingService) {\n    this._graph$ = rxjs_1.concat(rxjs_1.of(graph), graph.changed$).pipe(operators_1.publishReplay(1), operators_1.refCount());\n\n    this._graph$.subscribe(function () {});\n\n    this._graphMode = Graph_1.GraphMode.Spatial;\n    this._graphModeSubject$ = new rxjs_1.Subject();\n    this._graphMode$ = this._graphModeSubject$.pipe(operators_1.startWith(this._graphMode), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._graphMode$.subscribe(function () {});\n\n    this._imageLoadingService = imageLoadingService;\n    this._firstGraphSubjects$ = [];\n    this._initializeCacheSubscriptions = [];\n    this._sequenceSubscriptions = [];\n    this._spatialSubscriptions = [];\n  }\n\n  Object.defineProperty(GraphService.prototype, \"graphMode$\", {\n    /**\n     * Get graph mode observable.\n     *\n     * @description Emits the current graph mode.\n     *\n     * @returns {Observable<GraphMode>} Observable\n     * emitting the current graph mode when it changes.\n     */\n    get: function get() {\n      return this._graphMode$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Cache full nodes in a bounding box.\n   *\n   * @description When called, the full properties of\n   * the node are retrieved. The node cache is not initialized\n   * for any new nodes retrieved and the node assets are not\n   * retrieved, {@link cacheNode$} needs to be called for caching\n   * assets.\n   *\n   * @param {ILatLon} sw - South west corner of bounding box.\n   * @param {ILatLon} ne - North east corner of bounding box.\n   * @return {Observable<Array<Node>>} Observable emitting a single item,\n   * the nodes of the bounding box, when they have all been retrieved.\n   * @throws {Error} Propagates any IO node caching errors to the caller.\n   */\n\n  GraphService.prototype.cacheBoundingBox$ = function (sw, ne) {\n    return this._graph$.pipe(operators_1.first(), operators_1.mergeMap(function (graph) {\n      return graph.cacheBoundingBox$(sw, ne);\n    }));\n  };\n  /**\n   * Cache a node in the graph and retrieve it.\n   *\n   * @description When called, the full properties of\n   * the node are retrieved and the node cache is initialized.\n   * After that the node assets are cached and the node\n   * is emitted to the observable when.\n   * In parallel to caching the node assets, the sequence and\n   * spatial edges of the node are cached. For this, the sequence\n   * of the node and the required tiles and spatial nodes are\n   * retrieved. The sequence and spatial edges may be set before\n   * or after the node is returned.\n   *\n   * @param {string} key - Key of the node to cache.\n   * @return {Observable<Node>} Observable emitting a single item,\n   * the node, when it has been retrieved and its assets are cached.\n   * @throws {Error} Propagates any IO node caching errors to the caller.\n   */\n\n\n  GraphService.prototype.cacheNode$ = function (key) {\n    var _this = this;\n\n    var firstGraphSubject$ = new rxjs_1.Subject();\n\n    this._firstGraphSubjects$.push(firstGraphSubject$);\n\n    var firstGraph$ = firstGraphSubject$.pipe(operators_1.publishReplay(1), operators_1.refCount());\n    var node$ = firstGraph$.pipe(operators_1.map(function (graph) {\n      return graph.getNode(key);\n    }), operators_1.mergeMap(function (node) {\n      return node.assetsCached ? rxjs_1.of(node) : node.cacheAssets$();\n    }), operators_1.publishReplay(1), operators_1.refCount());\n    node$.subscribe(function (node) {\n      _this._imageLoadingService.loadnode$.next(node);\n    }, function (error) {\n      console.error(\"Failed to cache node (\" + key + \")\", error);\n    });\n\n    var initializeCacheSubscription = this._graph$.pipe(operators_1.first(), operators_1.mergeMap(function (graph) {\n      if (graph.isCachingFull(key) || !graph.hasNode(key)) {\n        return graph.cacheFull$(key);\n      }\n\n      if (graph.isCachingFill(key) || !graph.getNode(key).full) {\n        return graph.cacheFill$(key);\n      }\n\n      return rxjs_1.of(graph);\n    }), operators_1.tap(function (graph) {\n      if (!graph.hasInitializedCache(key)) {\n        graph.initializeCache(key);\n      }\n    }), operators_1.finalize(function () {\n      if (initializeCacheSubscription == null) {\n        return;\n      }\n\n      _this._removeFromArray(initializeCacheSubscription, _this._initializeCacheSubscriptions);\n\n      _this._removeFromArray(firstGraphSubject$, _this._firstGraphSubjects$);\n    })).subscribe(function (graph) {\n      firstGraphSubject$.next(graph);\n      firstGraphSubject$.complete();\n    }, function (error) {\n      firstGraphSubject$.error(error);\n    });\n\n    if (!initializeCacheSubscription.closed) {\n      this._initializeCacheSubscriptions.push(initializeCacheSubscription);\n    }\n\n    var graphSequence$ = firstGraph$.pipe(operators_1.mergeMap(function (graph) {\n      if (graph.isCachingNodeSequence(key) || !graph.hasNodeSequence(key)) {\n        return graph.cacheNodeSequence$(key);\n      }\n\n      return rxjs_1.of(graph);\n    }), operators_1.publishReplay(1), operators_1.refCount());\n    var sequenceSubscription = graphSequence$.pipe(operators_1.tap(function (graph) {\n      if (!graph.getNode(key).sequenceEdges.cached) {\n        graph.cacheSequenceEdges(key);\n      }\n    }), operators_1.finalize(function () {\n      if (sequenceSubscription == null) {\n        return;\n      }\n\n      _this._removeFromArray(sequenceSubscription, _this._sequenceSubscriptions);\n    })).subscribe(function (graph) {\n      return;\n    }, function (error) {\n      console.error(\"Failed to cache sequence edges (\" + key + \").\", error);\n    });\n\n    if (!sequenceSubscription.closed) {\n      this._sequenceSubscriptions.push(sequenceSubscription);\n    }\n\n    if (this._graphMode === Graph_1.GraphMode.Spatial) {\n      var spatialSubscription_1 = firstGraph$.pipe(operators_1.expand(function (graph) {\n        if (graph.hasTiles(key)) {\n          return rxjs_1.empty();\n        }\n\n        return rxjs_1.from(graph.cacheTiles$(key)).pipe(operators_1.mergeMap(function (graph$) {\n          return graph$.pipe(operators_1.mergeMap(function (g) {\n            if (g.isCachingTiles(key)) {\n              return rxjs_1.empty();\n            }\n\n            return rxjs_1.of(g);\n          }), operators_1.catchError(function (error, caught$) {\n            console.error(\"Failed to cache tile data (\" + key + \").\", error);\n            return rxjs_1.empty();\n          }));\n        }));\n      }), operators_1.last(), operators_1.mergeMap(function (graph) {\n        if (graph.hasSpatialArea(key)) {\n          return rxjs_1.of(graph);\n        }\n\n        return rxjs_1.from(graph.cacheSpatialArea$(key)).pipe(operators_1.mergeMap(function (graph$) {\n          return graph$.pipe(operators_1.catchError(function (error, caught$) {\n            console.error(\"Failed to cache spatial nodes (\" + key + \").\", error);\n            return rxjs_1.empty();\n          }));\n        }));\n      }), operators_1.last(), operators_1.mergeMap(function (graph) {\n        return graph.hasNodeSequence(key) ? rxjs_1.of(graph) : graph.cacheNodeSequence$(key);\n      }), operators_1.tap(function (graph) {\n        if (!graph.getNode(key).spatialEdges.cached) {\n          graph.cacheSpatialEdges(key);\n        }\n      }), operators_1.finalize(function () {\n        if (spatialSubscription_1 == null) {\n          return;\n        }\n\n        _this._removeFromArray(spatialSubscription_1, _this._spatialSubscriptions);\n      })).subscribe(function (graph) {\n        return;\n      }, function (error) {\n        console.error(\"Failed to cache spatial edges (\" + key + \").\", error);\n      });\n\n      if (!spatialSubscription_1.closed) {\n        this._spatialSubscriptions.push(spatialSubscription_1);\n      }\n    }\n\n    return node$.pipe(operators_1.first(function (node) {\n      return node.assetsCached;\n    }));\n  };\n  /**\n   * Cache a sequence in the graph and retrieve it.\n   *\n   * @param {string} sequenceKey - Sequence key.\n   * @returns {Observable<Sequence>} Observable emitting a single item,\n   * the sequence, when it has been retrieved and its assets are cached.\n   * @throws {Error} Propagates any IO node caching errors to the caller.\n   */\n\n\n  GraphService.prototype.cacheSequence$ = function (sequenceKey) {\n    return this._graph$.pipe(operators_1.first(), operators_1.mergeMap(function (graph) {\n      if (graph.isCachingSequence(sequenceKey) || !graph.hasSequence(sequenceKey)) {\n        return graph.cacheSequence$(sequenceKey);\n      }\n\n      return rxjs_1.of(graph);\n    }), operators_1.map(function (graph) {\n      return graph.getSequence(sequenceKey);\n    }));\n  };\n  /**\n   * Cache a sequence and its nodes in the graph and retrieve the sequence.\n   *\n   * @description Caches a sequence and its assets are cached and\n   * retrieves all nodes belonging to the sequence. The node assets\n   * or edges will not be cached.\n   *\n   * @param {string} sequenceKey - Sequence key.\n   * @param {string} referenceNodeKey - Key of node to use as reference\n   * for optimized caching.\n   * @returns {Observable<Sequence>} Observable emitting a single item,\n   * the sequence, when it has been retrieved, its assets are cached and\n   * all nodes belonging to the sequence has been retrieved.\n   * @throws {Error} Propagates any IO node caching errors to the caller.\n   */\n\n\n  GraphService.prototype.cacheSequenceNodes$ = function (sequenceKey, referenceNodeKey) {\n    return this._graph$.pipe(operators_1.first(), operators_1.mergeMap(function (graph) {\n      if (graph.isCachingSequence(sequenceKey) || !graph.hasSequence(sequenceKey)) {\n        return graph.cacheSequence$(sequenceKey);\n      }\n\n      return rxjs_1.of(graph);\n    }), operators_1.mergeMap(function (graph) {\n      if (graph.isCachingSequenceNodes(sequenceKey) || !graph.hasSequenceNodes(sequenceKey)) {\n        return graph.cacheSequenceNodes$(sequenceKey, referenceNodeKey);\n      }\n\n      return rxjs_1.of(graph);\n    }), operators_1.map(function (graph) {\n      return graph.getSequence(sequenceKey);\n    }));\n  };\n  /**\n   * Set a spatial edge filter on the graph.\n   *\n   * @description Resets the spatial edges of all cached nodes.\n   *\n   * @param {FilterExpression} filter - Filter expression to be applied.\n   * @return {Observable<Graph>} Observable emitting a single item,\n   * the graph, when the spatial edges have been reset.\n   */\n\n\n  GraphService.prototype.setFilter$ = function (filter) {\n    this._resetSubscriptions(this._spatialSubscriptions);\n\n    return this._graph$.pipe(operators_1.first(), operators_1.tap(function (graph) {\n      graph.resetSpatialEdges();\n      graph.setFilter(filter);\n    }), operators_1.map(function (graph) {\n      return undefined;\n    }));\n  };\n  /**\n   * Set the graph mode.\n   *\n   * @description If graph mode is set to spatial, caching\n   * is performed with emphasis on spatial edges. If graph\n   * mode is set to sequence no tile data is requested and\n   * no spatial edges are computed.\n   *\n   * When setting graph mode to sequence all spatial\n   * subscriptions are aborted.\n   *\n   * @param {GraphMode} mode - Graph mode to set.\n   */\n\n\n  GraphService.prototype.setGraphMode = function (mode) {\n    if (this._graphMode === mode) {\n      return;\n    }\n\n    if (mode === Graph_1.GraphMode.Sequence) {\n      this._resetSubscriptions(this._spatialSubscriptions);\n    }\n\n    this._graphMode = mode;\n\n    this._graphModeSubject$.next(this._graphMode);\n  };\n  /**\n   * Reset the graph.\n   *\n   * @description Resets the graph but keeps the nodes of the\n   * supplied keys.\n   *\n   * @param {Array<string>} keepKeys - Keys of nodes to keep in graph.\n   * @return {Observable<Node>} Observable emitting a single item,\n   * the graph, when it has been reset.\n   */\n\n\n  GraphService.prototype.reset$ = function (keepKeys) {\n    this._abortSubjects(this._firstGraphSubjects$);\n\n    this._resetSubscriptions(this._initializeCacheSubscriptions);\n\n    this._resetSubscriptions(this._sequenceSubscriptions);\n\n    this._resetSubscriptions(this._spatialSubscriptions);\n\n    return this._graph$.pipe(operators_1.first(), operators_1.tap(function (graph) {\n      graph.reset(keepKeys);\n    }), operators_1.map(function (graph) {\n      return undefined;\n    }));\n  };\n  /**\n   * Uncache the graph.\n   *\n   * @description Uncaches the graph by removing tiles, nodes and\n   * sequences. Keeps the nodes of the supplied keys and the tiles\n   * related to those nodes.\n   *\n   * @param {Array<string>} keepKeys - Keys of nodes to keep in graph.\n   * @param {string} keepSequenceKey - Optional key of sequence\n   * for which the belonging nodes should not be disposed or\n   * removed from the graph. These nodes may still be uncached if\n   * not specified in keep keys param.\n   * @return {Observable<Graph>} Observable emitting a single item,\n   * the graph, when the graph has been uncached.\n   */\n\n\n  GraphService.prototype.uncache$ = function (keepKeys, keepSequenceKey) {\n    return this._graph$.pipe(operators_1.first(), operators_1.tap(function (graph) {\n      graph.uncache(keepKeys, keepSequenceKey);\n    }), operators_1.map(function (graph) {\n      return undefined;\n    }));\n  };\n\n  GraphService.prototype._abortSubjects = function (subjects) {\n    for (var _i = 0, _a = subjects.slice(); _i < _a.length; _i++) {\n      var subject = _a[_i];\n\n      this._removeFromArray(subject, subjects);\n\n      subject.error(new Error(\"Cache node request was aborted.\"));\n    }\n  };\n\n  GraphService.prototype._removeFromArray = function (object, objects) {\n    var index = objects.indexOf(object);\n\n    if (index !== -1) {\n      objects.splice(index, 1);\n    }\n  };\n\n  GraphService.prototype._resetSubscriptions = function (subscriptions) {\n    for (var _i = 0, _a = subscriptions.slice(); _i < _a.length; _i++) {\n      var subscription = _a[_i];\n\n      this._removeFromArray(subscription, subscriptions);\n\n      if (!subscription.closed) {\n        subscription.unsubscribe();\n      }\n    }\n  };\n\n  return GraphService;\n}();\n\nexports.GraphService = GraphService;\nexports.default = GraphService;\n\n//# sourceURL=webpack://Mapillary/./src/graph/GraphService.ts?");

/***/ }),

/***/ "./src/graph/ImageLoadingService.ts":
/*!******************************************!*\
  !*** ./src/graph/ImageLoadingService.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar ImageLoadingService =\n/** @class */\nfunction () {\n  function ImageLoadingService() {\n    this._loadnode$ = new rxjs_1.Subject();\n    this._loadstatus$ = this._loadnode$.pipe(operators_1.scan(function (_a, node) {\n      var nodes = _a[0];\n      var changed = false;\n\n      if (node.loadStatus.total === 0 || node.loadStatus.loaded === node.loadStatus.total) {\n        if (node.key in nodes) {\n          delete nodes[node.key];\n          changed = true;\n        }\n      } else {\n        nodes[node.key] = node.loadStatus;\n        changed = true;\n      }\n\n      return [nodes, changed];\n    }, [{}, false]), operators_1.filter(function (_a) {\n      var nodes = _a[0],\n          changed = _a[1];\n      return changed;\n    }), operators_1.map(function (_a) {\n      var nodes = _a[0];\n      return nodes;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._loadstatus$.subscribe(function () {});\n  }\n\n  Object.defineProperty(ImageLoadingService.prototype, \"loadnode$\", {\n    get: function get() {\n      return this._loadnode$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ImageLoadingService.prototype, \"loadstatus$\", {\n    get: function get() {\n      return this._loadstatus$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return ImageLoadingService;\n}();\n\nexports.ImageLoadingService = ImageLoadingService;\n\n//# sourceURL=webpack://Mapillary/./src/graph/ImageLoadingService.ts?");

/***/ }),

/***/ "./src/graph/MeshReader.ts":
/*!*********************************!*\
  !*** ./src/graph/MeshReader.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Pbf = __webpack_require__(/*! pbf */ \"./node_modules/pbf/index.js\");\n\nvar MeshReader =\n/** @class */\nfunction () {\n  function MeshReader() {}\n\n  MeshReader.read = function (buffer) {\n    var pbf = new Pbf(buffer);\n    return pbf.readFields(MeshReader._readMeshField, {\n      faces: [],\n      vertices: []\n    });\n  };\n\n  MeshReader._readMeshField = function (tag, mesh, pbf) {\n    if (tag === 1) {\n      mesh.vertices.push(pbf.readFloat());\n    } else if (tag === 2) {\n      mesh.faces.push(pbf.readVarint());\n    }\n  };\n\n  return MeshReader;\n}();\n\nexports.MeshReader = MeshReader;\n\n//# sourceURL=webpack://Mapillary/./src/graph/MeshReader.ts?");

/***/ }),

/***/ "./src/graph/Node.ts":
/*!***************************!*\
  !*** ./src/graph/Node.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n/**\n * @class Node\n *\n * @classdesc Represents a node in the navigation graph.\n *\n * Explanation of position and bearing properties:\n *\n * When images are uploaded they will have GPS information in the EXIF, this is what\n * is called `originalLatLon` {@link Node.originalLatLon}.\n *\n * When Structure from Motions has been run for a node a `computedLatLon` that\n * differs from the `originalLatLon` will be created. It is different because\n * GPS positions are not very exact and SfM aligns the camera positions according\n * to the 3D reconstruction {@link Node.computedLatLon}.\n *\n * At last there exist a `latLon` property which evaluates to\n * the `computedLatLon` from SfM if it exists but falls back\n * to the `originalLatLon` from the EXIF GPS otherwise {@link Node.latLon}.\n *\n * Everything that is done in in the Viewer is based on the SfM positions,\n * i.e. `computedLatLon`. That is why the smooth transitions go in the right\n * direction (nd not in strange directions because of bad GPS).\n *\n * E.g. when placing a marker in the Viewer it is relative to the SfM\n * position i.e. the `computedLatLon`.\n *\n * The same concept as above also applies to the compass angle (or bearing) properties\n * `originalCa`, `computedCa` and `ca`.\n */\n\n\nvar Node =\n/** @class */\nfunction () {\n  /**\n   * Create a new node instance.\n   *\n   * @description Nodes are always created internally by the library.\n   * Nodes can not be added to the library through any API method.\n   *\n   * @param {ICoreNode} coreNode - Raw core node data.\n   * @ignore\n   */\n  function Node(core) {\n    this._cache = null;\n    this._core = core;\n    this._fill = null;\n  }\n\n  Object.defineProperty(Node.prototype, \"assetsCached\", {\n    /**\n     * Get assets cached.\n     *\n     * @description The assets that need to be cached for this property\n     * to report true are the following: fill properties, image and mesh.\n     * The library ensures that the current node will always have the\n     * assets cached.\n     *\n     * @returns {boolean} Value indicating whether all assets have been\n     * cached.\n     *\n     * @ignore\n     */\n    get: function get() {\n      return this._core != null && this._fill != null && this._cache != null && this._cache.image != null && this._cache.mesh != null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"alt\", {\n    /**\n     * Get alt.\n     *\n     * @description If SfM has not been run the computed altitude is\n     * set to a default value of two meters.\n     *\n     * @returns {number} Altitude, in meters.\n     */\n    get: function get() {\n      return this._fill.calt;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"ca\", {\n    /**\n     * Get ca.\n     *\n     * @description If the SfM computed compass angle exists it will\n     * be returned, otherwise the original EXIF compass angle.\n     *\n     * @returns {number} Compass angle, measured in degrees\n     * clockwise with respect to north.\n     */\n    get: function get() {\n      return this._fill.cca != null ? this._fill.cca : this._fill.ca;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"cameraProjection\", {\n    /**\n     * Get cameraProjection.\n     *\n     * @description Will be undefined if SfM has not been run.\n     *\n     * @returns {number} The camera projection of the image.\n     */\n    get: function get() {\n      return this._fill.camera_projection_type;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"capturedAt\", {\n    /**\n     * Get capturedAt.\n     *\n     * @returns {number} Timestamp when the image was captured.\n     */\n    get: function get() {\n      return this._fill.captured_at;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"cameraUuid\", {\n    /**\n     * Get camera uuid.\n     *\n     * @description Will be undefined if the camera uuid was not\n     * recorded in the image exif information.\n     *\n     * @returns {string} Universally unique id for camera used\n     * when capturing image.\n     */\n    get: function get() {\n      return this._fill.captured_with_camera_uuid;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"ck1\", {\n    /**\n     * Get ck1.\n     *\n     * @description Will not be set if SfM has not been run.\n     *\n     * @returns {number} SfM computed radial distortion parameter\n     * k1.\n     */\n    get: function get() {\n      return this._fill.ck1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"ck2\", {\n    /**\n     * Get ck2.\n     *\n     * @description Will not be set if SfM has not been run.\n     *\n     * @returns {number} SfM computed radial distortion parameter\n     * k2.\n     */\n    get: function get() {\n      return this._fill.ck2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"computedCA\", {\n    /**\n     * Get computedCA.\n     *\n     * @description Will not be set if SfM has not been run.\n     *\n     * @returns {number} SfM computed compass angle, measured\n     * in degrees clockwise with respect to north.\n     */\n    get: function get() {\n      return this._fill.cca;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"computedLatLon\", {\n    /**\n     * Get computedLatLon.\n     *\n     * @description Will not be set if SfM has not been run.\n     *\n     * @returns {ILatLon} SfM computed latitude longitude in WGS84 datum,\n     * measured in degrees.\n     */\n    get: function get() {\n      return this._core.cl;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"focal\", {\n    /**\n     * Get focal.\n     *\n     * @description Will not be set if SfM has not been run.\n     *\n     * @returns {number} SfM computed focal length.\n     */\n    get: function get() {\n      return this._fill.cfocal;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"full\", {\n    /**\n     * Get full.\n     *\n     * @description The library ensures that the current node will\n     * always be full.\n     *\n     * @returns {boolean} Value indicating whether the node has all\n     * properties filled.\n     *\n     * @ignore\n     */\n    get: function get() {\n      return this._fill != null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"fullPano\", {\n    /**\n     * Get fullPano.\n     *\n     * @returns {boolean} Value indicating whether the node is a complete\n     * 360 panorama.\n     */\n    get: function get() {\n      return this._fill.gpano != null && this._fill.gpano.CroppedAreaLeftPixels === 0 && this._fill.gpano.CroppedAreaTopPixels === 0 && this._fill.gpano.CroppedAreaImageWidthPixels === this._fill.gpano.FullPanoWidthPixels && this._fill.gpano.CroppedAreaImageHeightPixels === this._fill.gpano.FullPanoHeightPixels;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"gpano\", {\n    /**\n     * Get gpano.\n     *\n     * @description Will not be set for non panoramic images.\n     *\n     * @returns {IGPano} Panorama information for panorama images.\n     */\n    get: function get() {\n      return this._fill.gpano;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"height\", {\n    /**\n     * Get height.\n     *\n     * @returns {number} Height of original image, not adjusted\n     * for orientation.\n     */\n    get: function get() {\n      return this._fill.height;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"image\", {\n    /**\n     * Get image.\n     *\n     * @description The image will always be set on the current node.\n     *\n     * @returns {HTMLImageElement} Cached image element of the node.\n     */\n    get: function get() {\n      return this._cache.image;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"image$\", {\n    /**\n     * Get image$.\n     *\n     * @returns {Observable<HTMLImageElement>} Observable emitting\n     * the cached image when it is updated.\n     *\n     * @ignore\n     */\n    get: function get() {\n      return this._cache.image$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"key\", {\n    /**\n     * Get key.\n     *\n     * @returns {string} Unique key of the node.\n     */\n    get: function get() {\n      return this._core.key;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"latLon\", {\n    /**\n     * Get latLon.\n     *\n     * @description If the SfM computed latitude longitude exist\n     * it will be returned, otherwise the original EXIF latitude\n     * longitude.\n     *\n     * @returns {ILatLon} Latitude longitude in WGS84 datum,\n     * measured in degrees.\n     */\n    get: function get() {\n      return this._core.cl != null ? this._core.cl : this._core.l;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"loadStatus\", {\n    /**\n     * Get loadStatus.\n     *\n     * @returns {ILoadStatus} Value indicating the load status\n     * of the mesh and image.\n     *\n     * @ignore\n     */\n    get: function get() {\n      return this._cache.loadStatus;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"merged\", {\n    /**\n     * Get merged.\n     *\n     * @returns {boolean} Value indicating whether SfM has been\n     * run on the node and the node has been merged into a\n     * connected component.\n     */\n    get: function get() {\n      return this._fill != null && this._fill.merge_version != null && this._fill.merge_version > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"mergeCC\", {\n    /**\n     * Get mergeCC.\n     *\n     * @description Will not be set if SfM has not yet been run on\n     * node.\n     *\n     * @returns {number} SfM connected component key to which\n     * image belongs.\n     */\n    get: function get() {\n      return this._fill.merge_cc;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"mergeVersion\", {\n    /**\n     * Get mergeVersion.\n     *\n     * @returns {number} Version for which SfM was run and image was merged.\n     */\n    get: function get() {\n      return this._fill.merge_version;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"mesh\", {\n    /**\n     * Get mesh.\n     *\n     * @description The mesh will always be set on the current node.\n     *\n     * @returns {IMesh} SfM triangulated mesh of reconstructed\n     * atomic 3D points.\n     */\n    get: function get() {\n      return this._cache.mesh;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"organizationKey\", {\n    /**\n     * Get organizationKey.\n     *\n     * @returns {string} Unique key of the organization to which\n     * the node belongs. If the node does not belong to an\n     * organization the organization key will be undefined.\n     */\n    get: function get() {\n      return this._fill.organization_key;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"orientation\", {\n    /**\n     * Get orientation.\n     *\n     * @returns {number} EXIF orientation of original image.\n     */\n    get: function get() {\n      return this._fill.orientation;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"originalCA\", {\n    /**\n     * Get originalCA.\n     *\n     * @returns {number} Original EXIF compass angle, measured in\n     * degrees.\n     */\n    get: function get() {\n      return this._fill.ca;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"originalLatLon\", {\n    /**\n     * Get originalLatLon.\n     *\n     * @returns {ILatLon} Original EXIF latitude longitude in\n     * WGS84 datum, measured in degrees.\n     */\n    get: function get() {\n      return this._core.l;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"pano\", {\n    /**\n     * Get pano.\n     *\n     * @returns {boolean} Value indicating whether the node is a panorama.\n     * It could be a cropped or full panorama.\n     */\n    get: function get() {\n      return this._fill.gpano != null && this._fill.gpano.FullPanoWidthPixels != null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"private\", {\n    /**\n     * Get private.\n     *\n     * @returns {boolean} Value specifying if image is accessible to\n     * organization members only or to everyone.\n     */\n    get: function get() {\n      return this._fill.private;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"projectKey\", {\n    /**\n     * Get projectKey.\n     *\n     * @returns {string} Unique key of the project to which\n     * the node belongs. If the node does not belong to a\n     * project the project key will be undefined.\n     *\n     * @deprecated This property will be deprecated in favor\n     * of the organization key and private properties.\n     */\n    get: function get() {\n      return this._fill.project != null ? this._fill.project.key : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotation\", {\n    /**\n     * Get rotation.\n     *\n     * @description Will not be set if SfM has not been run.\n     *\n     * @returns {Array<number>} Rotation vector in angle axis representation.\n     */\n    get: function get() {\n      return this._fill.c_rotation;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scale\", {\n    /**\n     * Get scale.\n     *\n     * @description Will not be set if SfM has not been run.\n     *\n     * @returns {number} Scale of atomic reconstruction.\n     */\n    get: function get() {\n      return this._fill.atomic_scale;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"sequenceKey\", {\n    /**\n     * Get sequenceKey.\n     *\n     * @returns {string} Unique key of the sequence to which\n     * the node belongs.\n     */\n    get: function get() {\n      return this._core.sequence_key;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"sequenceEdges\", {\n    /**\n     * Get sequenceEdges.\n     *\n     * @returns {IEdgeStatus} Value describing the status of the\n     * sequence edges.\n     *\n     * @ignore\n     */\n    get: function get() {\n      return this._cache.sequenceEdges;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"sequenceEdges$\", {\n    /**\n     * Get sequenceEdges$.\n     *\n     * @description Internal observable, should not be used as an API.\n     *\n     * @returns {Observable<IEdgeStatus>} Observable emitting\n     * values describing the status of the sequence edges.\n     *\n     * @ignore\n     */\n    get: function get() {\n      return this._cache.sequenceEdges$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"spatialEdges\", {\n    /**\n     * Get spatialEdges.\n     *\n     * @returns {IEdgeStatus} Value describing the status of the\n     * spatial edges.\n     *\n     * @ignore\n     */\n    get: function get() {\n      return this._cache.spatialEdges;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"spatialEdges$\", {\n    /**\n     * Get spatialEdges$.\n     *\n     * @description Internal observable, should not be used as an API.\n     *\n     * @returns {Observable<IEdgeStatus>} Observable emitting\n     * values describing the status of the spatial edges.\n     *\n     * @ignore\n     */\n    get: function get() {\n      return this._cache.spatialEdges$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"userKey\", {\n    /**\n     * Get userKey.\n     *\n     * @returns {string} Unique key of the user who uploaded\n     * the image.\n     */\n    get: function get() {\n      return this._fill.user.key;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"username\", {\n    /**\n     * Get username.\n     *\n     * @returns {string} Username of the user who uploaded\n     * the image.\n     */\n    get: function get() {\n      return this._fill.user.username;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"width\", {\n    /**\n     * Get width.\n     *\n     * @returns {number} Width of original image, not\n     * adjusted for orientation.\n     */\n    get: function get() {\n      return this._fill.width;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Cache the image and mesh assets.\n   *\n   * @description The assets are always cached internally by the\n   * library prior to setting a node as the current node.\n   *\n   * @returns {Observable<Node>} Observable emitting this node whenever the\n   * load status has changed and when the mesh or image has been fully loaded.\n   *\n   * @ignore\n   */\n\n  Node.prototype.cacheAssets$ = function () {\n    var _this = this;\n\n    return this._cache.cacheAssets$(this.key, this.pano, this.merged).pipe(operators_1.map(function () {\n      return _this;\n    }));\n  };\n  /**\n   * Cache the image asset.\n   *\n   * @description Use for caching a differently sized image than\n   * the one currently held by the node.\n   *\n   * @returns {Observable<Node>} Observable emitting this node whenever the\n   * load status has changed and when the mesh or image has been fully loaded.\n   *\n   * @ignore\n   */\n\n\n  Node.prototype.cacheImage$ = function (imageSize) {\n    var _this = this;\n\n    return this._cache.cacheImage$(this.key, imageSize).pipe(operators_1.map(function () {\n      return _this;\n    }));\n  };\n  /**\n   * Cache the sequence edges.\n   *\n   * @description The sequence edges are cached asynchronously\n   * internally by the library.\n   *\n   * @param {Array<IEdge>} edges - Sequence edges to cache.\n   * @ignore\n   */\n\n\n  Node.prototype.cacheSequenceEdges = function (edges) {\n    this._cache.cacheSequenceEdges(edges);\n  };\n  /**\n   * Cache the spatial edges.\n   *\n   * @description The spatial edges are cached asynchronously\n   * internally by the library.\n   *\n   * @param {Array<IEdge>} edges - Spatial edges to cache.\n   * @ignore\n   */\n\n\n  Node.prototype.cacheSpatialEdges = function (edges) {\n    this._cache.cacheSpatialEdges(edges);\n  };\n  /**\n   * Dispose the node.\n   *\n   * @description Disposes all cached assets.\n   * @ignore\n   */\n\n\n  Node.prototype.dispose = function () {\n    if (this._cache != null) {\n      this._cache.dispose();\n\n      this._cache = null;\n    }\n\n    this._core = null;\n    this._fill = null;\n  };\n  /**\n   * Initialize the node cache.\n   *\n   * @description The node cache is initialized internally by\n   * the library.\n   *\n   * @param {NodeCache} cache - The node cache to set as cache.\n   * @ignore\n   */\n\n\n  Node.prototype.initializeCache = function (cache) {\n    if (this._cache != null) {\n      throw new Error(\"Node cache already initialized (\" + this.key + \").\");\n    }\n\n    this._cache = cache;\n  };\n  /**\n   * Fill the node with all properties.\n   *\n   * @description The node is filled internally by\n   * the library.\n   *\n   * @param {IFillNode} fill - The fill node struct.\n   * @ignore\n   */\n\n\n  Node.prototype.makeFull = function (fill) {\n    if (fill == null) {\n      throw new Error(\"Fill can not be null.\");\n    }\n\n    this._fill = fill;\n  };\n  /**\n   * Reset the sequence edges.\n   *\n   * @ignore\n   */\n\n\n  Node.prototype.resetSequenceEdges = function () {\n    this._cache.resetSequenceEdges();\n  };\n  /**\n   * Reset the spatial edges.\n   *\n   * @ignore\n   */\n\n\n  Node.prototype.resetSpatialEdges = function () {\n    this._cache.resetSpatialEdges();\n  };\n  /**\n   * Clears the image and mesh assets, aborts\n   * any outstanding requests and resets edges.\n   *\n   * @ignore\n   */\n\n\n  Node.prototype.uncache = function () {\n    if (this._cache == null) {\n      return;\n    }\n\n    this._cache.dispose();\n\n    this._cache = null;\n  };\n\n  return Node;\n}();\n\nexports.Node = Node;\nexports.default = Node;\n\n//# sourceURL=webpack://Mapillary/./src/graph/Node.ts?");

/***/ }),

/***/ "./src/graph/NodeCache.ts":
/*!********************************!*\
  !*** ./src/graph/NodeCache.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Graph_1 = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../Utils */ \"./src/Utils.ts\");\n/**\n * @class NodeCache\n *\n * @classdesc Represents the cached properties of a node.\n */\n\n\nvar NodeCache =\n/** @class */\nfunction () {\n  /**\n   * Create a new node cache instance.\n   */\n  function NodeCache() {\n    this._disposed = false;\n    this._image = null;\n    this._loadStatus = {\n      loaded: 0,\n      total: 0\n    };\n    this._mesh = null;\n    this._sequenceEdges = {\n      cached: false,\n      edges: []\n    };\n    this._spatialEdges = {\n      cached: false,\n      edges: []\n    };\n    this._imageChanged$ = new rxjs_1.Subject();\n    this._image$ = this._imageChanged$.pipe(operators_1.startWith(null), operators_1.publishReplay(1), operators_1.refCount());\n    this._iamgeSubscription = this._image$.subscribe();\n    this._sequenceEdgesChanged$ = new rxjs_1.Subject();\n    this._sequenceEdges$ = this._sequenceEdgesChanged$.pipe(operators_1.startWith(this._sequenceEdges), operators_1.publishReplay(1), operators_1.refCount());\n    this._sequenceEdgesSubscription = this._sequenceEdges$.subscribe(function () {});\n    this._spatialEdgesChanged$ = new rxjs_1.Subject();\n    this._spatialEdges$ = this._spatialEdgesChanged$.pipe(operators_1.startWith(this._spatialEdges), operators_1.publishReplay(1), operators_1.refCount());\n    this._spatialEdgesSubscription = this._spatialEdges$.subscribe(function () {});\n    this._cachingAssets$ = null;\n  }\n\n  Object.defineProperty(NodeCache.prototype, \"image\", {\n    /**\n     * Get image.\n     *\n     * @description Will not be set when assets have not been cached\n     * or when the object has been disposed.\n     *\n     * @returns {HTMLImageElement} Cached image element of the node.\n     */\n    get: function get() {\n      return this._image;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NodeCache.prototype, \"image$\", {\n    /**\n     * Get image$.\n     *\n     * @returns {Observable<HTMLImageElement>} Observable emitting\n     * the cached image when it is updated.\n     */\n    get: function get() {\n      return this._image$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NodeCache.prototype, \"loadStatus\", {\n    /**\n     * Get loadStatus.\n     *\n     * @returns {ILoadStatus} Value indicating the load status\n     * of the mesh and image.\n     */\n    get: function get() {\n      return this._loadStatus;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NodeCache.prototype, \"mesh\", {\n    /**\n     * Get mesh.\n     *\n     * @description Will not be set when assets have not been cached\n     * or when the object has been disposed.\n     *\n     * @returns {IMesh} SfM triangulated mesh of reconstructed\n     * atomic 3D points.\n     */\n    get: function get() {\n      return this._mesh;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NodeCache.prototype, \"sequenceEdges\", {\n    /**\n     * Get sequenceEdges.\n     *\n     * @returns {IEdgeStatus} Value describing the status of the\n     * sequence edges.\n     */\n    get: function get() {\n      return this._sequenceEdges;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NodeCache.prototype, \"sequenceEdges$\", {\n    /**\n     * Get sequenceEdges$.\n     *\n     * @returns {Observable<IEdgeStatus>} Observable emitting\n     * values describing the status of the sequence edges.\n     */\n    get: function get() {\n      return this._sequenceEdges$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NodeCache.prototype, \"spatialEdges\", {\n    /**\n     * Get spatialEdges.\n     *\n     * @returns {IEdgeStatus} Value describing the status of the\n     * spatial edges.\n     */\n    get: function get() {\n      return this._spatialEdges;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NodeCache.prototype, \"spatialEdges$\", {\n    /**\n     * Get spatialEdges$.\n     *\n     * @returns {Observable<IEdgeStatus>} Observable emitting\n     * values describing the status of the spatial edges.\n     */\n    get: function get() {\n      return this._spatialEdges$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Cache the image and mesh assets.\n   *\n   * @param {string} key - Key of the node to cache.\n   * @param {boolean} pano - Value indicating whether node is a panorama.\n   * @param {boolean} merged - Value indicating whether node is merged.\n   * @returns {Observable<NodeCache>} Observable emitting this node\n   * cache whenever the load status has changed and when the mesh or image\n   * has been fully loaded.\n   */\n\n  NodeCache.prototype.cacheAssets$ = function (key, pano, merged) {\n    var _this = this;\n\n    if (this._cachingAssets$ != null) {\n      return this._cachingAssets$;\n    }\n\n    var imageSize = pano ? Utils_1.Settings.basePanoramaSize : Utils_1.Settings.baseImageSize;\n    this._cachingAssets$ = rxjs_1.combineLatest(this._cacheImage$(key, imageSize), this._cacheMesh$(key, merged)).pipe(operators_1.map(function (_a) {\n      var imageStatus = _a[0],\n          meshStatus = _a[1];\n      _this._loadStatus.loaded = 0;\n      _this._loadStatus.total = 0;\n\n      if (meshStatus) {\n        _this._mesh = meshStatus.object;\n        _this._loadStatus.loaded += meshStatus.loaded.loaded;\n        _this._loadStatus.total += meshStatus.loaded.total;\n      }\n\n      if (imageStatus) {\n        _this._image = imageStatus.object;\n        _this._loadStatus.loaded += imageStatus.loaded.loaded;\n        _this._loadStatus.total += imageStatus.loaded.total;\n      }\n\n      return _this;\n    }), operators_1.finalize(function () {\n      _this._cachingAssets$ = null;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._cachingAssets$.pipe(operators_1.first(function (nodeCache) {\n      return !!nodeCache._image;\n    })).subscribe(function (nodeCache) {\n      _this._imageChanged$.next(_this._image);\n    }, function (error) {});\n\n    return this._cachingAssets$;\n  };\n  /**\n   * Cache an image with a higher resolution than the current one.\n   *\n   * @param {string} key - Key of the node to cache.\n   * @param {ImageSize} imageSize - The size to cache.\n   * @returns {Observable<NodeCache>} Observable emitting a single item,\n   * the node cache, when the image has been cached. If supplied image\n   * size is not larger than the current image size the node cache is\n   * returned immediately.\n   */\n\n\n  NodeCache.prototype.cacheImage$ = function (key, imageSize) {\n    var _this = this;\n\n    if (this._image != null && imageSize <= Math.max(this._image.width, this._image.height)) {\n      return rxjs_1.of(this);\n    }\n\n    var cacheImage$ = this._cacheImage$(key, imageSize).pipe(operators_1.first(function (status) {\n      return status.object != null;\n    }), operators_1.tap(function (status) {\n      _this._disposeImage();\n\n      _this._image = status.object;\n    }), operators_1.map(function (imageStatus) {\n      return _this;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    cacheImage$.subscribe(function (nodeCache) {\n      _this._imageChanged$.next(_this._image);\n    }, function (error) {});\n    return cacheImage$;\n  };\n  /**\n   * Cache the sequence edges.\n   *\n   * @param {Array<IEdge>} edges - Sequence edges to cache.\n   */\n\n\n  NodeCache.prototype.cacheSequenceEdges = function (edges) {\n    this._sequenceEdges = {\n      cached: true,\n      edges: edges\n    };\n\n    this._sequenceEdgesChanged$.next(this._sequenceEdges);\n  };\n  /**\n   * Cache the spatial edges.\n   *\n   * @param {Array<IEdge>} edges - Spatial edges to cache.\n   */\n\n\n  NodeCache.prototype.cacheSpatialEdges = function (edges) {\n    this._spatialEdges = {\n      cached: true,\n      edges: edges\n    };\n\n    this._spatialEdgesChanged$.next(this._spatialEdges);\n  };\n  /**\n   * Dispose the node cache.\n   *\n   * @description Disposes all cached assets and unsubscribes to\n   * all streams.\n   */\n\n\n  NodeCache.prototype.dispose = function () {\n    this._iamgeSubscription.unsubscribe();\n\n    this._sequenceEdgesSubscription.unsubscribe();\n\n    this._spatialEdgesSubscription.unsubscribe();\n\n    this._disposeImage();\n\n    this._mesh = null;\n    this._loadStatus.loaded = 0;\n    this._loadStatus.total = 0;\n    this._sequenceEdges = {\n      cached: false,\n      edges: []\n    };\n    this._spatialEdges = {\n      cached: false,\n      edges: []\n    };\n\n    this._imageChanged$.next(null);\n\n    this._sequenceEdgesChanged$.next(this._sequenceEdges);\n\n    this._spatialEdgesChanged$.next(this._spatialEdges);\n\n    this._disposed = true;\n\n    if (this._imageRequest != null) {\n      this._imageRequest.abort();\n    }\n\n    if (this._meshRequest != null) {\n      this._meshRequest.abort();\n    }\n  };\n  /**\n   * Reset the sequence edges.\n   */\n\n\n  NodeCache.prototype.resetSequenceEdges = function () {\n    this._sequenceEdges = {\n      cached: false,\n      edges: []\n    };\n\n    this._sequenceEdgesChanged$.next(this._sequenceEdges);\n  };\n  /**\n   * Reset the spatial edges.\n   */\n\n\n  NodeCache.prototype.resetSpatialEdges = function () {\n    this._spatialEdges = {\n      cached: false,\n      edges: []\n    };\n\n    this._spatialEdgesChanged$.next(this._spatialEdges);\n  };\n  /**\n   * Cache the image.\n   *\n   * @param {string} key - Key of the node to cache.\n   * @param {boolean} pano - Value indicating whether node is a panorama.\n   * @returns {Observable<ILoadStatusObject<HTMLImageElement>>} Observable\n   * emitting a load status object every time the load status changes\n   * and completes when the image is fully loaded.\n   */\n\n\n  NodeCache.prototype._cacheImage$ = function (key, imageSize) {\n    var _this = this;\n\n    return rxjs_1.Observable.create(function (subscriber) {\n      var xmlHTTP = new XMLHttpRequest();\n      xmlHTTP.open(\"GET\", Utils_1.Urls.thumbnail(key, imageSize, Utils_1.Urls.origin), true);\n      xmlHTTP.responseType = \"arraybuffer\";\n      xmlHTTP.timeout = 15000;\n\n      xmlHTTP.onload = function (pe) {\n        if (xmlHTTP.status !== 200) {\n          _this._imageRequest = null;\n          subscriber.error(new Error(\"Failed to fetch image (\" + key + \"). Status: \" + xmlHTTP.status + \", \" + xmlHTTP.statusText));\n          return;\n        }\n\n        var image = new Image();\n        image.crossOrigin = \"Anonymous\";\n\n        image.onload = function (e) {\n          _this._imageRequest = null;\n\n          if (_this._disposed) {\n            window.URL.revokeObjectURL(image.src);\n            subscriber.error(new Error(\"Image load was aborted (\" + key + \")\"));\n            return;\n          }\n\n          subscriber.next({\n            loaded: {\n              loaded: pe.loaded,\n              total: pe.total\n            },\n            object: image\n          });\n          subscriber.complete();\n        };\n\n        image.onerror = function (error) {\n          _this._imageRequest = null;\n          subscriber.error(new Error(\"Failed to load image (\" + key + \")\"));\n        };\n\n        var blob = new Blob([xmlHTTP.response]);\n        image.src = window.URL.createObjectURL(blob);\n      };\n\n      xmlHTTP.onprogress = function (pe) {\n        if (_this._disposed) {\n          return;\n        }\n\n        subscriber.next({\n          loaded: {\n            loaded: pe.loaded,\n            total: pe.total\n          },\n          object: null\n        });\n      };\n\n      xmlHTTP.onerror = function (error) {\n        _this._imageRequest = null;\n        subscriber.error(new Error(\"Failed to fetch image (\" + key + \")\"));\n      };\n\n      xmlHTTP.ontimeout = function (e) {\n        _this._imageRequest = null;\n        subscriber.error(new Error(\"Image request timed out (\" + key + \")\"));\n      };\n\n      xmlHTTP.onabort = function (event) {\n        _this._imageRequest = null;\n        subscriber.error(new Error(\"Image request was aborted (\" + key + \")\"));\n      };\n\n      _this._imageRequest = xmlHTTP;\n      xmlHTTP.send(null);\n    });\n  };\n  /**\n   * Cache the mesh.\n   *\n   * @param {string} key - Key of the node to cache.\n   * @param {boolean} merged - Value indicating whether node is merged.\n   * @returns {Observable<ILoadStatusObject<IMesh>>} Observable emitting\n   * a load status object every time the load status changes and completes\n   * when the mesh is fully loaded.\n   */\n\n\n  NodeCache.prototype._cacheMesh$ = function (key, merged) {\n    var _this = this;\n\n    return rxjs_1.Observable.create(function (subscriber) {\n      if (!merged) {\n        subscriber.next(_this._createEmptyMeshLoadStatus());\n        subscriber.complete();\n        return;\n      }\n\n      var xmlHTTP = new XMLHttpRequest();\n      xmlHTTP.open(\"GET\", Utils_1.Urls.protoMesh(key), true);\n      xmlHTTP.responseType = \"arraybuffer\";\n      xmlHTTP.timeout = 15000;\n\n      xmlHTTP.onload = function (pe) {\n        _this._meshRequest = null;\n\n        if (_this._disposed) {\n          return;\n        }\n\n        var mesh = xmlHTTP.status === 200 ? Graph_1.MeshReader.read(new Buffer(xmlHTTP.response)) : {\n          faces: [],\n          vertices: []\n        };\n        subscriber.next({\n          loaded: {\n            loaded: pe.loaded,\n            total: pe.total\n          },\n          object: mesh\n        });\n        subscriber.complete();\n      };\n\n      xmlHTTP.onprogress = function (pe) {\n        if (_this._disposed) {\n          return;\n        }\n\n        subscriber.next({\n          loaded: {\n            loaded: pe.loaded,\n            total: pe.total\n          },\n          object: null\n        });\n      };\n\n      xmlHTTP.onerror = function (e) {\n        _this._meshRequest = null;\n        console.error(\"Failed to cache mesh (\" + key + \")\");\n        subscriber.next(_this._createEmptyMeshLoadStatus());\n        subscriber.complete();\n      };\n\n      xmlHTTP.ontimeout = function (e) {\n        _this._meshRequest = null;\n        console.error(\"Mesh request timed out (\" + key + \")\");\n        subscriber.next(_this._createEmptyMeshLoadStatus());\n        subscriber.complete();\n      };\n\n      xmlHTTP.onabort = function (e) {\n        _this._meshRequest = null;\n        subscriber.error(new Error(\"Mesh request was aborted (\" + key + \")\"));\n      };\n\n      _this._meshRequest = xmlHTTP;\n      xmlHTTP.send(null);\n    });\n  };\n  /**\n   * Create a load status object with an empty mesh.\n   *\n   * @returns {ILoadStatusObject<IMesh>} Load status object\n   * with empty mesh.\n   */\n\n\n  NodeCache.prototype._createEmptyMeshLoadStatus = function () {\n    return {\n      loaded: {\n        loaded: 0,\n        total: 0\n      },\n      object: {\n        faces: [],\n        vertices: []\n      }\n    };\n  };\n\n  NodeCache.prototype._disposeImage = function () {\n    if (this._image != null) {\n      window.URL.revokeObjectURL(this._image.src);\n    }\n\n    this._image = null;\n  };\n\n  return NodeCache;\n}();\n\nexports.NodeCache = NodeCache;\nexports.default = NodeCache;\n\n//# sourceURL=webpack://Mapillary/./src/graph/NodeCache.ts?");

/***/ }),

/***/ "./src/graph/Sequence.ts":
/*!*******************************!*\
  !*** ./src/graph/Sequence.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @class Sequence\n *\n * @classdesc Represents a sequence of ordered nodes.\n */\n\nvar Sequence =\n/** @class */\nfunction () {\n  /**\n   * Create a new sequene instance.\n   *\n   * @param {ISequence} sequence - Raw sequence data.\n   */\n  function Sequence(sequence) {\n    this._key = sequence.key;\n    this._keys = sequence.keys;\n  }\n\n  Object.defineProperty(Sequence.prototype, \"key\", {\n    /**\n     * Get key.\n     *\n     * @returns {string} Unique sequence key.\n     */\n    get: function get() {\n      return this._key;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Sequence.prototype, \"keys\", {\n    /**\n     * Get keys.\n     *\n     * @returns {Array<string>} Array of ordered node keys in the sequence.\n     */\n    get: function get() {\n      return this._keys;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Dispose the sequence.\n   *\n   * @description Disposes all cached assets.\n   */\n\n  Sequence.prototype.dispose = function () {\n    this._key = null;\n    this._keys = null;\n  };\n  /**\n   * Find the next node key in the sequence with respect to\n   * the provided node key.\n   *\n   * @param {string} key - Reference node key.\n   * @returns {string} Next key in sequence if it exists, null otherwise.\n   */\n\n\n  Sequence.prototype.findNextKey = function (key) {\n    var i = this._keys.indexOf(key);\n\n    if (i + 1 >= this._keys.length || i === -1) {\n      return null;\n    } else {\n      return this._keys[i + 1];\n    }\n  };\n  /**\n   * Find the previous node key in the sequence with respect to\n   * the provided node key.\n   *\n   * @param {string} key - Reference node key.\n   * @returns {string} Previous key in sequence if it exists, null otherwise.\n   */\n\n\n  Sequence.prototype.findPrevKey = function (key) {\n    var i = this._keys.indexOf(key);\n\n    if (i === 0 || i === -1) {\n      return null;\n    } else {\n      return this._keys[i - 1];\n    }\n  };\n\n  return Sequence;\n}();\n\nexports.Sequence = Sequence;\nexports.default = Sequence;\n\n//# sourceURL=webpack://Mapillary/./src/graph/Sequence.ts?");

/***/ }),

/***/ "./src/graph/edge/EdgeCalculator.ts":
/*!******************************************!*\
  !*** ./src/graph/edge/EdgeCalculator.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar Edge_1 = __webpack_require__(/*! ../../Edge */ \"./src/Edge.ts\");\n\nvar Error_1 = __webpack_require__(/*! ../../Error */ \"./src/Error.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n/**\n * @class EdgeCalculator\n *\n * @classdesc Represents a class for calculating node edges.\n */\n\n\nvar EdgeCalculator =\n/** @class */\nfunction () {\n  /**\n   * Create a new edge calculator instance.\n   *\n   * @param {EdgeCalculatorSettings} settings - Settings struct.\n   * @param {EdgeCalculatorDirections} directions - Directions struct.\n   * @param {EdgeCalculatorCoefficients} coefficients - Coefficients struct.\n   */\n  function EdgeCalculator(settings, directions, coefficients) {\n    this._spatial = new Geo_1.Spatial();\n    this._geoCoords = new Geo_1.GeoCoords();\n    this._settings = settings != null ? settings : new Edge_1.EdgeCalculatorSettings();\n    this._directions = directions != null ? directions : new Edge_1.EdgeCalculatorDirections();\n    this._coefficients = coefficients != null ? coefficients : new Edge_1.EdgeCalculatorCoefficients();\n  }\n  /**\n   * Returns the potential edges to destination nodes for a set\n   * of nodes with respect to a source node.\n   *\n   * @param {Node} node - Source node.\n   * @param {Array<Node>} nodes - Potential destination nodes.\n   * @param {Array<string>} fallbackKeys - Keys for destination nodes that should\n   * be returned even if they do not meet the criteria for a potential edge.\n   * @throws {ArgumentMapillaryError} If node is not full.\n   */\n\n\n  EdgeCalculator.prototype.getPotentialEdges = function (node, potentialNodes, fallbackKeys) {\n    if (!node.full) {\n      throw new Error_1.ArgumentMapillaryError(\"Node has to be full.\");\n    }\n\n    if (!node.merged) {\n      return [];\n    }\n\n    var currentDirection = this._spatial.viewingDirection(node.rotation);\n\n    var currentVerticalDirection = this._spatial.angleToPlane(currentDirection.toArray(), [0, 0, 1]);\n\n    var potentialEdges = [];\n\n    for (var _i = 0, potentialNodes_1 = potentialNodes; _i < potentialNodes_1.length; _i++) {\n      var potential = potentialNodes_1[_i];\n\n      if (!potential.merged || potential.key === node.key) {\n        continue;\n      }\n\n      var enu = this._geoCoords.geodeticToEnu(potential.latLon.lat, potential.latLon.lon, potential.alt, node.latLon.lat, node.latLon.lon, node.alt);\n\n      var motion = new THREE.Vector3(enu[0], enu[1], enu[2]);\n      var distance = motion.length();\n\n      if (distance > this._settings.maxDistance && fallbackKeys.indexOf(potential.key) < 0) {\n        continue;\n      }\n\n      var motionChange = this._spatial.angleBetweenVector2(currentDirection.x, currentDirection.y, motion.x, motion.y);\n\n      var verticalMotion = this._spatial.angleToPlane(motion.toArray(), [0, 0, 1]);\n\n      var direction = this._spatial.viewingDirection(potential.rotation);\n\n      var directionChange = this._spatial.angleBetweenVector2(currentDirection.x, currentDirection.y, direction.x, direction.y);\n\n      var verticalDirection = this._spatial.angleToPlane(direction.toArray(), [0, 0, 1]);\n\n      var verticalDirectionChange = verticalDirection - currentVerticalDirection;\n\n      var rotation = this._spatial.relativeRotationAngle(node.rotation, potential.rotation);\n\n      var worldMotionAzimuth = this._spatial.angleBetweenVector2(1, 0, motion.x, motion.y);\n\n      var sameSequence = potential.sequenceKey != null && node.sequenceKey != null && potential.sequenceKey === node.sequenceKey;\n      var sameMergeCC = potential.mergeCC == null && node.mergeCC == null || potential.mergeCC === node.mergeCC;\n      var sameUser = potential.userKey === node.userKey;\n      var potentialEdge = {\n        capturedAt: potential.capturedAt,\n        croppedPano: potential.pano && !potential.fullPano,\n        directionChange: directionChange,\n        distance: distance,\n        fullPano: potential.fullPano,\n        key: potential.key,\n        motionChange: motionChange,\n        rotation: rotation,\n        sameMergeCC: sameMergeCC,\n        sameSequence: sameSequence,\n        sameUser: sameUser,\n        sequenceKey: potential.sequenceKey,\n        verticalDirectionChange: verticalDirectionChange,\n        verticalMotion: verticalMotion,\n        worldMotionAzimuth: worldMotionAzimuth\n      };\n      potentialEdges.push(potentialEdge);\n    }\n\n    return potentialEdges;\n  };\n  /**\n   * Computes the sequence edges for a node.\n   *\n   * @param {Node} node - Source node.\n   * @throws {ArgumentMapillaryError} If node is not full.\n   */\n\n\n  EdgeCalculator.prototype.computeSequenceEdges = function (node, sequence) {\n    if (!node.full) {\n      throw new Error_1.ArgumentMapillaryError(\"Node has to be full.\");\n    }\n\n    if (node.sequenceKey !== sequence.key) {\n      throw new Error_1.ArgumentMapillaryError(\"Node and sequence does not correspond.\");\n    }\n\n    var edges = [];\n    var nextKey = sequence.findNextKey(node.key);\n\n    if (nextKey != null) {\n      edges.push({\n        data: {\n          direction: Edge_1.EdgeDirection.Next,\n          worldMotionAzimuth: Number.NaN\n        },\n        from: node.key,\n        to: nextKey\n      });\n    }\n\n    var prevKey = sequence.findPrevKey(node.key);\n\n    if (prevKey != null) {\n      edges.push({\n        data: {\n          direction: Edge_1.EdgeDirection.Prev,\n          worldMotionAzimuth: Number.NaN\n        },\n        from: node.key,\n        to: prevKey\n      });\n    }\n\n    return edges;\n  };\n  /**\n   * Computes the similar edges for a node.\n   *\n   * @description Similar edges for perspective images and cropped panoramas\n   * look roughly in the same direction and are positioned closed to the node.\n   * Similar edges for full panoramas only target other full panoramas.\n   *\n   * @param {Node} node - Source node.\n   * @param {Array<IPotentialEdge>} potentialEdges - Potential edges.\n   * @throws {ArgumentMapillaryError} If node is not full.\n   */\n\n\n  EdgeCalculator.prototype.computeSimilarEdges = function (node, potentialEdges) {\n    var _this = this;\n\n    if (!node.full) {\n      throw new Error_1.ArgumentMapillaryError(\"Node has to be full.\");\n    }\n\n    var nodeFullPano = node.fullPano;\n    var sequenceGroups = {};\n\n    for (var _i = 0, potentialEdges_1 = potentialEdges; _i < potentialEdges_1.length; _i++) {\n      var potentialEdge = potentialEdges_1[_i];\n\n      if (potentialEdge.sequenceKey == null) {\n        continue;\n      }\n\n      if (potentialEdge.sameSequence) {\n        continue;\n      }\n\n      if (nodeFullPano) {\n        if (!potentialEdge.fullPano) {\n          continue;\n        }\n      } else {\n        if (!potentialEdge.fullPano && Math.abs(potentialEdge.directionChange) > this._settings.similarMaxDirectionChange) {\n          continue;\n        }\n      }\n\n      if (potentialEdge.distance > this._settings.similarMaxDistance) {\n        continue;\n      }\n\n      if (potentialEdge.sameUser && Math.abs(potentialEdge.capturedAt - node.capturedAt) < this._settings.similarMinTimeDifference) {\n        continue;\n      }\n\n      if (sequenceGroups[potentialEdge.sequenceKey] == null) {\n        sequenceGroups[potentialEdge.sequenceKey] = [];\n      }\n\n      sequenceGroups[potentialEdge.sequenceKey].push(potentialEdge);\n    }\n\n    var similarEdges = [];\n    var calculateScore = node.fullPano ? function (potentialEdge) {\n      return potentialEdge.distance;\n    } : function (potentialEdge) {\n      return _this._coefficients.similarDistance * potentialEdge.distance + _this._coefficients.similarRotation * potentialEdge.rotation;\n    };\n\n    for (var sequenceKey in sequenceGroups) {\n      if (!sequenceGroups.hasOwnProperty(sequenceKey)) {\n        continue;\n      }\n\n      var lowestScore = Number.MAX_VALUE;\n      var similarEdge = null;\n\n      for (var _a = 0, _b = sequenceGroups[sequenceKey]; _a < _b.length; _a++) {\n        var potentialEdge = _b[_a];\n        var score = calculateScore(potentialEdge);\n\n        if (score < lowestScore) {\n          lowestScore = score;\n          similarEdge = potentialEdge;\n        }\n      }\n\n      if (similarEdge == null) {\n        continue;\n      }\n\n      similarEdges.push(similarEdge);\n    }\n\n    return similarEdges.map(function (potentialEdge) {\n      return {\n        data: {\n          direction: Edge_1.EdgeDirection.Similar,\n          worldMotionAzimuth: potentialEdge.worldMotionAzimuth\n        },\n        from: node.key,\n        to: potentialEdge.key\n      };\n    });\n  };\n  /**\n   * Computes the step edges for a perspective node.\n   *\n   * @description Step edge targets can only be other perspective nodes.\n   * Returns an empty array for cropped and full panoramas.\n   *\n   * @param {Node} node - Source node.\n   * @param {Array<IPotentialEdge>} potentialEdges - Potential edges.\n   * @param {string} prevKey - Key of previous node in sequence.\n   * @param {string} prevKey - Key of next node in sequence.\n   * @throws {ArgumentMapillaryError} If node is not full.\n   */\n\n\n  EdgeCalculator.prototype.computeStepEdges = function (node, potentialEdges, prevKey, nextKey) {\n    if (!node.full) {\n      throw new Error_1.ArgumentMapillaryError(\"Node has to be full.\");\n    }\n\n    var edges = [];\n\n    if (node.pano) {\n      return edges;\n    }\n\n    for (var k in this._directions.steps) {\n      if (!this._directions.steps.hasOwnProperty(k)) {\n        continue;\n      }\n\n      var step = this._directions.steps[k];\n      var lowestScore = Number.MAX_VALUE;\n      var edge = null;\n      var fallback = null;\n\n      for (var _i = 0, potentialEdges_2 = potentialEdges; _i < potentialEdges_2.length; _i++) {\n        var potential = potentialEdges_2[_i];\n\n        if (potential.croppedPano || potential.fullPano) {\n          continue;\n        }\n\n        if (Math.abs(potential.directionChange) > this._settings.stepMaxDirectionChange) {\n          continue;\n        }\n\n        var motionDifference = this._spatial.angleDifference(step.motionChange, potential.motionChange);\n\n        var directionMotionDifference = this._spatial.angleDifference(potential.directionChange, motionDifference);\n\n        var drift = Math.max(Math.abs(motionDifference), Math.abs(directionMotionDifference));\n\n        if (Math.abs(drift) > this._settings.stepMaxDrift) {\n          continue;\n        }\n\n        var potentialKey = potential.key;\n\n        if (step.useFallback && (potentialKey === prevKey || potentialKey === nextKey)) {\n          fallback = potential;\n        }\n\n        if (potential.distance > this._settings.stepMaxDistance) {\n          continue;\n        }\n\n        motionDifference = Math.sqrt(motionDifference * motionDifference + potential.verticalMotion * potential.verticalMotion);\n        var score = this._coefficients.stepPreferredDistance * Math.abs(potential.distance - this._settings.stepPreferredDistance) / this._settings.stepMaxDistance + this._coefficients.stepMotion * motionDifference / this._settings.stepMaxDrift + this._coefficients.stepRotation * potential.rotation / this._settings.stepMaxDirectionChange + this._coefficients.stepSequencePenalty * (potential.sameSequence ? 0 : 1) + this._coefficients.stepMergeCCPenalty * (potential.sameMergeCC ? 0 : 1);\n\n        if (score < lowestScore) {\n          lowestScore = score;\n          edge = potential;\n        }\n      }\n\n      edge = edge == null ? fallback : edge;\n\n      if (edge != null) {\n        edges.push({\n          data: {\n            direction: step.direction,\n            worldMotionAzimuth: edge.worldMotionAzimuth\n          },\n          from: node.key,\n          to: edge.key\n        });\n      }\n    }\n\n    return edges;\n  };\n  /**\n   * Computes the turn edges for a perspective node.\n   *\n   * @description Turn edge targets can only be other perspective images.\n   * Returns an empty array for cropped and full panoramas.\n   *\n   * @param {Node} node - Source node.\n   * @param {Array<IPotentialEdge>} potentialEdges - Potential edges.\n   * @throws {ArgumentMapillaryError} If node is not full.\n   */\n\n\n  EdgeCalculator.prototype.computeTurnEdges = function (node, potentialEdges) {\n    if (!node.full) {\n      throw new Error_1.ArgumentMapillaryError(\"Node has to be full.\");\n    }\n\n    var edges = [];\n\n    if (node.pano) {\n      return edges;\n    }\n\n    for (var k in this._directions.turns) {\n      if (!this._directions.turns.hasOwnProperty(k)) {\n        continue;\n      }\n\n      var turn = this._directions.turns[k];\n      var lowestScore = Number.MAX_VALUE;\n      var edge = null;\n\n      for (var _i = 0, potentialEdges_3 = potentialEdges; _i < potentialEdges_3.length; _i++) {\n        var potential = potentialEdges_3[_i];\n\n        if (potential.croppedPano || potential.fullPano) {\n          continue;\n        }\n\n        if (potential.distance > this._settings.turnMaxDistance) {\n          continue;\n        }\n\n        var rig = turn.direction !== Edge_1.EdgeDirection.TurnU && potential.distance < this._settings.turnMaxRigDistance && Math.abs(potential.directionChange) > this._settings.turnMinRigDirectionChange;\n\n        var directionDifference = this._spatial.angleDifference(turn.directionChange, potential.directionChange);\n\n        var score = void 0;\n\n        if (rig && potential.directionChange * turn.directionChange > 0 && Math.abs(potential.directionChange) < Math.abs(turn.directionChange)) {\n          score = -Math.PI / 2 + Math.abs(potential.directionChange);\n        } else {\n          if (Math.abs(directionDifference) > this._settings.turnMaxDirectionChange) {\n            continue;\n          }\n\n          var motionDifference = turn.motionChange ? this._spatial.angleDifference(turn.motionChange, potential.motionChange) : 0;\n          motionDifference = Math.sqrt(motionDifference * motionDifference + potential.verticalMotion * potential.verticalMotion);\n          score = this._coefficients.turnDistance * potential.distance / this._settings.turnMaxDistance + this._coefficients.turnMotion * motionDifference / Math.PI + this._coefficients.turnSequencePenalty * (potential.sameSequence ? 0 : 1) + this._coefficients.turnMergeCCPenalty * (potential.sameMergeCC ? 0 : 1);\n        }\n\n        if (score < lowestScore) {\n          lowestScore = score;\n          edge = potential;\n        }\n      }\n\n      if (edge != null) {\n        edges.push({\n          data: {\n            direction: turn.direction,\n            worldMotionAzimuth: edge.worldMotionAzimuth\n          },\n          from: node.key,\n          to: edge.key\n        });\n      }\n    }\n\n    return edges;\n  };\n  /**\n   * Computes the pano edges for a perspective node.\n   *\n   * @description Perspective to pano edge targets can only be\n   * full pano nodes. Returns an empty array for cropped and full panoramas.\n   *\n   * @param {Node} node - Source node.\n   * @param {Array<IPotentialEdge>} potentialEdges - Potential edges.\n   * @throws {ArgumentMapillaryError} If node is not full.\n   */\n\n\n  EdgeCalculator.prototype.computePerspectiveToPanoEdges = function (node, potentialEdges) {\n    if (!node.full) {\n      throw new Error_1.ArgumentMapillaryError(\"Node has to be full.\");\n    }\n\n    if (node.pano) {\n      return [];\n    }\n\n    var lowestScore = Number.MAX_VALUE;\n    var edge = null;\n\n    for (var _i = 0, potentialEdges_4 = potentialEdges; _i < potentialEdges_4.length; _i++) {\n      var potential = potentialEdges_4[_i];\n\n      if (!potential.fullPano) {\n        continue;\n      }\n\n      var score = this._coefficients.panoPreferredDistance * Math.abs(potential.distance - this._settings.panoPreferredDistance) / this._settings.panoMaxDistance + this._coefficients.panoMotion * Math.abs(potential.motionChange) / Math.PI + this._coefficients.panoMergeCCPenalty * (potential.sameMergeCC ? 0 : 1);\n\n      if (score < lowestScore) {\n        lowestScore = score;\n        edge = potential;\n      }\n    }\n\n    if (edge == null) {\n      return [];\n    }\n\n    return [{\n      data: {\n        direction: Edge_1.EdgeDirection.Pano,\n        worldMotionAzimuth: edge.worldMotionAzimuth\n      },\n      from: node.key,\n      to: edge.key\n    }];\n  };\n  /**\n   * Computes the full pano and step edges for a full pano node.\n   *\n   * @description Pano to pano edge targets can only be\n   * full pano nodes. Pano to step edge targets can only be perspective\n   * nodes.\n   * Returns an empty array for cropped panoramas and perspective nodes.\n   *\n   * @param {Node} node - Source node.\n   * @param {Array<IPotentialEdge>} potentialEdges - Potential edges.\n   * @throws {ArgumentMapillaryError} If node is not full.\n   */\n\n\n  EdgeCalculator.prototype.computePanoEdges = function (node, potentialEdges) {\n    if (!node.full) {\n      throw new Error_1.ArgumentMapillaryError(\"Node has to be full.\");\n    }\n\n    if (!node.fullPano) {\n      return [];\n    }\n\n    var panoEdges = [];\n    var potentialPanos = [];\n    var potentialSteps = [];\n\n    for (var _i = 0, potentialEdges_5 = potentialEdges; _i < potentialEdges_5.length; _i++) {\n      var potential = potentialEdges_5[_i];\n\n      if (potential.distance > this._settings.panoMaxDistance) {\n        continue;\n      }\n\n      if (potential.fullPano) {\n        if (potential.distance < this._settings.panoMinDistance) {\n          continue;\n        }\n\n        potentialPanos.push(potential);\n      } else {\n        if (potential.croppedPano) {\n          continue;\n        }\n\n        for (var k in this._directions.panos) {\n          if (!this._directions.panos.hasOwnProperty(k)) {\n            continue;\n          }\n\n          var pano = this._directions.panos[k];\n\n          var turn = this._spatial.angleDifference(potential.directionChange, potential.motionChange);\n\n          var turnChange = this._spatial.angleDifference(pano.directionChange, turn);\n\n          if (Math.abs(turnChange) > this._settings.panoMaxStepTurnChange) {\n            continue;\n          }\n\n          potentialSteps.push([pano.direction, potential]); // break if step direction found\n\n          break;\n        }\n      }\n    }\n\n    var maxRotationDifference = Math.PI / this._settings.panoMaxItems;\n    var occupiedAngles = [];\n    var stepAngles = [];\n\n    for (var index = 0; index < this._settings.panoMaxItems; index++) {\n      var rotation = index / this._settings.panoMaxItems * 2 * Math.PI;\n      var lowestScore = Number.MAX_VALUE;\n      var edge = null;\n\n      for (var _a = 0, potentialPanos_1 = potentialPanos; _a < potentialPanos_1.length; _a++) {\n        var potential = potentialPanos_1[_a];\n\n        var motionDifference = this._spatial.angleDifference(rotation, potential.motionChange);\n\n        if (Math.abs(motionDifference) > maxRotationDifference) {\n          continue;\n        }\n\n        var occupiedDifference = Number.MAX_VALUE;\n\n        for (var _b = 0, occupiedAngles_1 = occupiedAngles; _b < occupiedAngles_1.length; _b++) {\n          var occupiedAngle = occupiedAngles_1[_b];\n          var difference = Math.abs(this._spatial.angleDifference(occupiedAngle, potential.motionChange));\n\n          if (difference < occupiedDifference) {\n            occupiedDifference = difference;\n          }\n        }\n\n        if (occupiedDifference <= maxRotationDifference) {\n          continue;\n        }\n\n        var score = this._coefficients.panoPreferredDistance * Math.abs(potential.distance - this._settings.panoPreferredDistance) / this._settings.panoMaxDistance + this._coefficients.panoMotion * Math.abs(motionDifference) / maxRotationDifference + this._coefficients.panoSequencePenalty * (potential.sameSequence ? 0 : 1) + this._coefficients.panoMergeCCPenalty * (potential.sameMergeCC ? 0 : 1);\n\n        if (score < lowestScore) {\n          lowestScore = score;\n          edge = potential;\n        }\n      }\n\n      if (edge != null) {\n        occupiedAngles.push(edge.motionChange);\n        panoEdges.push({\n          data: {\n            direction: Edge_1.EdgeDirection.Pano,\n            worldMotionAzimuth: edge.worldMotionAzimuth\n          },\n          from: node.key,\n          to: edge.key\n        });\n      } else {\n        stepAngles.push(rotation);\n      }\n    }\n\n    var occupiedStepAngles = {};\n    occupiedStepAngles[Edge_1.EdgeDirection.Pano] = occupiedAngles;\n    occupiedStepAngles[Edge_1.EdgeDirection.StepForward] = [];\n    occupiedStepAngles[Edge_1.EdgeDirection.StepLeft] = [];\n    occupiedStepAngles[Edge_1.EdgeDirection.StepBackward] = [];\n    occupiedStepAngles[Edge_1.EdgeDirection.StepRight] = [];\n\n    for (var _c = 0, stepAngles_1 = stepAngles; _c < stepAngles_1.length; _c++) {\n      var stepAngle = stepAngles_1[_c];\n      var occupations = [];\n\n      for (var k in this._directions.panos) {\n        if (!this._directions.panos.hasOwnProperty(k)) {\n          continue;\n        }\n\n        var pano = this._directions.panos[k];\n        var allOccupiedAngles = occupiedStepAngles[Edge_1.EdgeDirection.Pano].concat(occupiedStepAngles[pano.direction]).concat(occupiedStepAngles[pano.prev]).concat(occupiedStepAngles[pano.next]);\n        var lowestScore = Number.MAX_VALUE;\n        var edge = null;\n\n        for (var _d = 0, potentialSteps_1 = potentialSteps; _d < potentialSteps_1.length; _d++) {\n          var potential = potentialSteps_1[_d];\n\n          if (potential[0] !== pano.direction) {\n            continue;\n          }\n\n          var motionChange = this._spatial.angleDifference(stepAngle, potential[1].motionChange);\n\n          if (Math.abs(motionChange) > maxRotationDifference) {\n            continue;\n          }\n\n          var minOccupiedDifference = Number.MAX_VALUE;\n\n          for (var _e = 0, allOccupiedAngles_1 = allOccupiedAngles; _e < allOccupiedAngles_1.length; _e++) {\n            var occupiedAngle = allOccupiedAngles_1[_e];\n            var occupiedDifference = Math.abs(this._spatial.angleDifference(occupiedAngle, potential[1].motionChange));\n\n            if (occupiedDifference < minOccupiedDifference) {\n              minOccupiedDifference = occupiedDifference;\n            }\n          }\n\n          if (minOccupiedDifference <= maxRotationDifference) {\n            continue;\n          }\n\n          var score = this._coefficients.panoPreferredDistance * Math.abs(potential[1].distance - this._settings.panoPreferredDistance) / this._settings.panoMaxDistance + this._coefficients.panoMotion * Math.abs(motionChange) / maxRotationDifference + this._coefficients.panoMergeCCPenalty * (potential[1].sameMergeCC ? 0 : 1);\n\n          if (score < lowestScore) {\n            lowestScore = score;\n            edge = potential;\n          }\n        }\n\n        if (edge != null) {\n          occupations.push(edge);\n          panoEdges.push({\n            data: {\n              direction: edge[0],\n              worldMotionAzimuth: edge[1].worldMotionAzimuth\n            },\n            from: node.key,\n            to: edge[1].key\n          });\n        }\n      }\n\n      for (var _f = 0, occupations_1 = occupations; _f < occupations_1.length; _f++) {\n        var occupation = occupations_1[_f];\n        occupiedStepAngles[occupation[0]].push(occupation[1].motionChange);\n      }\n    }\n\n    return panoEdges;\n  };\n\n  return EdgeCalculator;\n}();\n\nexports.EdgeCalculator = EdgeCalculator;\nexports.default = EdgeCalculator;\n\n//# sourceURL=webpack://Mapillary/./src/graph/edge/EdgeCalculator.ts?");

/***/ }),

/***/ "./src/graph/edge/EdgeCalculatorCoefficients.ts":
/*!******************************************************!*\
  !*** ./src/graph/edge/EdgeCalculatorCoefficients.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar EdgeCalculatorCoefficients =\n/** @class */\nfunction () {\n  function EdgeCalculatorCoefficients() {\n    this.panoPreferredDistance = 2;\n    this.panoMotion = 2;\n    this.panoSequencePenalty = 1;\n    this.panoMergeCCPenalty = 4;\n    this.stepPreferredDistance = 4;\n    this.stepMotion = 3;\n    this.stepRotation = 4;\n    this.stepSequencePenalty = 2;\n    this.stepMergeCCPenalty = 6;\n    this.similarDistance = 2;\n    this.similarRotation = 3;\n    this.turnDistance = 4;\n    this.turnMotion = 2;\n    this.turnSequencePenalty = 1;\n    this.turnMergeCCPenalty = 4;\n  }\n\n  return EdgeCalculatorCoefficients;\n}();\n\nexports.EdgeCalculatorCoefficients = EdgeCalculatorCoefficients;\nexports.default = EdgeCalculatorCoefficients;\n\n//# sourceURL=webpack://Mapillary/./src/graph/edge/EdgeCalculatorCoefficients.ts?");

/***/ }),

/***/ "./src/graph/edge/EdgeCalculatorDirections.ts":
/*!****************************************************!*\
  !*** ./src/graph/edge/EdgeCalculatorDirections.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Edge_1 = __webpack_require__(/*! ../../Edge */ \"./src/Edge.ts\");\n\nvar EdgeCalculatorDirections =\n/** @class */\nfunction () {\n  function EdgeCalculatorDirections() {\n    this.steps = {};\n    this.turns = {};\n    this.panos = {};\n    this.steps[Edge_1.EdgeDirection.StepForward] = {\n      direction: Edge_1.EdgeDirection.StepForward,\n      motionChange: 0,\n      useFallback: true\n    };\n    this.steps[Edge_1.EdgeDirection.StepBackward] = {\n      direction: Edge_1.EdgeDirection.StepBackward,\n      motionChange: Math.PI,\n      useFallback: true\n    };\n    this.steps[Edge_1.EdgeDirection.StepLeft] = {\n      direction: Edge_1.EdgeDirection.StepLeft,\n      motionChange: Math.PI / 2,\n      useFallback: false\n    };\n    this.steps[Edge_1.EdgeDirection.StepRight] = {\n      direction: Edge_1.EdgeDirection.StepRight,\n      motionChange: -Math.PI / 2,\n      useFallback: false\n    };\n    this.turns[Edge_1.EdgeDirection.TurnLeft] = {\n      direction: Edge_1.EdgeDirection.TurnLeft,\n      directionChange: Math.PI / 2,\n      motionChange: Math.PI / 4\n    };\n    this.turns[Edge_1.EdgeDirection.TurnRight] = {\n      direction: Edge_1.EdgeDirection.TurnRight,\n      directionChange: -Math.PI / 2,\n      motionChange: -Math.PI / 4\n    };\n    this.turns[Edge_1.EdgeDirection.TurnU] = {\n      direction: Edge_1.EdgeDirection.TurnU,\n      directionChange: Math.PI,\n      motionChange: null\n    };\n    this.panos[Edge_1.EdgeDirection.StepForward] = {\n      direction: Edge_1.EdgeDirection.StepForward,\n      directionChange: 0,\n      next: Edge_1.EdgeDirection.StepLeft,\n      prev: Edge_1.EdgeDirection.StepRight\n    };\n    this.panos[Edge_1.EdgeDirection.StepBackward] = {\n      direction: Edge_1.EdgeDirection.StepBackward,\n      directionChange: Math.PI,\n      next: Edge_1.EdgeDirection.StepRight,\n      prev: Edge_1.EdgeDirection.StepLeft\n    };\n    this.panos[Edge_1.EdgeDirection.StepLeft] = {\n      direction: Edge_1.EdgeDirection.StepLeft,\n      directionChange: Math.PI / 2,\n      next: Edge_1.EdgeDirection.StepBackward,\n      prev: Edge_1.EdgeDirection.StepForward\n    };\n    this.panos[Edge_1.EdgeDirection.StepRight] = {\n      direction: Edge_1.EdgeDirection.StepRight,\n      directionChange: -Math.PI / 2,\n      next: Edge_1.EdgeDirection.StepForward,\n      prev: Edge_1.EdgeDirection.StepBackward\n    };\n  }\n\n  return EdgeCalculatorDirections;\n}();\n\nexports.EdgeCalculatorDirections = EdgeCalculatorDirections;\n\n//# sourceURL=webpack://Mapillary/./src/graph/edge/EdgeCalculatorDirections.ts?");

/***/ }),

/***/ "./src/graph/edge/EdgeCalculatorSettings.ts":
/*!**************************************************!*\
  !*** ./src/graph/edge/EdgeCalculatorSettings.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar EdgeCalculatorSettings =\n/** @class */\nfunction () {\n  function EdgeCalculatorSettings() {\n    this.panoMinDistance = 0.1;\n    this.panoMaxDistance = 20;\n    this.panoPreferredDistance = 5;\n    this.panoMaxItems = 4;\n    this.panoMaxStepTurnChange = Math.PI / 8;\n    this.rotationMaxDistance = this.turnMaxRigDistance;\n    this.rotationMaxDirectionChange = Math.PI / 6;\n    this.rotationMaxVerticalDirectionChange = Math.PI / 8;\n    this.similarMaxDirectionChange = Math.PI / 8;\n    this.similarMaxDistance = 12;\n    this.similarMinTimeDifference = 12 * 3600 * 1000;\n    this.stepMaxDistance = 20;\n    this.stepMaxDirectionChange = Math.PI / 6;\n    this.stepMaxDrift = Math.PI / 6;\n    this.stepPreferredDistance = 4;\n    this.turnMaxDistance = 15;\n    this.turnMaxDirectionChange = 2 * Math.PI / 9;\n    this.turnMaxRigDistance = 0.65;\n    this.turnMinRigDirectionChange = Math.PI / 6;\n  }\n\n  Object.defineProperty(EdgeCalculatorSettings.prototype, \"maxDistance\", {\n    get: function get() {\n      return Math.max(this.panoMaxDistance, this.similarMaxDistance, this.stepMaxDistance, this.turnMaxDistance);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return EdgeCalculatorSettings;\n}();\n\nexports.EdgeCalculatorSettings = EdgeCalculatorSettings;\nexports.default = EdgeCalculatorSettings;\n\n//# sourceURL=webpack://Mapillary/./src/graph/edge/EdgeCalculatorSettings.ts?");

/***/ }),

/***/ "./src/graph/edge/EdgeDirection.ts":
/*!*****************************************!*\
  !*** ./src/graph/edge/EdgeDirection.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enumeration for edge directions\n * @enum {number}\n * @readonly\n * @description Directions for edges in node graph describing\n * sequence, spatial and node type relations between nodes.\n */\n\nvar EdgeDirection;\n\n(function (EdgeDirection) {\n  /**\n   * Next node in the sequence.\n   */\n  EdgeDirection[EdgeDirection[\"Next\"] = 0] = \"Next\";\n  /**\n   * Previous node in the sequence.\n   */\n\n  EdgeDirection[EdgeDirection[\"Prev\"] = 1] = \"Prev\";\n  /**\n   * Step to the left keeping viewing direction.\n   */\n\n  EdgeDirection[EdgeDirection[\"StepLeft\"] = 2] = \"StepLeft\";\n  /**\n   * Step to the right keeping viewing direction.\n   */\n\n  EdgeDirection[EdgeDirection[\"StepRight\"] = 3] = \"StepRight\";\n  /**\n   * Step forward keeping viewing direction.\n   */\n\n  EdgeDirection[EdgeDirection[\"StepForward\"] = 4] = \"StepForward\";\n  /**\n   * Step backward keeping viewing direction.\n   */\n\n  EdgeDirection[EdgeDirection[\"StepBackward\"] = 5] = \"StepBackward\";\n  /**\n   * Turn 90 degrees counter clockwise.\n   */\n\n  EdgeDirection[EdgeDirection[\"TurnLeft\"] = 6] = \"TurnLeft\";\n  /**\n   * Turn 90 degrees clockwise.\n   */\n\n  EdgeDirection[EdgeDirection[\"TurnRight\"] = 7] = \"TurnRight\";\n  /**\n   * Turn 180 degrees.\n   */\n\n  EdgeDirection[EdgeDirection[\"TurnU\"] = 8] = \"TurnU\";\n  /**\n   * Panorama in general direction.\n   */\n\n  EdgeDirection[EdgeDirection[\"Pano\"] = 9] = \"Pano\";\n  /**\n   * Looking in roughly the same direction at rougly the same position.\n   */\n\n  EdgeDirection[EdgeDirection[\"Similar\"] = 10] = \"Similar\";\n})(EdgeDirection = exports.EdgeDirection || (exports.EdgeDirection = {}));\n\n//# sourceURL=webpack://Mapillary/./src/graph/edge/EdgeDirection.ts?");

/***/ }),

/***/ "./src/render/DOMRenderer.ts":
/*!***********************************!*\
  !*** ./src/render/DOMRenderer.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar rxjs_2 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Render_1 = __webpack_require__(/*! ../Render */ \"./src/Render.ts\");\n\nvar DOMRenderer =\n/** @class */\nfunction () {\n  function DOMRenderer(element, renderService, currentFrame$) {\n    this._adaptiveOperation$ = new rxjs_2.Subject();\n    this._render$ = new rxjs_2.Subject();\n    this._renderAdaptive$ = new rxjs_2.Subject();\n    this._renderService = renderService;\n    this._currentFrame$ = currentFrame$;\n    var rootNode = vd.create(vd.h(\"div.domRenderer\", []));\n    element.appendChild(rootNode);\n    this._offset$ = this._adaptiveOperation$.pipe(operators_1.scan(function (adaptive, operation) {\n      return operation(adaptive);\n    }, {\n      elementHeight: element.offsetHeight,\n      elementWidth: element.offsetWidth,\n      imageAspect: 0,\n      renderMode: Render_1.RenderMode.Fill\n    }), operators_1.filter(function (adaptive) {\n      return adaptive.imageAspect > 0 && adaptive.elementWidth > 0 && adaptive.elementHeight > 0;\n    }), operators_1.map(function (adaptive) {\n      var elementAspect = adaptive.elementWidth / adaptive.elementHeight;\n      var ratio = adaptive.imageAspect / elementAspect;\n      var verticalOffset = 0;\n      var horizontalOffset = 0;\n\n      if (adaptive.renderMode === Render_1.RenderMode.Letterbox) {\n        if (adaptive.imageAspect > elementAspect) {\n          verticalOffset = adaptive.elementHeight * (1 - 1 / ratio) / 2;\n        } else {\n          horizontalOffset = adaptive.elementWidth * (1 - ratio) / 2;\n        }\n      } else {\n        if (adaptive.imageAspect > elementAspect) {\n          horizontalOffset = -adaptive.elementWidth * (ratio - 1) / 2;\n        } else {\n          verticalOffset = -adaptive.elementHeight * (1 / ratio - 1) / 2;\n        }\n      }\n\n      return {\n        bottom: verticalOffset,\n        left: horizontalOffset,\n        right: horizontalOffset,\n        top: verticalOffset\n      };\n    }));\n\n    this._currentFrame$.pipe(operators_1.filter(function (frame) {\n      return frame.state.currentNode != null;\n    }), operators_1.distinctUntilChanged(function (k1, k2) {\n      return k1 === k2;\n    }, function (frame) {\n      return frame.state.currentNode.key;\n    }), operators_1.map(function (frame) {\n      return frame.state.currentTransform.basicAspect;\n    }), operators_1.map(function (aspect) {\n      return function (adaptive) {\n        adaptive.imageAspect = aspect;\n        return adaptive;\n      };\n    })).subscribe(this._adaptiveOperation$);\n\n    rxjs_1.combineLatest(this._renderAdaptive$.pipe(operators_1.scan(function (vNodeHashes, vNodeHash) {\n      if (vNodeHash.vnode == null) {\n        delete vNodeHashes[vNodeHash.name];\n      } else {\n        vNodeHashes[vNodeHash.name] = vNodeHash.vnode;\n      }\n\n      return vNodeHashes;\n    }, {})), this._offset$).pipe(operators_1.map(function (vo) {\n      var vNodes = [];\n      var hashes = vo[0];\n\n      for (var name_1 in hashes) {\n        if (!hashes.hasOwnProperty(name_1)) {\n          continue;\n        }\n\n        vNodes.push(hashes[name_1]);\n      }\n\n      var offset = vo[1];\n      var properties = {\n        style: {\n          bottom: offset.bottom + \"px\",\n          left: offset.left + \"px\",\n          \"pointer-events\": \"none\",\n          position: \"absolute\",\n          right: offset.right + \"px\",\n          top: offset.top + \"px\"\n        }\n      };\n      return {\n        name: \"adaptiveDomRenderer\",\n        vnode: vd.h(\"div.adaptiveDomRenderer\", properties, vNodes)\n      };\n    })).subscribe(this._render$);\n    this._vNode$ = this._render$.pipe(operators_1.scan(function (vNodeHashes, vNodeHash) {\n      if (vNodeHash.vnode == null) {\n        delete vNodeHashes[vNodeHash.name];\n      } else {\n        vNodeHashes[vNodeHash.name] = vNodeHash.vnode;\n      }\n\n      return vNodeHashes;\n    }, {}), operators_1.map(function (hashes) {\n      var vNodes = [];\n\n      for (var name_2 in hashes) {\n        if (!hashes.hasOwnProperty(name_2)) {\n          continue;\n        }\n\n        vNodes.push(hashes[name_2]);\n      }\n\n      return vd.h(\"div.domRenderer\", vNodes);\n    }));\n    this._vPatch$ = this._vNode$.pipe(operators_1.scan(function (nodePatch, vNode) {\n      nodePatch.vpatch = vd.diff(nodePatch.vnode, vNode);\n      nodePatch.vnode = vNode;\n      return nodePatch;\n    }, {\n      vnode: vd.h(\"div.domRenderer\", []),\n      vpatch: null\n    }), operators_1.pluck(\"vpatch\"));\n    this._element$ = this._vPatch$.pipe(operators_1.scan(function (oldElement, vPatch) {\n      return vd.patch(oldElement, vPatch);\n    }, rootNode), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._element$.subscribe(function () {});\n\n    this._renderService.size$.pipe(operators_1.map(function (size) {\n      return function (adaptive) {\n        adaptive.elementWidth = size.width;\n        adaptive.elementHeight = size.height;\n        return adaptive;\n      };\n    })).subscribe(this._adaptiveOperation$);\n\n    this._renderService.renderMode$.pipe(operators_1.map(function (renderMode) {\n      return function (adaptive) {\n        adaptive.renderMode = renderMode;\n        return adaptive;\n      };\n    })).subscribe(this._adaptiveOperation$);\n  }\n\n  Object.defineProperty(DOMRenderer.prototype, \"element$\", {\n    get: function get() {\n      return this._element$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DOMRenderer.prototype, \"render$\", {\n    get: function get() {\n      return this._render$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DOMRenderer.prototype, \"renderAdaptive$\", {\n    get: function get() {\n      return this._renderAdaptive$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  DOMRenderer.prototype.clear = function (name) {\n    this._renderAdaptive$.next({\n      name: name,\n      vnode: null\n    });\n\n    this._render$.next({\n      name: name,\n      vnode: null\n    });\n  };\n\n  return DOMRenderer;\n}();\n\nexports.DOMRenderer = DOMRenderer;\nexports.default = DOMRenderer;\n\n//# sourceURL=webpack://Mapillary/./src/render/DOMRenderer.ts?");

/***/ }),

/***/ "./src/render/GLRenderStage.ts":
/*!*************************************!*\
  !*** ./src/render/GLRenderStage.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar GLRenderStage;\n\n(function (GLRenderStage) {\n  GLRenderStage[GLRenderStage[\"Background\"] = 0] = \"Background\";\n  GLRenderStage[GLRenderStage[\"Foreground\"] = 1] = \"Foreground\";\n})(GLRenderStage = exports.GLRenderStage || (exports.GLRenderStage = {}));\n\nexports.default = GLRenderStage;\n\n//# sourceURL=webpack://Mapillary/./src/render/GLRenderStage.ts?");

/***/ }),

/***/ "./src/render/GLRenderer.ts":
/*!**********************************!*\
  !*** ./src/render/GLRenderer.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar Render_1 = __webpack_require__(/*! ../Render */ \"./src/Render.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../Utils */ \"./src/Utils.ts\");\n\nvar GLRenderer =\n/** @class */\nfunction () {\n  function GLRenderer(canvasContainer, renderService, dom) {\n    var _this = this;\n\n    this._renderFrame$ = new rxjs_1.Subject();\n    this._renderCameraOperation$ = new rxjs_1.Subject();\n    this._render$ = new rxjs_1.Subject();\n    this._clear$ = new rxjs_1.Subject();\n    this._renderOperation$ = new rxjs_1.Subject();\n    this._rendererOperation$ = new rxjs_1.Subject();\n    this._eraserOperation$ = new rxjs_1.Subject();\n    this._renderService = renderService;\n    this._dom = !!dom ? dom : new Utils_1.DOM();\n    this._renderer$ = this._rendererOperation$.pipe(operators_1.scan(function (renderer, operation) {\n      return operation(renderer);\n    }, {\n      needsRender: false,\n      renderer: null\n    }), operators_1.filter(function (renderer) {\n      return !!renderer.renderer;\n    }));\n    this._renderCollection$ = this._renderOperation$.pipe(operators_1.scan(function (hashes, operation) {\n      return operation(hashes);\n    }, {}), operators_1.share());\n    this._renderCamera$ = this._renderCameraOperation$.pipe(operators_1.scan(function (rc, operation) {\n      return operation(rc);\n    }, {\n      frameId: -1,\n      needsRender: false,\n      perspective: null\n    }));\n    this._eraser$ = this._eraserOperation$.pipe(operators_1.startWith(function (eraser) {\n      return eraser;\n    }), operators_1.scan(function (eraser, operation) {\n      return operation(eraser);\n    }, {\n      needsRender: false\n    }));\n    rxjs_1.combineLatest(this._renderer$, this._renderCollection$, this._renderCamera$, this._eraser$).pipe(operators_1.map(function (_a) {\n      var renderer = _a[0],\n          hashes = _a[1],\n          rc = _a[2],\n          eraser = _a[3];\n      var renders = Object.keys(hashes).map(function (key) {\n        return hashes[key];\n      });\n      return {\n        camera: rc,\n        eraser: eraser,\n        renderer: renderer,\n        renders: renders\n      };\n    }), operators_1.filter(function (co) {\n      var needsRender = co.renderer.needsRender || co.camera.needsRender || co.eraser.needsRender;\n      var frameId = co.camera.frameId;\n\n      for (var _i = 0, _a = co.renders; _i < _a.length; _i++) {\n        var render = _a[_i];\n\n        if (render.frameId !== frameId) {\n          return false;\n        }\n\n        needsRender = needsRender || render.needsRender;\n      }\n\n      return needsRender;\n    }), operators_1.distinctUntilChanged(function (n1, n2) {\n      return n1 === n2;\n    }, function (co) {\n      return co.eraser.needsRender ? -1 : co.camera.frameId;\n    })).subscribe(function (co) {\n      co.renderer.needsRender = false;\n      co.camera.needsRender = false;\n      co.eraser.needsRender = false;\n      var perspectiveCamera = co.camera.perspective;\n      var backgroundRenders = [];\n      var foregroundRenders = [];\n\n      for (var _i = 0, _a = co.renders; _i < _a.length; _i++) {\n        var render = _a[_i];\n\n        if (render.stage === Render_1.GLRenderStage.Background) {\n          backgroundRenders.push(render.render);\n        } else if (render.stage === Render_1.GLRenderStage.Foreground) {\n          foregroundRenders.push(render.render);\n        }\n      }\n\n      var renderer = co.renderer.renderer;\n      renderer.clear();\n\n      for (var _b = 0, backgroundRenders_1 = backgroundRenders; _b < backgroundRenders_1.length; _b++) {\n        var render = backgroundRenders_1[_b];\n        render(perspectiveCamera, renderer);\n      }\n\n      renderer.clearDepth();\n\n      for (var _c = 0, foregroundRenders_1 = foregroundRenders; _c < foregroundRenders_1.length; _c++) {\n        var render = foregroundRenders_1[_c];\n        render(perspectiveCamera, renderer);\n      }\n    });\n\n    this._renderFrame$.pipe(operators_1.map(function (rc) {\n      return function (irc) {\n        irc.frameId = rc.frameId;\n        irc.perspective = rc.perspective;\n\n        if (rc.changed === true) {\n          irc.needsRender = true;\n        }\n\n        return irc;\n      };\n    })).subscribe(this._renderCameraOperation$);\n\n    this._renderFrameSubscribe();\n\n    var renderHash$ = this._render$.pipe(operators_1.map(function (hash) {\n      return function (hashes) {\n        hashes[hash.name] = hash.render;\n        return hashes;\n      };\n    }));\n\n    var clearHash$ = this._clear$.pipe(operators_1.map(function (name) {\n      return function (hashes) {\n        delete hashes[name];\n        return hashes;\n      };\n    }));\n\n    rxjs_1.merge(renderHash$, clearHash$).subscribe(this._renderOperation$);\n    this._webGLRenderer$ = this._render$.pipe(operators_1.first(), operators_1.map(function (hash) {\n      var canvas = _this._dom.createElement(\"canvas\", \"mapillary-js-canvas\");\n\n      canvas.style.position = \"absolute\";\n      canvas.setAttribute(\"tabindex\", \"0\");\n      canvasContainer.appendChild(canvas);\n      var element = renderService.element;\n      var webGLRenderer = new THREE.WebGLRenderer({\n        canvas: canvas\n      });\n      webGLRenderer.setPixelRatio(window.devicePixelRatio);\n      webGLRenderer.setSize(element.offsetWidth, element.offsetHeight);\n      webGLRenderer.setClearColor(new THREE.Color(0x202020), 1.0);\n      webGLRenderer.autoClear = false;\n      return webGLRenderer;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._webGLRenderer$.subscribe(function () {});\n\n    var createRenderer$ = this._webGLRenderer$.pipe(operators_1.first(), operators_1.map(function (webGLRenderer) {\n      return function (renderer) {\n        renderer.needsRender = true;\n        renderer.renderer = webGLRenderer;\n        return renderer;\n      };\n    }));\n\n    var resizeRenderer$ = this._renderService.size$.pipe(operators_1.map(function (size) {\n      return function (renderer) {\n        if (renderer.renderer == null) {\n          return renderer;\n        }\n\n        renderer.renderer.setSize(size.width, size.height);\n        renderer.needsRender = true;\n        return renderer;\n      };\n    }));\n\n    var clearRenderer$ = this._clear$.pipe(operators_1.map(function (name) {\n      return function (renderer) {\n        if (renderer.renderer == null) {\n          return renderer;\n        }\n\n        renderer.needsRender = true;\n        return renderer;\n      };\n    }));\n\n    rxjs_1.merge(createRenderer$, resizeRenderer$, clearRenderer$).subscribe(this._rendererOperation$);\n\n    var renderCollectionEmpty$ = this._renderCollection$.pipe(operators_1.filter(function (hashes) {\n      return Object.keys(hashes).length === 0;\n    }), operators_1.share());\n\n    renderCollectionEmpty$.subscribe(function (hashes) {\n      if (_this._renderFrameSubscription == null) {\n        return;\n      }\n\n      _this._renderFrameSubscription.unsubscribe();\n\n      _this._renderFrameSubscription = null;\n\n      _this._renderFrameSubscribe();\n    });\n    renderCollectionEmpty$.pipe(operators_1.map(function (hashes) {\n      return function (eraser) {\n        eraser.needsRender = true;\n        return eraser;\n      };\n    })).subscribe(this._eraserOperation$);\n  }\n\n  Object.defineProperty(GLRenderer.prototype, \"render$\", {\n    get: function get() {\n      return this._render$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GLRenderer.prototype, \"webGLRenderer$\", {\n    get: function get() {\n      return this._webGLRenderer$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  GLRenderer.prototype.clear = function (name) {\n    this._clear$.next(name);\n  };\n\n  GLRenderer.prototype._renderFrameSubscribe = function () {\n    var _this = this;\n\n    this._render$.pipe(operators_1.first(), operators_1.map(function (renderHash) {\n      return function (irc) {\n        irc.needsRender = true;\n        return irc;\n      };\n    })).subscribe(function (operation) {\n      _this._renderCameraOperation$.next(operation);\n    });\n\n    this._renderFrameSubscription = this._render$.pipe(operators_1.first(), operators_1.mergeMap(function (hash) {\n      return _this._renderService.renderCameraFrame$;\n    })).subscribe(this._renderFrame$);\n  };\n\n  return GLRenderer;\n}();\n\nexports.GLRenderer = GLRenderer;\nexports.default = GLRenderer;\n\n//# sourceURL=webpack://Mapillary/./src/render/GLRenderer.ts?");

/***/ }),

/***/ "./src/render/RenderCamera.ts":
/*!************************************!*\
  !*** ./src/render/RenderCamera.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar Geo_1 = __webpack_require__(/*! ../Geo */ \"./src/Geo.ts\");\n\nvar Render_1 = __webpack_require__(/*! ../Render */ \"./src/Render.ts\");\n\nvar State_1 = __webpack_require__(/*! ../State */ \"./src/State.ts\");\n\nvar RenderCamera =\n/** @class */\nfunction () {\n  function RenderCamera(elementWidth, elementHeight, renderMode) {\n    this._spatial = new Geo_1.Spatial();\n    this._viewportCoords = new Geo_1.ViewportCoords();\n    this._initialFov = 50;\n    this._alpha = -1;\n    this._renderMode = renderMode;\n    this._zoom = 0;\n    this._frameId = -1;\n    this._changed = false;\n    this._changedForFrame = -1;\n    this._currentNodeId = null;\n    this._previousNodeId = null;\n    this._currentPano = false;\n    this._previousPano = false;\n    this._state = null;\n    this._currentProjectedPoints = [];\n    this._previousProjectedPoints = [];\n    this._currentFov = this._initialFov;\n    this._previousFov = this._initialFov;\n    this._camera = new Geo_1.Camera();\n    this._perspective = new THREE.PerspectiveCamera(this._initialFov, this._computeAspect(elementWidth, elementHeight), 0.16, 10000);\n    this._perspective.matrixAutoUpdate = false;\n    this._rotation = {\n      phi: 0,\n      theta: 0\n    };\n  }\n\n  Object.defineProperty(RenderCamera.prototype, \"alpha\", {\n    get: function get() {\n      return this._alpha;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderCamera.prototype, \"camera\", {\n    get: function get() {\n      return this._camera;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderCamera.prototype, \"changed\", {\n    get: function get() {\n      return this._frameId === this._changedForFrame;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderCamera.prototype, \"frameId\", {\n    get: function get() {\n      return this._frameId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderCamera.prototype, \"perspective\", {\n    get: function get() {\n      return this._perspective;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderCamera.prototype, \"renderMode\", {\n    get: function get() {\n      return this._renderMode;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderCamera.prototype, \"rotation\", {\n    get: function get() {\n      return this._rotation;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderCamera.prototype, \"zoom\", {\n    get: function get() {\n      return this._zoom;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  RenderCamera.prototype.setFrame = function (frame) {\n    var state = frame.state;\n\n    if (state.state !== this._state) {\n      this._state = state.state;\n      this._changed = true;\n    }\n\n    var currentNodeId = state.currentNode.key;\n    var previousNodeId = !!state.previousNode ? state.previousNode.key : null;\n\n    if (currentNodeId !== this._currentNodeId) {\n      this._currentNodeId = currentNodeId;\n      this._currentPano = !!state.currentTransform.gpano;\n      this._currentProjectedPoints = this._computeProjectedPoints(state.currentTransform);\n      this._changed = true;\n    }\n\n    if (previousNodeId !== this._previousNodeId) {\n      this._previousNodeId = previousNodeId;\n      this._previousPano = !!state.previousTransform.gpano;\n      this._previousProjectedPoints = this._computeProjectedPoints(state.previousTransform);\n      this._changed = true;\n    }\n\n    var zoom = state.zoom;\n\n    if (zoom !== this._zoom) {\n      this._zoom = zoom;\n      this._changed = true;\n    }\n\n    if (this._changed) {\n      this._currentFov = this._computeCurrentFov();\n      this._previousFov = this._computePreviousFov();\n    }\n\n    var alpha = state.alpha;\n\n    if (this._changed || alpha !== this._alpha) {\n      this._alpha = alpha;\n      this._perspective.fov = this._state === State_1.State.Earth ? 60 : this._interpolateFov(this._currentFov, this._previousFov, this._alpha);\n      this._changed = true;\n    }\n\n    var camera = state.camera;\n\n    if (this._camera.diff(camera) > 1e-9) {\n      this._camera.copy(camera);\n\n      this._rotation = this._computeRotation(camera);\n\n      this._perspective.up.copy(camera.up);\n\n      this._perspective.position.copy(camera.position);\n\n      this._perspective.lookAt(camera.lookat);\n\n      this._perspective.updateMatrix();\n\n      this._perspective.updateMatrixWorld(false);\n\n      this._changed = true;\n    }\n\n    if (this._changed) {\n      this._perspective.updateProjectionMatrix();\n    }\n\n    this._setFrameId(frame.id);\n  };\n\n  RenderCamera.prototype.setRenderMode = function (renderMode) {\n    this._renderMode = renderMode;\n    this._perspective.fov = this._computeFov();\n\n    this._perspective.updateProjectionMatrix();\n\n    this._changed = true;\n  };\n\n  RenderCamera.prototype.setSize = function (size) {\n    this._perspective.aspect = this._computeAspect(size.width, size.height);\n    this._perspective.fov = this._computeFov();\n\n    this._perspective.updateProjectionMatrix();\n\n    this._changed = true;\n  };\n\n  RenderCamera.prototype._computeAspect = function (elementWidth, elementHeight) {\n    return elementWidth === 0 ? 0 : elementWidth / elementHeight;\n  };\n\n  RenderCamera.prototype._computeCurrentFov = function () {\n    if (this._perspective.aspect === 0) {\n      return 0;\n    }\n\n    if (!this._currentNodeId) {\n      return this._initialFov;\n    }\n\n    return this._currentPano ? this._yToFov(1, this._zoom) : this._computeVerticalFov(this._currentProjectedPoints, this._renderMode, this._zoom, this.perspective.aspect);\n  };\n\n  RenderCamera.prototype._computeFov = function () {\n    this._currentFov = this._computeCurrentFov();\n    this._previousFov = this._computePreviousFov();\n    return this._interpolateFov(this._currentFov, this._previousFov, this._alpha);\n  };\n\n  RenderCamera.prototype._computePreviousFov = function () {\n    if (this._perspective.aspect === 0) {\n      return 0;\n    }\n\n    if (!this._currentNodeId) {\n      return this._initialFov;\n    }\n\n    return !this._previousNodeId ? this._currentFov : this._previousPano ? this._yToFov(1, this._zoom) : this._computeVerticalFov(this._previousProjectedPoints, this._renderMode, this._zoom, this.perspective.aspect);\n  };\n\n  RenderCamera.prototype._computeProjectedPoints = function (transform) {\n    var vertices = [[0.5, 0], [1, 0]];\n    var directions = [[0.5, 0], [0, 0.5]];\n    var pointsPerLine = 100;\n    return Geo_1.Geo.computeProjectedPoints(transform, vertices, directions, pointsPerLine, this._viewportCoords);\n  };\n\n  RenderCamera.prototype._computeRequiredVerticalFov = function (projectedPoint, zoom, aspect) {\n    var maxY = Math.max(projectedPoint[0] / aspect, projectedPoint[1]);\n    return this._yToFov(maxY, zoom);\n  };\n\n  RenderCamera.prototype._computeRotation = function (camera) {\n    var direction = camera.lookat.clone().sub(camera.position);\n    var up = camera.up.clone();\n\n    var phi = this._spatial.azimuthal(direction.toArray(), up.toArray());\n\n    var theta = Math.PI / 2 - this._spatial.angleToPlane(direction.toArray(), [0, 0, 1]);\n\n    return {\n      phi: phi,\n      theta: theta\n    };\n  };\n\n  RenderCamera.prototype._computeVerticalFov = function (projectedPoints, renderMode, zoom, aspect) {\n    var _this = this;\n\n    var fovs = projectedPoints.map(function (projectedPoint) {\n      return _this._computeRequiredVerticalFov(projectedPoint, zoom, aspect);\n    });\n    var fov = renderMode === Render_1.RenderMode.Fill ? Math.min.apply(Math, fovs) * 0.995 : Math.max.apply(Math, fovs);\n    return fov;\n  };\n\n  RenderCamera.prototype._yToFov = function (y, zoom) {\n    return 2 * Math.atan(y / Math.pow(2, zoom)) * 180 / Math.PI;\n  };\n\n  RenderCamera.prototype._interpolateFov = function (v1, v2, alpha) {\n    return alpha * v1 + (1 - alpha) * v2;\n  };\n\n  RenderCamera.prototype._setFrameId = function (frameId) {\n    this._frameId = frameId;\n\n    if (this._changed) {\n      this._changed = false;\n      this._changedForFrame = frameId;\n    }\n  };\n\n  return RenderCamera;\n}();\n\nexports.RenderCamera = RenderCamera;\nexports.default = RenderCamera;\n\n//# sourceURL=webpack://Mapillary/./src/render/RenderCamera.ts?");

/***/ }),

/***/ "./src/render/RenderMode.ts":
/*!**********************************!*\
  !*** ./src/render/RenderMode.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enumeration for render mode\n * @enum {number}\n * @readonly\n * @description Modes for specifying how rendering is done\n * in the viewer. All modes preserves the original aspect\n * ratio of the images.\n */\n\nvar RenderMode;\n\n(function (RenderMode) {\n  /**\n   * Displays all content within the viewer.\n   *\n   * @description Black bars shown on both\n   * sides of the content. Bars are shown\n   * either below and above or to the left\n   * and right of the content depending on\n   * the aspect ratio relation between the\n   * image and the viewer.\n   */\n  RenderMode[RenderMode[\"Letterbox\"] = 0] = \"Letterbox\";\n  /**\n   * Fills the viewer by cropping content.\n   *\n   * @description Cropping is done either\n   * in horizontal or vertical direction\n   * depending on the aspect ratio relation\n   * between the image and the viewer.\n   */\n\n  RenderMode[RenderMode[\"Fill\"] = 1] = \"Fill\";\n})(RenderMode = exports.RenderMode || (exports.RenderMode = {}));\n\nexports.default = RenderMode;\n\n//# sourceURL=webpack://Mapillary/./src/render/RenderMode.ts?");

/***/ }),

/***/ "./src/render/RenderService.ts":
/*!*************************************!*\
  !*** ./src/render/RenderService.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Geo_1 = __webpack_require__(/*! ../Geo */ \"./src/Geo.ts\");\n\nvar Render_1 = __webpack_require__(/*! ../Render */ \"./src/Render.ts\");\n\nvar RenderService =\n/** @class */\nfunction () {\n  function RenderService(element, currentFrame$, renderMode, renderCamera) {\n    var _this = this;\n\n    this._element = element;\n    this._currentFrame$ = currentFrame$;\n    this._spatial = new Geo_1.Spatial();\n    renderMode = renderMode != null ? renderMode : Render_1.RenderMode.Fill;\n    this._resize$ = new rxjs_1.Subject();\n    this._renderCameraOperation$ = new rxjs_1.Subject();\n    this._size$ = new rxjs_1.BehaviorSubject({\n      height: this._element.offsetHeight,\n      width: this._element.offsetWidth\n    });\n\n    this._resize$.pipe(operators_1.map(function () {\n      return {\n        height: _this._element.offsetHeight,\n        width: _this._element.offsetWidth\n      };\n    })).subscribe(this._size$);\n\n    this._renderMode$ = new rxjs_1.BehaviorSubject(renderMode);\n    this._renderCameraHolder$ = this._renderCameraOperation$.pipe(operators_1.startWith(function (rc) {\n      return rc;\n    }), operators_1.scan(function (rc, operation) {\n      return operation(rc);\n    }, !!renderCamera ? renderCamera : new Render_1.RenderCamera(this._element.offsetWidth, this._element.offsetHeight, renderMode)), operators_1.publishReplay(1), operators_1.refCount());\n    this._renderCameraFrame$ = this._currentFrame$.pipe(operators_1.withLatestFrom(this._renderCameraHolder$), operators_1.tap(function (_a) {\n      var frame = _a[0],\n          rc = _a[1];\n      rc.setFrame(frame);\n    }), operators_1.map(function (args) {\n      return args[1];\n    }), operators_1.publishReplay(1), operators_1.refCount());\n    this._renderCamera$ = this._renderCameraFrame$.pipe(operators_1.filter(function (rc) {\n      return rc.changed;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n    this._bearing$ = this._renderCamera$.pipe(operators_1.map(function (rc) {\n      var bearing = _this._spatial.radToDeg(_this._spatial.azimuthalToBearing(rc.rotation.phi));\n\n      return _this._spatial.wrap(bearing, 0, 360);\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._size$.pipe(operators_1.skip(1), operators_1.map(function (size) {\n      return function (rc) {\n        rc.setSize(size);\n        return rc;\n      };\n    })).subscribe(this._renderCameraOperation$);\n\n    this._renderMode$.pipe(operators_1.skip(1), operators_1.map(function (rm) {\n      return function (rc) {\n        rc.setRenderMode(rm);\n        return rc;\n      };\n    })).subscribe(this._renderCameraOperation$);\n\n    this._bearing$.subscribe(function () {});\n\n    this._renderCameraHolder$.subscribe(function () {});\n\n    this._size$.subscribe(function () {});\n\n    this._renderMode$.subscribe(function () {});\n\n    this._renderCamera$.subscribe(function () {});\n\n    this._renderCameraFrame$.subscribe(function () {});\n  }\n\n  Object.defineProperty(RenderService.prototype, \"bearing$\", {\n    get: function get() {\n      return this._bearing$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderService.prototype, \"element\", {\n    get: function get() {\n      return this._element;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderService.prototype, \"resize$\", {\n    get: function get() {\n      return this._resize$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderService.prototype, \"size$\", {\n    get: function get() {\n      return this._size$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderService.prototype, \"renderMode$\", {\n    get: function get() {\n      return this._renderMode$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderService.prototype, \"renderCameraFrame$\", {\n    get: function get() {\n      return this._renderCameraFrame$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RenderService.prototype, \"renderCamera$\", {\n    get: function get() {\n      return this._renderCamera$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return RenderService;\n}();\n\nexports.RenderService = RenderService;\nexports.default = RenderService;\n\n//# sourceURL=webpack://Mapillary/./src/render/RenderService.ts?");

/***/ }),

/***/ "./src/state/FrameGenerator.ts":
/*!*************************************!*\
  !*** ./src/state/FrameGenerator.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar FrameGenerator =\n/** @class */\nfunction () {\n  function FrameGenerator(root) {\n    if (root.requestAnimationFrame) {\n      this._cancelAnimationFrame = root.cancelAnimationFrame.bind(root);\n      this._requestAnimationFrame = root.requestAnimationFrame.bind(root);\n    } else if (root.mozRequestAnimationFrame) {\n      this._cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);\n      this._requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);\n    } else if (root.webkitRequestAnimationFrame) {\n      this._cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);\n      this._requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);\n    } else if (root.msRequestAnimationFrame) {\n      this._cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);\n      this._requestAnimationFrame = root.msRequestAnimationFrame.bind(root);\n    } else if (root.oRequestAnimationFrame) {\n      this._cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);\n      this._requestAnimationFrame = root.oRequestAnimationFrame.bind(root);\n    } else {\n      this._cancelAnimationFrame = root.clearTimeout.bind(root);\n\n      this._requestAnimationFrame = function (cb) {\n        return root.setTimeout(cb, 1000 / 60);\n      };\n    }\n  }\n\n  Object.defineProperty(FrameGenerator.prototype, \"cancelAnimationFrame\", {\n    get: function get() {\n      return this._cancelAnimationFrame;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FrameGenerator.prototype, \"requestAnimationFrame\", {\n    get: function get() {\n      return this._requestAnimationFrame;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return FrameGenerator;\n}();\n\nexports.FrameGenerator = FrameGenerator;\nexports.default = FrameGenerator;\n\n//# sourceURL=webpack://Mapillary/./src/state/FrameGenerator.ts?");

/***/ }),

/***/ "./src/state/RotationDelta.ts":
/*!************************************!*\
  !*** ./src/state/RotationDelta.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar RotationDelta =\n/** @class */\nfunction () {\n  function RotationDelta(phi, theta) {\n    this._phi = phi;\n    this._theta = theta;\n  }\n\n  Object.defineProperty(RotationDelta.prototype, \"phi\", {\n    get: function get() {\n      return this._phi;\n    },\n    set: function set(value) {\n      this._phi = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RotationDelta.prototype, \"theta\", {\n    get: function get() {\n      return this._theta;\n    },\n    set: function set(value) {\n      this._theta = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RotationDelta.prototype, \"isZero\", {\n    get: function get() {\n      return this._phi === 0 && this._theta === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  RotationDelta.prototype.copy = function (delta) {\n    this._phi = delta.phi;\n    this._theta = delta.theta;\n  };\n\n  RotationDelta.prototype.lerp = function (other, alpha) {\n    this._phi = (1 - alpha) * this._phi + alpha * other.phi;\n    this._theta = (1 - alpha) * this._theta + alpha * other.theta;\n  };\n\n  RotationDelta.prototype.multiply = function (value) {\n    this._phi *= value;\n    this._theta *= value;\n  };\n\n  RotationDelta.prototype.threshold = function (value) {\n    this._phi = Math.abs(this._phi) > value ? this._phi : 0;\n    this._theta = Math.abs(this._theta) > value ? this._theta : 0;\n  };\n\n  RotationDelta.prototype.lengthSquared = function () {\n    return this._phi * this._phi + this._theta * this._theta;\n  };\n\n  RotationDelta.prototype.reset = function () {\n    this._phi = 0;\n    this._theta = 0;\n  };\n\n  return RotationDelta;\n}();\n\nexports.RotationDelta = RotationDelta;\nexports.default = RotationDelta;\n\n//# sourceURL=webpack://Mapillary/./src/state/RotationDelta.ts?");

/***/ }),

/***/ "./src/state/State.ts":
/*!****************************!*\
  !*** ./src/state/State.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar State;\n\n(function (State) {\n  State[State[\"Earth\"] = 0] = \"Earth\";\n  State[State[\"Traversing\"] = 1] = \"Traversing\";\n  State[State[\"Waiting\"] = 2] = \"Waiting\";\n  State[State[\"WaitingInteractively\"] = 3] = \"WaitingInteractively\";\n})(State = exports.State || (exports.State = {}));\n\nexports.default = State;\n\n//# sourceURL=webpack://Mapillary/./src/state/State.ts?");

/***/ }),

/***/ "./src/state/StateContext.ts":
/*!***********************************!*\
  !*** ./src/state/StateContext.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar State_1 = __webpack_require__(/*! ../State */ \"./src/State.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../Geo */ \"./src/Geo.ts\");\n\nvar StateContext =\n/** @class */\nfunction () {\n  function StateContext(transitionMode) {\n    this._state = new State_1.TraversingState({\n      alpha: 1,\n      camera: new Geo_1.Camera(),\n      currentIndex: -1,\n      reference: {\n        alt: 0,\n        lat: 0,\n        lon: 0\n      },\n      trajectory: [],\n      transitionMode: transitionMode == null ? State_1.TransitionMode.Default : transitionMode,\n      zoom: 0\n    });\n  }\n\n  StateContext.prototype.earth = function () {\n    this._state = this._state.earth();\n  };\n\n  StateContext.prototype.traverse = function () {\n    this._state = this._state.traverse();\n  };\n\n  StateContext.prototype.wait = function () {\n    this._state = this._state.wait();\n  };\n\n  StateContext.prototype.waitInteractively = function () {\n    this._state = this._state.waitInteractively();\n  };\n\n  Object.defineProperty(StateContext.prototype, \"state\", {\n    get: function get() {\n      if (this._state instanceof State_1.EarthState) {\n        return State_1.State.Earth;\n      } else if (this._state instanceof State_1.TraversingState) {\n        return State_1.State.Traversing;\n      } else if (this._state instanceof State_1.WaitingState) {\n        return State_1.State.Waiting;\n      } else if (this._state instanceof State_1.InteractiveWaitingState) {\n        return State_1.State.WaitingInteractively;\n      }\n\n      throw new Error(\"Invalid state\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"reference\", {\n    get: function get() {\n      return this._state.reference;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"alpha\", {\n    get: function get() {\n      return this._state.alpha;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"camera\", {\n    get: function get() {\n      return this._state.camera;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"zoom\", {\n    get: function get() {\n      return this._state.zoom;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"currentNode\", {\n    get: function get() {\n      return this._state.currentNode;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"previousNode\", {\n    get: function get() {\n      return this._state.previousNode;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"currentCamera\", {\n    get: function get() {\n      return this._state.currentCamera;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"currentTransform\", {\n    get: function get() {\n      return this._state.currentTransform;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"previousTransform\", {\n    get: function get() {\n      return this._state.previousTransform;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"trajectory\", {\n    get: function get() {\n      return this._state.trajectory;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"currentIndex\", {\n    get: function get() {\n      return this._state.currentIndex;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"lastNode\", {\n    get: function get() {\n      return this._state.trajectory[this._state.trajectory.length - 1];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"nodesAhead\", {\n    get: function get() {\n      return this._state.trajectory.length - 1 - this._state.currentIndex;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateContext.prototype, \"motionless\", {\n    get: function get() {\n      return this._state.motionless;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StateContext.prototype.getCenter = function () {\n    return this._state.getCenter();\n  };\n\n  StateContext.prototype.setCenter = function (center) {\n    this._state.setCenter(center);\n  };\n\n  StateContext.prototype.setZoom = function (zoom) {\n    this._state.setZoom(zoom);\n  };\n\n  StateContext.prototype.update = function (fps) {\n    this._state.update(fps);\n  };\n\n  StateContext.prototype.append = function (nodes) {\n    this._state.append(nodes);\n  };\n\n  StateContext.prototype.prepend = function (nodes) {\n    this._state.prepend(nodes);\n  };\n\n  StateContext.prototype.remove = function (n) {\n    this._state.remove(n);\n  };\n\n  StateContext.prototype.clear = function () {\n    this._state.clear();\n  };\n\n  StateContext.prototype.clearPrior = function () {\n    this._state.clearPrior();\n  };\n\n  StateContext.prototype.cut = function () {\n    this._state.cut();\n  };\n\n  StateContext.prototype.set = function (nodes) {\n    this._state.set(nodes);\n  };\n\n  StateContext.prototype.rotate = function (delta) {\n    this._state.rotate(delta);\n  };\n\n  StateContext.prototype.rotateUnbounded = function (delta) {\n    this._state.rotateUnbounded(delta);\n  };\n\n  StateContext.prototype.rotateWithoutInertia = function (delta) {\n    this._state.rotateWithoutInertia(delta);\n  };\n\n  StateContext.prototype.rotateBasic = function (basicRotation) {\n    this._state.rotateBasic(basicRotation);\n  };\n\n  StateContext.prototype.rotateBasicUnbounded = function (basicRotation) {\n    this._state.rotateBasicUnbounded(basicRotation);\n  };\n\n  StateContext.prototype.rotateBasicWithoutInertia = function (basicRotation) {\n    this._state.rotateBasicWithoutInertia(basicRotation);\n  };\n\n  StateContext.prototype.rotateToBasic = function (basic) {\n    this._state.rotateToBasic(basic);\n  };\n\n  StateContext.prototype.move = function (delta) {\n    this._state.move(delta);\n  };\n\n  StateContext.prototype.moveTo = function (delta) {\n    this._state.moveTo(delta);\n  };\n\n  StateContext.prototype.zoomIn = function (delta, reference) {\n    this._state.zoomIn(delta, reference);\n  };\n\n  StateContext.prototype.setSpeed = function (speed) {\n    this._state.setSpeed(speed);\n  };\n\n  StateContext.prototype.setTransitionMode = function (mode) {\n    this._state.setTransitionMode(mode);\n  };\n\n  StateContext.prototype.dolly = function (delta) {\n    this._state.dolly(delta);\n  };\n\n  StateContext.prototype.orbit = function (rotation) {\n    this._state.orbit(rotation);\n  };\n\n  StateContext.prototype.truck = function (direction) {\n    this._state.truck(direction);\n  };\n\n  return StateContext;\n}();\n\nexports.StateContext = StateContext;\n\n//# sourceURL=webpack://Mapillary/./src/state/StateContext.ts?");

/***/ }),

/***/ "./src/state/StateService.ts":
/*!***********************************!*\
  !*** ./src/state/StateService.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar State_1 = __webpack_require__(/*! ../State */ \"./src/State.ts\");\n\nvar StateService =\n/** @class */\nfunction () {\n  function StateService(transitionMode) {\n    var _this = this;\n\n    this._appendNode$ = new rxjs_1.Subject();\n    this._start$ = new rxjs_1.Subject();\n    this._frame$ = new rxjs_1.Subject();\n    this._fpsSampleRate = 30;\n    this._contextOperation$ = new rxjs_1.BehaviorSubject(function (context) {\n      return context;\n    });\n    this._context$ = this._contextOperation$.pipe(operators_1.scan(function (context, operation) {\n      return operation(context);\n    }, new State_1.StateContext(transitionMode)), operators_1.publishReplay(1), operators_1.refCount());\n    this._state$ = this._context$.pipe(operators_1.map(function (context) {\n      return context.state;\n    }), operators_1.distinctUntilChanged(), operators_1.publishReplay(1), operators_1.refCount());\n    this._fps$ = this._start$.pipe(operators_1.switchMap(function () {\n      return _this._frame$.pipe(operators_1.bufferCount(1, _this._fpsSampleRate), operators_1.map(function (frameIds) {\n        return new Date().getTime();\n      }), operators_1.pairwise(), operators_1.map(function (times) {\n        return Math.max(20, 1000 * _this._fpsSampleRate / (times[1] - times[0]));\n      }), operators_1.startWith(60));\n    }), operators_1.share());\n    this._currentState$ = this._frame$.pipe(operators_1.withLatestFrom(this._fps$, this._context$, function (frameId, fps, context) {\n      return [frameId, fps, context];\n    }), operators_1.filter(function (fc) {\n      return fc[2].currentNode != null;\n    }), operators_1.tap(function (fc) {\n      fc[2].update(fc[1]);\n    }), operators_1.map(function (fc) {\n      return {\n        fps: fc[1],\n        id: fc[0],\n        state: fc[2]\n      };\n    }), operators_1.share());\n    this._lastState$ = this._currentState$.pipe(operators_1.publishReplay(1), operators_1.refCount());\n\n    var nodeChanged$ = this._currentState$.pipe(operators_1.distinctUntilChanged(undefined, function (f) {\n      return f.state.currentNode.key;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    var nodeChangedSubject$ = new rxjs_1.Subject();\n    nodeChanged$.subscribe(nodeChangedSubject$);\n    this._currentKey$ = new rxjs_1.BehaviorSubject(null);\n    nodeChangedSubject$.pipe(operators_1.map(function (f) {\n      return f.state.currentNode.key;\n    })).subscribe(this._currentKey$);\n    this._currentNode$ = nodeChangedSubject$.pipe(operators_1.map(function (f) {\n      return f.state.currentNode;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n    this._currentCamera$ = nodeChangedSubject$.pipe(operators_1.map(function (f) {\n      return f.state.currentCamera;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n    this._currentTransform$ = nodeChangedSubject$.pipe(operators_1.map(function (f) {\n      return f.state.currentTransform;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n    this._reference$ = nodeChangedSubject$.pipe(operators_1.map(function (f) {\n      return f.state.reference;\n    }), operators_1.distinctUntilChanged(function (r1, r2) {\n      return r1.lat === r2.lat && r1.lon === r2.lon;\n    }, function (reference) {\n      return {\n        lat: reference.lat,\n        lon: reference.lon\n      };\n    }), operators_1.publishReplay(1), operators_1.refCount());\n    this._currentNodeExternal$ = nodeChanged$.pipe(operators_1.map(function (f) {\n      return f.state.currentNode;\n    }), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._appendNode$.pipe(operators_1.map(function (node) {\n      return function (context) {\n        context.append([node]);\n        return context;\n      };\n    })).subscribe(this._contextOperation$);\n\n    this._inMotionOperation$ = new rxjs_1.Subject();\n    nodeChanged$.pipe(operators_1.map(function (frame) {\n      return true;\n    })).subscribe(this._inMotionOperation$);\n\n    this._inMotionOperation$.pipe(operators_1.distinctUntilChanged(), operators_1.filter(function (moving) {\n      return moving;\n    }), operators_1.switchMap(function (moving) {\n      return _this._currentState$.pipe(operators_1.filter(function (frame) {\n        return frame.state.nodesAhead === 0;\n      }), operators_1.map(function (frame) {\n        return [frame.state.camera.clone(), frame.state.zoom];\n      }), operators_1.pairwise(), operators_1.map(function (pair) {\n        var c1 = pair[0][0];\n        var c2 = pair[1][0];\n        var z1 = pair[0][1];\n        var z2 = pair[1][1];\n        return c1.diff(c2) > 1e-5 || Math.abs(z1 - z2) > 1e-5;\n      }), operators_1.first(function (changed) {\n        return !changed;\n      }));\n    })).subscribe(this._inMotionOperation$);\n\n    this._inMotion$ = this._inMotionOperation$.pipe(operators_1.distinctUntilChanged(), operators_1.publishReplay(1), operators_1.refCount());\n    this._inTranslationOperation$ = new rxjs_1.Subject();\n    nodeChanged$.pipe(operators_1.map(function (frame) {\n      return true;\n    })).subscribe(this._inTranslationOperation$);\n\n    this._inTranslationOperation$.pipe(operators_1.distinctUntilChanged(), operators_1.filter(function (inTranslation) {\n      return inTranslation;\n    }), operators_1.switchMap(function (inTranslation) {\n      return _this._currentState$.pipe(operators_1.filter(function (frame) {\n        return frame.state.nodesAhead === 0;\n      }), operators_1.map(function (frame) {\n        return frame.state.camera.position.clone();\n      }), operators_1.pairwise(), operators_1.map(function (pair) {\n        return pair[0].distanceToSquared(pair[1]) !== 0;\n      }), operators_1.first(function (changed) {\n        return !changed;\n      }));\n    })).subscribe(this._inTranslationOperation$);\n\n    this._inTranslation$ = this._inTranslationOperation$.pipe(operators_1.distinctUntilChanged(), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._state$.subscribe(function () {});\n\n    this._currentNode$.subscribe(function () {});\n\n    this._currentCamera$.subscribe(function () {});\n\n    this._currentTransform$.subscribe(function () {});\n\n    this._reference$.subscribe(function () {});\n\n    this._currentNodeExternal$.subscribe(function () {});\n\n    this._lastState$.subscribe(function () {});\n\n    this._inMotion$.subscribe(function () {});\n\n    this._inTranslation$.subscribe(function () {});\n\n    this._frameId = null;\n    this._frameGenerator = new State_1.FrameGenerator(window);\n  }\n\n  Object.defineProperty(StateService.prototype, \"currentState$\", {\n    get: function get() {\n      return this._currentState$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"currentNode$\", {\n    get: function get() {\n      return this._currentNode$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"currentKey$\", {\n    get: function get() {\n      return this._currentKey$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"currentNodeExternal$\", {\n    get: function get() {\n      return this._currentNodeExternal$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"currentCamera$\", {\n    get: function get() {\n      return this._currentCamera$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"currentTransform$\", {\n    get: function get() {\n      return this._currentTransform$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"state$\", {\n    get: function get() {\n      return this._state$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"reference$\", {\n    get: function get() {\n      return this._reference$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"inMotion$\", {\n    get: function get() {\n      return this._inMotion$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"inTranslation$\", {\n    get: function get() {\n      return this._inTranslation$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateService.prototype, \"appendNode$\", {\n    get: function get() {\n      return this._appendNode$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StateService.prototype.earth = function () {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.earth();\n    });\n  };\n\n  StateService.prototype.traverse = function () {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.traverse();\n    });\n  };\n\n  StateService.prototype.wait = function () {\n    this._invokeContextOperation(function (context) {\n      context.wait();\n    });\n  };\n\n  StateService.prototype.waitInteractively = function () {\n    this._invokeContextOperation(function (context) {\n      context.waitInteractively();\n    });\n  };\n\n  StateService.prototype.appendNodes = function (nodes) {\n    this._invokeContextOperation(function (context) {\n      context.append(nodes);\n    });\n  };\n\n  StateService.prototype.prependNodes = function (nodes) {\n    this._invokeContextOperation(function (context) {\n      context.prepend(nodes);\n    });\n  };\n\n  StateService.prototype.removeNodes = function (n) {\n    this._invokeContextOperation(function (context) {\n      context.remove(n);\n    });\n  };\n\n  StateService.prototype.clearNodes = function () {\n    this._invokeContextOperation(function (context) {\n      context.clear();\n    });\n  };\n\n  StateService.prototype.clearPriorNodes = function () {\n    this._invokeContextOperation(function (context) {\n      context.clearPrior();\n    });\n  };\n\n  StateService.prototype.cutNodes = function () {\n    this._invokeContextOperation(function (context) {\n      context.cut();\n    });\n  };\n\n  StateService.prototype.setNodes = function (nodes) {\n    this._invokeContextOperation(function (context) {\n      context.set(nodes);\n    });\n  };\n\n  StateService.prototype.rotate = function (delta) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.rotate(delta);\n    });\n  };\n\n  StateService.prototype.rotateUnbounded = function (delta) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.rotateUnbounded(delta);\n    });\n  };\n\n  StateService.prototype.rotateWithoutInertia = function (delta) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.rotateWithoutInertia(delta);\n    });\n  };\n\n  StateService.prototype.rotateBasic = function (basicRotation) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.rotateBasic(basicRotation);\n    });\n  };\n\n  StateService.prototype.rotateBasicUnbounded = function (basicRotation) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.rotateBasicUnbounded(basicRotation);\n    });\n  };\n\n  StateService.prototype.rotateBasicWithoutInertia = function (basicRotation) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.rotateBasicWithoutInertia(basicRotation);\n    });\n  };\n\n  StateService.prototype.rotateToBasic = function (basic) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.rotateToBasic(basic);\n    });\n  };\n\n  StateService.prototype.move = function (delta) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.move(delta);\n    });\n  };\n\n  StateService.prototype.moveTo = function (position) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.moveTo(position);\n    });\n  };\n\n  StateService.prototype.dolly = function (delta) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.dolly(delta);\n    });\n  };\n\n  StateService.prototype.orbit = function (rotation) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.orbit(rotation);\n    });\n  };\n\n  StateService.prototype.truck = function (direction) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.truck(direction);\n    });\n  };\n  /**\n   * Change zoom level while keeping the reference point position approximately static.\n   *\n   * @parameter {number} delta - Change in zoom level.\n   * @parameter {Array<number>} reference - Reference point in basic coordinates.\n   */\n\n\n  StateService.prototype.zoomIn = function (delta, reference) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.zoomIn(delta, reference);\n    });\n  };\n\n  StateService.prototype.getCenter = function () {\n    return this._lastState$.pipe(operators_1.first(), operators_1.map(function (frame) {\n      return frame.state.getCenter();\n    }));\n  };\n\n  StateService.prototype.getZoom = function () {\n    return this._lastState$.pipe(operators_1.first(), operators_1.map(function (frame) {\n      return frame.state.zoom;\n    }));\n  };\n\n  StateService.prototype.setCenter = function (center) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.setCenter(center);\n    });\n  };\n\n  StateService.prototype.setSpeed = function (speed) {\n    this._invokeContextOperation(function (context) {\n      context.setSpeed(speed);\n    });\n  };\n\n  StateService.prototype.setTransitionMode = function (mode) {\n    this._invokeContextOperation(function (context) {\n      context.setTransitionMode(mode);\n    });\n  };\n\n  StateService.prototype.setZoom = function (zoom) {\n    this._inMotionOperation$.next(true);\n\n    this._invokeContextOperation(function (context) {\n      context.setZoom(zoom);\n    });\n  };\n\n  StateService.prototype.start = function () {\n    if (this._frameId == null) {\n      this._start$.next(null);\n\n      this._frameId = this._frameGenerator.requestAnimationFrame(this._frame.bind(this));\n\n      this._frame$.next(this._frameId);\n    }\n  };\n\n  StateService.prototype.stop = function () {\n    if (this._frameId != null) {\n      this._frameGenerator.cancelAnimationFrame(this._frameId);\n\n      this._frameId = null;\n    }\n  };\n\n  StateService.prototype._invokeContextOperation = function (action) {\n    this._contextOperation$.next(function (context) {\n      action(context);\n      return context;\n    });\n  };\n\n  StateService.prototype._frame = function (time) {\n    this._frameId = this._frameGenerator.requestAnimationFrame(this._frame.bind(this));\n\n    this._frame$.next(this._frameId);\n  };\n\n  return StateService;\n}();\n\nexports.StateService = StateService;\n\n//# sourceURL=webpack://Mapillary/./src/state/StateService.ts?");

/***/ }),

/***/ "./src/state/TransitionMode.ts":
/*!*************************************!*\
  !*** ./src/state/TransitionMode.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enumeration for transition mode\n * @enum {number}\n * @readonly\n * @description Modes for specifying how transitions\n * between nodes are performed.\n */\n\nvar TransitionMode;\n\n(function (TransitionMode) {\n  /**\n   * Default transitions.\n   *\n   * @description The viewer dynamically determines\n   * whether transitions should be performed with or\n   * without motion and blending for each transition\n   * based on the underlying data.\n   */\n  TransitionMode[TransitionMode[\"Default\"] = 0] = \"Default\";\n  /**\n   * Instantaneous transitions.\n   *\n   * @description All transitions are performed\n   * without motion or blending.\n   */\n\n  TransitionMode[TransitionMode[\"Instantaneous\"] = 1] = \"Instantaneous\";\n})(TransitionMode = exports.TransitionMode || (exports.TransitionMode = {}));\n\nexports.default = TransitionMode;\n\n//# sourceURL=webpack://Mapillary/./src/state/TransitionMode.ts?");

/***/ }),

/***/ "./src/state/states/EarthState.ts":
/*!****************************************!*\
  !*** ./src/state/states/EarthState.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar State_1 = __webpack_require__(/*! ../../State */ \"./src/State.ts\");\n\nvar EarthState =\n/** @class */\nfunction (_super) {\n  __extends(EarthState, _super);\n\n  function EarthState(state) {\n    var _this = _super.call(this, state) || this;\n\n    var viewingDirection = _this._camera.lookat.clone().sub(_this._camera.position).normalize();\n\n    _this._camera.lookat.copy(_this._camera.position);\n\n    _this._camera.position.z = state.camera.position.z + 20;\n    _this._camera.position.x = state.camera.position.x - 16 * viewingDirection.x;\n    _this._camera.position.y = state.camera.position.y - 16 * viewingDirection.y;\n\n    _this._camera.up.set(0, 0, 1);\n\n    return _this;\n  }\n\n  EarthState.prototype.traverse = function () {\n    return new State_1.TraversingState(this);\n  };\n\n  EarthState.prototype.wait = function () {\n    return new State_1.WaitingState(this);\n  };\n\n  EarthState.prototype.waitInteractively = function () {\n    return new State_1.InteractiveWaitingState(this);\n  };\n\n  EarthState.prototype.dolly = function (delta) {\n    var camera = this._camera;\n    var offset = new THREE.Vector3().copy(camera.position).sub(camera.lookat);\n    var length = offset.length();\n    var scaled = length * Math.pow(2, -delta);\n    var clipped = Math.max(1, Math.min(scaled, 1000));\n    offset.normalize();\n    offset.multiplyScalar(clipped);\n    camera.position.copy(camera.lookat).add(offset);\n  };\n\n  EarthState.prototype.orbit = function (rotation) {\n    var camera = this._camera;\n    var q = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 0, 1));\n    var qInverse = q.clone().inverse();\n    var offset = new THREE.Vector3();\n    offset.copy(camera.position).sub(camera.lookat);\n    offset.applyQuaternion(q);\n    var length = offset.length();\n    var phi = Math.atan2(offset.y, offset.x);\n    phi += rotation.phi;\n    var theta = Math.atan2(Math.sqrt(offset.x * offset.x + offset.y * offset.y), offset.z);\n    theta += rotation.theta;\n    theta = Math.max(0.1, Math.min(Math.PI - 0.1, theta));\n    offset.x = Math.sin(theta) * Math.cos(phi);\n    offset.y = Math.sin(theta) * Math.sin(phi);\n    offset.z = Math.cos(theta);\n    offset.applyQuaternion(qInverse);\n    camera.position.copy(camera.lookat).add(offset.multiplyScalar(length));\n  };\n\n  EarthState.prototype.truck = function (direction) {\n    this._camera.position.add(new THREE.Vector3().fromArray(direction));\n\n    this._camera.lookat.add(new THREE.Vector3().fromArray(direction));\n  };\n\n  EarthState.prototype.update = function () {};\n\n  return EarthState;\n}(State_1.StateBase);\n\nexports.EarthState = EarthState;\nexports.default = EarthState;\n\n//# sourceURL=webpack://Mapillary/./src/state/states/EarthState.ts?");

/***/ }),

/***/ "./src/state/states/InteractiveStateBase.ts":
/*!**************************************************!*\
  !*** ./src/state/states/InteractiveStateBase.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar State_1 = __webpack_require__(/*! ../../State */ \"./src/State.ts\");\n\nvar InteractiveStateBase =\n/** @class */\nfunction (_super) {\n  __extends(InteractiveStateBase, _super);\n\n  function InteractiveStateBase(state) {\n    var _this = _super.call(this, state) || this;\n\n    _this._animationSpeed = 1 / 40;\n    _this._rotationDelta = new State_1.RotationDelta(0, 0);\n    _this._requestedRotationDelta = null;\n    _this._basicRotation = [0, 0];\n    _this._requestedBasicRotation = null;\n    _this._requestedBasicRotationUnbounded = null;\n    _this._rotationAcceleration = 0.86;\n    _this._rotationIncreaseAlpha = 0.97;\n    _this._rotationDecreaseAlpha = 0.9;\n    _this._rotationThreshold = 1e-3;\n    _this._unboundedRotationAlpha = 0.8;\n    _this._desiredZoom = state.zoom;\n    _this._minZoom = 0;\n    _this._maxZoom = 3;\n    _this._lookatDepth = 10;\n    _this._desiredLookat = null;\n    _this._desiredCenter = null;\n    return _this;\n  }\n\n  InteractiveStateBase.prototype.rotate = function (rotationDelta) {\n    if (this._currentNode == null) {\n      return;\n    }\n\n    if (rotationDelta.phi === 0 && rotationDelta.theta === 0) {\n      return;\n    }\n\n    this._desiredZoom = this._zoom;\n    this._desiredLookat = null;\n    this._requestedBasicRotation = null;\n\n    if (this._requestedRotationDelta != null) {\n      this._requestedRotationDelta.phi = this._requestedRotationDelta.phi + rotationDelta.phi;\n      this._requestedRotationDelta.theta = this._requestedRotationDelta.theta + rotationDelta.theta;\n    } else {\n      this._requestedRotationDelta = new State_1.RotationDelta(rotationDelta.phi, rotationDelta.theta);\n    }\n  };\n\n  InteractiveStateBase.prototype.rotateUnbounded = function (delta) {\n    if (this._currentNode == null) {\n      return;\n    }\n\n    this._requestedBasicRotation = null;\n    this._requestedRotationDelta = null;\n\n    this._applyRotation(delta, this._currentCamera);\n\n    this._applyRotation(delta, this._previousCamera);\n\n    if (!this._desiredLookat) {\n      return;\n    }\n\n    var q = new THREE.Quaternion().setFromUnitVectors(this._currentCamera.up, new THREE.Vector3(0, 0, 1));\n    var qInverse = q.clone().inverse();\n    var offset = new THREE.Vector3().copy(this._desiredLookat).sub(this._camera.position).applyQuaternion(q);\n    var length = offset.length();\n    var phi = Math.atan2(offset.y, offset.x);\n    phi += delta.phi;\n    var theta = Math.atan2(Math.sqrt(offset.x * offset.x + offset.y * offset.y), offset.z);\n    theta += delta.theta;\n    theta = Math.max(0.1, Math.min(Math.PI - 0.1, theta));\n    offset.x = Math.sin(theta) * Math.cos(phi);\n    offset.y = Math.sin(theta) * Math.sin(phi);\n    offset.z = Math.cos(theta);\n    offset.applyQuaternion(qInverse);\n\n    this._desiredLookat.copy(this._camera.position).add(offset.multiplyScalar(length));\n  };\n\n  InteractiveStateBase.prototype.rotateWithoutInertia = function (rotationDelta) {\n    if (this._currentNode == null) {\n      return;\n    }\n\n    this._desiredZoom = this._zoom;\n    this._desiredLookat = null;\n    this._requestedBasicRotation = null;\n    this._requestedRotationDelta = null;\n    var threshold = Math.PI / (10 * Math.pow(2, this._zoom));\n    var delta = {\n      phi: this._spatial.clamp(rotationDelta.phi, -threshold, threshold),\n      theta: this._spatial.clamp(rotationDelta.theta, -threshold, threshold)\n    };\n\n    this._applyRotation(delta, this._currentCamera);\n\n    this._applyRotation(delta, this._previousCamera);\n  };\n\n  InteractiveStateBase.prototype.rotateBasic = function (basicRotation) {\n    if (this._currentNode == null) {\n      return;\n    }\n\n    this._desiredZoom = this._zoom;\n    this._desiredLookat = null;\n    this._requestedRotationDelta = null;\n\n    if (this._requestedBasicRotation != null) {\n      this._requestedBasicRotation[0] += basicRotation[0];\n      this._requestedBasicRotation[1] += basicRotation[1];\n      var threshold = 0.05 / Math.pow(2, this._zoom);\n      this._requestedBasicRotation[0] = this._spatial.clamp(this._requestedBasicRotation[0], -threshold, threshold);\n      this._requestedBasicRotation[1] = this._spatial.clamp(this._requestedBasicRotation[1], -threshold, threshold);\n    } else {\n      this._requestedBasicRotation = basicRotation.slice();\n    }\n  };\n\n  InteractiveStateBase.prototype.rotateBasicUnbounded = function (basicRotation) {\n    if (this._currentNode == null) {\n      return;\n    }\n\n    if (this._requestedBasicRotationUnbounded != null) {\n      this._requestedBasicRotationUnbounded[0] += basicRotation[0];\n      this._requestedBasicRotationUnbounded[1] += basicRotation[1];\n    } else {\n      this._requestedBasicRotationUnbounded = basicRotation.slice();\n    }\n  };\n\n  InteractiveStateBase.prototype.rotateBasicWithoutInertia = function (basic) {\n    if (this._currentNode == null) {\n      return;\n    }\n\n    this._desiredZoom = this._zoom;\n    this._desiredLookat = null;\n    this._requestedRotationDelta = null;\n    this._requestedBasicRotation = null;\n    var threshold = 0.05 / Math.pow(2, this._zoom);\n    var basicRotation = basic.slice();\n    basicRotation[0] = this._spatial.clamp(basicRotation[0], -threshold, threshold);\n    basicRotation[1] = this._spatial.clamp(basicRotation[1], -threshold, threshold);\n\n    this._applyRotationBasic(basicRotation);\n  };\n\n  InteractiveStateBase.prototype.rotateToBasic = function (basic) {\n    if (this._currentNode == null) {\n      return;\n    }\n\n    this._desiredZoom = this._zoom;\n    this._desiredLookat = null;\n    basic[0] = this._spatial.clamp(basic[0], 0, 1);\n    basic[1] = this._spatial.clamp(basic[1], 0, 1);\n    var lookat = this.currentTransform.unprojectBasic(basic, this._lookatDepth);\n\n    this._currentCamera.lookat.fromArray(lookat);\n  };\n\n  InteractiveStateBase.prototype.zoomIn = function (delta, reference) {\n    if (this._currentNode == null) {\n      return;\n    }\n\n    this._desiredZoom = Math.max(this._minZoom, Math.min(this._maxZoom, this._desiredZoom + delta));\n    var currentCenter = this.currentTransform.projectBasic(this._currentCamera.lookat.toArray());\n    var currentCenterX = currentCenter[0];\n    var currentCenterY = currentCenter[1];\n    var zoom0 = Math.pow(2, this._zoom);\n    var zoom1 = Math.pow(2, this._desiredZoom);\n    var refX = reference[0];\n    var refY = reference[1];\n\n    if (this.currentTransform.gpano != null && this.currentTransform.gpano.CroppedAreaImageWidthPixels === this.currentTransform.gpano.FullPanoWidthPixels) {\n      if (refX - currentCenterX > 0.5) {\n        refX = refX - 1;\n      } else if (currentCenterX - refX > 0.5) {\n        refX = 1 + refX;\n      }\n    }\n\n    var newCenterX = refX - zoom0 / zoom1 * (refX - currentCenterX);\n    var newCenterY = refY - zoom0 / zoom1 * (refY - currentCenterY);\n    var gpano = this.currentTransform.gpano;\n\n    if (this._currentNode.fullPano) {\n      newCenterX = this._spatial.wrap(newCenterX + this._basicRotation[0], 0, 1);\n      newCenterY = this._spatial.clamp(newCenterY + this._basicRotation[1], 0.05, 0.95);\n    } else if (gpano != null && this.currentTransform.gpano.CroppedAreaImageWidthPixels === this.currentTransform.gpano.FullPanoWidthPixels) {\n      newCenterX = this._spatial.wrap(newCenterX + this._basicRotation[0], 0, 1);\n      newCenterY = this._spatial.clamp(newCenterY + this._basicRotation[1], 0, 1);\n    } else {\n      newCenterX = this._spatial.clamp(newCenterX, 0, 1);\n      newCenterY = this._spatial.clamp(newCenterY, 0, 1);\n    }\n\n    this._desiredLookat = new THREE.Vector3().fromArray(this.currentTransform.unprojectBasic([newCenterX, newCenterY], this._lookatDepth));\n  };\n\n  InteractiveStateBase.prototype.setCenter = function (center) {\n    this._desiredLookat = null;\n    this._requestedRotationDelta = null;\n    this._requestedBasicRotation = null;\n    this._desiredZoom = this._zoom;\n    var clamped = [this._spatial.clamp(center[0], 0, 1), this._spatial.clamp(center[1], 0, 1)];\n\n    if (this._currentNode == null) {\n      this._desiredCenter = clamped;\n      return;\n    }\n\n    this._desiredCenter = null;\n    var currentLookat = new THREE.Vector3().fromArray(this.currentTransform.unprojectBasic(clamped, this._lookatDepth));\n    var previousTransform = this.previousTransform != null ? this.previousTransform : this.currentTransform;\n    var previousLookat = new THREE.Vector3().fromArray(previousTransform.unprojectBasic(clamped, this._lookatDepth));\n\n    this._currentCamera.lookat.copy(currentLookat);\n\n    this._previousCamera.lookat.copy(previousLookat);\n  };\n\n  InteractiveStateBase.prototype.setZoom = function (zoom) {\n    this._desiredLookat = null;\n    this._requestedRotationDelta = null;\n    this._requestedBasicRotation = null;\n    this._zoom = this._spatial.clamp(zoom, this._minZoom, this._maxZoom);\n    this._desiredZoom = this._zoom;\n  };\n\n  InteractiveStateBase.prototype._applyRotation = function (delta, camera) {\n    if (camera == null) {\n      return;\n    }\n\n    var q = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 0, 1));\n    var qInverse = q.clone().inverse();\n    var offset = new THREE.Vector3();\n    offset.copy(camera.lookat).sub(camera.position);\n    offset.applyQuaternion(q);\n    var length = offset.length();\n    var phi = Math.atan2(offset.y, offset.x);\n    phi += delta.phi;\n    var theta = Math.atan2(Math.sqrt(offset.x * offset.x + offset.y * offset.y), offset.z);\n    theta += delta.theta;\n    theta = Math.max(0.1, Math.min(Math.PI - 0.1, theta));\n    offset.x = Math.sin(theta) * Math.cos(phi);\n    offset.y = Math.sin(theta) * Math.sin(phi);\n    offset.z = Math.cos(theta);\n    offset.applyQuaternion(qInverse);\n    camera.lookat.copy(camera.position).add(offset.multiplyScalar(length));\n  };\n\n  InteractiveStateBase.prototype._applyRotationBasic = function (basicRotation) {\n    var currentNode = this._currentNode;\n    var previousNode = this._previousNode != null ? this.previousNode : this.currentNode;\n    var currentCamera = this._currentCamera;\n    var previousCamera = this._previousCamera;\n    var currentTransform = this.currentTransform;\n    var previousTransform = this.previousTransform != null ? this.previousTransform : this.currentTransform;\n    var currentBasic = currentTransform.projectBasic(currentCamera.lookat.toArray());\n    var previousBasic = previousTransform.projectBasic(previousCamera.lookat.toArray());\n    var currentGPano = currentTransform.gpano;\n    var previousGPano = previousTransform.gpano;\n\n    if (currentNode.fullPano) {\n      currentBasic[0] = this._spatial.wrap(currentBasic[0] + basicRotation[0], 0, 1);\n      currentBasic[1] = this._spatial.clamp(currentBasic[1] + basicRotation[1], 0.05, 0.95);\n    } else if (currentGPano != null && currentTransform.gpano.CroppedAreaImageWidthPixels === currentTransform.gpano.FullPanoWidthPixels) {\n      currentBasic[0] = this._spatial.wrap(currentBasic[0] + basicRotation[0], 0, 1);\n      currentBasic[1] = this._spatial.clamp(currentBasic[1] + basicRotation[1], 0, 1);\n    } else {\n      currentBasic[0] = this._spatial.clamp(currentBasic[0] + basicRotation[0], 0, 1);\n      currentBasic[1] = this._spatial.clamp(currentBasic[1] + basicRotation[1], 0, 1);\n    }\n\n    if (previousNode.fullPano) {\n      previousBasic[0] = this._spatial.wrap(previousBasic[0] + basicRotation[0], 0, 1);\n      previousBasic[1] = this._spatial.clamp(previousBasic[1] + basicRotation[1], 0.05, 0.95);\n    } else if (previousGPano != null && previousTransform.gpano.CroppedAreaImageWidthPixels === previousTransform.gpano.FullPanoWidthPixels) {\n      previousBasic[0] = this._spatial.wrap(previousBasic[0] + basicRotation[0], 0, 1);\n      previousBasic[1] = this._spatial.clamp(previousBasic[1] + basicRotation[1], 0, 1);\n    } else {\n      previousBasic[0] = this._spatial.clamp(previousBasic[0] + basicRotation[0], 0, 1);\n      previousBasic[1] = this._spatial.clamp(currentBasic[1] + basicRotation[1], 0, 1);\n    }\n\n    var currentLookat = currentTransform.unprojectBasic(currentBasic, this._lookatDepth);\n    currentCamera.lookat.fromArray(currentLookat);\n    var previousLookat = previousTransform.unprojectBasic(previousBasic, this._lookatDepth);\n    previousCamera.lookat.fromArray(previousLookat);\n  };\n\n  InteractiveStateBase.prototype._updateZoom = function (animationSpeed) {\n    var diff = this._desiredZoom - this._zoom;\n    var sign = diff > 0 ? 1 : diff < 0 ? -1 : 0;\n\n    if (diff === 0) {\n      return;\n    } else if (Math.abs(diff) < 2e-3) {\n      this._zoom = this._desiredZoom;\n\n      if (this._desiredLookat != null) {\n        this._desiredLookat = null;\n      }\n    } else {\n      this._zoom += sign * Math.max(Math.abs(5 * animationSpeed * diff), 2e-3);\n    }\n  };\n\n  InteractiveStateBase.prototype._updateLookat = function (animationSpeed) {\n    if (this._desiredLookat === null) {\n      return;\n    }\n\n    var diff = this._desiredLookat.distanceToSquared(this._currentCamera.lookat);\n\n    if (Math.abs(diff) < 1e-6) {\n      this._currentCamera.lookat.copy(this._desiredLookat);\n\n      this._desiredLookat = null;\n    } else {\n      this._currentCamera.lookat.lerp(this._desiredLookat, 5 * animationSpeed);\n    }\n  };\n\n  InteractiveStateBase.prototype._updateRotation = function () {\n    if (this._requestedRotationDelta != null) {\n      var length_1 = this._rotationDelta.lengthSquared();\n\n      var requestedLength = this._requestedRotationDelta.lengthSquared();\n\n      if (requestedLength > length_1) {\n        this._rotationDelta.lerp(this._requestedRotationDelta, this._rotationIncreaseAlpha);\n      } else {\n        this._rotationDelta.lerp(this._requestedRotationDelta, this._rotationDecreaseAlpha);\n      }\n\n      this._requestedRotationDelta = null;\n      return;\n    }\n\n    if (this._rotationDelta.isZero) {\n      return;\n    }\n\n    var alpha = this.currentNode.fullPano ? 1 : this._alpha;\n\n    this._rotationDelta.multiply(this._rotationAcceleration * alpha);\n\n    this._rotationDelta.threshold(this._rotationThreshold);\n  };\n\n  InteractiveStateBase.prototype._updateRotationBasic = function () {\n    if (this._requestedBasicRotation != null) {\n      var x = this._basicRotation[0];\n      var y = this._basicRotation[1];\n      var reqX = this._requestedBasicRotation[0];\n      var reqY = this._requestedBasicRotation[1];\n\n      if (Math.abs(reqX) > Math.abs(x)) {\n        this._basicRotation[0] = (1 - this._rotationIncreaseAlpha) * x + this._rotationIncreaseAlpha * reqX;\n      } else {\n        this._basicRotation[0] = (1 - this._rotationDecreaseAlpha) * x + this._rotationDecreaseAlpha * reqX;\n      }\n\n      if (Math.abs(reqY) > Math.abs(y)) {\n        this._basicRotation[1] = (1 - this._rotationIncreaseAlpha) * y + this._rotationIncreaseAlpha * reqY;\n      } else {\n        this._basicRotation[1] = (1 - this._rotationDecreaseAlpha) * y + this._rotationDecreaseAlpha * reqY;\n      }\n\n      this._requestedBasicRotation = null;\n      return;\n    }\n\n    if (this._requestedBasicRotationUnbounded != null) {\n      var reqX = this._requestedBasicRotationUnbounded[0];\n      var reqY = this._requestedBasicRotationUnbounded[1];\n\n      if (Math.abs(reqX) > 0) {\n        this._basicRotation[0] = (1 - this._unboundedRotationAlpha) * this._basicRotation[0] + this._unboundedRotationAlpha * reqX;\n      }\n\n      if (Math.abs(reqY) > 0) {\n        this._basicRotation[1] = (1 - this._unboundedRotationAlpha) * this._basicRotation[1] + this._unboundedRotationAlpha * reqY;\n      }\n\n      if (this._desiredLookat != null) {\n        var desiredBasicLookat = this.currentTransform.projectBasic(this._desiredLookat.toArray());\n        desiredBasicLookat[0] += reqX;\n        desiredBasicLookat[1] += reqY;\n        this._desiredLookat = new THREE.Vector3().fromArray(this.currentTransform.unprojectBasic(desiredBasicLookat, this._lookatDepth));\n      }\n\n      this._requestedBasicRotationUnbounded = null;\n    }\n\n    if (this._basicRotation[0] === 0 && this._basicRotation[1] === 0) {\n      return;\n    }\n\n    this._basicRotation[0] = this._rotationAcceleration * this._basicRotation[0];\n    this._basicRotation[1] = this._rotationAcceleration * this._basicRotation[1];\n\n    if (Math.abs(this._basicRotation[0]) < this._rotationThreshold / Math.pow(2, this._zoom) && Math.abs(this._basicRotation[1]) < this._rotationThreshold / Math.pow(2, this._zoom)) {\n      this._basicRotation = [0, 0];\n    }\n  };\n\n  InteractiveStateBase.prototype._clearRotation = function () {\n    if (this._currentNode.fullPano) {\n      return;\n    }\n\n    if (this._requestedRotationDelta != null) {\n      this._requestedRotationDelta = null;\n    }\n\n    if (!this._rotationDelta.isZero) {\n      this._rotationDelta.reset();\n    }\n\n    if (this._requestedBasicRotation != null) {\n      this._requestedBasicRotation = null;\n    }\n\n    if (this._basicRotation[0] > 0 || this._basicRotation[1] > 0) {\n      this._basicRotation = [0, 0];\n    }\n  };\n\n  InteractiveStateBase.prototype._setDesiredCenter = function () {\n    if (this._desiredCenter == null) {\n      return;\n    }\n\n    var lookatDirection = new THREE.Vector3().fromArray(this.currentTransform.unprojectBasic(this._desiredCenter, this._lookatDepth)).sub(this._currentCamera.position);\n\n    this._currentCamera.lookat.copy(this._currentCamera.position.clone().add(lookatDirection));\n\n    this._previousCamera.lookat.copy(this._previousCamera.position.clone().add(lookatDirection));\n\n    this._desiredCenter = null;\n  };\n\n  InteractiveStateBase.prototype._setDesiredZoom = function () {\n    this._desiredZoom = this._currentNode.fullPano || this._previousNode == null ? this._zoom : 0;\n  };\n\n  return InteractiveStateBase;\n}(State_1.StateBase);\n\nexports.InteractiveStateBase = InteractiveStateBase;\nexports.default = InteractiveStateBase;\n\n//# sourceURL=webpack://Mapillary/./src/state/states/InteractiveStateBase.ts?");

/***/ }),

/***/ "./src/state/states/InteractiveWaitingState.ts":
/*!*****************************************************!*\
  !*** ./src/state/states/InteractiveWaitingState.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar State_1 = __webpack_require__(/*! ../../State */ \"./src/State.ts\");\n\nvar InteractiveWaitingState =\n/** @class */\nfunction (_super) {\n  __extends(InteractiveWaitingState, _super);\n\n  function InteractiveWaitingState(state) {\n    var _this = _super.call(this, state) || this;\n\n    _this._adjustCameras();\n\n    _this._motionless = _this._motionlessTransition();\n    return _this;\n  }\n\n  InteractiveWaitingState.prototype.traverse = function () {\n    return new State_1.TraversingState(this);\n  };\n\n  InteractiveWaitingState.prototype.wait = function () {\n    return new State_1.WaitingState(this);\n  };\n\n  InteractiveWaitingState.prototype.prepend = function (nodes) {\n    _super.prototype.prepend.call(this, nodes);\n\n    this._motionless = this._motionlessTransition();\n  };\n\n  InteractiveWaitingState.prototype.set = function (nodes) {\n    _super.prototype.set.call(this, nodes);\n\n    this._motionless = this._motionlessTransition();\n  };\n\n  InteractiveWaitingState.prototype.move = function (delta) {\n    this._alpha = Math.max(0, Math.min(1, this._alpha + delta));\n  };\n\n  InteractiveWaitingState.prototype.moveTo = function (position) {\n    this._alpha = Math.max(0, Math.min(1, position));\n  };\n\n  InteractiveWaitingState.prototype.update = function (fps) {\n    this._updateRotation();\n\n    if (!this._rotationDelta.isZero) {\n      this._applyRotation(this._rotationDelta, this._previousCamera);\n\n      this._applyRotation(this._rotationDelta, this._currentCamera);\n    }\n\n    this._updateRotationBasic();\n\n    if (this._basicRotation[0] !== 0 || this._basicRotation[1] !== 0) {\n      this._applyRotationBasic(this._basicRotation);\n    }\n\n    var animationSpeed = this._animationSpeed * (60 / fps);\n\n    this._updateZoom(animationSpeed);\n\n    this._updateLookat(animationSpeed);\n\n    this._camera.lerpCameras(this._previousCamera, this._currentCamera, this.alpha);\n  };\n\n  InteractiveWaitingState.prototype._getAlpha = function () {\n    return this._motionless ? Math.round(this._alpha) : this._alpha;\n  };\n\n  InteractiveWaitingState.prototype._setCurrentCamera = function () {\n    _super.prototype._setCurrentCamera.call(this);\n\n    this._adjustCameras();\n  };\n\n  InteractiveWaitingState.prototype._adjustCameras = function () {\n    if (this._previousNode == null) {\n      return;\n    }\n\n    if (this._currentNode.fullPano) {\n      var lookat = this._camera.lookat.clone().sub(this._camera.position);\n\n      this._currentCamera.lookat.copy(lookat.clone().add(this._currentCamera.position));\n    }\n\n    if (this._previousNode.fullPano) {\n      var lookat = this._currentCamera.lookat.clone().sub(this._currentCamera.position);\n\n      this._previousCamera.lookat.copy(lookat.clone().add(this._previousCamera.position));\n    }\n  };\n\n  return InteractiveWaitingState;\n}(State_1.InteractiveStateBase);\n\nexports.InteractiveWaitingState = InteractiveWaitingState;\nexports.default = InteractiveWaitingState;\n\n//# sourceURL=webpack://Mapillary/./src/state/states/InteractiveWaitingState.ts?");

/***/ }),

/***/ "./src/state/states/StateBase.ts":
/*!***************************************!*\
  !*** ./src/state/states/StateBase.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Error_1 = __webpack_require__(/*! ../../Error */ \"./src/Error.ts\");\n\nvar Geo_1 = __webpack_require__(/*! ../../Geo */ \"./src/Geo.ts\");\n\nvar State_1 = __webpack_require__(/*! ../../State */ \"./src/State.ts\");\n\nvar StateBase =\n/** @class */\nfunction () {\n  function StateBase(state) {\n    this._spatial = new Geo_1.Spatial();\n    this._geoCoords = new Geo_1.GeoCoords();\n    this._referenceThreshold = 0.01;\n    this._transitionMode = state.transitionMode;\n    this._reference = state.reference;\n    this._alpha = state.alpha;\n    this._camera = state.camera.clone();\n    this._zoom = state.zoom;\n    this._currentIndex = state.currentIndex;\n    this._trajectory = state.trajectory.slice();\n    this._trajectoryTransforms = [];\n    this._trajectoryCameras = [];\n\n    for (var _i = 0, _a = this._trajectory; _i < _a.length; _i++) {\n      var node = _a[_i];\n\n      var translation = this._nodeToTranslation(node, this._reference);\n\n      var transform = new Geo_1.Transform(node.orientation, node.width, node.height, node.focal, node.scale, node.gpano, node.rotation, translation, node.image, undefined, node.ck1, node.ck2, node.cameraProjection);\n\n      this._trajectoryTransforms.push(transform);\n\n      this._trajectoryCameras.push(new Geo_1.Camera(transform));\n    }\n\n    this._currentNode = this._trajectory.length > 0 ? this._trajectory[this._currentIndex] : null;\n    this._previousNode = this._trajectory.length > 1 && this.currentIndex > 0 ? this._trajectory[this._currentIndex - 1] : null;\n    this._currentCamera = this._trajectoryCameras.length > 0 ? this._trajectoryCameras[this._currentIndex].clone() : new Geo_1.Camera();\n    this._previousCamera = this._trajectoryCameras.length > 1 && this.currentIndex > 0 ? this._trajectoryCameras[this._currentIndex - 1].clone() : this._currentCamera.clone();\n  }\n\n  Object.defineProperty(StateBase.prototype, \"reference\", {\n    get: function get() {\n      return this._reference;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"alpha\", {\n    get: function get() {\n      return this._getAlpha();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"camera\", {\n    get: function get() {\n      return this._camera;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"zoom\", {\n    get: function get() {\n      return this._zoom;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"trajectory\", {\n    get: function get() {\n      return this._trajectory;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"currentIndex\", {\n    get: function get() {\n      return this._currentIndex;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"currentNode\", {\n    get: function get() {\n      return this._currentNode;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"previousNode\", {\n    get: function get() {\n      return this._previousNode;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"currentCamera\", {\n    get: function get() {\n      return this._currentCamera;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"currentTransform\", {\n    get: function get() {\n      return this._trajectoryTransforms.length > 0 ? this._trajectoryTransforms[this.currentIndex] : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"previousTransform\", {\n    get: function get() {\n      return this._trajectoryTransforms.length > 1 && this.currentIndex > 0 ? this._trajectoryTransforms[this.currentIndex - 1] : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"motionless\", {\n    get: function get() {\n      return this._motionless;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateBase.prototype, \"transitionMode\", {\n    get: function get() {\n      return this._transitionMode;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StateBase.prototype.earth = function () {\n    throw new Error(\"Not implemented\");\n  };\n\n  StateBase.prototype.traverse = function () {\n    throw new Error(\"Not implemented\");\n  };\n\n  StateBase.prototype.wait = function () {\n    throw new Error(\"Not implemented\");\n  };\n\n  StateBase.prototype.waitInteractively = function () {\n    throw new Error(\"Not implemented\");\n  };\n\n  StateBase.prototype.move = function (delta) {};\n\n  StateBase.prototype.moveTo = function (position) {};\n\n  StateBase.prototype.rotate = function (delta) {};\n\n  StateBase.prototype.rotateUnbounded = function (delta) {};\n\n  StateBase.prototype.rotateWithoutInertia = function (delta) {};\n\n  StateBase.prototype.rotateBasic = function (basicRotation) {};\n\n  StateBase.prototype.rotateBasicUnbounded = function (basicRotation) {};\n\n  StateBase.prototype.rotateBasicWithoutInertia = function (basicRotation) {};\n\n  StateBase.prototype.rotateToBasic = function (basic) {};\n\n  StateBase.prototype.setSpeed = function (speed) {};\n\n  StateBase.prototype.zoomIn = function (delta, reference) {};\n\n  StateBase.prototype.update = function (fps) {};\n\n  StateBase.prototype.setCenter = function (center) {};\n\n  StateBase.prototype.setZoom = function (zoom) {};\n\n  StateBase.prototype.dolly = function (delta) {};\n\n  StateBase.prototype.orbit = function (rotation) {};\n\n  StateBase.prototype.truck = function (direction) {};\n\n  StateBase.prototype.append = function (nodes) {\n    if (nodes.length < 1) {\n      throw Error(\"Trajectory can not be empty\");\n    }\n\n    if (this._currentIndex < 0) {\n      this.set(nodes);\n    } else {\n      this._trajectory = this._trajectory.concat(nodes);\n\n      this._appendToTrajectories(nodes);\n    }\n  };\n\n  StateBase.prototype.prepend = function (nodes) {\n    if (nodes.length < 1) {\n      throw Error(\"Trajectory can not be empty\");\n    }\n\n    this._trajectory = nodes.slice().concat(this._trajectory);\n    this._currentIndex += nodes.length;\n\n    this._setCurrentNode();\n\n    var referenceReset = this._setReference(this._currentNode);\n\n    if (referenceReset) {\n      this._setTrajectories();\n    } else {\n      this._prependToTrajectories(nodes);\n    }\n\n    this._setCurrentCamera();\n  };\n\n  StateBase.prototype.remove = function (n) {\n    if (n < 0) {\n      throw Error(\"n must be a positive integer\");\n    }\n\n    if (this._currentIndex - 1 < n) {\n      throw Error(\"Current and previous nodes can not be removed\");\n    }\n\n    for (var i = 0; i < n; i++) {\n      this._trajectory.shift();\n\n      this._trajectoryTransforms.shift();\n\n      this._trajectoryCameras.shift();\n\n      this._currentIndex--;\n    }\n\n    this._setCurrentNode();\n  };\n\n  StateBase.prototype.clearPrior = function () {\n    if (this._currentIndex > 0) {\n      this.remove(this._currentIndex - 1);\n    }\n  };\n\n  StateBase.prototype.clear = function () {\n    this.cut();\n\n    if (this._currentIndex > 0) {\n      this.remove(this._currentIndex - 1);\n    }\n  };\n\n  StateBase.prototype.cut = function () {\n    while (this._trajectory.length - 1 > this._currentIndex) {\n      this._trajectory.pop();\n\n      this._trajectoryTransforms.pop();\n\n      this._trajectoryCameras.pop();\n    }\n  };\n\n  StateBase.prototype.set = function (nodes) {\n    this._setTrajectory(nodes);\n\n    this._setCurrentNode();\n\n    this._setReference(this._currentNode);\n\n    this._setTrajectories();\n\n    this._setCurrentCamera();\n  };\n\n  StateBase.prototype.getCenter = function () {\n    return this._currentNode != null ? this.currentTransform.projectBasic(this._camera.lookat.toArray()) : [0.5, 0.5];\n  };\n\n  StateBase.prototype.setTransitionMode = function (mode) {\n    this._transitionMode = mode;\n  };\n\n  StateBase.prototype._getAlpha = function () {\n    return 1;\n  };\n\n  StateBase.prototype._setCurrent = function () {\n    this._setCurrentNode();\n\n    var referenceReset = this._setReference(this._currentNode);\n\n    if (referenceReset) {\n      this._setTrajectories();\n    }\n\n    this._setCurrentCamera();\n  };\n\n  StateBase.prototype._setCurrentCamera = function () {\n    this._currentCamera = this._trajectoryCameras[this._currentIndex].clone();\n    this._previousCamera = this._currentIndex > 0 ? this._trajectoryCameras[this._currentIndex - 1].clone() : this._currentCamera.clone();\n  };\n\n  StateBase.prototype._motionlessTransition = function () {\n    var nodesSet = this._currentNode != null && this._previousNode != null;\n    return nodesSet && (this._transitionMode === State_1.TransitionMode.Instantaneous || !(this._currentNode.merged && this._previousNode.merged && this._withinOriginalDistance() && this._sameConnectedComponent()));\n  };\n\n  StateBase.prototype._setReference = function (node) {\n    // do not reset reference if node is within threshold distance\n    if (Math.abs(node.latLon.lat - this.reference.lat) < this._referenceThreshold && Math.abs(node.latLon.lon - this.reference.lon) < this._referenceThreshold) {\n      return false;\n    } // do not reset reference if previous node exist and transition is with motion\n\n\n    if (this._previousNode != null && !this._motionlessTransition()) {\n      return false;\n    }\n\n    this._reference.lat = node.latLon.lat;\n    this._reference.lon = node.latLon.lon;\n    this._reference.alt = node.alt;\n    return true;\n  };\n\n  StateBase.prototype._setCurrentNode = function () {\n    this._currentNode = this._trajectory.length > 0 ? this._trajectory[this._currentIndex] : null;\n    this._previousNode = this._currentIndex > 0 ? this._trajectory[this._currentIndex - 1] : null;\n  };\n\n  StateBase.prototype._setTrajectory = function (nodes) {\n    if (nodes.length < 1) {\n      throw new Error_1.ArgumentMapillaryError(\"Trajectory can not be empty\");\n    }\n\n    if (this._currentNode != null) {\n      this._trajectory = [this._currentNode].concat(nodes);\n      this._currentIndex = 1;\n    } else {\n      this._trajectory = nodes.slice();\n      this._currentIndex = 0;\n    }\n  };\n\n  StateBase.prototype._setTrajectories = function () {\n    this._trajectoryTransforms.length = 0;\n    this._trajectoryCameras.length = 0;\n\n    this._appendToTrajectories(this._trajectory);\n  };\n\n  StateBase.prototype._appendToTrajectories = function (nodes) {\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n      var node = nodes_1[_i];\n\n      if (!node.assetsCached) {\n        throw new Error_1.ArgumentMapillaryError(\"Assets must be cached when node is added to trajectory\");\n      }\n\n      var translation = this._nodeToTranslation(node, this.reference);\n\n      var transform = new Geo_1.Transform(node.orientation, node.width, node.height, node.focal, node.scale, node.gpano, node.rotation, translation, node.image, undefined, node.ck1, node.ck2, node.cameraProjection);\n\n      this._trajectoryTransforms.push(transform);\n\n      this._trajectoryCameras.push(new Geo_1.Camera(transform));\n    }\n  };\n\n  StateBase.prototype._prependToTrajectories = function (nodes) {\n    for (var _i = 0, _a = nodes.reverse(); _i < _a.length; _i++) {\n      var node = _a[_i];\n\n      if (!node.assetsCached) {\n        throw new Error_1.ArgumentMapillaryError(\"Assets must be cached when added to trajectory\");\n      }\n\n      var translation = this._nodeToTranslation(node, this.reference);\n\n      var transform = new Geo_1.Transform(node.orientation, node.width, node.height, node.focal, node.scale, node.gpano, node.rotation, translation, node.image, undefined, node.ck1, node.ck2, node.cameraProjection);\n\n      this._trajectoryTransforms.unshift(transform);\n\n      this._trajectoryCameras.unshift(new Geo_1.Camera(transform));\n    }\n  };\n\n  StateBase.prototype._nodeToTranslation = function (node, reference) {\n    return Geo_1.Geo.computeTranslation({\n      alt: node.alt,\n      lat: node.latLon.lat,\n      lon: node.latLon.lon\n    }, node.rotation, reference);\n  };\n\n  StateBase.prototype._sameConnectedComponent = function () {\n    var current = this._currentNode;\n    var previous = this._previousNode;\n    return !!current && !!previous && current.mergeCC === previous.mergeCC;\n  };\n\n  StateBase.prototype._withinOriginalDistance = function () {\n    var current = this._currentNode;\n    var previous = this._previousNode;\n\n    if (!current || !previous) {\n      return true;\n    } // 50 km/h moves 28m in 2s\n\n\n    var distance = this._spatial.distanceFromLatLon(current.originalLatLon.lat, current.originalLatLon.lon, previous.originalLatLon.lat, previous.originalLatLon.lon);\n\n    return distance < 25;\n  };\n\n  return StateBase;\n}();\n\nexports.StateBase = StateBase;\n\n//# sourceURL=webpack://Mapillary/./src/state/states/StateBase.ts?");

/***/ }),

/***/ "./src/state/states/TraversingState.ts":
/*!*********************************************!*\
  !*** ./src/state/states/TraversingState.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar UnitBezier = __webpack_require__(/*! @mapbox/unitbezier */ \"./node_modules/@mapbox/unitbezier/index.js\");\n\nvar State_1 = __webpack_require__(/*! ../../State */ \"./src/State.ts\");\n\nvar TraversingState =\n/** @class */\nfunction (_super) {\n  __extends(TraversingState, _super);\n\n  function TraversingState(state) {\n    var _this = _super.call(this, state) || this;\n\n    _this._adjustCameras();\n\n    _this._motionless = _this._motionlessTransition();\n    _this._baseAlpha = _this._alpha;\n    _this._speedCoefficient = 1;\n    _this._unitBezier = new UnitBezier(0.74, 0.67, 0.38, 0.96);\n    _this._useBezier = false;\n    return _this;\n  }\n\n  TraversingState.prototype.earth = function () {\n    return new State_1.EarthState(this);\n  };\n\n  TraversingState.prototype.wait = function () {\n    return new State_1.WaitingState(this);\n  };\n\n  TraversingState.prototype.waitInteractively = function () {\n    return new State_1.InteractiveWaitingState(this);\n  };\n\n  TraversingState.prototype.append = function (nodes) {\n    var emptyTrajectory = this._trajectory.length === 0;\n\n    if (emptyTrajectory) {\n      this._resetTransition();\n    }\n\n    _super.prototype.append.call(this, nodes);\n\n    if (emptyTrajectory) {\n      this._setDesiredCenter();\n\n      this._setDesiredZoom();\n    }\n  };\n\n  TraversingState.prototype.prepend = function (nodes) {\n    var emptyTrajectory = this._trajectory.length === 0;\n\n    if (emptyTrajectory) {\n      this._resetTransition();\n    }\n\n    _super.prototype.prepend.call(this, nodes);\n\n    if (emptyTrajectory) {\n      this._setDesiredCenter();\n\n      this._setDesiredZoom();\n    }\n  };\n\n  TraversingState.prototype.set = function (nodes) {\n    _super.prototype.set.call(this, nodes);\n\n    this._desiredLookat = null;\n\n    this._resetTransition();\n\n    this._clearRotation();\n\n    this._setDesiredCenter();\n\n    this._setDesiredZoom();\n\n    if (this._trajectory.length < 3) {\n      this._useBezier = true;\n    }\n  };\n\n  TraversingState.prototype.setSpeed = function (speed) {\n    this._speedCoefficient = this._spatial.clamp(speed, 0, 10);\n  };\n\n  TraversingState.prototype.update = function (fps) {\n    if (this._alpha === 1 && this._currentIndex + this._alpha < this._trajectory.length) {\n      this._currentIndex += 1;\n      this._useBezier = this._trajectory.length < 3 && this._currentIndex + 1 === this._trajectory.length;\n\n      this._setCurrent();\n\n      this._resetTransition();\n\n      this._clearRotation();\n\n      this._desiredZoom = this._currentNode.fullPano ? this._zoom : 0;\n      this._desiredLookat = null;\n    }\n\n    var animationSpeed = this._animationSpeed * (60 / fps);\n    this._baseAlpha = Math.min(1, this._baseAlpha + this._speedCoefficient * animationSpeed);\n\n    if (this._useBezier) {\n      this._alpha = this._unitBezier.solve(this._baseAlpha);\n    } else {\n      this._alpha = this._baseAlpha;\n    }\n\n    this._updateRotation();\n\n    if (!this._rotationDelta.isZero) {\n      this._applyRotation(this._rotationDelta, this._previousCamera);\n\n      this._applyRotation(this._rotationDelta, this._currentCamera);\n    }\n\n    this._updateRotationBasic();\n\n    if (this._basicRotation[0] !== 0 || this._basicRotation[1] !== 0) {\n      this._applyRotationBasic(this._basicRotation);\n    }\n\n    this._updateZoom(animationSpeed);\n\n    this._updateLookat(animationSpeed);\n\n    this._camera.lerpCameras(this._previousCamera, this._currentCamera, this.alpha);\n  };\n\n  TraversingState.prototype._getAlpha = function () {\n    return this._motionless ? Math.ceil(this._alpha) : this._alpha;\n  };\n\n  TraversingState.prototype._setCurrentCamera = function () {\n    _super.prototype._setCurrentCamera.call(this);\n\n    this._adjustCameras();\n  };\n\n  TraversingState.prototype._adjustCameras = function () {\n    if (this._previousNode == null) {\n      return;\n    }\n\n    var lookat = this._camera.lookat.clone().sub(this._camera.position);\n\n    this._previousCamera.lookat.copy(lookat.clone().add(this._previousCamera.position));\n\n    if (this._currentNode.fullPano) {\n      this._currentCamera.lookat.copy(lookat.clone().add(this._currentCamera.position));\n    }\n  };\n\n  TraversingState.prototype._resetTransition = function () {\n    this._alpha = 0;\n    this._baseAlpha = 0;\n    this._motionless = this._motionlessTransition();\n  };\n\n  return TraversingState;\n}(State_1.InteractiveStateBase);\n\nexports.TraversingState = TraversingState;\nexports.default = TraversingState;\n\n//# sourceURL=webpack://Mapillary/./src/state/states/TraversingState.ts?");

/***/ }),

/***/ "./src/state/states/WaitingState.ts":
/*!******************************************!*\
  !*** ./src/state/states/WaitingState.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar State_1 = __webpack_require__(/*! ../../State */ \"./src/State.ts\");\n\nvar WaitingState =\n/** @class */\nfunction (_super) {\n  __extends(WaitingState, _super);\n\n  function WaitingState(state) {\n    var _this = _super.call(this, state) || this;\n\n    _this._zoom = 0;\n\n    _this._adjustCameras();\n\n    _this._motionless = _this._motionlessTransition();\n    return _this;\n  }\n\n  WaitingState.prototype.traverse = function () {\n    return new State_1.TraversingState(this);\n  };\n\n  WaitingState.prototype.waitInteractively = function () {\n    return new State_1.InteractiveWaitingState(this);\n  };\n\n  WaitingState.prototype.prepend = function (nodes) {\n    _super.prototype.prepend.call(this, nodes);\n\n    this._motionless = this._motionlessTransition();\n  };\n\n  WaitingState.prototype.set = function (nodes) {\n    _super.prototype.set.call(this, nodes);\n\n    this._motionless = this._motionlessTransition();\n  };\n\n  WaitingState.prototype.move = function (delta) {\n    this._alpha = Math.max(0, Math.min(1, this._alpha + delta));\n  };\n\n  WaitingState.prototype.moveTo = function (position) {\n    this._alpha = Math.max(0, Math.min(1, position));\n  };\n\n  WaitingState.prototype.update = function (fps) {\n    this._camera.lerpCameras(this._previousCamera, this._currentCamera, this.alpha);\n  };\n\n  WaitingState.prototype._getAlpha = function () {\n    return this._motionless ? Math.round(this._alpha) : this._alpha;\n  };\n\n  WaitingState.prototype._setCurrentCamera = function () {\n    _super.prototype._setCurrentCamera.call(this);\n\n    this._adjustCameras();\n  };\n\n  WaitingState.prototype._adjustCameras = function () {\n    if (this._previousNode == null) {\n      return;\n    }\n\n    if (this._currentNode.fullPano) {\n      var lookat = this._camera.lookat.clone().sub(this._camera.position);\n\n      this._currentCamera.lookat.copy(lookat.clone().add(this._currentCamera.position));\n    }\n\n    if (this._previousNode.fullPano) {\n      var lookat = this._currentCamera.lookat.clone().sub(this._currentCamera.position);\n\n      this._previousCamera.lookat.copy(lookat.clone().add(this._previousCamera.position));\n    }\n  };\n\n  return WaitingState;\n}(State_1.StateBase);\n\nexports.WaitingState = WaitingState;\nexports.default = WaitingState;\n\n//# sourceURL=webpack://Mapillary/./src/state/states/WaitingState.ts?");

/***/ }),

/***/ "./src/tiles/ImageTileLoader.ts":
/*!**************************************!*\
  !*** ./src/tiles/ImageTileLoader.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n/**\n * @class ImageTileLoader\n *\n * @classdesc Represents a loader of image tiles.\n */\n\n\nvar ImageTileLoader =\n/** @class */\nfunction () {\n  /**\n   * Create a new node image tile loader instance.\n   *\n   * @param {string} scheme - The URI scheme.\n   * @param {string} host - The URI host.\n   * @param {string} [origin] - The origin query param.\n   */\n  function ImageTileLoader(scheme, host, origin) {\n    this._scheme = scheme;\n    this._host = host;\n    this._origin = origin != null ? \"?origin=\" + origin : \"\";\n  }\n  /**\n   * Retrieve an image tile.\n   *\n   * @description Retrieve an image tile by specifying the area\n   * as well as the scaled size.\n   *\n   * @param {string} identifier - The identifier of the image.\n   * @param {number} x - The top left x pixel coordinate for the tile\n   * in the original image.\n   * @param {number} y - The top left y pixel coordinate for the tile\n   * in the original image.\n   * @param {number} w - The pixel width of the tile in the original image.\n   * @param {number} h - The pixel height of the tile in the original image.\n   * @param {number} scaledW - The scaled width of the returned tile.\n   * @param {number} scaledH - The scaled height of the returned tile.\n   */\n\n\n  ImageTileLoader.prototype.getTile = function (identifier, x, y, w, h, scaledW, scaledH) {\n    var characteristics = \"/\" + identifier + \"/\" + x + \",\" + y + \",\" + w + \",\" + h + \"/\" + scaledW + \",\" + scaledH + \"/0/default.jpg\";\n    var url = this._scheme + \"://\" + this._host + characteristics + this._origin;\n    var xmlHTTP = null;\n    return [rxjs_1.Observable.create(function (subscriber) {\n      xmlHTTP = new XMLHttpRequest();\n      xmlHTTP.open(\"GET\", url, true);\n      xmlHTTP.responseType = \"arraybuffer\";\n      xmlHTTP.timeout = 15000;\n\n      xmlHTTP.onload = function (event) {\n        if (xmlHTTP.status !== 200) {\n          subscriber.error(new Error(\"Failed to fetch tile (\" + identifier + \": \" + x + \",\" + y + \",\" + w + \",\" + h + \"). \" + (\"Status: \" + xmlHTTP.status + \", \" + xmlHTTP.statusText)));\n          return;\n        }\n\n        var image = new Image();\n        image.crossOrigin = \"Anonymous\";\n\n        image.onload = function (e) {\n          subscriber.next(image);\n          subscriber.complete();\n        };\n\n        image.onerror = function (error) {\n          subscriber.error(new Error(\"Failed to load tile image (\" + identifier + \": \" + x + \",\" + y + \",\" + w + \",\" + h + \")\"));\n        };\n\n        var blob = new Blob([xmlHTTP.response]);\n        image.src = window.URL.createObjectURL(blob);\n      };\n\n      xmlHTTP.onerror = function (error) {\n        subscriber.error(new Error(\"Failed to fetch tile (\" + identifier + \": \" + x + \",\" + y + \",\" + w + \",\" + h + \")\"));\n      };\n\n      xmlHTTP.ontimeout = function (error) {\n        subscriber.error(new Error(\"Tile request timed out (\" + identifier + \": \" + x + \",\" + y + \",\" + w + \",\" + h + \")\"));\n      };\n\n      xmlHTTP.onabort = function (event) {\n        subscriber.error(new Error(\"Tile request was aborted (\" + identifier + \": \" + x + \",\" + y + \",\" + w + \",\" + h + \")\"));\n      };\n\n      xmlHTTP.send(null);\n    }), function () {\n      if (xmlHTTP != null) {\n        xmlHTTP.abort();\n      }\n    }];\n  };\n\n  return ImageTileLoader;\n}();\n\nexports.ImageTileLoader = ImageTileLoader;\nexports.default = ImageTileLoader;\n\n//# sourceURL=webpack://Mapillary/./src/tiles/ImageTileLoader.ts?");

/***/ }),

/***/ "./src/tiles/ImageTileStore.ts":
/*!*************************************!*\
  !*** ./src/tiles/ImageTileStore.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @class ImageTileStore\n *\n * @classdesc Represents a store for image tiles.\n */\n\nvar ImageTileStore =\n/** @class */\nfunction () {\n  /**\n   * Create a new node image tile store instance.\n   */\n  function ImageTileStore() {\n    this._images = {};\n  }\n  /**\n   * Add an image tile to the store.\n   *\n   * @param {HTMLImageElement} image - The image tile.\n   * @param {string} key - The identifier for the tile.\n   * @param {number} level - The level of the tile.\n   */\n\n\n  ImageTileStore.prototype.addImage = function (image, key, level) {\n    if (!(level in this._images)) {\n      this._images[level] = {};\n    }\n\n    this._images[level][key] = image;\n  };\n  /**\n   * Dispose the store.\n   *\n   * @description Disposes all cached assets.\n   */\n\n\n  ImageTileStore.prototype.dispose = function () {\n    for (var _i = 0, _a = Object.keys(this._images); _i < _a.length; _i++) {\n      var level = _a[_i];\n      var levelImages = this._images[level];\n\n      for (var _b = 0, _c = Object.keys(levelImages); _b < _c.length; _b++) {\n        var key = _c[_b];\n        window.URL.revokeObjectURL(levelImages[key].src);\n        delete levelImages[key];\n      }\n\n      delete this._images[level];\n    }\n  };\n  /**\n   * Get an image tile from the store.\n   *\n   * @param {string} key - The identifier for the tile.\n   * @param {number} level - The level of the tile.\n   */\n\n\n  ImageTileStore.prototype.getImage = function (key, level) {\n    return this._images[level][key];\n  };\n  /**\n   * Check if an image tile exist in the store.\n   *\n   * @param {string} key - The identifier for the tile.\n   * @param {number} level - The level of the tile.\n   */\n\n\n  ImageTileStore.prototype.hasImage = function (key, level) {\n    return level in this._images && key in this._images[level];\n  };\n\n  return ImageTileStore;\n}();\n\nexports.ImageTileStore = ImageTileStore;\nexports.default = ImageTileStore;\n\n//# sourceURL=webpack://Mapillary/./src/tiles/ImageTileStore.ts?");

/***/ }),

/***/ "./src/tiles/RegionOfInterestCalculator.ts":
/*!*************************************************!*\
  !*** ./src/tiles/RegionOfInterestCalculator.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Geo_1 = __webpack_require__(/*! ../Geo */ \"./src/Geo.ts\");\n/**\n * @class RegionOfInterestCalculator\n *\n * @classdesc Represents a calculator for regions of interest.\n */\n\n\nvar RegionOfInterestCalculator =\n/** @class */\nfunction () {\n  function RegionOfInterestCalculator() {\n    this._viewportCoords = new Geo_1.ViewportCoords();\n  }\n  /**\n   * Compute a region of interest based on the current render camera\n   * and the viewport size.\n   *\n   * @param {RenderCamera} renderCamera - Render camera used for unprojections.\n   * @param {ISize} size - Viewport size in pixels.\n   * @param {Transform} transform - Transform used for projections.\n   *\n   * @returns {IRegionOfInterest} A region of interest.\n   */\n\n\n  RegionOfInterestCalculator.prototype.computeRegionOfInterest = function (renderCamera, size, transform) {\n    var viewportBoundaryPoints = this._viewportBoundaryPoints(4);\n\n    var bbox = this._viewportPointsBoundingBox(viewportBoundaryPoints, renderCamera, transform);\n\n    this._clipBoundingBox(bbox);\n\n    var viewportPixelWidth = 2 / size.width;\n    var viewportPixelHeight = 2 / size.height;\n    var centralViewportPixel = [[-0.5 * viewportPixelWidth, 0.5 * viewportPixelHeight], [0.5 * viewportPixelWidth, 0.5 * viewportPixelHeight], [0.5 * viewportPixelWidth, -0.5 * viewportPixelHeight], [-0.5 * viewportPixelWidth, -0.5 * viewportPixelHeight]];\n\n    var cpbox = this._viewportPointsBoundingBox(centralViewportPixel, renderCamera, transform);\n\n    return {\n      bbox: bbox,\n      pixelHeight: cpbox.maxY - cpbox.minY,\n      pixelWidth: cpbox.maxX - cpbox.minX + (cpbox.minX < cpbox.maxX ? 0 : 1)\n    };\n  };\n\n  RegionOfInterestCalculator.prototype._viewportBoundaryPoints = function (pointsPerSide) {\n    var points = [];\n    var os = [[-1, 1], [1, 1], [1, -1], [-1, -1]];\n    var ds = [[2, 0], [0, -2], [-2, 0], [0, 2]];\n\n    for (var side = 0; side < 4; ++side) {\n      var o = os[side];\n      var d = ds[side];\n\n      for (var i = 0; i < pointsPerSide; ++i) {\n        points.push([o[0] + d[0] * i / pointsPerSide, o[1] + d[1] * i / pointsPerSide]);\n      }\n    }\n\n    return points;\n  };\n\n  RegionOfInterestCalculator.prototype._viewportPointsBoundingBox = function (viewportPoints, renderCamera, transform) {\n    var _this = this;\n\n    var basicPoints = viewportPoints.map(function (point) {\n      return _this._viewportCoords.viewportToBasic(point[0], point[1], transform, renderCamera.perspective);\n    });\n\n    if (transform.gpano != null) {\n      return this._boundingBoxPano(basicPoints);\n    } else {\n      return this._boundingBox(basicPoints);\n    }\n  };\n\n  RegionOfInterestCalculator.prototype._boundingBox = function (points) {\n    var bbox = {\n      maxX: Number.NEGATIVE_INFINITY,\n      maxY: Number.NEGATIVE_INFINITY,\n      minX: Number.POSITIVE_INFINITY,\n      minY: Number.POSITIVE_INFINITY\n    };\n\n    for (var i = 0; i < points.length; ++i) {\n      bbox.minX = Math.min(bbox.minX, points[i][0]);\n      bbox.maxX = Math.max(bbox.maxX, points[i][0]);\n      bbox.minY = Math.min(bbox.minY, points[i][1]);\n      bbox.maxY = Math.max(bbox.maxY, points[i][1]);\n    }\n\n    return bbox;\n  };\n\n  RegionOfInterestCalculator.prototype._boundingBoxPano = function (points) {\n    var _this = this;\n\n    var xs = [];\n    var ys = [];\n\n    for (var i = 0; i < points.length; ++i) {\n      xs.push(points[i][0]);\n      ys.push(points[i][1]);\n    }\n\n    xs.sort(function (a, b) {\n      return _this._sign(a - b);\n    });\n    ys.sort(function (a, b) {\n      return _this._sign(a - b);\n    });\n\n    var intervalX = this._intervalPano(xs);\n\n    return {\n      maxX: intervalX[1],\n      maxY: ys[ys.length - 1],\n      minX: intervalX[0],\n      minY: ys[0]\n    };\n  };\n  /**\n   * Find the max interval between consecutive numbers.\n   * Assumes numbers are between 0 and 1, sorted and that\n   * x is equivalent to x + 1.\n   */\n\n\n  RegionOfInterestCalculator.prototype._intervalPano = function (xs) {\n    var maxdx = 0;\n    var maxi = -1;\n\n    for (var i = 0; i < xs.length - 1; ++i) {\n      var dx = xs[i + 1] - xs[i];\n\n      if (dx > maxdx) {\n        maxdx = dx;\n        maxi = i;\n      }\n    }\n\n    var loopdx = xs[0] + 1 - xs[xs.length - 1];\n\n    if (loopdx > maxdx) {\n      return [xs[0], xs[xs.length - 1]];\n    } else {\n      return [xs[maxi + 1], xs[maxi]];\n    }\n  };\n\n  RegionOfInterestCalculator.prototype._clipBoundingBox = function (bbox) {\n    bbox.minX = Math.max(0, Math.min(1, bbox.minX));\n    bbox.maxX = Math.max(0, Math.min(1, bbox.maxX));\n    bbox.minY = Math.max(0, Math.min(1, bbox.minY));\n    bbox.maxY = Math.max(0, Math.min(1, bbox.maxY));\n  };\n\n  RegionOfInterestCalculator.prototype._sign = function (n) {\n    return n > 0 ? 1 : n < 0 ? -1 : 0;\n  };\n\n  return RegionOfInterestCalculator;\n}();\n\nexports.RegionOfInterestCalculator = RegionOfInterestCalculator;\nexports.default = RegionOfInterestCalculator;\n\n//# sourceURL=webpack://Mapillary/./src/tiles/RegionOfInterestCalculator.ts?");

/***/ }),

/***/ "./src/tiles/TextureProvider.ts":
/*!**************************************!*\
  !*** ./src/tiles/TextureProvider.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n/**\n * @class TextureProvider\n *\n * @classdesc Represents a provider of textures.\n */\n\n\nvar TextureProvider =\n/** @class */\nfunction () {\n  /**\n   * Create a new node texture provider instance.\n   *\n   * @param {string} key - The identifier of the image for which to request tiles.\n   * @param {number} width - The full width of the original image.\n   * @param {number} height - The full height of the original image.\n   * @param {number} tileSize - The size used when requesting tiles.\n   * @param {HTMLImageElement} background - Image to use as background.\n   * @param {ImageTileLoader} imageTileLoader - Loader for retrieving tiles.\n   * @param {ImageTileStore} imageTileStore - Store for saving tiles.\n   * @param {THREE.WebGLRenderer} renderer - Renderer used for rendering tiles to texture.\n   */\n  function TextureProvider(key, width, height, tileSize, background, imageTileLoader, imageTileStore, renderer) {\n    this._disposed = false;\n    this._key = key;\n\n    if (width <= 0 || height <= 0) {\n      console.warn(\"Original image size (\" + width + \", \" + height + \") is invalid (\" + key + \"). Tiles will not be loaded.\");\n    }\n\n    this._width = width;\n    this._height = height;\n    this._maxLevel = Math.ceil(Math.log(Math.max(height, width)) / Math.log(2));\n    this._currentLevel = -1;\n    this._tileSize = tileSize;\n    this._updated$ = new rxjs_1.Subject();\n    this._createdSubject$ = new rxjs_1.Subject();\n    this._created$ = this._createdSubject$.pipe(operators_1.publishReplay(1), operators_1.refCount());\n    this._createdSubscription = this._created$.subscribe(function () {});\n    this._hasSubject$ = new rxjs_1.Subject();\n    this._has$ = this._hasSubject$.pipe(operators_1.startWith(false), operators_1.publishReplay(1), operators_1.refCount());\n    this._hasSubscription = this._has$.subscribe(function () {});\n    this._abortFunctions = [];\n    this._tileSubscriptions = {};\n    this._renderedCurrentLevelTiles = {};\n    this._renderedTiles = {};\n    this._background = background;\n    this._camera = null;\n    this._imageTileLoader = imageTileLoader;\n    this._imageTileStore = imageTileStore;\n    this._renderer = renderer;\n    this._renderTarget = null;\n    this._roi = null;\n  }\n\n  Object.defineProperty(TextureProvider.prototype, \"disposed\", {\n    /**\n     * Get disposed.\n     *\n     * @returns {boolean} Value indicating whether provider has\n     * been disposed.\n     */\n    get: function get() {\n      return this._disposed;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TextureProvider.prototype, \"hasTexture$\", {\n    /**\n     * Get hasTexture$.\n     *\n     * @returns {Observable<boolean>} Observable emitting\n     * values indicating when the existance of a texture\n     * changes.\n     */\n    get: function get() {\n      return this._has$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TextureProvider.prototype, \"key\", {\n    /**\n     * Get key.\n     *\n     * @returns {boolean} The identifier of the image for\n     * which to render textures.\n     */\n    get: function get() {\n      return this._key;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TextureProvider.prototype, \"textureUpdated$\", {\n    /**\n     * Get textureUpdated$.\n     *\n     * @returns {Observable<boolean>} Observable emitting\n     * values when an existing texture has been updated.\n     */\n    get: function get() {\n      return this._updated$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TextureProvider.prototype, \"textureCreated$\", {\n    /**\n     * Get textureCreated$.\n     *\n     * @returns {Observable<boolean>} Observable emitting\n     * values when a new texture has been created.\n     */\n    get: function get() {\n      return this._created$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Abort all outstanding image tile requests.\n   */\n\n  TextureProvider.prototype.abort = function () {\n    for (var key in this._tileSubscriptions) {\n      if (!this._tileSubscriptions.hasOwnProperty(key)) {\n        continue;\n      }\n\n      this._tileSubscriptions[key].unsubscribe();\n    }\n\n    this._tileSubscriptions = {};\n\n    for (var _i = 0, _a = this._abortFunctions; _i < _a.length; _i++) {\n      var abort = _a[_i];\n      abort();\n    }\n\n    this._abortFunctions = [];\n  };\n  /**\n   * Dispose the provider.\n   *\n   * @description Disposes all cached assets and\n   * aborts all outstanding image tile requests.\n   */\n\n\n  TextureProvider.prototype.dispose = function () {\n    if (this._disposed) {\n      console.warn(\"Texture already disposed (\" + this._key + \")\");\n      return;\n    }\n\n    this.abort();\n\n    if (this._renderTarget != null) {\n      this._renderTarget.dispose();\n\n      this._renderTarget = null;\n    }\n\n    this._imageTileStore.dispose();\n\n    this._imageTileStore = null;\n    this._background = null;\n    this._camera = null;\n    this._imageTileLoader = null;\n    this._renderer = null;\n    this._roi = null;\n\n    this._createdSubscription.unsubscribe();\n\n    this._hasSubscription.unsubscribe();\n\n    this._disposed = true;\n  };\n  /**\n   * Set the region of interest.\n   *\n   * @description When the region of interest is set the\n   * the tile level is determined and tiles for the region\n   * are fetched from the store or the loader and renderedLevel\n   * to the texture.\n   *\n   * @param {IRegionOfInterest} roi - Spatial edges to cache.\n   */\n\n\n  TextureProvider.prototype.setRegionOfInterest = function (roi) {\n    if (this._width <= 0 || this._height <= 0) {\n      return;\n    }\n\n    this._roi = roi;\n    var width = 1 / this._roi.pixelWidth;\n    var height = 1 / this._roi.pixelHeight;\n    var size = Math.max(height, width);\n    var currentLevel = Math.max(0, Math.min(this._maxLevel, Math.ceil(Math.log(size) / Math.log(2))));\n\n    if (currentLevel !== this._currentLevel) {\n      this.abort();\n      this._currentLevel = currentLevel;\n\n      if (!(this._currentLevel in this._renderedTiles)) {\n        this._renderedTiles[this._currentLevel] = [];\n      }\n\n      this._renderedCurrentLevelTiles = {};\n\n      for (var _i = 0, _a = this._renderedTiles[this._currentLevel]; _i < _a.length; _i++) {\n        var tile = _a[_i];\n        this._renderedCurrentLevelTiles[this._tileKey(this._tileSize, tile)] = true;\n      }\n    }\n\n    var topLeft = this._getTileCoords([this._roi.bbox.minX, this._roi.bbox.minY]);\n\n    var bottomRight = this._getTileCoords([this._roi.bbox.maxX, this._roi.bbox.maxY]);\n\n    var tiles = this._getTiles(topLeft, bottomRight);\n\n    if (this._camera == null) {\n      this._camera = new THREE.OrthographicCamera(-this._width / 2, this._width / 2, this._height / 2, -this._height / 2, -1, 1);\n      this._camera.position.z = 1;\n\n      var gl = this._renderer.getContext();\n\n      var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n      var backgroundSize = Math.max(this._width, this._height);\n      var scale = maxTextureSize > backgroundSize ? 1 : maxTextureSize / backgroundSize;\n      var targetWidth = Math.floor(scale * this._width);\n      var targetHeight = Math.floor(scale * this._height);\n      this._renderTarget = new THREE.WebGLRenderTarget(targetWidth, targetHeight, {\n        depthBuffer: false,\n        format: THREE.RGBFormat,\n        magFilter: THREE.LinearFilter,\n        minFilter: THREE.LinearFilter,\n        stencilBuffer: false\n      });\n\n      this._renderToTarget(0, 0, this._width, this._height, this._background);\n\n      this._createdSubject$.next(this._renderTarget.texture);\n\n      this._hasSubject$.next(true);\n    }\n\n    this._fetchTiles(tiles);\n  };\n\n  TextureProvider.prototype.setTileSize = function (tileSize) {\n    this._tileSize = tileSize;\n  };\n  /**\n   * Update the image used as background for the texture.\n   *\n   * @param {HTMLImageElement} background - The background image.\n   */\n\n\n  TextureProvider.prototype.updateBackground = function (background) {\n    this._background = background;\n  };\n  /**\n   * Retrieve an image tile.\n   *\n   * @description Retrieve an image tile and render it to the\n   * texture. Add the tile to the store and emit to the updated\n   * observable.\n   *\n   * @param {Array<number>} tile - The tile coordinates.\n   * @param {number} level - The tile level.\n   * @param {number} x - The top left x pixel coordinate of the tile.\n   * @param {number} y - The top left y pixel coordinate of the tile.\n   * @param {number} w - The pixel width of the tile.\n   * @param {number} h - The pixel height of the tile.\n   * @param {number} scaledW - The scaled width of the returned tile.\n   * @param {number} scaledH - The scaled height of the returned tile.\n   */\n\n\n  TextureProvider.prototype._fetchTile = function (tile, level, x, y, w, h, scaledX, scaledY) {\n    var _this = this;\n\n    var getTile = this._imageTileLoader.getTile(this._key, x, y, w, h, scaledX, scaledY);\n\n    var tile$ = getTile[0];\n    var abort = getTile[1];\n\n    this._abortFunctions.push(abort);\n\n    var tileKey = this._tileKey(this._tileSize, tile);\n\n    var subscription = tile$.subscribe(function (image) {\n      _this._renderToTarget(x, y, w, h, image);\n\n      _this._removeFromDictionary(tileKey, _this._tileSubscriptions);\n\n      _this._removeFromArray(abort, _this._abortFunctions);\n\n      _this._setTileRendered(tile, _this._currentLevel);\n\n      _this._imageTileStore.addImage(image, tileKey, level);\n\n      _this._updated$.next(true);\n    }, function (error) {\n      _this._removeFromDictionary(tileKey, _this._tileSubscriptions);\n\n      _this._removeFromArray(abort, _this._abortFunctions);\n\n      console.error(error);\n    });\n\n    if (!subscription.closed) {\n      this._tileSubscriptions[tileKey] = subscription;\n    }\n  };\n  /**\n   * Retrieve image tiles.\n   *\n   * @description Retrieve a image tiles and render them to the\n   * texture. Retrieve from store if it exists, otherwise Retrieve\n   * from loader.\n   *\n   * @param {Array<Array<number>>} tiles - Array of tile coordinates to\n   * retrieve.\n   */\n\n\n  TextureProvider.prototype._fetchTiles = function (tiles) {\n    var tileSize = this._tileSize * Math.pow(2, this._maxLevel - this._currentLevel);\n\n    for (var _i = 0, tiles_1 = tiles; _i < tiles_1.length; _i++) {\n      var tile = tiles_1[_i];\n\n      var tileKey = this._tileKey(this._tileSize, tile);\n\n      if (tileKey in this._renderedCurrentLevelTiles || tileKey in this._tileSubscriptions) {\n        continue;\n      }\n\n      var tileX = tileSize * tile[0];\n      var tileY = tileSize * tile[1];\n      var tileWidth = tileX + tileSize > this._width ? this._width - tileX : tileSize;\n      var tileHeight = tileY + tileSize > this._height ? this._height - tileY : tileSize;\n\n      if (this._imageTileStore.hasImage(tileKey, this._currentLevel)) {\n        this._renderToTarget(tileX, tileY, tileWidth, tileHeight, this._imageTileStore.getImage(tileKey, this._currentLevel));\n\n        this._setTileRendered(tile, this._currentLevel);\n\n        this._updated$.next(true);\n\n        continue;\n      }\n\n      var scaledX = Math.floor(tileWidth / tileSize * this._tileSize);\n      var scaledY = Math.floor(tileHeight / tileSize * this._tileSize);\n\n      this._fetchTile(tile, this._currentLevel, tileX, tileY, tileWidth, tileHeight, scaledX, scaledY);\n    }\n  };\n  /**\n   * Get tile coordinates for a point using the current level.\n   *\n   * @param {Array<number>} point - Point in basic coordinates.\n   *\n   * @returns {Array<number>} x and y tile coodinates.\n   */\n\n\n  TextureProvider.prototype._getTileCoords = function (point) {\n    var tileSize = this._tileSize * Math.pow(2, this._maxLevel - this._currentLevel);\n    var maxX = Math.ceil(this._width / tileSize) - 1;\n    var maxY = Math.ceil(this._height / tileSize) - 1;\n    return [Math.min(Math.floor(this._width * point[0] / tileSize), maxX), Math.min(Math.floor(this._height * point[1] / tileSize), maxY)];\n  };\n  /**\n   * Get tile coordinates for all tiles contained in a bounding\n   * box.\n   *\n   * @param {Array<number>} topLeft - Top left tile coordinate of bounding box.\n   * @param {Array<number>} bottomRight - Bottom right tile coordinate of bounding box.\n   *\n   * @returns {Array<Array<number>>} Array of x, y tile coodinates.\n   */\n\n\n  TextureProvider.prototype._getTiles = function (topLeft, bottomRight) {\n    var xs = [];\n\n    if (topLeft[0] > bottomRight[0]) {\n      var tileSize = this._tileSize * Math.pow(2, this._maxLevel - this._currentLevel);\n      var maxX = Math.ceil(this._width / tileSize) - 1;\n\n      for (var x = topLeft[0]; x <= maxX; x++) {\n        xs.push(x);\n      }\n\n      for (var x = 0; x <= bottomRight[0]; x++) {\n        xs.push(x);\n      }\n    } else {\n      for (var x = topLeft[0]; x <= bottomRight[0]; x++) {\n        xs.push(x);\n      }\n    }\n\n    var tiles = [];\n\n    for (var _i = 0, xs_1 = xs; _i < xs_1.length; _i++) {\n      var x = xs_1[_i];\n\n      for (var y = topLeft[1]; y <= bottomRight[1]; y++) {\n        tiles.push([x, y]);\n      }\n    }\n\n    return tiles;\n  };\n  /**\n   * Remove an item from an array if it exists in array.\n   *\n   * @param {T} item - Item to remove.\n   * @param {Array<T>} array - Array from which item should be removed.\n   */\n\n\n  TextureProvider.prototype._removeFromArray = function (item, array) {\n    var index = array.indexOf(item);\n\n    if (index !== -1) {\n      array.splice(index, 1);\n    }\n  };\n  /**\n   * Remove an item from a dictionary.\n   *\n   * @param {string} key - Key of the item to remove.\n   * @param {Object} dict - Dictionary from which item should be removed.\n   */\n\n\n  TextureProvider.prototype._removeFromDictionary = function (key, dict) {\n    if (key in dict) {\n      delete dict[key];\n    }\n  };\n  /**\n   * Render an image tile to the target texture.\n   *\n   * @param {number} x - The top left x pixel coordinate of the tile.\n   * @param {number} y - The top left y pixel coordinate of the tile.\n   * @param {number} w - The pixel width of the tile.\n   * @param {number} h - The pixel height of the tile.\n   * @param {HTMLImageElement} background - The image tile to render.\n   */\n\n\n  TextureProvider.prototype._renderToTarget = function (x, y, w, h, image) {\n    var texture = new THREE.Texture(image);\n    texture.minFilter = THREE.LinearFilter;\n    texture.needsUpdate = true;\n    var geometry = new THREE.PlaneGeometry(w, h);\n    var material = new THREE.MeshBasicMaterial({\n      map: texture,\n      side: THREE.FrontSide\n    });\n    var mesh = new THREE.Mesh(geometry, material);\n    mesh.position.x = -this._width / 2 + x + w / 2;\n    mesh.position.y = this._height / 2 - y - h / 2;\n    var scene = new THREE.Scene();\n    scene.add(mesh);\n\n    this._renderer.render(scene, this._camera, this._renderTarget);\n\n    this._renderer.setRenderTarget(undefined);\n\n    scene.remove(mesh);\n    geometry.dispose();\n    material.dispose();\n    texture.dispose();\n  };\n  /**\n   * Mark a tile as rendered.\n   *\n   * @description Clears tiles marked as rendered in other\n   * levels of the tile pyramid  if they were rendered on\n   * top of or below the tile.\n   *\n   * @param {Arrary<number>} tile - The tile coordinates.\n   * @param {number} level - Tile level of the tile coordinates.\n   */\n\n\n  TextureProvider.prototype._setTileRendered = function (tile, level) {\n    var otherLevels = Object.keys(this._renderedTiles).map(function (key) {\n      return parseInt(key, 10);\n    }).filter(function (renderedLevel) {\n      return renderedLevel !== level;\n    });\n\n    for (var _i = 0, otherLevels_1 = otherLevels; _i < otherLevels_1.length; _i++) {\n      var otherLevel = otherLevels_1[_i];\n      var scale = Math.pow(2, otherLevel - level);\n\n      if (otherLevel < level) {\n        var x = Math.floor(scale * tile[0]);\n        var y = Math.floor(scale * tile[1]);\n\n        for (var _a = 0, _b = this._renderedTiles[otherLevel].slice(); _a < _b.length; _a++) {\n          var otherTile = _b[_a];\n\n          if (otherTile[0] === x && otherTile[1] === y) {\n            var index = this._renderedTiles[otherLevel].indexOf(otherTile);\n\n            this._renderedTiles[otherLevel].splice(index, 1);\n          }\n        }\n      } else {\n        var startX = scale * tile[0];\n        var endX = startX + scale - 1;\n        var startY = scale * tile[1];\n        var endY = startY + scale - 1;\n\n        for (var _c = 0, _d = this._renderedTiles[otherLevel].slice(); _c < _d.length; _c++) {\n          var otherTile = _d[_c];\n\n          if (otherTile[0] >= startX && otherTile[0] <= endX && otherTile[1] >= startY && otherTile[1] <= endY) {\n            var index = this._renderedTiles[otherLevel].indexOf(otherTile);\n\n            this._renderedTiles[otherLevel].splice(index, 1);\n          }\n        }\n      }\n\n      if (this._renderedTiles[otherLevel].length === 0) {\n        delete this._renderedTiles[otherLevel];\n      }\n    }\n\n    this._renderedTiles[level].push(tile);\n\n    this._renderedCurrentLevelTiles[this._tileKey(this._tileSize, tile)] = true;\n  };\n  /**\n   * Create a tile key from a tile coordinates.\n   *\n   * @description Tile keys are used as a hash for\n   * storing the tile in a dictionary.\n   *\n   * @param {number} tileSize - The tile size.\n   * @param {Arrary<number>} tile - The tile coordinates.\n   */\n\n\n  TextureProvider.prototype._tileKey = function (tileSize, tile) {\n    return tileSize + \"-\" + tile[0] + \"-\" + tile[1];\n  };\n\n  return TextureProvider;\n}();\n\nexports.TextureProvider = TextureProvider;\nexports.default = TextureProvider;\n\n//# sourceURL=webpack://Mapillary/./src/tiles/TextureProvider.ts?");

/***/ }),

/***/ "./src/utils/DOM.ts":
/*!**************************!*\
  !*** ./src/utils/DOM.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DOM =\n/** @class */\nfunction () {\n  function DOM(doc) {\n    this._document = !!doc ? doc : document;\n  }\n\n  Object.defineProperty(DOM.prototype, \"document\", {\n    get: function get() {\n      return this._document;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  DOM.prototype.createElement = function (tagName, className, container) {\n    var element = this._document.createElement(tagName);\n\n    if (!!className) {\n      element.className = className;\n    }\n\n    if (!!container) {\n      container.appendChild(element);\n    }\n\n    return element;\n  };\n\n  return DOM;\n}();\n\nexports.DOM = DOM;\nexports.default = DOM;\n\n//# sourceURL=webpack://Mapillary/./src/utils/DOM.ts?");

/***/ }),

/***/ "./src/utils/EventEmitter.ts":
/*!***********************************!*\
  !*** ./src/utils/EventEmitter.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar EventEmitter =\n/** @class */\nfunction () {\n  function EventEmitter() {\n    this._events = {};\n  }\n  /**\n   * Subscribe to an event by its name.\n   * @param {string }eventType - The name of the event to subscribe to.\n   * @param {any} fn - The handler called when the event occurs.\n   */\n\n\n  EventEmitter.prototype.on = function (eventType, fn) {\n    this._events[eventType] = this._events[eventType] || [];\n\n    this._events[eventType].push(fn);\n\n    return;\n  };\n  /**\n   * Unsubscribe from an event by its name.\n   * @param {string} eventType - The name of the event to subscribe to.\n   * @param {any} fn - The handler to remove.\n   */\n\n\n  EventEmitter.prototype.off = function (eventType, fn) {\n    if (!eventType) {\n      this._events = {};\n      return;\n    }\n\n    if (!this._listens(eventType)) {\n      var idx = this._events[eventType].indexOf(fn);\n\n      if (idx >= 0) {\n        this._events[eventType].splice(idx, 1);\n      }\n\n      if (this._events[eventType].length) {\n        delete this._events[eventType];\n      }\n    } else {\n      delete this._events[eventType];\n    }\n\n    return;\n  };\n\n  EventEmitter.prototype.fire = function (eventType, data) {\n    if (!this._listens(eventType)) {\n      return;\n    }\n\n    for (var _i = 0, _a = this._events[eventType]; _i < _a.length; _i++) {\n      var fn = _a[_i];\n      fn.call(this, data);\n    }\n\n    return;\n  };\n\n  EventEmitter.prototype._listens = function (eventType) {\n    return !!(this._events && this._events[eventType]);\n  };\n\n  return EventEmitter;\n}();\n\nexports.EventEmitter = EventEmitter;\nexports.default = EventEmitter;\n\n//# sourceURL=webpack://Mapillary/./src/utils/EventEmitter.ts?");

/***/ }),

/***/ "./src/utils/Settings.ts":
/*!*******************************!*\
  !*** ./src/utils/Settings.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Viewer_1 = __webpack_require__(/*! ../Viewer */ \"./src/Viewer.ts\");\n\nvar Settings =\n/** @class */\nfunction () {\n  function Settings() {}\n\n  Settings.setOptions = function (options) {\n    Settings._baseImageSize = options.baseImageSize != null ? options.baseImageSize : Viewer_1.ImageSize.Size640;\n    Settings._basePanoramaSize = options.basePanoramaSize != null ? options.basePanoramaSize : Viewer_1.ImageSize.Size2048;\n    Settings._maxImageSize = options.maxImageSize != null ? options.maxImageSize : Viewer_1.ImageSize.Size2048;\n  };\n\n  Object.defineProperty(Settings, \"baseImageSize\", {\n    get: function get() {\n      return Settings._baseImageSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Settings, \"basePanoramaSize\", {\n    get: function get() {\n      return Settings._basePanoramaSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Settings, \"maxImageSize\", {\n    get: function get() {\n      return Settings._maxImageSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Settings;\n}();\n\nexports.Settings = Settings;\nexports.default = Settings;\n\n//# sourceURL=webpack://Mapillary/./src/utils/Settings.ts?");

/***/ }),

/***/ "./src/utils/Support.ts":
/*!******************************!*\
  !*** ./src/utils/Support.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction isBrowser() {\n  return typeof window !== \"undefined\" && typeof document !== \"undefined\";\n}\n\nexports.isBrowser = isBrowser;\n\nfunction isArraySupported() {\n  return !!(Array.prototype && Array.prototype.filter && Array.prototype.indexOf && Array.prototype.map && Array.prototype.reverse);\n}\n\nexports.isArraySupported = isArraySupported;\n\nfunction isFunctionSupported() {\n  return !!(Function.prototype && Function.prototype.bind);\n}\n\nexports.isFunctionSupported = isFunctionSupported;\n\nfunction isJSONSupported() {\n  return \"JSON\" in window && \"parse\" in JSON && \"stringify\" in JSON;\n}\n\nexports.isJSONSupported = isJSONSupported;\n\nfunction isObjectSupported() {\n  return !!(Object.keys && Object.assign);\n}\n\nexports.isObjectSupported = isObjectSupported;\n\nfunction isBlobSupported() {\n  return \"Blob\" in window && \"URL\" in window;\n}\n\nexports.isBlobSupported = isBlobSupported;\nvar isWebGLSupportedCache = undefined;\n\nfunction isWebGLSupportedCached() {\n  if (isWebGLSupportedCache === undefined) {\n    isWebGLSupportedCache = isWebGLSupported();\n  }\n\n  return isWebGLSupportedCache;\n}\n\nexports.isWebGLSupportedCached = isWebGLSupportedCached;\n\nfunction isWebGLSupported() {\n  var webGLContextAttributes = {\n    alpha: false,\n    antialias: false,\n    depth: true,\n    failIfMajorPerformanceCaveat: false,\n    premultipliedAlpha: true,\n    preserveDrawingBuffer: false,\n    stencil: true\n  };\n  var canvas = document.createElement(\"canvas\");\n  var context = canvas.getContext(\"webgl\", webGLContextAttributes) || canvas.getContext(\"experimental-webgl\", webGLContextAttributes);\n\n  if (!context) {\n    return false;\n  }\n\n  var requiredExtensions = [\"OES_standard_derivatives\"];\n  var supportedExtensions = context.getSupportedExtensions();\n\n  for (var _i = 0, requiredExtensions_1 = requiredExtensions; _i < requiredExtensions_1.length; _i++) {\n    var requiredExtension = requiredExtensions_1[_i];\n\n    if (supportedExtensions.indexOf(requiredExtension) === -1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isWebGLSupported = isWebGLSupported;\n\n//# sourceURL=webpack://Mapillary/./src/utils/Support.ts?");

/***/ }),

/***/ "./src/utils/Urls.ts":
/*!***************************!*\
  !*** ./src/utils/Urls.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Urls =\n/** @class */\nfunction () {\n  function Urls() {}\n\n  Object.defineProperty(Urls, \"explore\", {\n    get: function get() {\n      return Urls._scheme + \"://\" + Urls._exploreHost;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Urls, \"origin\", {\n    get: function get() {\n      return Urls._origin;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Urls, \"tileScheme\", {\n    get: function get() {\n      return Urls._scheme;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Urls, \"tileDomain\", {\n    get: function get() {\n      return Urls._imageTileHost;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Urls.atomicReconstruction = function (key) {\n    return Urls._scheme + \"://\" + Urls._atomicReconstructionHost + \"/\" + key + \"/sfm/v1.0/atomic_reconstruction.json\";\n  };\n\n  Urls.exporeImage = function (key) {\n    return Urls._scheme + \"://\" + Urls._exploreHost + \"/app/?pKey=\" + key + \"&focus=photo\";\n  };\n\n  Urls.exporeUser = function (username) {\n    return Urls._scheme + \"://\" + Urls._exploreHost + \"/app/user/\" + username;\n  };\n\n  Urls.falcorModel = function (clientId) {\n    return Urls._scheme + \"://\" + Urls._apiHost + \"/v3/model.json?client_id=\" + clientId;\n  };\n\n  Urls.protoMesh = function (key) {\n    return Urls._scheme + \"://\" + Urls._meshHost + \"/v2/mesh/\" + key;\n  };\n\n  Urls.thumbnail = function (key, size, origin) {\n    var query = !!origin ? \"?origin=\" + origin : \"\";\n    return Urls._scheme + \"://\" + Urls._imageHost + \"/\" + key + \"/thumb-\" + size + \".jpg\" + query;\n  };\n\n  Urls.setOptions = function (options) {\n    if (!options) {\n      return;\n    }\n\n    if (!!options.apiHost) {\n      Urls._apiHost = options.apiHost;\n    }\n\n    if (!!options.atomicReconstructionHost) {\n      Urls._atomicReconstructionHost = options.atomicReconstructionHost;\n    }\n\n    if (!!options.exploreHost) {\n      Urls._exploreHost = options.exploreHost;\n    }\n\n    if (!!options.imageHost) {\n      Urls._imageHost = options.imageHost;\n    }\n\n    if (!!options.imageTileHost) {\n      Urls._imageTileHost = options.imageTileHost;\n    }\n\n    if (!!options.meshHost) {\n      Urls._meshHost = options.meshHost;\n    }\n\n    if (!!options.scheme) {\n      Urls._scheme = options.scheme;\n    }\n  };\n\n  Urls._apiHost = \"a.mapillary.com\";\n  Urls._atomicReconstructionHost = \"atomic-reconstructions.mapillary.com\";\n  Urls._exploreHost = \"www.mapillary.com\";\n  Urls._imageHost = \"images.mapillary.com\";\n  Urls._imageTileHost = \"loris.mapillary.com\";\n  Urls._meshHost = \"meshes.mapillary.com\";\n  Urls._origin = \"mapillary.webgl\";\n  Urls._scheme = \"https\";\n  return Urls;\n}();\n\nexports.Urls = Urls;\nexports.default = Urls;\n\n//# sourceURL=webpack://Mapillary/./src/utils/Urls.ts?");

/***/ }),

/***/ "./src/viewer/Alignment.ts":
/*!*********************************!*\
  !*** ./src/viewer/Alignment.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enumeration for alignments\n * @enum {number}\n * @readonly\n */\n\nvar Alignment;\n\n(function (Alignment) {\n  /**\n   * Align to bottom\n   */\n  Alignment[Alignment[\"Bottom\"] = 0] = \"Bottom\";\n  /**\n   * Align to bottom left\n   */\n\n  Alignment[Alignment[\"BottomLeft\"] = 1] = \"BottomLeft\";\n  /**\n   * Align to bottom right\n   */\n\n  Alignment[Alignment[\"BottomRight\"] = 2] = \"BottomRight\";\n  /**\n   * Align to center\n   */\n\n  Alignment[Alignment[\"Center\"] = 3] = \"Center\";\n  /**\n   * Align to left\n   */\n\n  Alignment[Alignment[\"Left\"] = 4] = \"Left\";\n  /**\n   * Align to right\n   */\n\n  Alignment[Alignment[\"Right\"] = 5] = \"Right\";\n  /**\n   * Align to top\n   */\n\n  Alignment[Alignment[\"Top\"] = 6] = \"Top\";\n  /**\n   * Align to top left\n   */\n\n  Alignment[Alignment[\"TopLeft\"] = 7] = \"TopLeft\";\n  /**\n   * Align to top right\n   */\n\n  Alignment[Alignment[\"TopRight\"] = 8] = \"TopRight\";\n})(Alignment = exports.Alignment || (exports.Alignment = {}));\n\nexports.default = Alignment;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/Alignment.ts?");

/***/ }),

/***/ "./src/viewer/CacheService.ts":
/*!************************************!*\
  !*** ./src/viewer/CacheService.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Graph_1 = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n\nvar CacheService =\n/** @class */\nfunction () {\n  function CacheService(graphService, stateService) {\n    this._graphService = graphService;\n    this._stateService = stateService;\n    this._started = false;\n  }\n\n  Object.defineProperty(CacheService.prototype, \"started\", {\n    get: function get() {\n      return this._started;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CacheService.prototype.start = function () {\n    var _this = this;\n\n    if (this._started) {\n      return;\n    }\n\n    this._uncacheSubscription = this._stateService.currentState$.pipe(operators_1.distinctUntilChanged(undefined, function (frame) {\n      return frame.state.currentNode.key;\n    }), operators_1.map(function (frame) {\n      var trajectory = frame.state.trajectory;\n      var trajectoryKeys = trajectory.map(function (n) {\n        return n.key;\n      });\n      var sequenceKey = trajectory[trajectory.length - 1].sequenceKey;\n      return [trajectoryKeys, sequenceKey];\n    }), operators_1.bufferCount(1, 5), operators_1.withLatestFrom(this._graphService.graphMode$), operators_1.switchMap(function (_a) {\n      var keepBuffer = _a[0],\n          graphMode = _a[1];\n      var keepKeys = keepBuffer[0][0];\n      var keepSequenceKey = graphMode === Graph_1.GraphMode.Sequence ? keepBuffer[0][1] : undefined;\n      return _this._graphService.uncache$(keepKeys, keepSequenceKey);\n    })).subscribe(function () {});\n    this._cacheNodeSubscription = this._graphService.graphMode$.pipe(operators_1.skip(1), operators_1.withLatestFrom(this._stateService.currentState$), operators_1.switchMap(function (_a) {\n      var mode = _a[0],\n          frame = _a[1];\n      return mode === Graph_1.GraphMode.Sequence ? _this._keyToEdges(frame.state.currentNode.key, function (node) {\n        return node.sequenceEdges$;\n      }) : rxjs_1.from(frame.state.trajectory.map(function (node) {\n        return node.key;\n      }).slice(frame.state.currentIndex)).pipe(operators_1.mergeMap(function (key) {\n        return _this._keyToEdges(key, function (node) {\n          return node.spatialEdges$;\n        });\n      }, 6));\n    })).subscribe(function () {});\n    this._started = true;\n  };\n\n  CacheService.prototype.stop = function () {\n    if (!this._started) {\n      return;\n    }\n\n    this._uncacheSubscription.unsubscribe();\n\n    this._uncacheSubscription = null;\n\n    this._cacheNodeSubscription.unsubscribe();\n\n    this._cacheNodeSubscription = null;\n    this._started = false;\n  };\n\n  CacheService.prototype._keyToEdges = function (key, nodeToEdgeMap) {\n    return this._graphService.cacheNode$(key).pipe(operators_1.switchMap(nodeToEdgeMap), operators_1.first(function (status) {\n      return status.cached;\n    }), operators_1.timeout(15000), operators_1.catchError(function (error) {\n      console.error(\"Failed to cache edges (\" + key + \").\", error);\n      return rxjs_1.empty();\n    }));\n  };\n\n  return CacheService;\n}();\n\nexports.CacheService = CacheService;\nexports.default = CacheService;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/CacheService.ts?");

/***/ }),

/***/ "./src/viewer/ComponentController.ts":
/*!*******************************************!*\
  !*** ./src/viewer/ComponentController.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Component_1 = __webpack_require__(/*! ../Component */ \"./src/Component.ts\");\n\nvar ComponentController =\n/** @class */\nfunction () {\n  function ComponentController(container, navigator, observer, key, options, componentService) {\n    var _this = this;\n\n    this._container = container;\n    this._observer = observer;\n    this._navigator = navigator;\n    this._options = options != null ? options : {};\n    this._key = key;\n    this._navigable = key == null;\n    this._componentService = !!componentService ? componentService : new Component_1.ComponentService(this._container, this._navigator);\n    this._coverComponent = this._componentService.getCover();\n\n    this._initializeComponents();\n\n    if (key) {\n      this._initilizeCoverComponent();\n\n      this._subscribeCoverComponent();\n    } else {\n      this._navigator.movedToKey$.pipe(operators_1.first(function (k) {\n        return k != null;\n      })).subscribe(function (k) {\n        _this._key = k;\n\n        _this._componentService.deactivateCover();\n\n        _this._coverComponent.configure({\n          key: _this._key,\n          state: Component_1.CoverState.Hidden\n        });\n\n        _this._subscribeCoverComponent();\n\n        _this._navigator.stateService.start();\n\n        _this._navigator.cacheService.start();\n\n        _this._navigator.panService.start();\n\n        _this._observer.startEmit();\n      });\n    }\n  }\n\n  Object.defineProperty(ComponentController.prototype, \"navigable\", {\n    get: function get() {\n      return this._navigable;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ComponentController.prototype.get = function (name) {\n    return this._componentService.get(name);\n  };\n\n  ComponentController.prototype.activate = function (name) {\n    this._componentService.activate(name);\n  };\n\n  ComponentController.prototype.activateCover = function () {\n    this._coverComponent.configure({\n      state: Component_1.CoverState.Visible\n    });\n  };\n\n  ComponentController.prototype.deactivate = function (name) {\n    this._componentService.deactivate(name);\n  };\n\n  ComponentController.prototype.deactivateCover = function () {\n    this._coverComponent.configure({\n      state: Component_1.CoverState.Loading\n    });\n  };\n\n  ComponentController.prototype._initializeComponents = function () {\n    var options = this._options;\n\n    this._uFalse(options.background, \"background\");\n\n    this._uFalse(options.debug, \"debug\");\n\n    this._uFalse(options.image, \"image\");\n\n    this._uFalse(options.marker, \"marker\");\n\n    this._uFalse(options.navigation, \"navigation\");\n\n    this._uFalse(options.popup, \"popup\");\n\n    this._uFalse(options.route, \"route\");\n\n    this._uFalse(options.slider, \"slider\");\n\n    this._uFalse(options.spatialData, \"spatialData\");\n\n    this._uFalse(options.tag, \"tag\");\n\n    this._uTrue(options.attribution, \"attribution\");\n\n    this._uTrue(options.bearing, \"bearing\");\n\n    this._uTrue(options.cache, \"cache\");\n\n    this._uTrue(options.direction, \"direction\");\n\n    this._uTrue(options.imagePlane, \"imagePlane\");\n\n    this._uTrue(options.keyboard, \"keyboard\");\n\n    this._uTrue(options.loading, \"loading\");\n\n    this._uTrue(options.mouse, \"mouse\");\n\n    this._uTrue(options.sequence, \"sequence\");\n\n    this._uTrue(options.stats, \"stats\");\n\n    this._uTrue(options.zoom, \"zoom\");\n  };\n\n  ComponentController.prototype._initilizeCoverComponent = function () {\n    var options = this._options;\n\n    this._coverComponent.configure({\n      key: this._key\n    });\n\n    if (options.cover === undefined || options.cover) {\n      this.activateCover();\n    } else {\n      this.deactivateCover();\n    }\n  };\n\n  ComponentController.prototype._setNavigable = function (navigable) {\n    if (this._navigable === navigable) {\n      return;\n    }\n\n    this._navigable = navigable;\n\n    this._observer.navigable$.next(navigable);\n  };\n\n  ComponentController.prototype._subscribeCoverComponent = function () {\n    var _this = this;\n\n    this._coverComponent.configuration$.pipe(operators_1.distinctUntilChanged(undefined, function (c) {\n      return c.state;\n    })).subscribe(function (conf) {\n      if (conf.state === Component_1.CoverState.Loading) {\n        _this._navigator.stateService.currentKey$.pipe(operators_1.first(), operators_1.switchMap(function (key) {\n          var keyChanged = key == null || key !== conf.key;\n\n          if (keyChanged) {\n            _this._setNavigable(false);\n          }\n\n          return keyChanged ? _this._navigator.moveToKey$(conf.key) : _this._navigator.stateService.currentNode$.pipe(operators_1.first());\n        })).subscribe(function () {\n          _this._navigator.stateService.start();\n\n          _this._navigator.cacheService.start();\n\n          _this._navigator.panService.start();\n\n          _this._observer.startEmit();\n\n          _this._coverComponent.configure({\n            state: Component_1.CoverState.Hidden\n          });\n\n          _this._componentService.deactivateCover();\n\n          _this._setNavigable(true);\n        }, function (error) {\n          console.error(\"Failed to deactivate cover.\", error);\n\n          _this._coverComponent.configure({\n            state: Component_1.CoverState.Visible\n          });\n        });\n      } else if (conf.state === Component_1.CoverState.Visible) {\n        _this._observer.stopEmit();\n\n        _this._navigator.stateService.stop();\n\n        _this._navigator.cacheService.stop();\n\n        _this._navigator.playService.stop();\n\n        _this._navigator.panService.stop();\n\n        _this._componentService.activateCover();\n\n        _this._setNavigable(conf.key == null);\n      }\n    });\n  };\n\n  ComponentController.prototype._uFalse = function (option, name) {\n    if (option === undefined) {\n      this._componentService.deactivate(name);\n\n      return;\n    }\n\n    if (typeof option === \"boolean\") {\n      if (option) {\n        this._componentService.activate(name);\n      } else {\n        this._componentService.deactivate(name);\n      }\n\n      return;\n    }\n\n    this._componentService.configure(name, option);\n\n    this._componentService.activate(name);\n  };\n\n  ComponentController.prototype._uTrue = function (option, name) {\n    if (option === undefined) {\n      this._componentService.activate(name);\n\n      return;\n    }\n\n    if (typeof option === \"boolean\") {\n      if (option) {\n        this._componentService.activate(name);\n      } else {\n        this._componentService.deactivate(name);\n      }\n\n      return;\n    }\n\n    this._componentService.configure(name, option);\n\n    this._componentService.activate(name);\n  };\n\n  return ComponentController;\n}();\n\nexports.ComponentController = ComponentController;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/ComponentController.ts?");

/***/ }),

/***/ "./src/viewer/Container.ts":
/*!*********************************!*\
  !*** ./src/viewer/Container.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Render_1 = __webpack_require__(/*! ../Render */ \"./src/Render.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../Utils */ \"./src/Utils.ts\");\n\nvar Viewer_1 = __webpack_require__(/*! ../Viewer */ \"./src/Viewer.ts\");\n\nvar Container =\n/** @class */\nfunction () {\n  function Container(id, stateService, options, dom) {\n    this.id = id;\n    this._dom = !!dom ? dom : new Utils_1.DOM();\n    this._container = this._dom.document.getElementById(id);\n\n    if (!this._container) {\n      throw new Error(\"Container '\" + id + \"' not found.\");\n    }\n\n    this._container.classList.add(\"mapillary-js\");\n\n    this._canvasContainer = this._dom.createElement(\"div\", \"mapillary-js-interactive\", this._container);\n    this._domContainer = this._dom.createElement(\"div\", \"mapillary-js-dom\", this._container);\n    this.renderService = new Render_1.RenderService(this._container, stateService.currentState$, options.renderMode);\n    this.glRenderer = new Render_1.GLRenderer(this._canvasContainer, this.renderService, this._dom);\n    this.domRenderer = new Render_1.DOMRenderer(this._domContainer, this.renderService, stateService.currentState$);\n    this.keyboardService = new Viewer_1.KeyboardService(this._canvasContainer);\n    this.mouseService = new Viewer_1.MouseService(this._container, this._canvasContainer, this._domContainer, document);\n    this.touchService = new Viewer_1.TouchService(this._canvasContainer, this._domContainer);\n    this.spriteService = new Viewer_1.SpriteService(options.sprite);\n  }\n\n  Object.defineProperty(Container.prototype, \"element\", {\n    get: function get() {\n      return this._container;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"canvasContainer\", {\n    get: function get() {\n      return this._canvasContainer;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"domContainer\", {\n    get: function get() {\n      return this._domContainer;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Container;\n}();\n\nexports.Container = Container;\nexports.default = Container;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/Container.ts?");

/***/ }),

/***/ "./src/viewer/ImageSize.ts":
/*!*********************************!*\
  !*** ./src/viewer/ImageSize.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enumeration for image sizes\n * @enum {number}\n * @readonly\n * @description Image sizes in pixels for the long side of the image.\n */\n\nvar ImageSize;\n\n(function (ImageSize) {\n  /**\n   * 320 pixels image size\n   */\n  ImageSize[ImageSize[\"Size320\"] = 320] = \"Size320\";\n  /**\n   * 640 pixels image size\n   */\n\n  ImageSize[ImageSize[\"Size640\"] = 640] = \"Size640\";\n  /**\n   * 1024 pixels image size\n   */\n\n  ImageSize[ImageSize[\"Size1024\"] = 1024] = \"Size1024\";\n  /**\n   * 2048 pixels image size\n   */\n\n  ImageSize[ImageSize[\"Size2048\"] = 2048] = \"Size2048\";\n})(ImageSize = exports.ImageSize || (exports.ImageSize = {}));\n\n//# sourceURL=webpack://Mapillary/./src/viewer/ImageSize.ts?");

/***/ }),

/***/ "./src/viewer/KeyboardService.ts":
/*!***************************************!*\
  !*** ./src/viewer/KeyboardService.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar KeyboardService =\n/** @class */\nfunction () {\n  function KeyboardService(canvasContainer) {\n    this._keyDown$ = rxjs_1.fromEvent(canvasContainer, \"keydown\");\n    this._keyUp$ = rxjs_1.fromEvent(canvasContainer, \"keyup\");\n  }\n\n  Object.defineProperty(KeyboardService.prototype, \"keyDown$\", {\n    get: function get() {\n      return this._keyDown$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(KeyboardService.prototype, \"keyUp$\", {\n    get: function get() {\n      return this._keyUp$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return KeyboardService;\n}();\n\nexports.KeyboardService = KeyboardService;\nexports.default = KeyboardService;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/KeyboardService.ts?");

/***/ }),

/***/ "./src/viewer/LoadingService.ts":
/*!**************************************!*\
  !*** ./src/viewer/LoadingService.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar LoadingService =\n/** @class */\nfunction () {\n  function LoadingService() {\n    this._loadersSubject$ = new rxjs_1.Subject();\n    this._loaders$ = this._loadersSubject$.pipe(operators_1.scan(function (loaders, loader) {\n      if (loader.task !== undefined) {\n        loaders[loader.task] = loader.loading;\n      }\n\n      return loaders;\n    }, {}), operators_1.startWith({}), operators_1.publishReplay(1), operators_1.refCount());\n  }\n\n  Object.defineProperty(LoadingService.prototype, \"loading$\", {\n    get: function get() {\n      return this._loaders$.pipe(operators_1.map(function (loaders) {\n        for (var key in loaders) {\n          if (!loaders.hasOwnProperty(key)) {\n            continue;\n          }\n\n          if (loaders[key]) {\n            return true;\n          }\n        }\n\n        return false;\n      }), operators_1.debounceTime(100), operators_1.distinctUntilChanged());\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  LoadingService.prototype.taskLoading$ = function (task) {\n    return this._loaders$.pipe(operators_1.map(function (loaders) {\n      return !!loaders[task];\n    }), operators_1.debounceTime(100), operators_1.distinctUntilChanged());\n  };\n\n  LoadingService.prototype.startLoading = function (task) {\n    this._loadersSubject$.next({\n      loading: true,\n      task: task\n    });\n  };\n\n  LoadingService.prototype.stopLoading = function (task) {\n    this._loadersSubject$.next({\n      loading: false,\n      task: task\n    });\n  };\n\n  return LoadingService;\n}();\n\nexports.LoadingService = LoadingService;\nexports.default = LoadingService;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/LoadingService.ts?");

/***/ }),

/***/ "./src/viewer/MouseService.ts":
/*!************************************!*\
  !*** ./src/viewer/MouseService.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar MouseService =\n/** @class */\nfunction () {\n  function MouseService(container, canvasContainer, domContainer, doc) {\n    var _this = this;\n\n    this._activeSubject$ = new rxjs_1.BehaviorSubject(false);\n    this._active$ = this._activeSubject$.pipe(operators_1.distinctUntilChanged(), operators_1.publishReplay(1), operators_1.refCount());\n    this._claimMouse$ = new rxjs_1.Subject();\n    this._claimWheel$ = new rxjs_1.Subject();\n    this._deferPixelClaims$ = new rxjs_1.Subject();\n    this._deferPixels$ = this._deferPixelClaims$.pipe(operators_1.scan(function (claims, claim) {\n      if (claim.deferPixels == null) {\n        delete claims[claim.name];\n      } else {\n        claims[claim.name] = claim.deferPixels;\n      }\n\n      return claims;\n    }, {}), operators_1.map(function (claims) {\n      var deferPixelMax = -1;\n\n      for (var key in claims) {\n        if (!claims.hasOwnProperty(key)) {\n          continue;\n        }\n\n        var deferPixels = claims[key];\n\n        if (deferPixels > deferPixelMax) {\n          deferPixelMax = deferPixels;\n        }\n      }\n\n      return deferPixelMax;\n    }), operators_1.startWith(-1), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._deferPixels$.subscribe(function () {});\n\n    this._documentMouseMove$ = rxjs_1.fromEvent(doc, \"mousemove\");\n    this._documentMouseUp$ = rxjs_1.fromEvent(doc, \"mouseup\");\n    this._mouseDown$ = rxjs_1.fromEvent(canvasContainer, \"mousedown\");\n    this._mouseLeave$ = rxjs_1.fromEvent(canvasContainer, \"mouseleave\");\n    this._mouseMove$ = rxjs_1.fromEvent(canvasContainer, \"mousemove\");\n    this._mouseUp$ = rxjs_1.fromEvent(canvasContainer, \"mouseup\");\n    this._mouseOut$ = rxjs_1.fromEvent(canvasContainer, \"mouseout\");\n    this._mouseOver$ = rxjs_1.fromEvent(canvasContainer, \"mouseover\");\n    this._domMouseDown$ = rxjs_1.fromEvent(domContainer, \"mousedown\");\n    this._domMouseMove$ = rxjs_1.fromEvent(domContainer, \"mousemove\");\n    this._click$ = rxjs_1.fromEvent(canvasContainer, \"click\");\n    this._contextMenu$ = rxjs_1.fromEvent(canvasContainer, \"contextmenu\");\n    this._dblClick$ = rxjs_1.merge(rxjs_1.fromEvent(container, \"click\"), rxjs_1.fromEvent(canvasContainer, \"dblclick\")).pipe(operators_1.bufferCount(3, 1), operators_1.filter(function (events) {\n      var event1 = events[0];\n      var event2 = events[1];\n      var event3 = events[2];\n      return event1.type === \"click\" && event2.type === \"click\" && event3.type === \"dblclick\" && event1.target.parentNode === canvasContainer && event2.target.parentNode === canvasContainer;\n    }), operators_1.map(function (events) {\n      return events[2];\n    }), operators_1.share());\n    rxjs_1.merge(this._domMouseDown$, this._domMouseMove$, this._dblClick$, this._contextMenu$).subscribe(function (event) {\n      event.preventDefault();\n    });\n    this._mouseWheel$ = rxjs_1.merge(rxjs_1.fromEvent(canvasContainer, \"wheel\"), rxjs_1.fromEvent(domContainer, \"wheel\")).pipe(operators_1.share());\n    this._consistentContextMenu$ = rxjs_1.merge(this._mouseDown$, this._mouseMove$, this._mouseOut$, this._mouseUp$, this._contextMenu$).pipe(operators_1.bufferCount(3, 1), operators_1.filter(function (events) {\n      // fire context menu on mouse up both on mac and windows\n      return events[0].type === \"mousedown\" && events[1].type === \"contextmenu\" && events[2].type === \"mouseup\";\n    }), operators_1.map(function (events) {\n      return events[1];\n    }), operators_1.share());\n    var dragStop$ = rxjs_1.merge(rxjs_1.fromEvent(window, \"blur\"), this._documentMouseUp$.pipe(operators_1.filter(function (e) {\n      return e.button === 0;\n    }))).pipe(operators_1.share());\n\n    var mouseDragInitiate$ = this._createMouseDragInitiate$(this._mouseDown$, dragStop$, true).pipe(operators_1.share());\n\n    this._mouseDragStart$ = this._createMouseDragStart$(mouseDragInitiate$).pipe(operators_1.share());\n    this._mouseDrag$ = this._createMouseDrag$(mouseDragInitiate$, dragStop$).pipe(operators_1.share());\n    this._mouseDragEnd$ = this._createMouseDragEnd$(this._mouseDragStart$, dragStop$).pipe(operators_1.share());\n\n    var domMouseDragInitiate$ = this._createMouseDragInitiate$(this._domMouseDown$, dragStop$, false).pipe(operators_1.share());\n\n    this._domMouseDragStart$ = this._createMouseDragStart$(domMouseDragInitiate$).pipe(operators_1.share());\n    this._domMouseDrag$ = this._createMouseDrag$(domMouseDragInitiate$, dragStop$).pipe(operators_1.share());\n    this._domMouseDragEnd$ = this._createMouseDragEnd$(this._domMouseDragStart$, dragStop$).pipe(operators_1.share());\n    this._proximateClick$ = this._mouseDown$.pipe(operators_1.switchMap(function (mouseDown) {\n      return _this._click$.pipe(operators_1.takeUntil(_this._createDeferredMouseMove$(mouseDown, _this._documentMouseMove$)), operators_1.take(1));\n    }), operators_1.share());\n    this._staticClick$ = this._mouseDown$.pipe(operators_1.switchMap(function (e) {\n      return _this._click$.pipe(operators_1.takeUntil(_this._documentMouseMove$), operators_1.take(1));\n    }), operators_1.share());\n\n    this._mouseDragStart$.subscribe();\n\n    this._mouseDrag$.subscribe();\n\n    this._mouseDragEnd$.subscribe();\n\n    this._domMouseDragStart$.subscribe();\n\n    this._domMouseDrag$.subscribe();\n\n    this._domMouseDragEnd$.subscribe();\n\n    this._staticClick$.subscribe();\n\n    this._mouseOwner$ = this._createOwner$(this._claimMouse$).pipe(operators_1.publishReplay(1), operators_1.refCount());\n    this._wheelOwner$ = this._createOwner$(this._claimWheel$).pipe(operators_1.publishReplay(1), operators_1.refCount());\n\n    this._mouseOwner$.subscribe(function () {});\n\n    this._wheelOwner$.subscribe(function () {});\n  }\n\n  Object.defineProperty(MouseService.prototype, \"active$\", {\n    get: function get() {\n      return this._active$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"activate$\", {\n    get: function get() {\n      return this._activeSubject$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"documentMouseMove$\", {\n    get: function get() {\n      return this._documentMouseMove$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"documentMouseUp$\", {\n    get: function get() {\n      return this._documentMouseUp$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"domMouseDragStart$\", {\n    get: function get() {\n      return this._domMouseDragStart$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"domMouseDrag$\", {\n    get: function get() {\n      return this._domMouseDrag$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"domMouseDragEnd$\", {\n    get: function get() {\n      return this._domMouseDragEnd$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"domMouseDown$\", {\n    get: function get() {\n      return this._domMouseDown$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"domMouseMove$\", {\n    get: function get() {\n      return this._domMouseMove$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"mouseOwner$\", {\n    get: function get() {\n      return this._mouseOwner$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"mouseDown$\", {\n    get: function get() {\n      return this._mouseDown$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"mouseMove$\", {\n    get: function get() {\n      return this._mouseMove$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"mouseLeave$\", {\n    get: function get() {\n      return this._mouseLeave$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"mouseOut$\", {\n    get: function get() {\n      return this._mouseOut$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"mouseOver$\", {\n    get: function get() {\n      return this._mouseOver$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"mouseUp$\", {\n    get: function get() {\n      return this._mouseUp$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"click$\", {\n    get: function get() {\n      return this._click$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"dblClick$\", {\n    get: function get() {\n      return this._dblClick$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"contextMenu$\", {\n    get: function get() {\n      return this._consistentContextMenu$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"mouseWheel$\", {\n    get: function get() {\n      return this._mouseWheel$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"mouseDragStart$\", {\n    get: function get() {\n      return this._mouseDragStart$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"mouseDrag$\", {\n    get: function get() {\n      return this._mouseDrag$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"mouseDragEnd$\", {\n    get: function get() {\n      return this._mouseDragEnd$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"proximateClick$\", {\n    get: function get() {\n      return this._proximateClick$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MouseService.prototype, \"staticClick$\", {\n    get: function get() {\n      return this._staticClick$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MouseService.prototype.claimMouse = function (name, zindex) {\n    this._claimMouse$.next({\n      name: name,\n      zindex: zindex\n    });\n  };\n\n  MouseService.prototype.unclaimMouse = function (name) {\n    this._claimMouse$.next({\n      name: name,\n      zindex: null\n    });\n  };\n\n  MouseService.prototype.deferPixels = function (name, deferPixels) {\n    this._deferPixelClaims$.next({\n      name: name,\n      deferPixels: deferPixels\n    });\n  };\n\n  MouseService.prototype.undeferPixels = function (name) {\n    this._deferPixelClaims$.next({\n      name: name,\n      deferPixels: null\n    });\n  };\n\n  MouseService.prototype.claimWheel = function (name, zindex) {\n    this._claimWheel$.next({\n      name: name,\n      zindex: zindex\n    });\n  };\n\n  MouseService.prototype.unclaimWheel = function (name) {\n    this._claimWheel$.next({\n      name: name,\n      zindex: null\n    });\n  };\n\n  MouseService.prototype.filtered$ = function (name, observable$) {\n    return this._filtered(name, observable$, this._mouseOwner$);\n  };\n\n  MouseService.prototype.filteredWheel$ = function (name, observable$) {\n    return this._filtered(name, observable$, this._wheelOwner$);\n  };\n\n  MouseService.prototype._createDeferredMouseMove$ = function (origin, mouseMove$) {\n    return mouseMove$.pipe(operators_1.map(function (mouseMove) {\n      var deltaX = mouseMove.clientX - origin.clientX;\n      var deltaY = mouseMove.clientY - origin.clientY;\n      return [mouseMove, Math.sqrt(deltaX * deltaX + deltaY * deltaY)];\n    }), operators_1.withLatestFrom(this._deferPixels$), operators_1.filter(function (_a) {\n      var _b = _a[0],\n          mouseMove = _b[0],\n          delta = _b[1],\n          deferPixels = _a[1];\n      return delta > deferPixels;\n    }), operators_1.map(function (_a) {\n      var _b = _a[0],\n          mouseMove = _b[0],\n          delta = _b[1],\n          deferPixels = _a[1];\n      return mouseMove;\n    }));\n  };\n\n  MouseService.prototype._createMouseDrag$ = function (mouseDragStartInitiate$, stop$) {\n    var _this = this;\n\n    return mouseDragStartInitiate$.pipe(operators_1.map(function (_a) {\n      var mouseDown = _a[0],\n          mouseMove = _a[1];\n      return mouseMove;\n    }), operators_1.switchMap(function (mouseMove) {\n      return rxjs_1.concat(rxjs_1.of(mouseMove), _this._documentMouseMove$).pipe(operators_1.takeUntil(stop$));\n    }));\n  };\n\n  MouseService.prototype._createMouseDragEnd$ = function (mouseDragStart$, stop$) {\n    return mouseDragStart$.pipe(operators_1.switchMap(function (event) {\n      return stop$.pipe(operators_1.first());\n    }));\n  };\n\n  MouseService.prototype._createMouseDragStart$ = function (mouseDragStartInitiate$) {\n    return mouseDragStartInitiate$.pipe(operators_1.map(function (_a) {\n      var mouseDown = _a[0],\n          mouseMove = _a[1];\n      return mouseDown;\n    }));\n  };\n\n  MouseService.prototype._createMouseDragInitiate$ = function (mouseDown$, stop$, defer) {\n    var _this = this;\n\n    return mouseDown$.pipe(operators_1.filter(function (mouseDown) {\n      return mouseDown.button === 0;\n    }), operators_1.switchMap(function (mouseDown) {\n      return rxjs_1.combineLatest(rxjs_1.of(mouseDown), defer ? _this._createDeferredMouseMove$(mouseDown, _this._documentMouseMove$) : _this._documentMouseMove$).pipe(operators_1.takeUntil(stop$), operators_1.take(1));\n    }));\n  };\n\n  MouseService.prototype._createOwner$ = function (claim$) {\n    return claim$.pipe(operators_1.scan(function (claims, claim) {\n      if (claim.zindex == null) {\n        delete claims[claim.name];\n      } else {\n        claims[claim.name] = claim.zindex;\n      }\n\n      return claims;\n    }, {}), operators_1.map(function (claims) {\n      var owner = null;\n      var zIndexMax = -1;\n\n      for (var name_1 in claims) {\n        if (!claims.hasOwnProperty(name_1)) {\n          continue;\n        }\n\n        if (claims[name_1] > zIndexMax) {\n          zIndexMax = claims[name_1];\n          owner = name_1;\n        }\n      }\n\n      return owner;\n    }), operators_1.startWith(null));\n  };\n\n  MouseService.prototype._filtered = function (name, observable$, owner$) {\n    return observable$.pipe(operators_1.withLatestFrom(owner$), operators_1.filter(function (_a) {\n      var item = _a[0],\n          owner = _a[1];\n      return owner === name;\n    }), operators_1.map(function (_a) {\n      var item = _a[0],\n          owner = _a[1];\n      return item;\n    }));\n  };\n\n  return MouseService;\n}();\n\nexports.MouseService = MouseService;\nexports.default = MouseService;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/MouseService.ts?");

/***/ }),

/***/ "./src/viewer/Navigator.ts":
/*!*********************************!*\
  !*** ./src/viewer/Navigator.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar API_1 = __webpack_require__(/*! ../API */ \"./src/API.ts\");\n\nvar Graph_1 = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n\nvar Edge_1 = __webpack_require__(/*! ../Edge */ \"./src/Edge.ts\");\n\nvar Error_1 = __webpack_require__(/*! ../Error */ \"./src/Error.ts\");\n\nvar State_1 = __webpack_require__(/*! ../State */ \"./src/State.ts\");\n\nvar Viewer_1 = __webpack_require__(/*! ../Viewer */ \"./src/Viewer.ts\");\n\nvar PanService_1 = __webpack_require__(/*! ./PanService */ \"./src/viewer/PanService.ts\");\n\nvar Navigator =\n/** @class */\nfunction () {\n  function Navigator(clientId, options, token, apiV3, graphService, imageLoadingService, loadingService, stateService, cacheService, playService, panService) {\n    this._apiV3 = apiV3 != null ? apiV3 : new API_1.APIv3(clientId, token);\n    this._imageLoadingService = imageLoadingService != null ? imageLoadingService : new Graph_1.ImageLoadingService();\n    this._graphService = graphService != null ? graphService : new Graph_1.GraphService(new Graph_1.Graph(this.apiV3), this._imageLoadingService);\n    this._loadingService = loadingService != null ? loadingService : new Viewer_1.LoadingService();\n    this._loadingName = \"navigator\";\n    this._stateService = stateService != null ? stateService : new State_1.StateService(options.transitionMode);\n    this._cacheService = cacheService != null ? cacheService : new Viewer_1.CacheService(this._graphService, this._stateService);\n    this._playService = playService != null ? playService : new Viewer_1.PlayService(this._graphService, this._stateService);\n    this._panService = panService != null ? panService : new PanService_1.PanService(this._graphService, this._stateService, options.combinedPanning);\n    this._keyRequested$ = new rxjs_1.BehaviorSubject(null);\n    this._movedToKey$ = new rxjs_1.BehaviorSubject(null);\n    this._request$ = null;\n    this._requestSubscription = null;\n    this._nodeRequestSubscription = null;\n  }\n\n  Object.defineProperty(Navigator.prototype, \"apiV3\", {\n    get: function get() {\n      return this._apiV3;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Navigator.prototype, \"cacheService\", {\n    get: function get() {\n      return this._cacheService;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Navigator.prototype, \"graphService\", {\n    get: function get() {\n      return this._graphService;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Navigator.prototype, \"imageLoadingService\", {\n    get: function get() {\n      return this._imageLoadingService;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Navigator.prototype, \"loadingService\", {\n    get: function get() {\n      return this._loadingService;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Navigator.prototype, \"movedToKey$\", {\n    get: function get() {\n      return this._movedToKey$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Navigator.prototype, \"panService\", {\n    get: function get() {\n      return this._panService;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Navigator.prototype, \"playService\", {\n    get: function get() {\n      return this._playService;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Navigator.prototype, \"stateService\", {\n    get: function get() {\n      return this._stateService;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Navigator.prototype.moveToKey$ = function (key) {\n    this._abortRequest(\"to key \" + key);\n\n    this._loadingService.startLoading(this._loadingName);\n\n    var node$ = this._moveToKey$(key);\n\n    return this._makeRequest$(node$);\n  };\n\n  Navigator.prototype.moveDir$ = function (direction) {\n    var _this = this;\n\n    this._abortRequest(\"in dir \" + Edge_1.EdgeDirection[direction]);\n\n    this._loadingService.startLoading(this._loadingName);\n\n    var node$ = this.stateService.currentNode$.pipe(operators_1.first(), operators_1.mergeMap(function (node) {\n      return ([Edge_1.EdgeDirection.Next, Edge_1.EdgeDirection.Prev].indexOf(direction) > -1 ? node.sequenceEdges$ : node.spatialEdges$).pipe(operators_1.first(), operators_1.map(function (status) {\n        for (var _i = 0, _a = status.edges; _i < _a.length; _i++) {\n          var edge = _a[_i];\n\n          if (edge.data.direction === direction) {\n            return edge.to;\n          }\n        }\n\n        return null;\n      }));\n    }), operators_1.mergeMap(function (directionKey) {\n      if (directionKey == null) {\n        _this._loadingService.stopLoading(_this._loadingName);\n\n        return rxjs_1.throwError(new Error(\"Direction (\" + direction + \") does not exist for current node.\"));\n      }\n\n      return _this._moveToKey$(directionKey);\n    }));\n    return this._makeRequest$(node$);\n  };\n\n  Navigator.prototype.moveCloseTo$ = function (lat, lon) {\n    var _this = this;\n\n    this._abortRequest(\"to lat \" + lat + \", lon \" + lon);\n\n    this._loadingService.startLoading(this._loadingName);\n\n    var node$ = this.apiV3.imageCloseTo$(lat, lon).pipe(operators_1.mergeMap(function (fullNode) {\n      if (fullNode == null) {\n        _this._loadingService.stopLoading(_this._loadingName);\n\n        return rxjs_1.throwError(new Error(\"No image found close to lat \" + lat + \", lon \" + lon + \".\"));\n      }\n\n      return _this._moveToKey$(fullNode.key);\n    }));\n    return this._makeRequest$(node$);\n  };\n\n  Navigator.prototype.setFilter$ = function (filter) {\n    var _this = this;\n\n    this._stateService.clearNodes();\n\n    return this._movedToKey$.pipe(operators_1.first(), operators_1.mergeMap(function (key) {\n      if (key != null) {\n        return _this._trajectoryKeys$().pipe(operators_1.mergeMap(function (keys) {\n          return _this._graphService.setFilter$(filter).pipe(operators_1.mergeMap(function () {\n            return _this._cacheKeys$(keys);\n          }));\n        }), operators_1.last());\n      }\n\n      return _this._keyRequested$.pipe(operators_1.first(), operators_1.mergeMap(function (requestedKey) {\n        if (requestedKey != null) {\n          return _this._graphService.setFilter$(filter).pipe(operators_1.mergeMap(function () {\n            return _this._graphService.cacheNode$(requestedKey);\n          }));\n        }\n\n        return _this._graphService.setFilter$(filter).pipe(operators_1.map(function () {\n          return undefined;\n        }));\n      }));\n    }), operators_1.map(function (node) {\n      return undefined;\n    }));\n  };\n\n  Navigator.prototype.setToken$ = function (token) {\n    var _this = this;\n\n    this._abortRequest(\"to set token\");\n\n    this._stateService.clearNodes();\n\n    return this._movedToKey$.pipe(operators_1.first(), operators_1.tap(function (key) {\n      _this._apiV3.setToken(token);\n    }), operators_1.mergeMap(function (key) {\n      return key == null ? _this._graphService.reset$([]) : _this._trajectoryKeys$().pipe(operators_1.mergeMap(function (keys) {\n        return _this._graphService.reset$(keys).pipe(operators_1.mergeMap(function () {\n          return _this._cacheKeys$(keys);\n        }));\n      }), operators_1.last(), operators_1.map(function (node) {\n        return undefined;\n      }));\n    }));\n  };\n\n  Navigator.prototype._cacheKeys$ = function (keys) {\n    var _this = this;\n\n    var cacheNodes$ = keys.map(function (key) {\n      return _this._graphService.cacheNode$(key);\n    });\n    return rxjs_1.from(cacheNodes$).pipe(operators_1.mergeAll());\n  };\n\n  Navigator.prototype._abortRequest = function (reason) {\n    if (this._requestSubscription != null) {\n      this._requestSubscription.unsubscribe();\n\n      this._requestSubscription = null;\n    }\n\n    if (this._nodeRequestSubscription != null) {\n      this._nodeRequestSubscription.unsubscribe();\n\n      this._nodeRequestSubscription = null;\n    }\n\n    if (this._request$ != null) {\n      if (!(this._request$.isStopped || this._request$.hasError)) {\n        this._request$.error(new Error_1.AbortMapillaryError(\"Request aborted by a subsequent request \" + reason + \".\"));\n      }\n\n      this._request$ = null;\n    }\n  };\n\n  Navigator.prototype._makeRequest$ = function (node$) {\n    var _this = this;\n\n    var request$ = new rxjs_1.ReplaySubject(1);\n    this._requestSubscription = request$.subscribe(undefined, function () {});\n    this._request$ = request$;\n    this._nodeRequestSubscription = node$.subscribe(function (node) {\n      _this._request$ = null;\n      request$.next(node);\n      request$.complete();\n    }, function (error) {\n      _this._request$ = null;\n      request$.error(error);\n    });\n    return request$;\n  };\n\n  Navigator.prototype._moveToKey$ = function (key) {\n    var _this = this;\n\n    this._keyRequested$.next(key);\n\n    return this._graphService.cacheNode$(key).pipe(operators_1.tap(function (node) {\n      _this._stateService.setNodes([node]);\n\n      _this._movedToKey$.next(node.key);\n    }), operators_1.finalize(function () {\n      _this._loadingService.stopLoading(_this._loadingName);\n    }));\n  };\n\n  Navigator.prototype._trajectoryKeys$ = function () {\n    return this._stateService.currentState$.pipe(operators_1.first(), operators_1.map(function (frame) {\n      return frame.state.trajectory.map(function (node) {\n        return node.key;\n      });\n    }));\n  };\n\n  return Navigator;\n}();\n\nexports.Navigator = Navigator;\nexports.default = Navigator;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/Navigator.ts?");

/***/ }),

/***/ "./src/viewer/Observer.ts":
/*!********************************!*\
  !*** ./src/viewer/Observer.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Viewer_1 = __webpack_require__(/*! ../Viewer */ \"./src/Viewer.ts\");\n\nvar Observer =\n/** @class */\nfunction () {\n  function Observer(eventEmitter, navigator, container) {\n    var _this = this;\n\n    this._container = container;\n    this._eventEmitter = eventEmitter;\n    this._navigator = navigator;\n    this._projection = new Viewer_1.Projection();\n    this._started = false;\n    this._navigable$ = new rxjs_1.Subject(); // navigable and loading should always emit, also when cover is activated.\n\n    this._navigable$.subscribe(function (navigable) {\n      _this._eventEmitter.fire(Viewer_1.Viewer.navigablechanged, navigable);\n    });\n\n    this._navigator.loadingService.loading$.subscribe(function (loading) {\n      _this._eventEmitter.fire(Viewer_1.Viewer.loadingchanged, loading);\n    });\n  }\n\n  Object.defineProperty(Observer.prototype, \"started\", {\n    get: function get() {\n      return this._started;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Observer.prototype, \"navigable$\", {\n    get: function get() {\n      return this._navigable$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Observer.prototype.projectBasic$ = function (basicPoint) {\n    var _this = this;\n\n    return rxjs_1.combineLatest(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$).pipe(operators_1.first(), operators_1.map(function (_a) {\n      var render = _a[0],\n          transform = _a[1];\n\n      var canvasPoint = _this._projection.basicToCanvas(basicPoint, _this._container.element, render, transform);\n\n      return [Math.round(canvasPoint[0]), Math.round(canvasPoint[1])];\n    }));\n  };\n\n  Observer.prototype.startEmit = function () {\n    var _this = this;\n\n    if (this._started) {\n      return;\n    }\n\n    this._started = true;\n    this._currentNodeSubscription = this._navigator.stateService.currentNodeExternal$.subscribe(function (node) {\n      _this._eventEmitter.fire(Viewer_1.Viewer.nodechanged, node);\n    });\n    this._sequenceEdgesSubscription = this._navigator.stateService.currentNodeExternal$.pipe(operators_1.switchMap(function (node) {\n      return node.sequenceEdges$;\n    })).subscribe(function (status) {\n      _this._eventEmitter.fire(Viewer_1.Viewer.sequenceedgeschanged, status);\n    });\n    this._spatialEdgesSubscription = this._navigator.stateService.currentNodeExternal$.pipe(operators_1.switchMap(function (node) {\n      return node.spatialEdges$;\n    })).subscribe(function (status) {\n      _this._eventEmitter.fire(Viewer_1.Viewer.spatialedgeschanged, status);\n    });\n    this._moveSubscription = rxjs_1.combineLatest(this._navigator.stateService.inMotion$, this._container.mouseService.active$, this._container.touchService.active$).pipe(operators_1.map(function (values) {\n      return values[0] || values[1] || values[2];\n    }), operators_1.distinctUntilChanged()).subscribe(function (started) {\n      if (started) {\n        _this._eventEmitter.fire(Viewer_1.Viewer.movestart, null);\n      } else {\n        _this._eventEmitter.fire(Viewer_1.Viewer.moveend, null);\n      }\n    });\n    this._bearingSubscription = this._container.renderService.bearing$.pipe(operators_1.auditTime(100), operators_1.distinctUntilChanged(function (b1, b2) {\n      return Math.abs(b2 - b1) < 1;\n    })).subscribe(function (bearing) {\n      _this._eventEmitter.fire(Viewer_1.Viewer.bearingchanged, bearing);\n    });\n\n    var mouseMove$ = this._container.mouseService.active$.pipe(operators_1.switchMap(function (active) {\n      return active ? rxjs_1.empty() : _this._container.mouseService.mouseMove$;\n    }));\n\n    this._viewerMouseEventSubscription = rxjs_1.merge(this._mapMouseEvent$(Viewer_1.Viewer.click, this._container.mouseService.staticClick$), this._mapMouseEvent$(Viewer_1.Viewer.contextmenu, this._container.mouseService.contextMenu$), this._mapMouseEvent$(Viewer_1.Viewer.dblclick, this._container.mouseService.dblClick$), this._mapMouseEvent$(Viewer_1.Viewer.mousedown, this._container.mouseService.mouseDown$), this._mapMouseEvent$(Viewer_1.Viewer.mousemove, mouseMove$), this._mapMouseEvent$(Viewer_1.Viewer.mouseout, this._container.mouseService.mouseOut$), this._mapMouseEvent$(Viewer_1.Viewer.mouseover, this._container.mouseService.mouseOver$), this._mapMouseEvent$(Viewer_1.Viewer.mouseup, this._container.mouseService.mouseUp$)).pipe(operators_1.withLatestFrom(this._container.renderService.renderCamera$, this._navigator.stateService.reference$, this._navigator.stateService.currentTransform$), operators_1.map(function (_a) {\n      var _b = _a[0],\n          type = _b[0],\n          event = _b[1],\n          render = _a[1],\n          reference = _a[2],\n          transform = _a[3];\n\n      var unprojection = _this._projection.eventToUnprojection(event, _this._container.element, render, reference, transform);\n\n      return {\n        basicPoint: unprojection.basicPoint,\n        latLon: unprojection.latLon,\n        originalEvent: event,\n        pixelPoint: unprojection.pixelPoint,\n        target: _this._eventEmitter,\n        type: type\n      };\n    })).subscribe(function (event) {\n      _this._eventEmitter.fire(event.type, event);\n    });\n  };\n\n  Observer.prototype.stopEmit = function () {\n    if (!this.started) {\n      return;\n    }\n\n    this._started = false;\n\n    this._bearingSubscription.unsubscribe();\n\n    this._currentNodeSubscription.unsubscribe();\n\n    this._moveSubscription.unsubscribe();\n\n    this._sequenceEdgesSubscription.unsubscribe();\n\n    this._spatialEdgesSubscription.unsubscribe();\n\n    this._viewerMouseEventSubscription.unsubscribe();\n\n    this._bearingSubscription = null;\n    this._currentNodeSubscription = null;\n    this._moveSubscription = null;\n    this._sequenceEdgesSubscription = null;\n    this._spatialEdgesSubscription = null;\n    this._viewerMouseEventSubscription = null;\n  };\n\n  Observer.prototype.unproject$ = function (canvasPoint) {\n    var _this = this;\n\n    return rxjs_1.combineLatest(this._container.renderService.renderCamera$, this._navigator.stateService.reference$, this._navigator.stateService.currentTransform$).pipe(operators_1.first(), operators_1.map(function (_a) {\n      var render = _a[0],\n          reference = _a[1],\n          transform = _a[2];\n\n      var unprojection = _this._projection.canvasToUnprojection(canvasPoint, _this._container.element, render, reference, transform);\n\n      return unprojection.latLon;\n    }));\n  };\n\n  Observer.prototype.unprojectBasic$ = function (canvasPoint) {\n    var _this = this;\n\n    return rxjs_1.combineLatest(this._container.renderService.renderCamera$, this._navigator.stateService.currentTransform$).pipe(operators_1.first(), operators_1.map(function (_a) {\n      var render = _a[0],\n          transform = _a[1];\n      return _this._projection.canvasToBasic(canvasPoint, _this._container.element, render, transform);\n    }));\n  };\n\n  Observer.prototype._mapMouseEvent$ = function (type, mouseEvent$) {\n    return mouseEvent$.pipe(operators_1.map(function (event) {\n      return [type, event];\n    }));\n  };\n\n  return Observer;\n}();\n\nexports.Observer = Observer;\nexports.default = Observer;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/Observer.ts?");

/***/ }),

/***/ "./src/viewer/PanService.ts":
/*!**********************************!*\
  !*** ./src/viewer/PanService.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Geo = __webpack_require__(/*! ../geo/Geo */ \"./src/geo/Geo.ts\");\n\nvar GeoCoords_1 = __webpack_require__(/*! ../geo/GeoCoords */ \"./src/geo/GeoCoords.ts\");\n\nvar GraphCalculator_1 = __webpack_require__(/*! ../graph/GraphCalculator */ \"./src/graph/GraphCalculator.ts\");\n\nvar Spatial_1 = __webpack_require__(/*! ../geo/Spatial */ \"./src/geo/Spatial.ts\");\n\nvar Transform_1 = __webpack_require__(/*! ../geo/Transform */ \"./src/geo/Transform.ts\");\n\nvar ViewportCoords_1 = __webpack_require__(/*! ../geo/ViewportCoords */ \"./src/geo/ViewportCoords.ts\");\n\nvar PanMode;\n\n(function (PanMode) {\n  PanMode[PanMode[\"Disabled\"] = 0] = \"Disabled\";\n  PanMode[PanMode[\"Enabled\"] = 1] = \"Enabled\";\n  PanMode[PanMode[\"Started\"] = 2] = \"Started\";\n})(PanMode || (PanMode = {}));\n\nvar PanService =\n/** @class */\nfunction () {\n  function PanService(graphService, stateService, enabled, geoCoords, graphCalculator, spatial, viewportCoords) {\n    this._graphService = graphService;\n    this._stateService = stateService;\n    this._geoCoords = !!geoCoords ? geoCoords : new GeoCoords_1.default();\n    this._graphCalculator = !!graphCalculator ? graphCalculator : new GraphCalculator_1.default(this._geoCoords);\n    this._spatial = !!spatial ? spatial : new Spatial_1.default();\n    this._viewportCoords = !!viewportCoords ? viewportCoords : new ViewportCoords_1.default();\n    this._mode = enabled !== false ? PanMode.Enabled : PanMode.Disabled;\n    this._panNodesSubject$ = new rxjs_1.Subject();\n    this._panNodes$ = this._panNodesSubject$.pipe(operators_1.startWith([]), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._panNodes$.subscribe();\n  }\n\n  Object.defineProperty(PanService.prototype, \"panNodes$\", {\n    get: function get() {\n      return this._panNodes$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  PanService.prototype.enable = function () {\n    if (this._mode !== PanMode.Disabled) {\n      return;\n    }\n\n    this._mode = PanMode.Enabled;\n    this.start();\n  };\n\n  PanService.prototype.disable = function () {\n    if (this._mode === PanMode.Disabled) {\n      return;\n    }\n\n    this.stop();\n    this._mode = PanMode.Disabled;\n  };\n\n  PanService.prototype.start = function () {\n    var _this = this;\n\n    if (this._mode !== PanMode.Enabled) {\n      return;\n    }\n\n    var panNodes$ = this._stateService.currentNode$.pipe(operators_1.switchMap(function (current) {\n      if (!current.merged) {\n        return rxjs_1.of([]);\n      }\n\n      var current$ = rxjs_1.of(current);\n\n      var bounds = _this._graphCalculator.boundingBoxCorners(current.latLon, 20);\n\n      var adjacent$ = _this._graphService.cacheBoundingBox$(bounds[0], bounds[1]).pipe(operators_1.catchError(function (error) {\n        console.error(\"Failed to cache periphery bounding box (\" + current.key + \")\", error);\n        return rxjs_1.empty();\n      }), operators_1.map(function (nodes) {\n        if (current.pano) {\n          return [];\n        }\n\n        var potential = [];\n\n        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n          var node = nodes_1[_i];\n\n          if (node.key === current.key) {\n            continue;\n          }\n\n          if (node.mergeCC !== current.mergeCC) {\n            continue;\n          }\n\n          if (node.pano) {\n            continue;\n          }\n\n          if (_this._distance(node, current) > 4) {\n            continue;\n          }\n\n          potential.push(node);\n        }\n\n        return potential;\n      }));\n\n      return rxjs_1.combineLatest(current$, adjacent$).pipe(operators_1.withLatestFrom(_this._stateService.reference$), operators_1.map(function (_a) {\n        var _b = _a[0],\n            cn = _b[0],\n            adjacent = _b[1],\n            reference = _a[1];\n\n        var currentDirection = _this._spatial.viewingDirection(cn.rotation);\n\n        var currentTranslation = Geo.computeTranslation({\n          lat: cn.latLon.lat,\n          lon: cn.latLon.lon,\n          alt: cn.alt\n        }, cn.rotation, reference);\n\n        var currentTransform = _this._createTransform(cn, currentTranslation);\n\n        var currentAzimuthal = _this._spatial.wrap(_this._spatial.azimuthal(currentDirection.toArray(), currentTransform.upVector().toArray()), 0, 2 * Math.PI);\n\n        var currentProjectedPoints = _this._computeProjectedPoints(currentTransform);\n\n        var currentHFov = _this._computeHorizontalFov(currentProjectedPoints) / 180 * Math.PI;\n        var preferredOverlap = Math.PI / 8;\n        var left = undefined;\n        var right = undefined;\n\n        for (var _i = 0, adjacent_1 = adjacent; _i < adjacent_1.length; _i++) {\n          var a = adjacent_1[_i];\n          var translation = Geo.computeTranslation({\n            lat: a.latLon.lat,\n            lon: a.latLon.lon,\n            alt: a.alt\n          }, a.rotation, reference);\n\n          var transform = _this._createTransform(a, translation);\n\n          var projectedPoints = _this._computeProjectedPoints(transform);\n\n          var hFov = _this._computeHorizontalFov(projectedPoints) / 180 * Math.PI;\n\n          var direction = _this._spatial.viewingDirection(a.rotation);\n\n          var azimuthal = _this._spatial.wrap(_this._spatial.azimuthal(direction.toArray(), transform.upVector().toArray()), 0, 2 * Math.PI);\n\n          var directionChange = _this._spatial.angleBetweenVector2(currentDirection.x, currentDirection.y, direction.x, direction.y);\n\n          var overlap = Number.NEGATIVE_INFINITY;\n\n          if (directionChange > 0) {\n            if (currentAzimuthal > azimuthal) {\n              overlap = currentAzimuthal - 2 * Math.PI + currentHFov / 2 - (azimuthal - hFov / 2);\n            } else {\n              overlap = currentAzimuthal + currentHFov / 2 - (azimuthal - hFov / 2);\n            }\n          } else {\n            if (currentAzimuthal < azimuthal) {\n              overlap = azimuthal + hFov / 2 - (currentAzimuthal + 2 * Math.PI - currentHFov / 2);\n            } else {\n              overlap = azimuthal + hFov / 2 - (currentAzimuthal - currentHFov / 2);\n            }\n          }\n\n          var nonOverlap = Math.abs(hFov - overlap);\n\n          var distanceCost = _this._distance(a, cn);\n\n          var timeCost = Math.min(_this._timeDifference(a, cn), 4);\n          var overlapCost = 20 * Math.abs(overlap - preferredOverlap);\n          var fovCost = Math.min(5, 1 / Math.min(hFov / currentHFov, 1));\n          var nonOverlapCost = overlap > 0 ? -2 * nonOverlap : 0;\n          var cost = distanceCost + timeCost + overlapCost + fovCost + nonOverlapCost;\n\n          if (overlap > 0 && overlap < 0.5 * currentHFov && overlap < 0.5 * hFov && nonOverlap > 0.5 * currentHFov) {\n            if (directionChange > 0) {\n              if (!left) {\n                left = [cost, a, transform, hFov];\n              } else {\n                if (cost < left[0]) {\n                  left = [cost, a, transform, hFov];\n                }\n              }\n            } else {\n              if (!right) {\n                right = [cost, a, transform, hFov];\n              } else {\n                if (cost < right[0]) {\n                  right = [cost, a, transform, hFov];\n                }\n              }\n            }\n          }\n        }\n\n        var panNodes = [];\n\n        if (!!left) {\n          panNodes.push([left[1], left[2], left[3]]);\n        }\n\n        if (!!right) {\n          panNodes.push([right[1], right[2], right[3]]);\n        }\n\n        return panNodes;\n      }), operators_1.startWith([]));\n    }));\n\n    this._panNodesSubscription = this._stateService.currentState$.pipe(operators_1.map(function (frame) {\n      return frame.state.nodesAhead > 0;\n    }), operators_1.distinctUntilChanged(), operators_1.switchMap(function (traversing) {\n      return traversing ? rxjs_1.of([]) : panNodes$;\n    })).subscribe(function (panNodes) {\n      _this._panNodesSubject$.next(panNodes);\n    });\n    this._mode = PanMode.Started;\n  };\n\n  PanService.prototype.stop = function () {\n    if (this._mode !== PanMode.Started) {\n      return;\n    }\n\n    this._panNodesSubscription.unsubscribe();\n\n    this._panNodesSubject$.next([]);\n\n    this._mode = PanMode.Enabled;\n  };\n\n  PanService.prototype._distance = function (node, reference) {\n    var _a = this._geoCoords.geodeticToEnu(node.latLon.lat, node.latLon.lon, node.alt, reference.latLon.lat, reference.latLon.lon, reference.alt),\n        x = _a[0],\n        y = _a[1],\n        z = _a[2];\n\n    return Math.sqrt(x * x + y * y + z * z);\n  };\n\n  PanService.prototype._timeDifference = function (node, reference) {\n    return Math.abs(node.capturedAt - reference.capturedAt) / (1000 * 60 * 60 * 24 * 30);\n  };\n\n  PanService.prototype._createTransform = function (node, translation) {\n    return new Transform_1.Transform(node.orientation, node.width, node.height, node.focal, node.scale, node.gpano, node.rotation, translation, node.assetsCached ? node.image : undefined, undefined, node.ck1, node.ck2, node.cameraProjection);\n  };\n\n  PanService.prototype._computeProjectedPoints = function (transform) {\n    var vertices = [[1, 0]];\n    var directions = [[0, 0.5]];\n    var pointsPerLine = 20;\n    return Geo.computeProjectedPoints(transform, vertices, directions, pointsPerLine, this._viewportCoords);\n  };\n\n  PanService.prototype._computeHorizontalFov = function (projectedPoints) {\n    var _this = this;\n\n    var fovs = projectedPoints.map(function (projectedPoint) {\n      return _this._coordToFov(projectedPoint[0]);\n    });\n    var fov = Math.min.apply(Math, fovs);\n    return fov;\n  };\n\n  PanService.prototype._coordToFov = function (x) {\n    return 2 * Math.atan(x) * 180 / Math.PI;\n  };\n\n  return PanService;\n}();\n\nexports.PanService = PanService;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/PanService.ts?");

/***/ }),

/***/ "./src/viewer/PlayService.ts":
/*!***********************************!*\
  !*** ./src/viewer/PlayService.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar Edge_1 = __webpack_require__(/*! ../Edge */ \"./src/Edge.ts\");\n\nvar Graph_1 = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n\nvar PlayService =\n/** @class */\nfunction () {\n  function PlayService(graphService, stateService, graphCalculator) {\n    this._graphService = graphService;\n    this._stateService = stateService;\n    this._graphCalculator = !!graphCalculator ? graphCalculator : new Graph_1.GraphCalculator();\n    this._directionSubject$ = new rxjs_1.Subject();\n    this._direction$ = this._directionSubject$.pipe(operators_1.startWith(Edge_1.EdgeDirection.Next), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._direction$.subscribe();\n\n    this._playing = false;\n    this._playingSubject$ = new rxjs_1.Subject();\n    this._playing$ = this._playingSubject$.pipe(operators_1.startWith(this._playing), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._playing$.subscribe();\n\n    this._speed = 0.5;\n    this._speedSubject$ = new rxjs_1.Subject();\n    this._speed$ = this._speedSubject$.pipe(operators_1.startWith(this._speed), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._speed$.subscribe();\n\n    this._nodesAhead = this._mapNodesAhead(this._mapSpeed(this._speed));\n    this._bridging$ = null;\n  }\n\n  Object.defineProperty(PlayService.prototype, \"playing\", {\n    get: function get() {\n      return this._playing;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PlayService.prototype, \"direction$\", {\n    get: function get() {\n      return this._direction$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PlayService.prototype, \"playing$\", {\n    get: function get() {\n      return this._playing$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PlayService.prototype, \"speed$\", {\n    get: function get() {\n      return this._speed$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  PlayService.prototype.play = function () {\n    var _this = this;\n\n    if (this._playing) {\n      return;\n    }\n\n    this._stateService.cutNodes();\n\n    var stateSpeed = this._setSpeed(this._speed);\n\n    this._stateService.setSpeed(stateSpeed);\n\n    this._graphModeSubscription = this._speed$.pipe(operators_1.map(function (speed) {\n      return speed > PlayService.sequenceSpeed ? Graph_1.GraphMode.Sequence : Graph_1.GraphMode.Spatial;\n    }), operators_1.distinctUntilChanged()).subscribe(function (mode) {\n      _this._graphService.setGraphMode(mode);\n    });\n    this._cacheSubscription = rxjs_1.combineLatest(this._stateService.currentNode$.pipe(operators_1.map(function (node) {\n      return [node.sequenceKey, node.key];\n    }), operators_1.distinctUntilChanged(undefined, function (_a) {\n      var sequenceKey = _a[0],\n          nodeKey = _a[1];\n      return sequenceKey;\n    })), this._graphService.graphMode$, this._direction$).pipe(operators_1.switchMap(function (_a) {\n      var _b = _a[0],\n          sequenceKey = _b[0],\n          nodeKey = _b[1],\n          mode = _a[1],\n          direction = _a[2];\n\n      if (direction !== Edge_1.EdgeDirection.Next && direction !== Edge_1.EdgeDirection.Prev) {\n        return rxjs_1.of([undefined, direction]);\n      }\n\n      var sequence$ = (mode === Graph_1.GraphMode.Sequence ? _this._graphService.cacheSequenceNodes$(sequenceKey, nodeKey) : _this._graphService.cacheSequence$(sequenceKey)).pipe(operators_1.retry(3), operators_1.catchError(function (error) {\n        console.error(error);\n        return rxjs_1.of(undefined);\n      }));\n      return rxjs_1.combineLatest(sequence$, rxjs_1.of(direction));\n    }), operators_1.switchMap(function (_a) {\n      var sequence = _a[0],\n          direction = _a[1];\n\n      if (sequence === undefined) {\n        return rxjs_1.empty();\n      }\n\n      var sequenceKeys = sequence.keys.slice();\n\n      if (direction === Edge_1.EdgeDirection.Prev) {\n        sequenceKeys.reverse();\n      }\n\n      return _this._stateService.currentState$.pipe(operators_1.map(function (frame) {\n        return [frame.state.trajectory[frame.state.trajectory.length - 1].key, frame.state.nodesAhead];\n      }), operators_1.scan(function (_a, _b) {\n        var lastRequestKey = _a[0],\n            previousRequestKeys = _a[1];\n        var lastTrajectoryKey = _b[0],\n            nodesAhead = _b[1];\n\n        if (lastRequestKey === undefined) {\n          lastRequestKey = lastTrajectoryKey;\n        }\n\n        var lastIndex = sequenceKeys.length - 1;\n\n        if (nodesAhead >= _this._nodesAhead || sequenceKeys[lastIndex] === lastRequestKey) {\n          return [lastRequestKey, []];\n        }\n\n        var current = sequenceKeys.indexOf(lastTrajectoryKey);\n        var start = sequenceKeys.indexOf(lastRequestKey) + 1;\n        var end = Math.min(lastIndex, current + _this._nodesAhead - nodesAhead) + 1;\n\n        if (end <= start) {\n          return [lastRequestKey, []];\n        }\n\n        return [sequenceKeys[end - 1], sequenceKeys.slice(start, end)];\n      }, [undefined, []]), operators_1.mergeMap(function (_a) {\n        var lastRequestKey = _a[0],\n            newRequestKeys = _a[1];\n        return rxjs_1.from(newRequestKeys);\n      }));\n    }), operators_1.mergeMap(function (key) {\n      return _this._graphService.cacheNode$(key).pipe(operators_1.catchError(function () {\n        return rxjs_1.empty();\n      }));\n    }, 6)).subscribe();\n    this._playingSubscription = this._stateService.currentState$.pipe(operators_1.filter(function (frame) {\n      return frame.state.nodesAhead < _this._nodesAhead;\n    }), operators_1.distinctUntilChanged(undefined, function (frame) {\n      return frame.state.lastNode.key;\n    }), operators_1.map(function (frame) {\n      var lastNode = frame.state.lastNode;\n      var trajectory = frame.state.trajectory;\n      var increasingTime = undefined;\n\n      for (var i = trajectory.length - 2; i >= 0; i--) {\n        var node = trajectory[i];\n\n        if (node.sequenceKey !== lastNode.sequenceKey) {\n          break;\n        }\n\n        if (node.capturedAt !== lastNode.capturedAt) {\n          increasingTime = node.capturedAt < lastNode.capturedAt;\n          break;\n        }\n      }\n\n      return [frame.state.lastNode, increasingTime];\n    }), operators_1.withLatestFrom(this._direction$), operators_1.switchMap(function (_a) {\n      var _b = _a[0],\n          node = _b[0],\n          increasingTime = _b[1],\n          direction = _a[1];\n      return rxjs_1.zip(([Edge_1.EdgeDirection.Next, Edge_1.EdgeDirection.Prev].indexOf(direction) > -1 ? node.sequenceEdges$ : node.spatialEdges$).pipe(operators_1.first(function (status) {\n        return status.cached;\n      }), operators_1.timeout(15000)), rxjs_1.of(direction)).pipe(operators_1.map(function (_a) {\n        var s = _a[0],\n            d = _a[1];\n\n        for (var _i = 0, _b = s.edges; _i < _b.length; _i++) {\n          var edge = _b[_i];\n\n          if (edge.data.direction === d) {\n            return edge.to;\n          }\n        }\n\n        return null;\n      }), operators_1.switchMap(function (key) {\n        return key != null ? _this._graphService.cacheNode$(key) : _this._bridge$(node, increasingTime).pipe(operators_1.filter(function (n) {\n          return !!n;\n        }));\n      }));\n    })).subscribe(function (node) {\n      _this._stateService.appendNodes([node]);\n    }, function (error) {\n      console.error(error);\n\n      _this.stop();\n    });\n    this._clearSubscription = this._stateService.currentNode$.pipe(operators_1.bufferCount(1, 10)).subscribe(function (nodes) {\n      _this._stateService.clearPriorNodes();\n    });\n\n    this._setPlaying(true);\n\n    var currentLastNodes$ = this._stateService.currentState$.pipe(operators_1.map(function (frame) {\n      return frame.state;\n    }), operators_1.distinctUntilChanged(function (_a, _b) {\n      var kc1 = _a[0],\n          kl1 = _a[1];\n      var kc2 = _b[0],\n          kl2 = _b[1];\n      return kc1 === kc2 && kl1 === kl2;\n    }, function (state) {\n      return [state.currentNode.key, state.lastNode.key];\n    }), operators_1.filter(function (state) {\n      return state.currentNode.key === state.lastNode.key && state.currentIndex === state.trajectory.length - 1;\n    }), operators_1.map(function (state) {\n      return state.currentNode;\n    }));\n\n    this._stopSubscription = rxjs_1.combineLatest(currentLastNodes$, this._direction$).pipe(operators_1.switchMap(function (_a) {\n      var node = _a[0],\n          direction = _a[1];\n      var edgeStatus$ = ([Edge_1.EdgeDirection.Next, Edge_1.EdgeDirection.Prev].indexOf(direction) > -1 ? node.sequenceEdges$ : node.spatialEdges$).pipe(operators_1.first(function (status) {\n        return status.cached;\n      }), operators_1.timeout(15000), operators_1.catchError(function (error) {\n        console.error(error);\n        return rxjs_1.of({\n          cached: false,\n          edges: []\n        });\n      }));\n      return rxjs_1.combineLatest(rxjs_1.of(direction), edgeStatus$).pipe(operators_1.map(function (_a) {\n        var d = _a[0],\n            es = _a[1];\n\n        for (var _i = 0, _b = es.edges; _i < _b.length; _i++) {\n          var edge = _b[_i];\n\n          if (edge.data.direction === d) {\n            return true;\n          }\n        }\n\n        return false;\n      }));\n    }), operators_1.mergeMap(function (hasEdge) {\n      if (hasEdge || !_this._bridging$) {\n        return rxjs_1.of(hasEdge);\n      }\n\n      return _this._bridging$.pipe(operators_1.map(function (node) {\n        return node != null;\n      }), operators_1.catchError(function (error) {\n        console.error(error);\n        return rxjs_1.of(false);\n      }));\n    }), operators_1.first(function (hasEdge) {\n      return !hasEdge;\n    })).subscribe(undefined, undefined, function () {\n      _this.stop();\n    });\n\n    if (this._stopSubscription.closed) {\n      this._stopSubscription = null;\n    }\n  };\n\n  PlayService.prototype.setDirection = function (direction) {\n    this._directionSubject$.next(direction);\n  };\n\n  PlayService.prototype.setSpeed = function (speed) {\n    speed = Math.max(0, Math.min(1, speed));\n\n    if (speed === this._speed) {\n      return;\n    }\n\n    var stateSpeed = this._setSpeed(speed);\n\n    if (this._playing) {\n      this._stateService.setSpeed(stateSpeed);\n    }\n\n    this._speedSubject$.next(this._speed);\n  };\n\n  PlayService.prototype.stop = function () {\n    if (!this._playing) {\n      return;\n    }\n\n    if (!!this._stopSubscription) {\n      if (!this._stopSubscription.closed) {\n        this._stopSubscription.unsubscribe();\n      }\n\n      this._stopSubscription = null;\n    }\n\n    this._graphModeSubscription.unsubscribe();\n\n    this._graphModeSubscription = null;\n\n    this._cacheSubscription.unsubscribe();\n\n    this._cacheSubscription = null;\n\n    this._playingSubscription.unsubscribe();\n\n    this._playingSubscription = null;\n\n    this._clearSubscription.unsubscribe();\n\n    this._clearSubscription = null;\n\n    this._stateService.setSpeed(1);\n\n    this._stateService.cutNodes();\n\n    this._graphService.setGraphMode(Graph_1.GraphMode.Spatial);\n\n    this._setPlaying(false);\n  };\n\n  PlayService.prototype._bridge$ = function (node, increasingTime) {\n    var _this = this;\n\n    if (increasingTime === undefined) {\n      return rxjs_1.of(null);\n    }\n\n    var boundingBox = this._graphCalculator.boundingBoxCorners(node.latLon, 25);\n\n    this._bridging$ = this._graphService.cacheBoundingBox$(boundingBox[0], boundingBox[1]).pipe(operators_1.mergeMap(function (nodes) {\n      var nextNode = null;\n\n      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var n = nodes_1[_i];\n\n        if (n.sequenceKey === node.sequenceKey || !n.cameraUuid || n.cameraUuid !== node.cameraUuid || n.capturedAt === node.capturedAt || n.capturedAt > node.capturedAt !== increasingTime) {\n          continue;\n        }\n\n        var delta = Math.abs(n.capturedAt - node.capturedAt);\n\n        if (delta > 15000) {\n          continue;\n        }\n\n        if (!nextNode || delta < Math.abs(nextNode.capturedAt - node.capturedAt)) {\n          nextNode = n;\n        }\n      }\n\n      return !!nextNode ? _this._graphService.cacheNode$(nextNode.key) : rxjs_1.of(null);\n    }), operators_1.finalize(function () {\n      _this._bridging$ = null;\n    }), operators_1.publish(), operators_1.refCount());\n    return this._bridging$;\n  };\n\n  PlayService.prototype._mapSpeed = function (speed) {\n    var x = 2 * speed - 1;\n    return Math.pow(10, x) - 0.2 * x;\n  };\n\n  PlayService.prototype._mapNodesAhead = function (stateSpeed) {\n    return Math.round(Math.max(10, Math.min(50, 8 + 6 * stateSpeed)));\n  };\n\n  PlayService.prototype._setPlaying = function (playing) {\n    this._playing = playing;\n\n    this._playingSubject$.next(playing);\n  };\n\n  PlayService.prototype._setSpeed = function (speed) {\n    this._speed = speed;\n\n    var stateSpeed = this._mapSpeed(this._speed);\n\n    this._nodesAhead = this._mapNodesAhead(stateSpeed);\n    return stateSpeed;\n  };\n\n  PlayService.sequenceSpeed = 0.54;\n  return PlayService;\n}();\n\nexports.PlayService = PlayService;\nexports.default = PlayService;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/PlayService.ts?");

/***/ }),

/***/ "./src/viewer/Projection.ts":
/*!**********************************!*\
  !*** ./src/viewer/Projection.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar Geo_1 = __webpack_require__(/*! ../Geo */ \"./src/Geo.ts\");\n\nvar Projection =\n/** @class */\nfunction () {\n  function Projection(geoCoords, viewportCoords) {\n    this._geoCoords = !!geoCoords ? geoCoords : new Geo_1.GeoCoords();\n    this._viewportCoords = !!viewportCoords ? viewportCoords : new Geo_1.ViewportCoords();\n  }\n\n  Projection.prototype.basicToCanvas = function (basicPoint, container, render, transform) {\n    return this._viewportCoords.basicToCanvas(basicPoint[0], basicPoint[1], container, transform, render.perspective);\n  };\n\n  Projection.prototype.canvasToBasic = function (canvasPoint, container, render, transform) {\n    var basicPoint = this._viewportCoords.canvasToBasic(canvasPoint[0], canvasPoint[1], container, transform, render.perspective);\n\n    if (basicPoint[0] < 0 || basicPoint[0] > 1 || basicPoint[1] < 0 || basicPoint[1] > 1) {\n      basicPoint = null;\n    }\n\n    return basicPoint;\n  };\n\n  Projection.prototype.eventToUnprojection = function (event, container, render, reference, transform) {\n    var pixelPoint = this._viewportCoords.canvasPosition(event, container);\n\n    return this.canvasToUnprojection(pixelPoint, container, render, reference, transform);\n  };\n\n  Projection.prototype.canvasToUnprojection = function (canvasPoint, container, render, reference, transform) {\n    var canvasX = canvasPoint[0];\n    var canvasY = canvasPoint[1];\n\n    var _a = this._viewportCoords.canvasToViewport(canvasX, canvasY, container),\n        viewportX = _a[0],\n        viewportY = _a[1];\n\n    var point3d = new THREE.Vector3(viewportX, viewportY, 1).unproject(render.perspective);\n    var basicPoint = transform.projectBasic(point3d.toArray());\n\n    if (basicPoint[0] < 0 || basicPoint[0] > 1 || basicPoint[1] < 0 || basicPoint[1] > 1) {\n      basicPoint = null;\n    }\n\n    var direction3d = point3d.clone().sub(render.camera.position).normalize();\n    var dist = -2 / direction3d.z;\n    var latLon = null;\n\n    if (dist > 0 && dist < 100 && !!basicPoint) {\n      var point = direction3d.clone().multiplyScalar(dist).add(render.camera.position);\n\n      var latLonArray = this._geoCoords.enuToGeodetic(point.x, point.y, point.z, reference.lat, reference.lon, reference.alt).slice(0, 2);\n\n      latLon = {\n        lat: latLonArray[0],\n        lon: latLonArray[1]\n      };\n    }\n\n    var unprojection = {\n      basicPoint: basicPoint,\n      latLon: latLon,\n      pixelPoint: [canvasX, canvasY]\n    };\n    return unprojection;\n  };\n\n  return Projection;\n}();\n\nexports.Projection = Projection;\nexports.default = Projection;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/Projection.ts?");

/***/ }),

/***/ "./src/viewer/SpriteService.ts":
/*!*************************************!*\
  !*** ./src/viewer/SpriteService.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.min.js\");\n\nvar vd = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'virtual-dom'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar Viewer_1 = __webpack_require__(/*! ../Viewer */ \"./src/Viewer.ts\");\n\nvar SpriteAtlas =\n/** @class */\nfunction () {\n  function SpriteAtlas() {}\n\n  Object.defineProperty(SpriteAtlas.prototype, \"json\", {\n    set: function set(value) {\n      this._json = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SpriteAtlas.prototype, \"image\", {\n    set: function set(value) {\n      this._image = value;\n      this._texture = new THREE.Texture(this._image);\n      this._texture.minFilter = THREE.NearestFilter;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SpriteAtlas.prototype, \"loaded\", {\n    get: function get() {\n      return !!(this._image && this._json);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SpriteAtlas.prototype.getGLSprite = function (name) {\n    if (!this.loaded) {\n      throw new Error(\"Sprites cannot be retrieved before the atlas is loaded.\");\n    }\n\n    var definition = this._json[name];\n\n    if (!definition) {\n      console.warn(\"Sprite with key\" + name + \"does not exist in sprite definition.\");\n      return new THREE.Object3D();\n    }\n\n    var texture = this._texture.clone();\n\n    texture.needsUpdate = true;\n    var width = this._image.width;\n    var height = this._image.height;\n    texture.offset.x = definition.x / width;\n    texture.offset.y = (height - definition.y - definition.height) / height;\n    texture.repeat.x = definition.width / width;\n    texture.repeat.y = definition.height / height;\n    var material = new THREE.SpriteMaterial({\n      map: texture\n    });\n    return new THREE.Sprite(material);\n  };\n\n  SpriteAtlas.prototype.getDOMSprite = function (name, float) {\n    if (!this.loaded) {\n      throw new Error(\"Sprites cannot be retrieved before the atlas is loaded.\");\n    }\n\n    if (float == null) {\n      float = Viewer_1.Alignment.Center;\n    }\n\n    var definition = this._json[name];\n\n    if (!definition) {\n      console.warn(\"Sprite with key\" + name + \"does not exist in sprite definition.\");\n      return vd.h(\"div\", {}, []);\n    }\n\n    var clipTop = definition.y;\n    var clipRigth = definition.x + definition.width;\n    var clipBottom = definition.y + definition.height;\n    var clipLeft = definition.x;\n    var left = -definition.x;\n    var top = -definition.y;\n    var height = this._image.height;\n    var width = this._image.width;\n\n    switch (float) {\n      case Viewer_1.Alignment.Bottom:\n      case Viewer_1.Alignment.Center:\n      case Viewer_1.Alignment.Top:\n        left -= definition.width / 2;\n        break;\n\n      case Viewer_1.Alignment.BottomLeft:\n      case Viewer_1.Alignment.Left:\n      case Viewer_1.Alignment.TopLeft:\n        left -= definition.width;\n        break;\n\n      case Viewer_1.Alignment.BottomRight:\n      case Viewer_1.Alignment.Right:\n      case Viewer_1.Alignment.TopRight:\n      default:\n        break;\n    }\n\n    switch (float) {\n      case Viewer_1.Alignment.Center:\n      case Viewer_1.Alignment.Left:\n      case Viewer_1.Alignment.Right:\n        top -= definition.height / 2;\n        break;\n\n      case Viewer_1.Alignment.Top:\n      case Viewer_1.Alignment.TopLeft:\n      case Viewer_1.Alignment.TopRight:\n        top -= definition.height;\n        break;\n\n      case Viewer_1.Alignment.Bottom:\n      case Viewer_1.Alignment.BottomLeft:\n      case Viewer_1.Alignment.BottomRight:\n      default:\n        break;\n    }\n\n    var pixelRatioInverse = 1 / definition.pixelRatio;\n    clipTop *= pixelRatioInverse;\n    clipRigth *= pixelRatioInverse;\n    clipBottom *= pixelRatioInverse;\n    clipLeft *= pixelRatioInverse;\n    left *= pixelRatioInverse;\n    top *= pixelRatioInverse;\n    height *= pixelRatioInverse;\n    width *= pixelRatioInverse;\n    var properties = {\n      src: this._image.src,\n      style: {\n        clip: \"rect(\" + clipTop + \"px, \" + clipRigth + \"px, \" + clipBottom + \"px, \" + clipLeft + \"px)\",\n        height: height + \"px\",\n        left: left + \"px\",\n        position: \"absolute\",\n        top: top + \"px\",\n        width: width + \"px\"\n      }\n    };\n    return vd.h(\"img\", properties, []);\n  };\n\n  return SpriteAtlas;\n}();\n\nvar SpriteService =\n/** @class */\nfunction () {\n  function SpriteService(sprite) {\n    var _this = this;\n\n    this._retina = window.devicePixelRatio > 1;\n    this._spriteAtlasOperation$ = new rxjs_1.Subject();\n    this._spriteAtlas$ = this._spriteAtlasOperation$.pipe(operators_1.startWith(function (atlas) {\n      return atlas;\n    }), operators_1.scan(function (atlas, operation) {\n      return operation(atlas);\n    }, new SpriteAtlas()), operators_1.publishReplay(1), operators_1.refCount());\n\n    this._spriteAtlas$.subscribe(function () {});\n\n    if (sprite == null) {\n      return;\n    }\n\n    var format = this._retina ? \"@2x\" : \"\";\n    var imageXmlHTTP = new XMLHttpRequest();\n    imageXmlHTTP.open(\"GET\", sprite + format + \".png\", true);\n    imageXmlHTTP.responseType = \"arraybuffer\";\n\n    imageXmlHTTP.onload = function () {\n      var image = new Image();\n\n      image.onload = function () {\n        _this._spriteAtlasOperation$.next(function (atlas) {\n          atlas.image = image;\n          return atlas;\n        });\n      };\n\n      var blob = new Blob([imageXmlHTTP.response]);\n      image.src = window.URL.createObjectURL(blob);\n    };\n\n    imageXmlHTTP.onerror = function (error) {\n      console.error(new Error(\"Failed to fetch sprite sheet (\" + sprite + format + \".png)\"));\n    };\n\n    imageXmlHTTP.send();\n    var jsonXmlHTTP = new XMLHttpRequest();\n    jsonXmlHTTP.open(\"GET\", sprite + format + \".json\", true);\n    jsonXmlHTTP.responseType = \"text\";\n\n    jsonXmlHTTP.onload = function () {\n      var json = JSON.parse(jsonXmlHTTP.response);\n\n      _this._spriteAtlasOperation$.next(function (atlas) {\n        atlas.json = json;\n        return atlas;\n      });\n    };\n\n    jsonXmlHTTP.onerror = function (error) {\n      console.error(new Error(\"Failed to fetch sheet (\" + sprite + format + \".json)\"));\n    };\n\n    jsonXmlHTTP.send();\n  }\n\n  Object.defineProperty(SpriteService.prototype, \"spriteAtlas$\", {\n    get: function get() {\n      return this._spriteAtlas$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return SpriteService;\n}();\n\nexports.SpriteService = SpriteService;\nexports.default = SpriteService;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/SpriteService.ts?");

/***/ }),

/***/ "./src/viewer/TouchService.ts":
/*!************************************!*\
  !*** ./src/viewer/TouchService.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar TouchService =\n/** @class */\nfunction () {\n  function TouchService(canvasContainer, domContainer) {\n    var _this = this;\n\n    this._activeSubject$ = new rxjs_1.BehaviorSubject(false);\n    this._active$ = this._activeSubject$.pipe(operators_1.distinctUntilChanged(), operators_1.publishReplay(1), operators_1.refCount());\n    rxjs_1.fromEvent(domContainer, \"touchmove\").subscribe(function (event) {\n      event.preventDefault();\n    });\n    this._touchStart$ = rxjs_1.fromEvent(canvasContainer, \"touchstart\");\n    this._touchMove$ = rxjs_1.fromEvent(canvasContainer, \"touchmove\");\n    this._touchEnd$ = rxjs_1.fromEvent(canvasContainer, \"touchend\");\n    this._touchCancel$ = rxjs_1.fromEvent(canvasContainer, \"touchcancel\");\n\n    var tapStart$ = this._touchStart$.pipe(operators_1.filter(function (te) {\n      return te.touches.length === 1 && te.targetTouches.length === 1;\n    }), operators_1.share());\n\n    this._doubleTap$ = tapStart$.pipe(operators_1.bufferWhen(function () {\n      return tapStart$.pipe(operators_1.first(), operators_1.switchMap(function (event) {\n        return rxjs_1.merge(rxjs_1.timer(300), tapStart$).pipe(operators_1.take(1));\n      }));\n    }), operators_1.filter(function (events) {\n      return events.length === 2;\n    }), operators_1.map(function (events) {\n      return events[events.length - 1];\n    }), operators_1.share());\n\n    this._doubleTap$.subscribe(function (event) {\n      event.preventDefault();\n    });\n\n    this._singleTouchMove$ = this._touchMove$.pipe(operators_1.filter(function (te) {\n      return te.touches.length === 1 && te.targetTouches.length === 1;\n    }), operators_1.share());\n    var singleTouchStart$ = rxjs_1.merge(this._touchStart$, this._touchEnd$, this._touchCancel$).pipe(operators_1.filter(function (te) {\n      return te.touches.length === 1 && te.targetTouches.length === 1;\n    }));\n    var multipleTouchStart$ = rxjs_1.merge(this._touchStart$, this._touchEnd$, this._touchCancel$).pipe(operators_1.filter(function (te) {\n      return te.touches.length >= 1;\n    }));\n    var touchStop$ = rxjs_1.merge(this._touchEnd$, this._touchCancel$).pipe(operators_1.filter(function (te) {\n      return te.touches.length === 0;\n    }));\n    this._singleTouchDragStart$ = singleTouchStart$.pipe(operators_1.mergeMap(function (e) {\n      return _this._singleTouchMove$.pipe(operators_1.takeUntil(rxjs_1.merge(touchStop$, multipleTouchStart$)), operators_1.take(1));\n    }));\n    this._singleTouchDragEnd$ = singleTouchStart$.pipe(operators_1.mergeMap(function (e) {\n      return rxjs_1.merge(touchStop$, multipleTouchStart$).pipe(operators_1.first());\n    }));\n    this._singleTouchDrag$ = singleTouchStart$.pipe(operators_1.switchMap(function (te) {\n      return _this._singleTouchMove$.pipe(operators_1.skip(1), operators_1.takeUntil(rxjs_1.merge(multipleTouchStart$, touchStop$)));\n    }));\n    var touchesChanged$ = rxjs_1.merge(this._touchStart$, this._touchEnd$, this._touchCancel$);\n    this._pinchStart$ = touchesChanged$.pipe(operators_1.filter(function (te) {\n      return te.touches.length === 2 && te.targetTouches.length === 2;\n    }));\n    this._pinchEnd$ = touchesChanged$.pipe(operators_1.filter(function (te) {\n      return te.touches.length !== 2 || te.targetTouches.length !== 2;\n    }));\n    this._pinchOperation$ = new rxjs_1.Subject();\n    this._pinch$ = this._pinchOperation$.pipe(operators_1.scan(function (pinch, operation) {\n      return operation(pinch);\n    }, {\n      changeX: 0,\n      changeY: 0,\n      clientX: 0,\n      clientY: 0,\n      distance: 0,\n      distanceChange: 0,\n      distanceX: 0,\n      distanceY: 0,\n      originalEvent: null,\n      pageX: 0,\n      pageY: 0,\n      screenX: 0,\n      screenY: 0,\n      touch1: null,\n      touch2: null\n    }));\n\n    this._touchMove$.pipe(operators_1.filter(function (te) {\n      return te.touches.length === 2 && te.targetTouches.length === 2;\n    }), operators_1.map(function (te) {\n      return function (previous) {\n        var touch1 = te.touches[0];\n        var touch2 = te.touches[1];\n        var minX = Math.min(touch1.clientX, touch2.clientX);\n        var maxX = Math.max(touch1.clientX, touch2.clientX);\n        var minY = Math.min(touch1.clientY, touch2.clientY);\n        var maxY = Math.max(touch1.clientY, touch2.clientY);\n        var centerClientX = minX + (maxX - minX) / 2;\n        var centerClientY = minY + (maxY - minY) / 2;\n        var centerPageX = centerClientX + touch1.pageX - touch1.clientX;\n        var centerPageY = centerClientY + touch1.pageY - touch1.clientY;\n        var centerScreenX = centerClientX + touch1.screenX - touch1.clientX;\n        var centerScreenY = centerClientY + touch1.screenY - touch1.clientY;\n        var distanceX = Math.abs(touch1.clientX - touch2.clientX);\n        var distanceY = Math.abs(touch1.clientY - touch2.clientY);\n        var distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n        var distanceChange = distance - previous.distance;\n        var changeX = distanceX - previous.distanceX;\n        var changeY = distanceY - previous.distanceY;\n        var current = {\n          changeX: changeX,\n          changeY: changeY,\n          clientX: centerClientX,\n          clientY: centerClientY,\n          distance: distance,\n          distanceChange: distanceChange,\n          distanceX: distanceX,\n          distanceY: distanceY,\n          originalEvent: te,\n          pageX: centerPageX,\n          pageY: centerPageY,\n          screenX: centerScreenX,\n          screenY: centerScreenY,\n          touch1: touch1,\n          touch2: touch2\n        };\n        return current;\n      };\n    })).subscribe(this._pinchOperation$);\n\n    this._pinchChange$ = this._pinchStart$.pipe(operators_1.switchMap(function (te) {\n      return _this._pinch$.pipe(operators_1.skip(1), operators_1.takeUntil(_this._pinchEnd$));\n    }));\n  }\n\n  Object.defineProperty(TouchService.prototype, \"active$\", {\n    get: function get() {\n      return this._active$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"activate$\", {\n    get: function get() {\n      return this._activeSubject$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"doubleTap$\", {\n    get: function get() {\n      return this._doubleTap$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"touchStart$\", {\n    get: function get() {\n      return this._touchStart$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"touchMove$\", {\n    get: function get() {\n      return this._touchMove$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"touchEnd$\", {\n    get: function get() {\n      return this._touchEnd$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"touchCancel$\", {\n    get: function get() {\n      return this._touchCancel$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"singleTouchDragStart$\", {\n    get: function get() {\n      return this._singleTouchDragStart$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"singleTouchDrag$\", {\n    get: function get() {\n      return this._singleTouchDrag$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"singleTouchDragEnd$\", {\n    get: function get() {\n      return this._singleTouchDragEnd$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"pinch$\", {\n    get: function get() {\n      return this._pinchChange$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"pinchStart$\", {\n    get: function get() {\n      return this._pinchStart$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TouchService.prototype, \"pinchEnd$\", {\n    get: function get() {\n      return this._pinchEnd$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return TouchService;\n}();\n\nexports.TouchService = TouchService;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/TouchService.ts?");

/***/ }),

/***/ "./src/viewer/Viewer.ts":
/*!******************************!*\
  !*** ./src/viewer/Viewer.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm5/index.js\");\n\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm5/operators/index.js\");\n\nvar when = __webpack_require__(/*! when */ \"./node_modules/when/when.js\");\n\nvar Viewer_1 = __webpack_require__(/*! ../Viewer */ \"./src/Viewer.ts\");\n\nvar Utils_1 = __webpack_require__(/*! ../Utils */ \"./src/Utils.ts\");\n/**\n * @class Viewer\n *\n * @classdesc The Viewer object represents the navigable image viewer.\n * Create a Viewer by specifying a container, client ID, image key and\n * other options. The viewer exposes methods and events for programmatic\n * interaction.\n *\n * In the case of asynchronous methods, MapillaryJS returns promises to\n * the results. Notifications are always emitted through JavaScript events.\n *\n * The viewer works with a few different coordinate systems.\n *\n * Container pixel coordinates\n *\n * Pixel coordinates are coordinates on the viewer container. The origin is\n * in the top left corner of the container. The axes are\n * directed according to the following for a viewer container with a width\n * of 640 pixels and height of 480 pixels.\n *\n * ```\n * (0,0)                          (640, 0)\n *      +------------------------>\n *      |\n *      |\n *      |\n *      v                        +\n * (0, 480)                       (640, 480)\n * ```\n *\n * Basic image coordinates\n *\n * Basic image coordinates represents points in the original image adjusted for\n * orientation. They range from 0 to 1 on both axes. The origin is in the top left\n * corner of the image and the axes are directed\n * according to the following for all image types.\n *\n * ```\n * (0,0)                          (1, 0)\n *      +------------------------>\n *      |\n *      |\n *      |\n *      v                        +\n * (0, 1)                         (1, 1)\n * ```\n *\n * For every camera viewing direction it is possible to convert between these\n * two coordinate systems for the current node. The image can be panned and\n * zoomed independently of the size of the viewer container resulting in\n * different conversion results for different viewing directions.\n */\n\n\nvar Viewer =\n/** @class */\nfunction (_super) {\n  __extends(Viewer, _super);\n  /**\n   * Create a new viewer instance.\n   *\n   * @description It is possible to initialize the viewer with or\n   * without a key.\n   *\n   * When you want to show a specific image in the viewer from\n   * the start you should initialize it with a key.\n   *\n   * When you do not know the first image key at implementation\n   * time, e.g. in a map-viewer application you should initialize\n   * the viewer without a key and call `moveToKey` instead.\n   *\n   * When initializing with a key the viewer is bound to that key\n   * until the node for that key has been successfully loaded.\n   * Also, a cover with the image of the key will be shown.\n   * If the data for that key can not be loaded because the key is\n   * faulty or other errors occur it is not possible to navigate\n   * to another key because the viewer is not navigable. The viewer\n   * becomes navigable when the data for the key has been loaded and\n   * the image is shown in the viewer. This way of initializing\n   * the viewer is mostly for embedding in blog posts and similar\n   * where one wants to show a specific image initially.\n   *\n   * If the viewer is initialized without a key (with null or\n   * undefined) it is not bound to any particular key and it is\n   * possible to move to any key with `viewer.moveToKey(\"<my-image-key>\")`.\n   * If the first move to a key fails it is possible to move to another\n   * key. The viewer will show a black background until a move\n   * succeeds. This way of intitializing is suited for a map-viewer\n   * application when the initial key is not known at implementation\n   * time.\n   *\n   * @param {string} id - Required `id` of a DOM element which will\n   * be transformed into the viewer.\n   * @param {string} clientId - Required `Mapillary API ClientID`. Can\n   * be obtained from https://www.mapillary.com/app/settings/developers.\n   * @param {string} key - Optional `image-key` to start from. The key\n   * can be any Mapillary image. If a key is provided the viewer is\n   * bound to that key until it has been fully loaded. If null is provided\n   * no image is loaded at viewer initialization and the viewer is not\n   * bound to any particular key. Any image can then be navigated to\n   * with e.g. `viewer.moveToKey(\"<my-image-key>\")`.\n   * @param {IViewerOptions} options - Optional configuration object\n   * specifing Viewer's and the components' initial setup.\n   * @param {string} token - Optional bearer token for API requests of\n   * protected resources.\n   *\n   * @example\n   * ```\n   * var viewer = new Mapillary.Viewer(\"<element-id>\", \"<client-id>\", \"<image-key>\");\n   * ```\n   */\n\n\n  function Viewer(id, clientId, key, options, token) {\n    var _this = _super.call(this) || this;\n\n    options = options != null ? options : {};\n    Utils_1.Settings.setOptions(options);\n    Utils_1.Urls.setOptions(options.url);\n    _this._navigator = new Viewer_1.Navigator(clientId, options, token);\n    _this._container = new Viewer_1.Container(id, _this._navigator.stateService, options);\n    _this._observer = new Viewer_1.Observer(_this, _this._navigator, _this._container);\n    _this._componentController = new Viewer_1.ComponentController(_this._container, _this._navigator, _this._observer, key, options.component);\n    return _this;\n  }\n\n  Object.defineProperty(Viewer.prototype, \"isNavigable\", {\n    /**\n     * Return a boolean indicating if the viewer is in a navigable state.\n     *\n     * @description The navigable state indicates if the viewer supports\n     * moving, i.e. calling the {@link moveToKey}, {@link moveDir}\n     * and {@link moveCloseTo} methods or changing the authentication state,\n     * i.e. calling {@link setAuthToken}. The viewer will not be in a navigable\n     * state if the cover is activated and the viewer has been supplied a key.\n     * When the cover is deactivated or the viewer is activated without being\n     * supplied a key it will be navigable.\n     *\n     * @returns {boolean} Boolean indicating whether the viewer is navigable.\n     */\n    get: function get() {\n      return this._componentController.navigable;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Activate the combined panning functionality.\n   *\n   * @description The combined panning functionality is active by default.\n   */\n\n  Viewer.prototype.activateCombinedPanning = function () {\n    this._navigator.panService.enable();\n  };\n  /**\n   * Activate a component.\n   *\n   * @param {string} name - Name of the component which will become active.\n   *\n   * @example\n   * ```\n   * viewer.activateComponent(\"marker\");\n   * ```\n   */\n\n\n  Viewer.prototype.activateComponent = function (name) {\n    this._componentController.activate(name);\n  };\n  /**\n   * Activate the cover (deactivates all other components).\n   */\n\n\n  Viewer.prototype.activateCover = function () {\n    this._componentController.activateCover();\n  };\n  /**\n   * Deactivate the combined panning functionality.\n   *\n   * @description Deactivating the combined panning functionality\n   * could be needed in scenarios involving sequence only navigation.\n   */\n\n\n  Viewer.prototype.deactivateCombinedPanning = function () {\n    this._navigator.panService.disable();\n  };\n  /**\n   * Deactivate a component.\n   *\n   * @param {string} name - Name of component which become inactive.\n   *\n   * @example\n   * ```\n   * viewer.deactivateComponent(\"mouse\");\n   * ```\n   */\n\n\n  Viewer.prototype.deactivateComponent = function (name) {\n    this._componentController.deactivate(name);\n  };\n  /**\n   * Deactivate the cover (activates all components marked as active).\n   */\n\n\n  Viewer.prototype.deactivateCover = function () {\n    this._componentController.deactivateCover();\n  };\n  /**\n   * Get the bearing of the current viewer camera.\n   *\n   * @description The bearing depends on how the camera\n   * is currently rotated and does not correspond\n   * to the compass angle of the current node if the view\n   * has been panned.\n   *\n   * Bearing is measured in degrees clockwise with respect to\n   * north.\n   *\n   * @returns {Promise<number>} Promise to the bearing\n   * of the current viewer camera.\n   *\n   * @example\n   * ```\n   * viewer.getBearing().then((b) => { console.log(b); });\n   * ```\n   */\n\n\n  Viewer.prototype.getBearing = function () {\n    var _this = this;\n\n    return when.promise(function (resolve, reject) {\n      _this._container.renderService.bearing$.pipe(operators_1.first()).subscribe(function (bearing) {\n        resolve(bearing);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Get the basic coordinates of the current image that is\n   * at the center of the viewport.\n   *\n   * @description Basic coordinates are 2D coordinates on the [0, 1] interval\n   * and have the origin point, (0, 0), at the top left corner and the\n   * maximum value, (1, 1), at the bottom right corner of the original\n   * image.\n   *\n   * @returns {Promise<number[]>} Promise to the basic coordinates\n   * of the current image at the center for the viewport.\n   *\n   * @example\n   * ```\n   * viewer.getCenter().then((c) => { console.log(c); });\n   * ```\n   */\n\n\n  Viewer.prototype.getCenter = function () {\n    var _this = this;\n\n    return when.promise(function (resolve, reject) {\n      _this._navigator.stateService.getCenter().subscribe(function (center) {\n        resolve(center);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Get a component.\n   *\n   * @param {string} name - Name of component.\n   * @returns {Component} The requested component.\n   *\n   * @example\n   * ```\n   * var mouseComponent = viewer.getComponent(\"mouse\");\n   * ```\n   */\n\n\n  Viewer.prototype.getComponent = function (name) {\n    return this._componentController.get(name);\n  };\n  /**\n   * Returns the viewer's containing HTML element.\n   *\n   * @returns {HTMLElement} The viewer's container.\n   */\n\n\n  Viewer.prototype.getContainer = function () {\n    return this._container.element;\n  };\n  /**\n   * Get the image's current zoom level.\n   *\n   * @returns {Promise<number>} Promise to the viewers's current\n   * zoom level.\n   *\n   * @example\n   * ```\n   * viewer.getZoom().then((z) => { console.log(z); });\n   * ```\n   */\n\n\n  Viewer.prototype.getZoom = function () {\n    var _this = this;\n\n    return when.promise(function (resolve, reject) {\n      _this._navigator.stateService.getZoom().subscribe(function (zoom) {\n        resolve(zoom);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Move close to given latitude and longitude.\n   *\n   * @description Because the method propagates IO errors, these potential errors\n   * need to be handled by the method caller (see example).\n   *\n   * @param {Number} lat - Latitude, in degrees.\n   * @param {Number} lon - Longitude, in degrees.\n   * @returns {Promise<Node>} Promise to the node that was navigated to.\n   * @throws {Error} If no nodes exist close to provided latitude\n   * longitude.\n   * @throws {Error} Propagates any IO errors to the caller.\n   * @throws {Error} When viewer is not navigable.\n   * @throws  {@link AbortMapillaryError} When a subsequent move request is made\n   * before the move close to call has completed.\n   *\n   * @example\n   * ```\n   * viewer.moveCloseTo(0, 0).then(\n   *     (n) => { console.log(n); },\n   *     (e) => { console.error(e); });\n   * ```\n   */\n\n\n  Viewer.prototype.moveCloseTo = function (lat, lon) {\n    var moveCloseTo$ = this.isNavigable ? this._navigator.moveCloseTo$(lat, lon) : rxjs_1.throwError(new Error(\"Calling moveCloseTo is not supported when viewer is not navigable.\"));\n    return when.promise(function (resolve, reject) {\n      moveCloseTo$.subscribe(function (node) {\n        resolve(node);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Navigate in a given direction.\n   *\n   * @description This method has to be called through EdgeDirection enumeration as in the example.\n   *\n   * @param {EdgeDirection} dir - Direction in which which to move.\n   * @returns {Promise<Node>} Promise to the node that was navigated to.\n   * @throws {Error} If the current node does not have the edge direction\n   * or the edges has not yet been cached.\n   * @throws {Error} Propagates any IO errors to the caller.\n   * @throws {Error} When viewer is not navigable.\n   * @throws  {@link AbortMapillaryError} When a subsequent move request is made\n   * before the move dir call has completed.\n   *\n   * @example\n   * ```\n   * viewer.moveDir(Mapillary.EdgeDirection.Next).then(\n   *     (n) => { console.log(n); },\n   *     (e) => { console.error(e); });\n   * ```\n   */\n\n\n  Viewer.prototype.moveDir = function (dir) {\n    var moveDir$ = this.isNavigable ? this._navigator.moveDir$(dir) : rxjs_1.throwError(new Error(\"Calling moveDir is not supported when viewer is not navigable.\"));\n    return when.promise(function (resolve, reject) {\n      moveDir$.subscribe(function (node) {\n        resolve(node);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Navigate to a given image key.\n   *\n   * @param {string} key - A valid Mapillary image key.\n   * @returns {Promise<Node>} Promise to the node that was navigated to.\n   * @throws {Error} Propagates any IO errors to the caller.\n   * @throws {Error} When viewer is not navigable.\n   * @throws  {@link AbortMapillaryError} When a subsequent move request is made\n   * before the move to key call has completed.\n   *\n   * @example\n   * ```\n   * viewer.moveToKey(\"<my key>\").then(\n   *     (n) => { console.log(n); },\n   *     (e) => { console.error(e); });\n   * ```\n   */\n\n\n  Viewer.prototype.moveToKey = function (key) {\n    var moveToKey$ = this.isNavigable ? this._navigator.moveToKey$(key) : rxjs_1.throwError(new Error(\"Calling moveToKey is not supported when viewer is not navigable.\"));\n    return when.promise(function (resolve, reject) {\n      moveToKey$.subscribe(function (node) {\n        resolve(node);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Project basic image coordinates for the current node to canvas pixel\n   * coordinates.\n   *\n   * @description The basic image coordinates may not always correspond to a\n   * pixel point that lies in the visible area of the viewer container.\n   *\n   * @param {Array<number>} basicPoint - Basic images coordinates to project.\n   * @returns {Promise<Array<number>>} Promise to the pixel coordinates corresponding\n   * to the basic image point.\n   *\n   * @example\n   * ```\n   * viewer.projectFromBasic([0.3, 0.7])\n   *     .then((pixelPoint) => { console.log(pixelPoint); });\n   * ```\n   */\n\n\n  Viewer.prototype.projectFromBasic = function (basicPoint) {\n    var _this = this;\n\n    return when.promise(function (resolve, reject) {\n      _this._observer.projectBasic$(basicPoint).subscribe(function (pixelPoint) {\n        resolve(pixelPoint);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Detect the viewer's new width and height and resize it.\n   *\n   * @description The components will also detect the viewer's\n   * new size and resize their rendered elements if needed.\n   *\n   * @example\n   * ```\n   * viewer.resize();\n   * ```\n   */\n\n\n  Viewer.prototype.resize = function () {\n    this._container.renderService.resize$.next(null);\n  };\n  /**\n   * Set a bearer token for authenticated API requests of\n   * protected resources.\n   *\n   * @description When the supplied token is null or undefined,\n   * any previously set bearer token will be cleared and the\n   * viewer will make unauthenticated requests.\n   *\n   * Calling setAuthToken aborts all outstanding move requests.\n   * The promises of those move requests will be rejected with a\n   * {@link AbortMapillaryError} the rejections need to be caught.\n   *\n   * Calling setAuthToken also resets the complete viewer cache\n   * so it should not be called repeatedly.\n   *\n   * @param {string} [token] token - Bearer token.\n   * @returns {Promise<void>} Promise that resolves after token\n   * is set.\n   *\n   * @throws {Error} When viewer is not navigable.\n   *\n   * @example\n   * ```\n   * viewer.setAuthToken(\"<my token>\")\n   *     .then(() => { console.log(\"token set\"); });\n   * ```\n   */\n\n\n  Viewer.prototype.setAuthToken = function (token) {\n    var setToken$ = this.isNavigable ? this._navigator.setToken$(token) : rxjs_1.throwError(new Error(\"Calling setAuthToken is not supported when viewer is not navigable.\"));\n    return when.promise(function (resolve, reject) {\n      setToken$.subscribe(function () {\n        resolve(undefined);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Set the basic coordinates of the current image to be in the\n   * center of the viewport.\n   *\n   * @description Basic coordinates are 2D coordinates on the [0, 1] interval\n   * and has the origin point, (0, 0), at the top left corner and the\n   * maximum value, (1, 1), at the bottom right corner of the original\n   * image.\n   *\n   * @param {number[]} The basic coordinates of the current\n   * image to be at the center for the viewport.\n   *\n   * @example\n   * ```\n   * viewer.setCenter([0.5, 0.5]);\n   * ```\n   */\n\n\n  Viewer.prototype.setCenter = function (center) {\n    this._navigator.stateService.setCenter(center);\n  };\n  /**\n   * Set the filter selecting nodes to use when calculating\n   * the spatial edges.\n   *\n   * @description The following filter types are supported:\n   *\n   * Comparison\n   *\n   * `[\"==\", key, value]` equality: `node[key] = value`\n   *\n   * `[\"!=\", key, value]` inequality: `node[key] ≠ value`\n   *\n   * `[\"<\", key, value]` less than: `node[key] < value`\n   *\n   * `[\"<=\", key, value]` less than or equal: `node[key] ≤ value`\n   *\n   * `[\">\", key, value]` greater than: `node[key] > value`\n   *\n   * `[\">=\", key, value]` greater than or equal: `node[key] ≥ value`\n   *\n   * Set membership\n   *\n   * `[\"in\", key, v0, ..., vn]` set inclusion: `node[key] ∈ {v0, ..., vn}`\n   *\n   * `[\"!in\", key, v0, ..., vn]` set exclusion: `node[key] ∉ {v0, ..., vn}`\n   *\n   * Combining\n   *\n   * `[\"all\", f0, ..., fn]` logical `AND`: `f0 ∧ ... ∧ fn`\n   *\n   * A key must be a string that identifies a property name of a\n   * simple {@link Node} property. A value must be a string, number, or\n   * boolean. Strictly-typed comparisons are used. The values\n   * `f0, ..., fn` of the combining filter must be filter expressions.\n   *\n   * Clear the filter by setting it to null or empty array.\n   *\n   * Commonly used filter properties (see the {@link Node} class\n   * documentation for a full list of properties that can be used\n   * in a filter) and common use cases:\n   *\n   * ```\n   * fullPano        // Show only full 360 panoramas or not\n   * organizationKey // Show images from one or several organizations\n   * sequenceKey     // Show images from one or several sequences\n   * userKey         // Show images from one or several users\n   * capturedAt      // Show images from a certain time interval\n   * ```\n   *\n   * @param {FilterExpression} filter - The filter expression.\n   * @returns {Promise<void>} Promise that resolves after filter is applied.\n   *\n   * @example\n   * ```\n   * viewer.setFilter([\"==\", \"sequenceKey\", \"<my sequence key>\"]);\n   *\n   * // Other examples\n   * // viewer.setFilter([\"==\", \"organizationKey\", \"<my organization key>\"]);\n   * // viewer.setFilter([\"in\", \"userKey\", \"<my user key #1>\", \"<my user key #2>\"]);\n   * // viewer.setFilter([\"==\", \"fullPano\", true]);\n   * // viewer.setFilter([\">=\", \"capturedAt\", <my time stamp>]);\n   * ```\n   */\n\n\n  Viewer.prototype.setFilter = function (filter) {\n    var _this = this;\n\n    return when.promise(function (resolve, reject) {\n      _this._navigator.setFilter$(filter).subscribe(function () {\n        resolve(undefined);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Set the viewer's render mode.\n   *\n   * @param {RenderMode} renderMode - Render mode.\n   *\n   * @example\n   * ```\n   * viewer.setRenderMode(Mapillary.RenderMode.Letterbox);\n   * ```\n   */\n\n\n  Viewer.prototype.setRenderMode = function (renderMode) {\n    this._container.renderService.renderMode$.next(renderMode);\n  };\n  /**\n   * Set the viewer's transition mode.\n   *\n   * @param {TransitionMode} transitionMode - Transition mode.\n   *\n   * @example\n   * ```\n   * viewer.setTransitionMode(Mapillary.TransitionMode.Instantaneous);\n   * ```\n   */\n\n\n  Viewer.prototype.setTransitionMode = function (transitionMode) {\n    this._navigator.stateService.setTransitionMode(transitionMode);\n  };\n  /**\n   * Set the image's current zoom level.\n   *\n   * @description Possible zoom level values are on the [0, 3] interval.\n   * Zero means zooming out to fit the image to the view whereas three\n   * shows the highest level of detail.\n   *\n   * @param {number} The image's current zoom level.\n   *\n   * @example\n   * ```\n   * viewer.setZoom(2);\n   * ```\n   */\n\n\n  Viewer.prototype.setZoom = function (zoom) {\n    this._navigator.stateService.setZoom(zoom);\n  };\n  /**\n   * Unproject canvas pixel coordinates to an ILatLon representing geographical\n   * coordinates.\n   *\n   * @description The pixel point may not always correspond to geographical\n   * coordinates. In the case of no correspondence the returned value will\n   * be `null`.\n   *\n   * @param {Array<number>} pixelPoint - Pixel coordinates to unproject.\n   * @returns {Promise<ILatLon>} Promise to the latLon corresponding to the pixel point.\n   *\n   * @example\n   * ```\n   * viewer.unproject([100, 100])\n   *     .then((latLon) => { console.log(latLon); });\n   * ```\n   */\n\n\n  Viewer.prototype.unproject = function (pixelPoint) {\n    var _this = this;\n\n    return when.promise(function (resolve, reject) {\n      _this._observer.unproject$(pixelPoint).subscribe(function (latLon) {\n        resolve(latLon);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Unproject canvas pixel coordinates to basic image coordinates for the\n   * current node.\n   *\n   * @description The pixel point may not always correspond to basic image\n   * coordinates. In the case of no correspondence the returned value will\n   * be `null`.\n   *\n   * @param {Array<number>} pixelPoint - Pixel coordinates to unproject.\n   * @returns {Promise<ILatLon>} Promise to the basic coordinates corresponding\n   * to the pixel point.\n   *\n   * @example\n   * ```\n   * viewer.unprojectToBasic([100, 100])\n   *     .then((basicPoint) => { console.log(basicPoint); });\n   * ```\n   */\n\n\n  Viewer.prototype.unprojectToBasic = function (pixelPoint) {\n    var _this = this;\n\n    return when.promise(function (resolve, reject) {\n      _this._observer.unprojectBasic$(pixelPoint).subscribe(function (basicPoint) {\n        resolve(basicPoint);\n      }, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /**\n   * Fired when the viewing direction of the camera changes.\n   *\n   * @description Related to the computed compass angle\n   * ({@link Node.computedCA}) from SfM, not the original EXIF compass\n   * angle.\n   *\n   * @event\n   * @type {number} bearing - Value indicating the current bearing\n   * measured in degrees clockwise with respect to north.\n   */\n\n\n  Viewer.bearingchanged = \"bearingchanged\";\n  /**\n   * Fired when a pointing device (usually a mouse) is pressed and released at\n   * the same point in the viewer.\n   * @event\n   * @type  {@link IViewerMouseEvent} event - Viewer mouse event data.\n   */\n\n  Viewer.click = \"click\";\n  /**\n   * Fired when the right button of the mouse is clicked within the viewer.\n   * @event\n   * @type  {@link IViewerMouseEvent} event - Viewer mouse event data.\n   */\n\n  Viewer.contextmenu = \"contextmenu\";\n  /**\n   * Fired when a pointing device (usually a mouse) is clicked twice at\n   * the same point in the viewer.\n   * @event\n   * @type  {@link IViewerMouseEvent} event - Viewer mouse event data.\n   */\n\n  Viewer.dblclick = \"dblclick\";\n  /**\n   * Fired when the viewer is loading more data.\n   * @event\n   * @type {boolean} loading - Boolean indicating whether the viewer is loading.\n   */\n\n  Viewer.loadingchanged = \"loadingchanged\";\n  /**\n   * Fired when a pointing device (usually a mouse) is pressed within the viewer.\n   * @event\n   * @type  {@link IViewerMouseEvent} event - Viewer mouse event data.\n   */\n\n  Viewer.mousedown = \"mousedown\";\n  /**\n   * Fired when a pointing device (usually a mouse) is moved within the viewer.\n   * @description Will not fire when the mouse is actively used, e.g. for drag pan.\n   * @event\n   * @type  {@link IViewerMouseEvent} event - Viewer mouse event data.\n   */\n\n  Viewer.mousemove = \"mousemove\";\n  /**\n   * Fired when a pointing device (usually a mouse) leaves the viewer's canvas.\n   * @event\n   * @type  {@link IViewerMouseEvent} event - Viewer mouse event data.\n   */\n\n  Viewer.mouseout = \"mouseout\";\n  /**\n   * Fired when a pointing device (usually a mouse) is moved onto the viewer's canvas.\n   * @event\n   * @type  {@link IViewerMouseEvent} event - Viewer mouse event data.\n   */\n\n  Viewer.mouseover = \"mouseover\";\n  /**\n   * Fired when a pointing device (usually a mouse) is released within the viewer.\n   * @event\n   * @type  {@link IViewerMouseEvent} event - Viewer mouse event data.\n   */\n\n  Viewer.mouseup = \"mouseup\";\n  /**\n   * Fired when the viewer motion stops and it is in a fixed\n   * position with a fixed point of view.\n   * @event\n   */\n\n  Viewer.moveend = \"moveend\";\n  /**\n   * Fired when the motion from one view to another start,\n   * either by changing the position (e.g. when changing node) or\n   * when changing point of view (e.g. by interaction such as pan and zoom).\n   * @event\n   */\n\n  Viewer.movestart = \"movestart\";\n  /**\n   * Fired when the navigable state of the viewer changes.\n   *\n   * @description The navigable state indicates if the viewer supports\n   * moving, i.e. calling the `moveToKey`, `moveDir` and `moveCloseTo`\n   * methods. The viewer will not be in a navigable state if the cover\n   * is activated and the viewer has been supplied a key. When the cover\n   * is deactivated or activated without being supplied a key it will\n   * be navigable.\n   *\n   * @event\n   * @type {boolean} navigable - Boolean indicating whether the viewer is navigable.\n   */\n\n  Viewer.navigablechanged = \"navigablechanged\";\n  /**\n   * Fired every time the viewer navigates to a new node.\n   * @event\n   * @type  {@link Node} node - Current node.\n   */\n\n  Viewer.nodechanged = \"nodechanged\";\n  /**\n   * Fired every time the sequence edges of the current node changes.\n   * @event\n   * @type  {@link IEdgeStatus} status - The edge status object.\n   */\n\n  Viewer.sequenceedgeschanged = \"sequenceedgeschanged\";\n  /**\n   * Fired every time the spatial edges of the current node changes.\n   * @event\n   * @type  {@link IEdgeStatus} status - The edge status object.\n   */\n\n  Viewer.spatialedgeschanged = \"spatialedgeschanged\";\n  return Viewer;\n}(Utils_1.EventEmitter);\n\nexports.Viewer = Viewer;\n\n//# sourceURL=webpack://Mapillary/./src/viewer/Viewer.ts?");

/***/ })

/******/ })["default"];